#alias HDR_PROP_OFF set property PDBSearchResults.doubleClick PDBSearchResults.Query PDBSearchResults.tableTitle PDBSearchResults.cursor PDBSearchResults.separateTab show off
alias HDR_PROP_OFF dummy=""

alias sys unix
macro nice auto s_PdbSelection ("") l_invert (no) l_wormStyle (no) l_append (no) l_nodisplay (no)
  l_info=no
#  GRAPHICS.l_redraw = no
  if(s_PdbSelection!="") then
    s_PdbSelection=Tolower(s_PdbSelection)
    s_PdbFileName=s_PdbSelection[1:Min(4,Length(s_PdbSelection ))]
    if(Nof( a_$s_PdbFileName. )>0)then
      set object a_$s_PdbFileName.
    elseif(Exist(s_PdbFileName+".ob")) then
      read object s_PdbSelection
    else
      read pdb html sstructure s_PdbSelection
      if (Error()) return
    endif
  else
    s_PdbSelection=Nof(a_)==0?"":Name(a_)[1]
  endif
  if l_nodisplay return
  if(Nof(object )>1 & !l_append ) undisplay store !a_
  #delete label
  resLabelShift = 1.5
  if(l_wormStyle)GRAPHICS.dnaRibbonWorm = yes
  if(l_wormStyle)GRAPHICS.ribbonWorm = yes
  if(l_wormStyle)GRAPHICS.wormRadius = 0.8

  cool a_ no
#  display ribbon Select( a_N, "n>1" )
#  ribbonColorStyle = 2
#  display ribbon Select( a_!H,!N "n>1" )
#  display Res(a_!H) & a_/cyss & ( a_.//!o,n,h*,q* | a_./"P"/n ) xstick
#  display a_H,U,S & a_!W  xstick
#  display Select( a_A,N "n==1" ) xstick
#  display a_M cpk
#  center a_!W
#  SITE.labelOffset = 10.0
#  if(l_invert) then
#    display residue label a_H & a_!W black
#    color background white
#    color a_//c* dimgray
#    if(Nof( a_/FABCDFGLMNtepm ) == 0) print "NO SITES ASSIGNED"
#  else
#    display residue label a_H & a_!W  & !Res( a_CATRACE.//ca )
#    if(Nof( a_/FABCDFGLMNtepm ) == 0) print "NO SITES ASSIGNED"
#  endif

  if(l_info) print " To change display styles, use File/Preferences"
  addToRecent "S_RecentPDBs" s_PdbSelection
  GRAPHICS.resLabelDrag = yes
#  GRAPHICS.l_redraw = yes
  display new
  #keep SITE GRAPHICS
endmacro

macro cool auto rs_ (a_) l_static (no)
 l_info=no
 l_commands = no
 GRAPHICS.l_redraw = no
 if Nof(object)==0 return
 if(Nof(Obj(rs_))==0) return  # should fix double click on an .sdf file
 if Nof(plane)==0 set plane 1
#
 display restore rs_ & a_*.G # selection of prev. stored ds,kr
 if   Nof( Mol(rs_) & Mol(a_*.//DD)) == 0 store display delete Mol(rs_)
 rs_ = rs_ & a_*.!G

 undisplay rs_
 #all the first ds should be static if l_static'
 make bond chain rs_ & a_CATRACE.//ca
 color molecule field store rs_   # need option --new to avoid overwriting set colors , need better color for 1,2,3,4,5
 if comboDisplayStyle == 1 then
  resLabelShift = 1.5
  display static=l_static ribbon rs_ & Select( a_!*_ca.!H & Mol( rs_ ) "n>1" )
  color ribbon a_!*_ca.N & Mol( rs_ ) molecule
  color ribbon a_!*_ca.N & Mol( rs_ ) base ribbonColorStyle=1

  display xstick rs_ & Res(a_*.!H) & ( a_!*_ca./cyss,FABCFGLMstepm & ( a_.//!o,n,h*,q* | a_./"P"/n ))

  display xstick rs_ & (a_*_ca. | a_!*_ca./cyss/!o,n,h*,q* | a_*.H,U & a_*.!W//!M5 | a_*.S )
#  color xstick rs_ & a_*./!gol,edo,peg,dms,nag,po4,fmt/c* molecule
  #color xstick rs_ & a_*.A//c* white # a mne tak bol'she nravitsq
  if( Nof(Res(rs_ & a_*.A,N )) < 30 & Nof(Res(Obj(rs_)))<40 ) display wire rs_ & a_*.A
  display cpk rs_ & a_*.M

 elseif comboDisplayStyle == 2 then
  display static=l_static ribbon a_!*_ca. & rs_
  display xstick rs_ & a_*_ca.
  display xstick rs_ & ( Res( Sphere( rs_ & a_*.H  Obj( rs_ ) ) ) | a_*./cyss/!o,n,h*,q* )
 elseif comboDisplayStyle == 3 then
  ribbonColorStyle = 2
  display static=l_static rs_ wire
  display xstick rs_ & ( a_*.H | a_*./FA/!ca,c,n,o )
  display rs_ & Sphere( ( a_*.H | a_*./FA/!ca,c,n,o ) a_*.W 5. )  # show water
  display xstick rs_ & a_*.A,N//ca,c,n grey
  if (!l_static) center rs_ & ( a_1/FAB | a_H ) static margin = 10.
 elseif comboDisplayStyle == 4 then
  wireStyle = 2
  atomLabelStyle = 6
  display static=l_static rs_
  display atom label rs_
  keep wireStyle atomLabelStyle
 else
  display static=l_static rs_
 endif
 display xstick rs_ & Select( a_*.A,N & Mol( rs_ ) "n==1" )  # xstick for single residue molecules
 display rs_ & a_*.!W & !Res(a_*.//DD)  # to avoid a no show
 display hydrogen # displays hydrogens according to the GRAPHICS.hydrogenDisplay
 delete rs_
 GRAPHICS.l_redraw = yes
 display new
endmacro
#
macro dsLigandComplex2 auto ms_lig ( a_H [1] ) ms_rec (a_none.) r_dist (1.25) l_center (no)
  l_commands = no
  if(Nof(ms_lig)==0) return
  if(Nof(ms_rec)==0) ms_rec = Mol(Obj(ms_lig)[1]) & ! ms_lig
  ms_lig = Mol( ms_lig )
  set field name="_LIGAND_" ms_lig
  assign sstructure ms_rec l_warn=no
  hbondPrepare ms_lig | ms_rec
  undo store slide display
  GRAPHICS.l_redraw = no
#  GRAPHICS.sketchAccents = yes
  if(Exist(view)) vligcomp = View()
  color background white
  undisplay ms_rec | ms_lig
  display ribbon ms_rec
  set transparent ribbon
  display xstick ms_lig
  as_sc = Sphere( ms_lig & a_*.//!h*,vt*  ms_rec & a_*.//!h*,c,ca,n,o , -r_dist )
  as_bb = Sphere( ms_lig & a_*.//!h*,vt*  ms_rec & a_*.//c,ca,n,o,hn , -r_dist )
  display xstick Res( as_sc ) & a_*.//!n,o,hn
  display xstick ( Res( as_bb ) & a_*.//c,ca,n ) | as_bb
  display xstick Next( Res( as_bb ) & a_*.//n , bond ) & a_*.//c
  display xstick Res( as_bb | as_sc ) &  a_*./pro*,hyp*/n
  display xstick Next( a_*./pro*,hyp*/n & Res( as_bb | as_sc )  bond )
  color xstick a_*.//o* & Res( as_sc | as_bb ) lightcoral
  set label ( Res(as_sc) & a_*.//cb ) | (Res( as_bb  ) & a_*.//ca )
  display residue label black as_sc | as_bb | ms_lig
  GRAPHICS.l_redraw = yes
  if(!l_center & Type(vligcomp)=="rarray" ) set view vligcomp
  if( l_center | Type(vligcomp)!="rarray" ) center static ms_lig | (ms_rec & Res(as_sc | as_bb )) margin=1.
  if( Nof(ms_lig [1] & a_*.H )==1 & Type( Obj(ms_lig) 2 )!= "ICM" ) set charge formal ms_lig auto
  make hbond refresh ms_lig | Res( as_bb | as_sc )  ms_lig | Res( as_bb | as_sc ) name="hbondpairs"
  if Nof(hbondpairs)>0 then
    display hbondpairs ms_lig | ms_rec
    keep global hbondpairs
  endif
  display new
  keep global GRAPHICS
endmacro

macro dsLigandComplex ms_rec ms_lig l_center
  GRAPHICS.l_redraw = no
  undo store slide display
  undisplay
  display ms_rec ribbon
  color ms_rec ribbon white
  GRAPHICS.sketchAccents = yes
  GRAPHICS.ribbonWorm = yes
  GRAPHICS.wormRadius = 0.6
  GRAPHICS.stickRadius = 0.15
  GRAPHICS.transparency = { 0.95 1. }
  display ms_lig xstick cpk
  color xstick ms_lig
  color cpk ms_lig magenta
  color background white
  as_pocket = Sphere( ms_lig & a_*.//!h* ms_rec & a_*.//!h* 4.5 ) | Sphere( ms_lig & a_*.//!h* ms_rec & a_*.//hn 2.5)
  as_pocket = as_pocket | ( Res( as_pocket ) & ! ( a_*.//hn,o | a_*./!pro/n ))
  display residue label black as_pocket
  set label as_pocket & a_*.//c*
  set label Res(Sphere( ms_lig &  a_*.//!h* ms_rec & a_*./!pro,ala/!h*,c,ca,n,o 5. )) & ! ( a_*./asp,asn,gln,glu,arg,leu,val/c,o,h*,o*,n*,cd?,cg? | a_*.A/!asp,asn,gln,glu,arg,leu,val/c,o,h* )
#  display atom label a_*.//Ag*,As*,Au*,Cu*,Mo*,Hg*,Pb*,Sn*,Zn* & a_*.//!L & as_pocket black
  display xstick as_pocket
  color xstick as_pocket
  if (l_center) center static ms_lig
  if (Obj(ms_lig) == Obj(ms_rec) & Type(Obj(ms_rec),2)=="ICM" ) then
    GRAPHICS.hbondStyle = 2
    show energy "hb" ms_lig ms_rec mute
    display hbond
  else
  endif
  GRAPHICS.l_redraw = yes
  display new
  keep global GRAPHICS
endmacro

macro dsSelection auto s l_only (yes) l_water (no)
  l_info=no   # macro to use in actions for columns built with Name( <sel> full )
  GRAPHICS.l_redraw = no
  ilv = Nof(s,".")+Nof(s,"/")
  if(s[$]==".") ilv = 0
  if(Nof( $s )==0) then
    l_pdb = !Exist(s_xpdbDir + "cr/1crn.icb")
    pdbcod = s[3:6]
    if(Length(pdbcod)!=4 | pdbcod[1]!~"[0-9]") return
    if(Nof( a_$pdbcod. )==0) read l_pdb?:binary pdb pdbcod
    if(ilv==0) then
      nice pdbcod no no no no
      return
    endif
  endif
  set object Obj( $s )
  if(l_only) undisplay a_*.
  display ribbon Mol( $s )
  if(ilv>=2) then
    display xstick Res(Sphere( $s l_water? a_ : a_!W 3.5))
    color xstick ( $s ) & a_*.//c* molecule
    display residue label $s black
    display atom label ( $s ) & a_//!c*,o*,n*,s*,h*,p*,
  endif
  center $s margin = 10.
  GRAPHICS.l_redraw = yes
  display new
endmacro

macro dsMultiWindow os_ i_nWnd
  l_commands = l_info = no
  if (i_nWnd == 0) i_nWnd = Min( Nof(Obj(os_)), Max( graphic ) )
  undisplay os_
  for i=1,Nof(Obj(os_))
    os1_ = Obj(os_) [i]
    i_wnd = Mod( i-1, i_nWnd ) + 1
    display window=i_wnd
    set window number=i_wnd
    undisplay all
    #clear plane i
    cool os1_
    #display os1_
  endfor
endmacro

#ifdef Product >= bio  # ds3D
macro ds3D auto M_dist S_names ({""}) S_comments ({""}) s_tabname ("")
# display 3D coordinates corresponding to an input distance data matrix;
# errors of embedding to 3D space are in R_out (first: total, next three: x, y and z coordinates)
   n_at = Nof(M_dist)
   if (n_at != Length(M_dist)) return error "ds3D> ERROR: Non-square input matrix"
   if (n_at <= 3) return error "ds3D> ERROR: Input matrix is too small: n <= 3"
   if(Max(Max(M_dist))<=1.) M_dist = 100.*M_dist
   corMat=Disgeo(M_dist)
   if (Error) return error "ds3D> ERROR: Disgeo calculations failed. Check input matrix"
   if (Nof(S_names) != n_at) S_names = Sarray(n_at, "v")+Sarray(Count(n_at))
   build string Sum(Sarray(n_at,"\nml ")+Replace(S_names," ","_")+Sarray(n_at,"\nse o")) name="dots"
   if (Error) return error "ds3D> ERROR: Cannot build virtual molecular object"
   set a_//o corMat[1:n_at,1:3]
   for i = 1, Nof(S_names)
     rename a_/$i   S_names[i]
#     rename a_/$i/o S_names[i]
   endfor
   if (Error) return error "ds3D> ERROR: Cannot assign calculated coordinates"
   lineWidth = 3.
   atomSingleStyle = "dot"
   display blue
   resLabelStyle = "Mol"
   display residue label
   set font residue 14
   keep resLabelStyle atomSingleStyle R_out lineWidth
endmacro
#endif

macro dsCellBox os_ (a_)
  gCell = Grob ("cell" Cell(os_))
  if( Type( Obj( os_ ), 2)=="NMR" )  return error " NMR object does not have cell information"
  display gCell green
  axisLength = 5.
  display origin
  print " Info> gCell is a mesh. To undisplay click on the gCell display icon"
  print Symgroup( os_ ), Cell(os_)
  keep gCell axisLength
endmacro

macro dsCellBoxMap m_
   gCellMap = Grob ("cell" Cell(m_))
   display gCellMap green
   display origin
   print Symgroup( m_ ), Cell(m_)
   keep gCellMap
endmacro

macro dsCell os_ (a_) l_deleteRemoteNeighbors (yes) i_Ncells (4)
# Obsolete. see also findSymNeighbors
   set object os_[1]
   if(Symgroup(a_)=="undefined") return error " Error_in_dsCell: symmetry group undefined"
   r_Sphere = selectSphereRadius
   if( Nof(Atom(os_ & a_*.//ca))==Nof(Atom(os_))) r_Sphere = 8.
   if(Nof(a_tm*.)>0) delete a_tm*.
   aaa = Atom(a_)
   ngr = Symgroup(a_ number)
   nTrans = i_out
   if (ngr == 0) return error "no symmetry found"
   for i=2, nTrans * i_Ncells # i_Ncells elem.cells will be filled
     copy a_ "tm"+i
     transform a_tm$i. i # was i-1 before transition in Jun 2010 R
     if(l_deleteRemoteNeighbors)then
       if( Nof( Sphere( aaa a_tm$i. r_Sphere) )==0 ) delete a_tm$i.
     endif
   endfor
   display only a_ white
   n1 =Nof(a_*)
   n = n1
   for i=2, nTrans * i_Ncells
     if( Nof( a_tm$i. ) > 0 )then
       move a_tm$i. a_
       n0 = n1+1
       n1 = n1+n
       display a_$n0:$n1 color[i+2]
     endif
   endfor
   gcell=Grob("cell",Cell())
   obl=Augment(Cell())           #this will work also for any oblique matrix
   g1 = gcell + obl[1:3,1]       #shift cell by vector 'a' from the oblique matrix
   display gcell g1
   center
   print " cell=" Cell() "\n Symgroup=" Symgroup(a_) "Nof.sym.=" nTrans
   A=obl[1:3,1]
   B=obl[1:3,2]
   C=obl[1:3,3]
   keep A B C gcell g1
endmacro

macro dsVarLabels
  display variable v_//S label magenta
  color   variable v_//H label
  color   variable v_//M label green
  color   variable v_//P label red
endmacro

macro printMatrix s_format (" %4.1f") M_matrix (def)
  l_info = no
  s_matr=""
  for i=1,Nof(M_matrix)
    for j=1,Length(M_matrix)
      sprintf s_format M_matrix[i,j]
      s_matr = s_matr + s_out
    endfor
    s_matr = s_matr + "\n"
  endfor
  show s_matr
endmacro

macro calcSeqContent S_sequenceNames
  l_commands = no
  l_info = no
  aminoacids="ACDEFGHIKLMNPQRSTVWY"
  aafrequencies = {7.85,2.55,5.17,6.95,4.,6.52,2.12,5.45,5.66,8.86,2.51,4.59,4.67,4.09,5.17,7.1,5.48,6.2,1.46,3.05}
  nAA = Length(aminoacids)

  if( Nof(S_sequenceNames) == 0 ) return error "No sequences match the pattern. Try \"*\" "
  sum = ""
  for j=1,Nof(S_sequenceNames)
    sname = S_sequenceNames[j]
    sum = sum + String( $sname )
  endfor
  rnn = Real(Length(sum))
  printf "\nStatistics for %d sequence(s): %s\n", Nof(S_sequenceNames),Sum(S_sequenceNames)
  if Type(SeqContent)!="table" then
    global group table SeqContent Split(aminoacids,"") "AA" Iarray(nAA) "N" Rarray(nAA) "Proc"  Rarray(aafrequencies) "Expected" Rarray(nAA) "RelFreq"
    make plot SeqContent "x=N;y=RelFreq;color=AA;size=8;title=Relative Residue Frequencies"
  endif
#  print "AA   N   %   Expected"
  ntt=0
  for i=1,nAA
    n=Nof(sum,aminoacids[i])
#    printf "%s %4d %5.2f  %5.2f\n" aminoacids[i] n (n*100./rnn) aafrequencies[i]
    SeqContent.N   [i]= n
    SeqContent.Proc[i]= n*100./rnn
    SeqContent.RelFreq[i]= SeqContent.Proc[i]/SeqContent.Expected[i]
    ntt = ntt + n
  endfor
  set format SeqContent.RelFreq "%.2f" name="" color="rainbow='#88FF88/#FFFFFF/#FF8888/#FF0000,0.:3.,pinwheel'"
#  if(Nof(S_sequenceNames)==1) rename SeqContent "SeqContent_" + S_sequenceNames[1]
  ndiff = Integer(rnn)-ntt
  if ndiff !=0 & l_warn print " Warning> there are/is "+ ndiff + " non-standard amino-acid(s)"
#  gui refresh "SeqContent"
endmacro

macro calcEllipsoid auto M_xyz s_grobName ("g_ellipsoid")
  a=Tensor(M_xyz)        # compute 3x3 matrix of the second moments
  b=Eigen(a)              # returns 3 axis vectors
  ellipseAxis1= b[?,1] # this is the longest half axis
  ellipseAxis2= b[?,2] # this is the second half axis
  ellipseAxis3= b[?,3] # this is the shortest half axis
  ellipseRotMatrix = Matrix(3,3)
# to make the rotation matrix from b normalize the axes
  ellipseRotMatrix[?,1] = ellipseAxis1 / Length( ellipseAxis1 )
  ellipseRotMatrix[?,2] = ellipseAxis2 / Length( ellipseAxis2 )
  ellipseRotMatrix[?,3] = Vector( ellipseRotMatrix[?,1], ellipseRotMatrix[?,2] )
  ellipseRotMatrix = Transpose(ellipseRotMatrix) # rotates the principal axes to x,y,z
  s_out = Name(s_grobName,unique)
  $s_out = Grob("SPHERE",1.,10)
  transform $s_out Transform(b)
  $s_out = 2.* $s_out
  translate $s_out Mean(M_xyz)
  keep ellipseRotMatrix ellipseAxis1 ellipseAxis2 ellipseAxis3 $s_out s_out
endmacro

macro calcEllips  &g_
HELP = """
  calculates elliptical half-axes and returns them in len1,len2,len3
  Example:

"""
  b=Eigen(Tensor(Xyz(g_)))
  len1 = Length(b[?,1])
  len2 = Length(b[?,2])
  len3 = Length(b[?,3])
  keep len1, len2, len3
endmacro

macro plotCluster M_distances S_names ({""}) s_plotArgs ("CIRCLE display {\"Title\" \"X\" \"Y\"}")
   n=Nof(M_distances)      # number of points
   if(S_names!={""} & Nof(S_names) != n) return error " Error_plotCluster> nonmatching size of the name array"
   b=Disgeo(M_distances)   # calculate principal components
   corMat=b[1:n,1:n-1]     # coordinate matrix [n,n-1] of n points
   eigenV=b[1:n,n]         # vector with n sorted eigenvalues
   xplot= corMat[1:n,1]    # we will just use the fist two princ. coordinates
   yplot= corMat[1:n,2]    #
   if(S_names=={""}) then
     plot xplot yplot $s_plotArgs # call plot a 2D distrib
   else
     plot xplot//xplot yplot//yplot Sarray(n,"_"+Field(s_plotArgs,1))//S_names $s_plotArgs # call plot a 2D distrib
   endif
endmacro

#ok
macro plotRamaEps auto rs_ (a_/A) l_mark_residue_label (yes) l_shaded_boundaries (no)
  l_commands = no
  l_info     = no
  l_confirm  = no
  l_icmobj = yes
# prepare plot layout with boudaries
  s_File=Sum(Name(Obj(rs_)))
  t_rama  =("Ramachandran plot of "+s_File) // "Phi, deg"//"Psi, deg"
  if(Type(Obj(rs_),2) != "ICM") then
    convert Obj(rs_)
    s_out = "a_" + Field( String( rs_ ) 2 "." )
    rs_ = $s_out
    l_icmobj = no
  endif
  read table s_icmhome+"RAMACORE"
  n_raco = 36
  RAMACORE = Matrix(n_raco, n_raco, 0.)
  for kk = 1, Nof(RAMAAREA.IY)
    for k = RAMAAREA.IXLOW[kk], RAMAAREA.IXUPP[kk]
      RAMACORE[k, RAMAAREA.IY[kk]] = -1.
    endfor
  endfor
  if (l_shaded_boundaries) then
    PLOT.rainbowStyle = 2
    plot area RAMACORE link frame transparent={-0.1,0.1} color={-3., 3.} t_rama s_File
  else
    plot               link frame RAMALINE.XAR RAMALINE.YAR RAMALINE.SAR \
         {-180.,180.,90.,30.,-180.,180.,90.,30.} t_rama s_File
  endif
  resLabelStyle = 1
  rs_= Res(rs_)
  nesl_rama=Nof(rs_)
  x_rama=Rarray(nesl_rama)
  y_rama=Rarray(nesl_rama)
  s_rama=Sarray(nesl_rama)
  s_name=Sarray(nesl_rama)
  j=0
  n_outliers=0
  for i=1,nesl_rama
    v1=V_*.//phi* & rs_[i]
    v2=V_*.//psi  & Next( rs_[i] )
    if (Nof(v1)==1 & Nof(v2)==1 ) then
      j=j+1
      x_rama[j]=Sum(Value(v1))
      y_rama[j]=Sum(Value(v2))
      s_name[j]=Sum(Label(rs_[i]))
      if (Sum(Name(rs_[i]))!="gly") then
        s_rama[j]="_black CIRCLE"
        ikx = Integer(x_rama[j]/10)+n_raco/2+1
        iky = Integer(y_rama[j]/10)+n_raco/2+1
        if (ikx > n_raco) ikx = 1
        if (iky > n_raco) iky = 1
        if (RAMACORE[iky, ikx] == 0.) then
          n_outliers=n_outliers+1
          printf "%-s %7.2f %7.2f\n", s_name[j], x_rama[j], y_rama[j]
        endif
      else
        s_rama[j]="_black square"
      endif
    endif
  endfor
  x_rama=x_rama[1:j]
  y_rama=y_rama[1:j]
  s_rama=s_rama[1:j]
  s_name=s_name[1:j]
  if (l_mark_residue_label) then
    x_rama=x_rama//x_rama
    y_rama=y_rama//y_rama
    s_rama=s_rama//s_name
  endif
  if(!l_icmobj) delete a_
  print "plotRama> Number of non-glycine core outliers: " n_outliers
  print "plotRama> Output postscript file : " s_File+".eps"
#ifdef WIN32
        if(Exist(s_psViewer)) then
                plot display link append x_rama y_rama s_rama {"" "" ""} {-180.,180.,90.,30.,-180.,180.,90.,30.} s_File
        else
                Askg( "PostScript Viewer was not found. Please install GSviewer from\nhttp://www.cs.wisc.edu/~ghost/\nand correct PS Viewer settings in File/Preferences","",simple)

        endif
#else
        plot display link append x_rama y_rama s_rama {"" "" ""} {-180.,180.,90.,30.,-180.,180.,90.,30.} s_File
#endif
endmacro

#ok
macro plotRama2 auto rs_ (a_/A) l_mark_residue_label (yes) l_shaded_boundaries (no)
  l_commands = no
  l_info     = no
  l_confirm  = yes
  l_icmobj = yes
  PLOT.logo = no
# prepare plot layout with boundaries
  s_File=Sum(Name(Obj(rs_)))
  t_rama  =("Ramachandran plot of "+s_File) // "Phi, deg"//"Psi, deg"
  if(Type(Obj(rs_),2) != "ICM") then
    convert Obj(rs_)
    s_out = "a_" + Field( String( rs_ ) 2 "." )
    rs_ = $s_out
    l_icmobj = no
  endif
  read table s_icmhome+"RAMACORE2"
  n_raco = 36
  RAMACORE = Matrix(n_raco, n_raco, 0.)
  for kk = 1, Nof(RAMAAREA.IY)
    for k = RAMAAREA.IXLOWG[kk], RAMAAREA.IXUPPG[kk]
      RAMACORE[k, RAMAAREA.IY[kk]] = -0.5
    endfor
    for k = RAMAAREA.IXLOW[kk], RAMAAREA.IXUPP[kk]
      if (RAMAAREA.IXLOW[kk] > 0) RAMACORE[k, RAMAAREA.IY[kk]] = -1.
    endfor
  endfor
  if (l_shaded_boundaries) then
    PLOT.rainbowStyle = 2
    plot area RAMACORE link frame transparent={-0.1,0.1} color={-3., 3.} t_rama s_File
  else
    plot               link frame RAMALINE.XAR RAMALINE.YAR RAMALINE.SAR \
         {-180.,180.,90.,30.,-180.,180.,90.,30.} t_rama s_File
  endif
  resLabelStyle = 1
  rs_= Res(rs_)
  nesl_rama=Nof(rs_)
  x_rama=Rarray(nesl_rama)
  y_rama=Rarray(nesl_rama)
  s_rama=Sarray(nesl_rama)
  s_name=Sarray(nesl_rama)
  s_outlier=Sarray(nesl_rama)
  j=0
  n_outliers=0
  for i=1,nesl_rama
    v1=V_*.//phi* & rs_[i]
    v2=V_*.//psi  & Next( rs_[i] )
    if (Nof(v1)==1 & Nof(v2)==1 ) then
      j=j+1
      x_rama[j]=Sum(Value(v1))
      y_rama[j]=Sum(Value(v2))
      s_name[j]=Sum(Label(rs_[i]))
      if (Sum(Name(rs_[i]))!="gly") then
        s_rama[j]="_black CIRCLE"
        ikx = Integer(x_rama[j]/10)+n_raco/2+1
        iky = Integer(y_rama[j]/10)+n_raco/2+1
        if (ikx > n_raco) ikx = 1
        if (iky > n_raco) iky = 1
        if (RAMACORE[iky, ikx] == 0.) then
          n_outliers=n_outliers+1
          s_outlier[j] = s_name[j]
          printf "%-s %7.2f %7.2f\n", s_name[j], x_rama[j], y_rama[j]
        endif
      else
        s_rama[j]="_black square"
      endif
    endif
  endfor
  x_rama=x_rama[1:j]
  y_rama=y_rama[1:j]
  s_rama=s_rama[1:j]
  s_name=s_name[1:j]
  s_outlier=s_outlier[1:j]
  if (l_mark_residue_label) then
    x_rama=x_rama//x_rama
    y_rama=y_rama//y_rama
    s_rama=s_rama//s_outlier
  endif
  if(!l_icmobj) delete a_
  print "plotRama> Number of non-glycine core outliers: " n_outliers
  print "plotRama> Output postscript file : " s_File+".eps"
  plot display link append x_rama y_rama s_rama {"" "" ""} {-180.,180.,90.,30.,-180.,180.,90.,30.} s_File
endmacro

macro plotRama rs_
  rs_ = rs_ & a_*.A
  GRAPHICS.occupancyDisplay = 3
  resLabelStyle = 1
  display xstick Select( Atom( rs_ ) , "o<1." )
  global group table RAMA Sarray( rs_ residue ) "A", Value( rs_ "phi") "Phi",Value( rs_ "psi" ) "Psi",Value( rs_ "omn" ) "Omg",Trim(Label( rs_ ) all) "Name",Match(Label( rs_ ),"[GP].*"),"L" Count(Nof(rs_)) "i" header "as_graph=a_%1/ca,c,n,o,cb\ndisplay residue label a_%1 \ncenter a_%1" "cursor"
  delete  RAMA.Omg==0. | RAMA.Phi==0. | RAMA.Psi==0.
  if(Nof(RAMA)==0) return error " No suitable residues selected. Requirements: non-terminal and correct names for ca,c,n "
  set format show off RAMA.L
  if (Type(ramaFreq)=="unknown") then
    read binary s_icmhome + "RAMADATA.icb"
    set property RAMADATA show off
    keep RAMADATA
  endif
  make plot RAMA "x=i;y=Omg;labels=Name;labelOnSelect=yes;;y=$$RAMADATA.omgFreq;pos=-90;step=10;binWidth=1;color=lightgreen;relHeight=0.3;;yStep=30;title=Omega"
  make plot RAMA "x=Phi;y=Psi;filter=Name~'^G';labels=Name;labelOnSelect=yes;;matrix=$$RAMADATA.phipsiFreqGly;pos=-180,-180;step=10;rainbow=white/lightyellow/lightgreen/lightblue/royalblue/mediumpurple;legend=no;depth=-1;;xStep=30;yStep=30;title=Phi/Psi (Gly)"
  make plot RAMA "x=Phi;y=Psi;filter=Name!~'^G';labels=Name;labelOnSelect=yes;;matrix=$$RAMADATA.phipsiFreq;pos=-180,-180;step=10;rainbow=white/lightyellow/lightgreen/lightblue/royalblue/mediumpurple;legend=no;depth=-1;;xStep=30;yStep=30;title=Phi/Psi"
endmacro

macro plot2DSeq ali_
  n_disgeo = Nof(ali_)
  s_disgeo = Name(ali_)
  align ali_
  di_disgeo = Distance(ali_)
  b_disgeo = Disgeo(di_disgeo)
  plot display link b_disgeo[1:n_disgeo,1] b_disgeo[1:n_disgeo,2] s_disgeo \
       {"Distribution of sequences","1st princ. axis","2nd princ. axis"}
endmacro

macro printPostScript s_PrinterCommand ("lp") l_color (yes)
  l_info = no
  IMAGE.previewResolution = 0
  if (l_color) then  # color printer
    write postscript reverse color 5 2. "tmp.eps"
  else
    write postscript reverse bw 5 2. "tmp.eps"
  endif
  unix $s_PrinterCommand tmp.eps
endmacro

#ifdef Product >= bio
macro buildpep s_seq  ("ala his")
# create new object from a sequence string.
# Recognizes both one and three letter code
    amino="ala arg asn asp cys gln glu gly his ile leu lys met mse phe pro ser thr trp tyr val"
  if(Toupper(s_seq)!=s_seq) then  # 3-letter
    if(Index(amino,s_seq[1:3] )!= 0) then
     s_seq = "ml a\nse 0 nter "+Replace(s_seq,{".","-",";"}," cooh\nml b\nse 0 nter ")+" cooh"
    else
     s_seq = "ml a\nse "+Replace(s_seq,{".","-",";"}," \nml b\nse ")+" "
    endif
    build string s_seq          # three-leter
  else                          # 1-letter
    build string IcmSequence(Toupper(Replace(s_seq,{" ","-"},"")),"0 nter","cooh")
  endif
  if Exist( display ) display center virtual
endmacro

macro mkModPep s_se
  S = Split(s_se "\n")[Index(Split(s_se "\n") "^modres" regexp all)] # parse lines of 'modres <pos> <smiles>' format
  for i = 1 Nof(S)
    i_res  = Field(S[i] 2)
    s_grp  = Field(S[i] 3)
    i_ix = Index(s_grp "X")
    if(i_ix!=0 & i_ix!=Length(s_grp))then
      s_X= s_grp[i_ix+1]
      if(Length(s_grp)> i_ix+1)then
        s_grp = s_grp[1:i_ix] + s_grp[i_ix+2:$]
      else
        s_grp = s_grp[1:i_ix]
      endif
    else
      s_X=""
    endif
    if(Name( a_/$i_res )[1]=="acet" | Name( a_/$i_res )[1]=="cmt")then
      modifyGroupSmiles a_/$i_res/hm3 s_grp no no no # special terminals can be made from N-acetyl or C-terminal methylamide
    else
      s_at = "cb"
      if(Index(i_res "/")!=0) then
        s_at = Field(i_res 2 "/")
        i_res = Field(i_res 1 "/")
      endif
      modifyGroupSmiles a_/$i_res/$s_at s_grp no no no
      rename a_/$i_res/!x*,y* peptide
    endif
    if(Nof( a_/$i_res/x* )>0) rename a_/$i_res/x* "y" + s_X
  endfor
  S_lnat =  Unique( Sort( Name( a_//y* )))
  for i = 1 Nof(S_lnat)
    s_X = S_lnat[i]
    if(Nof( a_//$s_X )==2 & Nof(Res( a_//$s_X ))==2)then
      x1 = Next( a_//$s_X [1] bond )
      x2 = Next( a_//$s_X [2] bond )
      if( Type(x1 mmff)[1]  !=1 | Type(x1 mmff)[1]  !=1) print " Warning> It is recommended that the cross-link is placed between aliphatic carbon atoms"
      modify a_//$s_X [2] none
      modify a_//$s_X [1] none
      make bond simple x1 x2
      set term "bb,bs,af,to"
    else
      print " Warning> unable to interpret crosslink " + s_X
    endif
  endfor
#  if(Nof( a_//x* )!=0) print " Warning> only single crosslink specified via two 'x' pseudoatoms is supported "
endmacro

macro plotFlexibility &seq_ i_windowSize (7)
# Protein Eng. 1989 May;2(7):497-504. Flexibility plot of proteins. Ragone R, Facchiano F, Facchiano A, Facchiano AM, Colonna G.
#           A  B   C    D    E    F    G     H     I   J   K     L     M    N   O   P    Q     R   S    T   U    V     W   X    Y   Z
  flexInd={1.2,0.,0.37,0.95,0.2,-1.33,1.75,-0.09,-1.02,0.,0.04,-0.81,-0.74,0.65,0.,0.76,0.12,-0.6,1.31,0.83,0.,-0.39,-2.04,0.,-1.16, 0.00 }
  PLOT.Yratio = 0.2
  R_flexi= Smooth ( Rarray(seq_,flexInd), i_windowSize)/Sqrt(i_windowSize)
  R_ruler  = {0.}//(Length(seq_)+1.)//{50.,10.,-1.,1.,0.5,0.25}
  plot number comment=String(seq_) R_flexi R_ruler {"Flexibility plot","Sequence","Flexibility"} grid
  group table T_flexi Count(Length(seq_)) "i" Split(String(seq_),"")   "seq"  R_flexi  "flex"
  keep T_flexi
endmacro
#endif

#ifdef Product > bio
macro mkStackConf i_from (1) i_to (Nof(conf))
  if(Type(a_ ,2)!="ICM") return error "the current object is not found or irrelevant"
  if(Nof(conf)<=0) return error "stack not loaded or empty"
  store conf   # append to the end
  for i=i_from,i_to
    load conf i
    copy a_ Name(a_)[1] + i
  endfor
  load conf Nof(conf)
endmacro

macro changeEntryAtom as_
  l_info = no
# CRASHES WITH TWO HETEROs
  as_ = Atom( as_ )
  if Nof( as_ ) > 1 return error "\n Error_reroot> More than one atom selected \n"
  if Nof( as_ ) < 1 return error "\n Error_reroot> Empty selection \n"
  os_ = Obj ( as_ )
  if Nof( Atom( os_) ) > 200 return error "\n Can not reroot a macromolecule. Too many atoms\n"
  set object os_
  s_name = Name( a_ )[1]
  if Type( Obj( as_ ) 2) == "ICM" then
     convert as_ [1]
  else
     convert as_ s_name
     strip virtual
  endif
endmacro

macro dsStackConf as_ (a_//n,ca,c) i_from (1) i_to (Nof(conf)) s_superimpRes ("*")
  l_info=no
  l_confirm=no
  if(Type(s_scratchDir)=="unknown") s_scratchDir = s_tempDir
  if(Nof(conf)==0) return error " dsStackConf> stack is not loaded (use: read stack command)"
  load conf 0
  aaa = a_
  iMax= Min(i_to,Nof(conf))
  ener = Rarray(iMax-i_from+1)
  for i=i_from,iMax
    load conf i
    ener[i-i_from+1]=Integer(Energy("func")*10.)/10.
    write pdb as_ s_scratchDir+"/c"+i
  endfor
  eMin=Min(ener)
  ener = ener - eMin
  c1 = "c"+i_from
  for i=i_from,iMax
    read pdb s_scratchDir+"/c"+i
    j=3+Mod(i,Nof(color)-2)
    if(i>i_from) superimpose a_$c1.1/$s_superimpRes/ca,c,n a_1/$s_superimpRes/ca,c,n  # need an NA-fix
  endfor
  display a_c*. ener
  display a_c1. xstick
  color background grey # Strings are black
  delete label
  set font 18
  display " Range = "+String(Max(ener))+" kcal/mole.   Emin (blue conf.) = "+String(eMin) black
  display Sum(Sarray(ener),"  "), -0.9, 0.8 black
  set object aaa
  superimpose a_$c1.1/$s_superimpRes/ca,c,n a_1/$s_superimpRes/ca,c,n  # need an NA-fix
  center as_
  display residue label a_$c1. black
  print "delete a_c*.        # to delete previous models"
  print "delete label        # to delete old string labels"
  print "write postscipt bw  # to save the picture"
  print "edit dsStackConf    # to change the macro"
endmacro
#endif

macro searchObjSegment ms_  i_MinNofMatchingResidues (20) r_RMSD (5.)
# this macro is obsolete, ignore it
  if(Type(Obj(ms_),2)!="ICM") return " searchObjSegment_Error> can not assign segments in the non-ICM object."
  l_info=no
  if(Nof(segment)==0) read segment s_icmhome + "/foldbank"
  assign sstructure ms_
  assign sstructure segment ms_
  find segment ms_ i_MinNofMatchingResidues 2*i_MinNofMatchingResidues r_RMSD
# the second integer parameter is the min. res. length of the final composite solution
endmacro

#macro readPdbList S_list_of_pdb_codes
#  for i=1,Nof(S_list_of_pdb_codes)
#    read pdb Replace(S_list_of_pdb_codes[i]," ","")
#  endfor
#  make sequence a_*.
#endmacro

#ifdef Product > bio
macro calcEnsembleAver r_temperature (300.) s_parameter ("Value(v_/2/phi)")
# see also calcPepHelicity macro
  l_info=no
  s_oldterms = Info(term)
  if(Nof(object)==0) return error " macroError> Object not loaded"
  if(Nof(conf)==0) return error " macroError> Stack not loaded"
  load conf 0       # we assume that an object and the stack are loaded
  e0=Energy("func") # extract the lowest energy
  ansAver = 0.      #
  statsum = 0.      # the statistical sum initialization
  rt = r_temperature * Boltzmann
  for i=1,Nof(conf) # loop through all the stack conformations
    load conf i
    prob = Exp((e0-Energy("func"))/rt)
# s_parameter can contain any expression returning the parameter of interest
    ansAver = ansAver + $s_parameter *prob
    statsum = statsum+ prob
  endfor
  r_out= ansAver/statsum
  printf "Ansemble average of %s at %.1f K is: %.2f\n",s_parameter,r_temperature,r_out
  set terms only s_oldterms
  keep r_out
endmacro
#endif

macro calcDihedralAngle as_plane1 as_plane2
  l_info=no
                         # normal to the plane defined by the 1st triple
  v1 = Sum(Xyz(as_plane1[1])-Xyz(as_plane1[2]))
  v2 = Sum(Xyz(as_plane1[2])-Xyz(as_plane1[3]))
  n1 = Vector(v1,v2)
  n1 = n1/Length(n1)     # normal to the plane defined by the 2nd triple
  v1 = Sum(Xyz(as_plane2[1])-Xyz(as_plane2[2]))
  v2 = Sum(Xyz(as_plane2[2])-Xyz(as_plane2[3]))
  n2 = Vector(v1,v2)
  n2 = n2/Length(n2)     # similar usage of the Sum function
                         # r_out contains the resulting dihedral angle
  r_out = Acos(Sum(n1*n2))
  print "Angle= " r_out " deg. (in r_out)."
  keep r_out
endmacro

function DihedralAngle as_plane1 as_plane2
  as_out = ( a_*.A/as?,gl*,tyr,phe,trp,his/cg,[cno]d*,[cno]e* | a_*.A/arg/ne,nh* )  # define planes. add a_N..
  if(Nof(as_plane1 & as_out )<3 ) as_plane1 = Atom( as_plane1 & a_*.//!h* )
  if(Nof(as_plane2 & as_out )<3 ) as_plane2 = Atom( as_plane2 & a_*.//!h* )
  if(Type(as_plane1 1)=="residue") as_plane1 = as_plane1 & as_out
  if(Type(as_plane2 1)=="residue") as_plane2 = as_plane2 & as_out
  if(Nof(as_plane1)<3 | Nof(as_plane2)<3) return -1.
  v1 = Sum(Xyz(as_plane1[1])-Xyz(as_plane1[2]))
  v2 = Sum(Xyz(as_plane1[2])-Xyz(as_plane1[3]))
  n1 = Vector(v1,v2)
  n1 = n1/Length(n1)     # normal to the plane defined by the 2nd triple
  v1 = Sum(Xyz(as_plane2[1])-Xyz(as_plane2[2]))
  v2 = Sum(Xyz(as_plane2[2])-Xyz(as_plane2[3]))
  n2 = Vector(v1,v2)
  n2 = n2/Length(n2)     # similar usage of the Sum function
  return Acos(Sum(n1*n2))
endfunction

#ifdef Product > bio
macro calcPepHelicity s_movieName r_temperature (300.)
# see also ansembleAverage macro
# attention: 'temperature' is extremely important
   l_info=no
   if(Nof(object)==0) return error " macroError> Object not loaded"
   if(Nof(conf)==0) return " macroError> Stack not loaded"
   e0=Energy("func") # the lowest energy
   av=0.
   ssum = 0.
   r_temperature = r_temperature * Boltzmann
   res = Real(Nof(a_/*))
   read trajectory s_movieName
   for i=1,Nof(frame)
      load frame i s_movieName
      assign sstructure
      prob = Exp((e0-Energy("func"))/r_temperature)
      av = av + prob*Nof(Sstructure(a_1/*),"H")/res
      ssum= ssum+prob
   endfor
   print " The best E=", e0, "  Helicity= " av*100./ssum
endmacro

macro plotLearningCurve s_NNlearningOutputFile ("a.ou")
  if(!Exist(s_NNlearningOutputFile)) return error "Input not found"
  s_tab = Name( s_NNlearningOutputFile )
  if(Type( $s_tab )!="unknown") delete $s_tab
  read column unix grep epoch= $s_NNlearningOutputFile  | sed s/=\ \ /=/g |  sed s/=\ /=/g | sed s/=/\ /g | sed s/\(/\ /g | sed s/\)/\ /g | awk 'NF==15'
  group table s_tab Toreal(def3) "Epoch" def5 "Q2" def7 "RMSDcross" def9 "R2" def11 "RMSDself"
  make plot $s_tab "x=R2;y=Q2;color=Epoch;rainbow=purple/darkblue/blue/green/gold/orange/red;size=1;labelOnSelect=no;regression=xy;style=connected;;title=Learning Curve"
  make plot $s_tab "x=Epoch;y=R2;size=1.;style=connected;;x=Epoch;y=Q2;color=#ff0000;size=1.;style=connected;;xScale=log;yTitle=R2/Q2;;title=Epoch-R2/Q2"
  keep $s_tab
endmacro

macro plotEnergy s_McOutputFiles ("f1.ou") r_energyWindow (50.) l_best (no)
  if(!Exist(s_McOutputFiles)) then
    read sarray "S_files" sys ls $s_McOutputFiles
    if( Nof(S_files)==0 ) return error "This macro requires the montecarlo output file , e.g. icm _f1 > f1.ou"
  else
    S_files = Sarray( s_McOutputFiles )
  endif
  for ifi = 1,Nof(S_files)
    s_out = "awk 'BEGIN{printf \"#>T T\\n#> Ncalcs Energy\\n\"}{if ( ( $1 == \"DY\" || $1 == \"_Y\") && NF==14){print $14, $10}}' " + S_files[ifi]
    read table unix $s_out
    if(l_best)then
      eymin = T.Energy[1]
      j=0
      for i=2,Nof(T)
        if(T.Energy[i]>eymin)then
          T.Energy[i]=eymin
          j=j+1
          if(j>1)T.Ncalcs[i-1]=-1
        else
          eymin=T.Energy[i]
          j=0
        endif
      endfor
      delete T.Ncalcs==-1
    endif
    T.Energy = Trim(T.Energy,-999999.,Min(T.Energy) + r_energyWindow)
    if(Nof(S_files)>1) group table append T Iarray(Nof(T) ifi) "Run"
    if(ifi==1)then
      Tall=T
    else
      add Tall T
    endif
  endfor
#  plot display T.Ncalcs T.Energy (" MC Energy Profile of "+s_McOutputFile)//"Function calls"//"Energy"
  make plot Tall "x=Ncalcs;y=Energy;color=Run;style=connected;size=0;;"
  keep Tall
endmacro

#macro plotOldEnergy s_McOutputFile ("f1.ou") r_energyWindow (50.)
##  if(!Exist(s_McOutputFile)) print "This macro requires the montecarlo output file , e.g. icm _f1 > f1.ou"
#  read all unix egrep 'DY|_Y' $s_McOutputFile | awk 'BEGIN{printf "#>T T\n#> tm1 tm2\n"}NF==13{print $13, $9}'
#  T.tm2 = Trim(T.tm2,-999999.,Min(T.tm2) + r_energyWindow)
#  plot display T.tm1 T.tm2 (" MC Energy Profile of "+s_McOutputFilei)//"Function calls"//"Energy"
#endmacro

macro plotBestEnergies s_McOutputFiles ("f1,f2") r_energyWindow (50.) s_extraPlotArgs ("display")
 l_info=no
 print "This macro requires the montecarlo output file , e.g. icm _f1 > f1.ou"

 S_McOutputFile = Split(s_McOutputFiles,",")

 i_Txmax = 0
 r_Tymin = 1000.
 r_Tymax = -9999.

 for j = 1, Nof(S_McOutputFile)

 s_McOutputFile = S_McOutputFile[j]
 if(Extension(s_McOutputFile)=="") s_McOutputFile += ".ou"
 read all unix egrep 'DY|_Y' $s_McOutputFile | awk 'BEGIN{printf "#>T T\n#> tm1 tm2 I\n"}{if (NF==14) {print $14, $10, 0}}'  # does not work on Windows
  T.tm2 = Trim(T.tm2,-999999.,Min(T.tm2) + r_energyWindow)
  emin=T.tm2[1]
  T.I[1]=1
  for i=2,Nof(T.tm1)
    if(T.tm2[i] < emin) then
      T.tm2[i-1]=emin
      emin=T.tm2[i]
      T.I[i ]=1
      T.I[i-1]=1
    endif
  endfor
  T.tm2[Nof(T.tm1)]=emin
  T.I  [Nof(T.tm1)]=1
  T = T.I==1

  T$j.tm1 = T.tm1
  T$j.tm2 = T.tm2

  i_Txmax = Max(Max(T.tm1) i_Txmax)
  r_Tymin = Min(Min(T.tm2) r_Tymin)
  r_Tymax = Max(Max(T.tm2) r_Tymax)
  endfor

  Xmin = 0.
  Xmax = (Integer(i_Txmax / 10000) + 1 ) * 10000.
  Ymin = (Integer(Integer(r_Tymin) / 10.) - 1 ) * 10.
  Ymax = (Integer(Integer(r_Tymax) / 10.) + 1 ) * 10.
  R_axis = {$Xmin, $Xmax, 50000., 50000.,$Ymin,  $Ymax, 10., 10.}

  plot Rarray(T1.tm1) T1.tm2 ""//""//"" R_axis
  for i = 2, Nof(S_McOutputFile) - 1
   plot  Rarray(T$i.tm1) T$i.tm2 ""//""//"" append R_axis
  endfor
  i = Nof(S_McOutputFile)
  plot Rarray(T$i.tm1) T$i.tm2 (" MC Energy Profile of "+ Sum(S_McOutputFile))//"Function \
  calls"//"Energy" display append R_axis

endmacro
#endif

macro plotRose i_prime (13) r_radius (1.)
# just for fun
  fi={0.}
  for i=1,i_prime/2
    fi=fi//Rarray(i_prime i*360./i_prime i*360. )
  endfor
  plot display r_radius*Sin(fi) r_radius*Cos(fi) {-1. 1. 1. 1. ,-1. 1. 1. 1.} link frame
  if (Error) print "\n Hint> Try radius <= 1.3 and prime number of sides < 200\n"
endmacro

macro printTorsions rs_ (a_/A)
   # resLabelStyle = 2  # moved to Label(.,2)
   if (Type(Obj(rs_),2) != "ICM") return error " printTorsions_Error> object is not converted"
   rs_ = Res(rs_)
   nesl_ = Nof(rs_)
   Sto = {"phi", "psi",  "omg",  "xi1", "xi2", "xi21", "xi22", \
          "xi3", "xi31", "xi32", "xi4", "xi5", "xi6"}
   nto = Nof(Sto)
   sou_ = "residue     chain  "
   for ito = 1, nto
     sprintf "%-8s ", Sto[ito]
     sou_ = sou_ + s_out
   endfor
   printf "#\n%s\n#\n" sou_
   for i = 1, nesl_
     sprintf "%-10s %5s ", Tolower(Sum(Label(rs_[i],2))), Sum(Name(Mol(rs_[i])))
     sou_ = s_out
     for ito = 1, nto
       meto = Sto[ito]
       if (meto == "phi"|meto == "psi"|meto == "omg") meto = meto + "*"
       s_out = "      -  "
       if (meto != "psi*") then
         if (Nof(V_//$meto & rs_[i]) == 1) then
           sprintf "%8.1f ", Sum(Value(V_//$meto & rs_[i]))
         endif
       else
         if (Nof(V_//$meto & Next(rs_[i])) == 1) then
           sprintf "%8.1f ", Sum(Value(V_//$meto & Next(rs_[i])))
         endif
       endif
       sou_ = sou_ + s_out
     endfor
     print sou_
   endfor
   print "#"
endmacro

# new clean dsPocket.. and dsSkinPocket macros
macro dsGoodSpace as_source (a_)
  l_info=no
  l_commands=no
  l_gcxs = no
  if(Type(m_gc)=="map" ) then
    if( Nof( as_source & Box(m_gc) ) > 0 ) then
      l_gcxs = yes
    endif
  endif
  if(!l_gcxs) make map potential 0.5 Res(as_source) "gc" simple
  make grob m_gc name="g_vwspace" exact, -1.2  solid
  set g_vwspace reverse
  split g_vwspace 6 60.
  delete g_vwspace
  display g_vwspace1 smooth transparent lightgreen
  l_done = yes
  keep grob
endmacro

# REWRITE ALL POCKET MACROS   (currently only dsPocket is used) to allow direct selection.
macro dsPocketVw ms_ligand (a_H [1])
  l_info=no
  l_commands=no
  os = Obj( ms_ligand )[1]
  ms_receptor = Obj( ms_ligand )[1] & ! ms_ligand & ! a_*.W
  make map potential Sphere( ms_ligand ms_receptor 8. ) "gc" simple
  rename m_gc "m_vw" delete
  make grob m_gc name="g_excluded" exact 0.1 header
  make grob m_gc name="g_preferred" exact, -1.2 header
  display g_excluded pink
  display g_preferred grey
  keep g_excluded g_preferred m_vw
endmacro

macro dsPocket ms_lig (a_H [1]) s_GrobNa ("") l_overwr (yes) l_ds_xstick_hb (no) l_resLabels (yes) auto
  l_info=l_commands=l_warn=no
  ms_rec = a_CURREC.* & a_ICM. & !ms_lig
  if Nof(ms_rec)==0 ms_rec = Obj( ms_lig )[1] & ! ms_lig & ! a_*.W
  if Nof(ms_rec)==0 ms_rec = Obj( Sphere( ms_lig a_ICM./DD 7. ) & ! ms_lig )[1] & ! a_*.W
  if Nof(ms_rec)==0 return
  dsPocketRec ms_lig ms_rec s_GrobNa 6.5 l_overwr l_ds_xstick_hb l_resLabels
  keep grob
  if(Type(pocket_hbonds)=="parray") keep pocket_hbonds
endmacro

macro dsPocketRec ms_ligand (a_H [1]) ms_receptor (a_!H ) r_margin ( 6.5 ) s_GrobName ("") l_overwrite (yes) l_dsXstickHb (no) l_resLabels (yes) auto
  l_info=l_commands=l_warn=no
  GRAPHICS.l_redraw = no
  s_options = ""
  if(l_overwrite) s_options =  " delete "
  if( s_GrobName != "") s_options += " name=\"" + s_GrobName + "\""
  if (s_GrobName != "" & Type($s_GrobName)!="unknown") delete $s_GrobName
  make grob skin Sphere(ms_ligand ms_receptor r_margin ) ms_receptor  $s_options
  gname = s_out
  split $gname 1 delete # get rid of little fluff
  if Type( Obj(ms_receptor)[1] 2)=="ICM" then
    boxtm = Box( $gname 1.5 )
    make map potential "gs,gb" boxtm Atom( ms_receptor ) & boxtm  1.  s_skipMessages = "[73]"
    color $gname white
    color $gname map -m_gs { 0,0,0,3,4,5 } { 0. 0.5  } green
    # add GRAPHICS.NtoCRainbow forcing
    color $gname map solid m_gb { 1,1,2,3,0,0,7,8,9 } { -.7 .7 } GRAPHICS.NtoCRainbow = "blue/white/red" # for new hb maps augment hydrogen field
  else
    color $gname lightcyan
  endif
  if(l_dsXstickHb) then
     rs_rec = Res( Sphere( ms_ligand & a_*.//!h*,vt*  ( ms_receptor & !ms_ligand & a_*.//!h*,vt* ) , -1.6 ) )
     display xstick rs_rec
     make hbond  rs_rec ms_ligand display  name="pocket_hbonds"
     if (l_resLabels) display residue label rs_rec
     keep pocket_hbonds
  endif
  set label Sphere( ms_ligand & a_*.//!h*,vt* , ms_receptor & a_*.//!h*,vt* , -1.8)
  link $gname Mol( ms_ligand )
  display $gname transparent smooth
  GRAPHICS.l_redraw = yes ; display new
  keep $gname
endmacro
#
macro makeLigandPocketSurface r_distance (3.5)
  l_info=l_commands=l_warn=no
  makeLigandPocketSurfaceLigRec a_LIG.I a_CURREC. LIGAND.box r_distance
  link g_recPocketSurface a_CURREC.
  keep g_recPocketSurface # gdon gacc
endmacro
#
macro makeLigandPocketSurfaceLig ms_ligand r_distance (3.5)
  l_info=l_commands=l_warn=no
  ms_rec = Mol( a_CURREC. [1] ) & a_ICM. & !ms_ligand
  if Nof(ms_rec)==0 ms_rec = Obj( ms_ligand )[1] & ! ms_ligand & ! a_*.W
  if Nof(ms_rec)==0 ms_rec = Obj( Sphere( ms_ligand a_ICM./DD 7. ) & ! ms_ligand )[1] & ! a_*.W
  if Nof(ms_rec)==0 return error "cannot find receptor object"
  makeLigandPocketSurfaceLigRec ms_ligand Obj( ms_rec ) Box( ms_ligand  3. ) r_distance
  keep g_recPocketSurface # gdon gacc
endmacro
#
macro makeLigandPocketSurfaceLigRec ms_lig os_rec R_box r_dist
  l_info=no; l_warn=no;
  if( Nof( os_rec & R_box ) ==0  ) return " Error> LIGAND.receptor or LIGAND.box not defined or do not match"
  gridSize = 0.35
  tol=0.; if(GRAPHICS.hbondMinStrength<1.) tol=0.33*Sqrt(1.-GRAPHICS.hbondMinStrength);
  HPdi = 1.5+0.4*tol;ARdi = 1.45+0.4*tol;HBAdi = 1.6+tol; HBDdi = 1.5+tol # additional to van der Waals probe radii
#
  set object Obj( os_rec ) [1]
  N=5; print bar "Building surface" N l_info=yes

  print bar N
  make map potential "gc" simple R_box Res( a_ & Box( R_box 2.5 ) ) & ( a_//M5 | a_//!h* ) & !ms_lig gridSize
  print bar N
  if(r_dist>0. & Nof(Atom( ms_lig & R_box ))>1 ) then
    make grob m_gc exact 0.001 ms_lig margin=r_dist name="g_recPocketSurface"
  else
    make grob m_gc exact 0.001 name="g_recPocketSurface"
  endif
  print bar N
  split g_recPocketSurface 1
  if(Type(g_recPocketSurface1)=="grob") g_recPocketSurface=g_recPocketSurface1

# -- pocketFinder
#  m_cav = Bracket( m_gc , -3.5,  -0.8) + 0.8
#  for i=1,10
#     m_cav= Smooth( m_cav  )
#  endfor
#  make grob m_cav exact -0.18 name="g_cav"
#  split g_cav 1 50.
#  set g_cav reverse
#  display g_cav white smooth transparent
#  keep g_cav

  color g_recPocketSurface a_//H  & !ms_lig green add GROB.atomSphereRadius= HPdi
  color g_recPocketSurface a_//R  & !ms_lig white add GROB.atomSphereRadius= ARdi
  color g_recPocketSurface a_//HA & !ms_lig lightblue pseudo GROB.atomSphereRadius= HBAdi+0.3
  color g_recPocketSurface a_//HA & !ms_lig blue pseudo GROB.atomSphereRadius= HBAdi
  color g_recPocketSurface a_//HA & !ms_lig navy pseudo GROB.atomSphereRadius= HBAdi-0.2
  color g_recPocketSurface a_//HD & !ms_lig pink   add GROB.atomSphereRadius= HBDdi+0.3
  color g_recPocketSurface a_//HD & !ms_lig red   add GROB.atomSphereRadius= HBDdi
  print bar N

  display g_recPocketSurface

  print bar "End\n" l_info=yes
  keep g_recPocketSurface # gdon gacc
  display new
endmacro

macro hbondPrepare os_objects
  l_info = l_commands = no
  ms = Mol( os_objects ) & a_!ICM. & a_*.!W
  if Nof(Atom(ms)) > 0 then
    build hydrogen Atom( ms ) & a_*.!W//!c* l_warn=no
    set type mmff ms # & a_*.H
    if (l_warn) print " Warning> for an optimal orientation of rotatable hydrogens apply convert PDB"
  endif
endmacro

#ifdef Product >= bio
macro dsSkinPocket ms_ligand (a_2) ms_receptor (a_) r_radius (7.) l_biggestBlobOnly (yes)
  ms_receptor = ms_receptor & !ms_ligand
  gname = "g_pocket_"+Name(Obj(ms_receptor))[1]+"_"
  if Type( $gname ) == "grob" delete $gname
  make grob skin wire Sphere(ms_ligand ms_receptor r_radius) ms_receptor  name=gname
# think beyond your single today's case!!!
  if(l_biggestBlobOnly) then
    split $gname 3 80.  # delete tiny grobs
    delete $gname
    gname1=gname+1
    rename $gname1 $gname
  endif
  display $gname yellow
  set label Sphere( ms_ligand ms_receptor 4.)  & a_*.//!o,hn,c,n,h*
  display residue label Res(Sphere(ms_ligand ms_receptor 3.5))
  print "Grob  "+gname+"  created (rename it to avoid overwriting)"
  print "color, undisplay, write and remove it, e.g.: color "+gname+" green"
  s_out = gname
  keep $gname
endmacro

macro dsSkinPocketIcm ms_ligand (a_H [1]) ms_receptor (a_!H) r_radius (7.) l_biggestBlobOnly (yes)
  l_commands = no
  l_info     = no
  l_warn = no
  l_confirm = no
  l_minRedraw = no
  if( Nof( Obj( ms_receptor ) & a_ICM. ) == 0 ) return error " Error> Use convertObject first"
  as_sel =  Sphere(ms_ligand ms_receptor r_radius)
  set object Obj( as_sel )
  ms_tmp = Mol( as_sel )
  boxtm = Box( as_sel 1.5 )
  make map potential "gs,gb" boxtm Atom( ms_tmp ) & boxtm  1.
  make grob skin wire "g_recSkin" Sphere( as_sel ms_tmp 1.3)  ms_tmp
# think beyond your single today's case!!!
  if(l_biggestBlobOnly) then
    split g_recSkin 3 70. # less 70. points is one atom shere
    delete g_recSkin
    rename g_recSkin1 "g_recSkin"
  endif
  display g_recSkin
  display residue label Res(Sphere(ms_ligand ms_receptor 3.5))
  color g_recSkin white
  color g_recSkin map -m_gs { 0,0,0,3,4,5 } { 0. 0.5  } green
  color g_recSkin map  m_gb { 1,1,2,3,0,0,7,8,9 } { -.7 .7 }
  print " Color code:"
  print " Green - hydrophobic"
  print " Red   - hydrogen bond acceptor"
  print " Blue  - hydrogen bond donor"
  keep g_recSkin
  keep map
endmacro
#endif

macro makeContactMesh as_first (a_H) as_second (a_!H) l_apolar (yes)
  as_include = a_*.//!P
  if(l_apolar) as_include = a_*.//!P,o*,n*
  R_box = Box( Sphere( as_first as_second 5. ) | Sphere( as_second as_first 5. ) )
  make map potential 0.25 as_first & as_include  R_box name="m_first"
  m_first = Trim( m_first 0. 1. )
  make map potential 0.25 as_second & as_include R_box name="m_second"
  m_second= Trim( m_second 0. 1. )
  make grob Smooth(Smooth(m_first*m_second)) exact 0.3 solid name = "g_contact" # contour smoothened overlap
  split grob g_contact join 100.  # get rid of tiny fragments
  compress g_contact1 0.1         # clean up mesh somewhat
  color g_contact1 yellow
  keep g_contact1
endmacro


macro calcEnergyStrain rs_ ( a_/A ) l_colorByEnergy (yes) r_max (7.)
  l_info=no ; olffme=ffMethod
  rs_ = Res( rs_ ) & a_ICM./A & a_ICM./!cyss,cyx
  if Nof(Obj( rs_ ))==0 return error "\n Error> No ICM objects found. Convert the object to the ICM type first\n"
  set object Obj( rs_ )[1]
  rs_ = rs_ & a_
  n =   Nof( rs_ )
  assign sstructure
  oldfix = v_//*
  unfix only V_//S
# the Energy( rs_ simple ) function will temporarily redefine vwMethod and the terms
  #s_out = "x=i;y=NormEnergy;color=BondsAngles;size=8;title=Normalized residue energies"
  l_showResCodeInSelection=yes
# change curson to doubleClick or link to selection (set format) RA
  global group table ENERGY_STRAIN Count(n) "i" Name( rs_ full ) "Sel" Name(rs_ ) "Res" Split(Sstructure(rs_),"") "sec_str" Energy(rs_ simple) "NormEnergy" Iarray(n) "Occupancy" Rarray(n) \
  "BondsAngles" Rarray(n) "Bonds" Rarray(n) "Angles" Rarray(n) \
  "Phi" Rarray(n) "Psi" header "center %2 margin=12.; display residue label %2; as_graph= Atom( %2 )" "cursor"

  make plot ENERGY_STRAIN "x=i;y=NormEnergy;color=BondsAngles;size=8;title=Normalized residue energies"
  set format ENERGY_STRAIN.NormEnergy "%.4g" name="" color="rainbow='#8888FF/#FFFFFF/#FF8888,-1.:6.,pinwheel'"
  if l_colorByEnergy color wire xstick cpk skin ribbon rs_ Trim( ENERGY_STRAIN.NormEnergy , -3., r_max ) window = -3. // r_max
  set field rs_ ENERGY_STRAIN.NormEnergy
  if( Nof( rs_ & a_//DX ) > 0 ) set xstick Res(Select( rs_ "o<0.2" )) GRAPHICS.stickRadius * 3.
  ffMethod = 2
  ENERGY_STRAIN.Bonds  = Energy( rs_ "bs" )
  ENERGY_STRAIN.Angles = Energy( rs_ "bb" )
  ENERGY_STRAIN.BondsAngles = ENERGY_STRAIN.Bonds + ENERGY_STRAIN.Angles
  ENERGY_STRAIN.Phi = Rarray(Iarray(Value( rs_ "phi")))
  ENERGY_STRAIN.Psi = Rarray(Iarray(Value( rs_ "psi")))
  ENERGY_STRAIN.Occupancy = Iarray( Occupancy( rs_ )*100 )
  set format ENERGY_STRAIN.BondsAngles color="rainbow='#FFFFFF/#FFFF00/#FF0000,45.:150.,pinwheel'"
  set format ENERGY_STRAIN.Bonds color="rainbow='#FFFFFF/#FFFF00/#FF0000,10.:150.,pinwheel'"
  set format ENERGY_STRAIN.Angles color="rainbow='#FFFFFF/#FFFF00/#FF0000,35.:150.,pinwheel'"
  sort ENERGY_STRAIN.NormEnergy reverse
  unfix only oldfix   # re-set original fixation
  ffMethod=olffme
#  gui refresh "ENERGY_STRAIN"
endmacro

#ifdef Product > bio
macro dsLocalReliability ms_ (a_1) ali_ (alignment[0]) l_plot (no)
   l_commands = no
   l_info = no
   print "Basis: consider sequence-structure alignment. Color the template by the similarity strength"
   if(Nof(ms_)!=1) return error "Specify only one molecule"
   if (Nof(ali_) != 2) return error "Input alignment should contain only two sequences"
   display ribbon ms_ grey
   s_seq = Name(ms_ , sequence)[1]
   if (s_seq == "none") return error "No links to 3D structure."
   R_p = Rarray(Probability(ali_), ali_, $s_seq )
   R_p = Trim(-Log(R_p, 10), 0.3, 6.0)
   color ribbon ms_ & a_*./A -R_p
   S_tit = Sarray("Local reliablity of the alignment "+Sum(Name(ali_))) // "Sequence" // \
           "Reliabilty index"
   if (l_plot) plot display number comment=Sarray(String($s_seq)) R_p S_tit
endmacro

macro dsModelReliability ms_ ( a_1 ) &seq_  r_probThreshold (0.0001)
 print "Basis: consider sequence-structure alignment. Color the template by the similarity strength"
 ms_ = Mol( ms_ )
 for i=1,Nof(ms_)
     make sequence ms_[i] name = "seqTempl"
     if(Type(seqTempl)!="sequence"|Length(seqTempl)<10) continue
     sx = Align(seqTempl seq_)
     if(Probability(Length(seq_),Score(sx)) < 0.001) then
         p= -Log(Probability(sx))
         p1 = Rarray(p,sx,seq_)
         display ribbon Res(ms_[i]) p1
         show p1
  else
         print "The overall alignment reliability is below threshold of ",r_probThreshold
         show sx
  endif
  endfor
  keep p1
endmacro

#endif

macro plotSeqProperty R_property s_seqString S_3titles ({"Title","Position","Y"}) s_fileName ("tm.eps") i_numPerLine (30) s_orientation ("portrait")
# a template for plotting multiple data sets
  if (Extension(s_fileName)!=".eps") s_fileName = s_fileName+".eps"
  if (Exist(s_fileName)) sys $s_sysRm $s_fileName
  ns=(Nof( R_property )+i_numPerLine-1)/i_numPerLine
  PLOT.orientation = s_orientation
  PLOT.Yratio= 0.         # auto: preserve Yratio of PLOT.box
  PLOT.box   = {0. 0.05 1. } // .9/ns
  range=Power(10. Ceil(Log(Max(R_property)-Min(R_property)+.000001 10.))-1)
  Tics = {10. 5.} // Floor(Min(R_property) range) // Ceil(Max(R_property) range) // .5*range // range
  for i=1,Nof( R_property ),i_numPerLine
    PLOT.numberOffset = i-1
    PLOT.box[2]= .95 - .9/ns*(i/i_numPerLine+1.)
    i2=Min(i-1+i_numPerLine,Nof( R_property ))
    if(i>1)S_3titles[1]=""
    if(i>1)PLOT.logo=no
    plot comment=s_seqString[i:i2] number R_property[i:i2] Rarray(2,i-1.,i+i_numPerLine)//Tics s_fileName S_3titles append
  endfor
  sys $s_psViewer $s_fileName
endmacro

macro plotMatrix M_data s_longXstring S_titles ({"Title","X","Y"}) s_fileName ("tm.eps") i_numPerLine (10) i_orientation (1)
  if (Extension(s_fileName)!=".eps") s_fileName = s_fileName+".eps"
  if (Exist(s_fileName)) sys $s_sysRm $s_fileName
  if (Length(s_longXstring)!=Nof(M_data)) s_longXstring=String(" ",Nof(M_data))
  ns=(Nof( M_data )+i_numPerLine-1)/i_numPerLine
  PLOT.orientation = i_orientation
  PLOT.Yratio= 0.         # auto: preserve Yratio of PLOT.box
  PLOT.box   = {0. 0.05 1. } // .9/ns
  range=Power(10. Ceil(Log(Max(Max(M_data))-Min(Min(M_data))+.000001 10.))-1)
  Tics = {10. 5.} // Floor(Min(Min(M_data)) range) // Ceil(Max(Max(M_data)) range) // .5*range // range
  for i=1,Nof( M_data ),i_numPerLine
    PLOT.numberOffset = i-1
    PLOT.box[2]= .95 - .9/ns*(i/i_numPerLine+1.)
    i2=Min(i-1+i_numPerLine,Nof( M_data ))
    if(i>1)S_titles[1]=""
    if(i>1)PLOT.logo=no
    plot comment=s_longXstring[i:i2] number M_data[i:i2,?] Rarray(2,i-1.,i+i_numPerLine)//Tics s_fileName S_titles append
  endfor
  sys $s_psViewer $s_fileName
endmacro

#ifdef Product > browser
macro icmCavityFinder as_ ( a_A ) r_minVolume ( 3. )
   l_info = no
   l_confirm = no
   l_openPocket= no
   r_contourLevel =0.2
   as_ = as_ & a_*.!W  # exclude water
   mar = 2.2
   delete grob "g_cavity*"
   if(l_openPocket ) then
     bbb = Box( a_ mar)
     make map potential as_ bbb Ceil(Power(Volume(bbb[4:6]-bbb[1:3])/130000.,0.33),0.1)
     make grob m_atoms r_contourLevel exact solid name="g_cavity"
   else
     make grob skin as_ as_ "g_cavity"
   endif
   split g_cavity 20.
   nShells = i_out
   if(nShells==0) then
     rename g_cavity g_cavity1
     nShells=1
   endif
   if(Type(g_cavity)=="grob") delete g_cavity
   for i=1,nShells
     if( Abs(Volume(g_cavity$i)) < r_minVolume ) break
   endfor
   nShells = i-1
   global group table CLOSED_CAVITIES Count(nShells) "i" Rarray(nShells) "Volume" Rarray(nShells) "Area" Rarray(nShells) "Radius" Sarray(nShells) "Type" \
    header "undisplay grob\ndisplay smooth g_cavity%1 color[%1+1]\nas_graph=Sphere(g_cavity%1,2.5)" "cursor"
   make plot CLOSED_CAVITIES "x=Volume;y=Area;color=i;size=8;title=Volumes and areas;;element=rectangle;x1=150;y1=200;x2=550;y2=550;color=blue;fillStyle=BDiagPattern;label=Drugs;labelPos=center"
   for i=1,nShells
     if( Type( g_cavity$i )=="grob" ) then
     v = Volume(g_cavity$i)
     s = r_out
     if( Abs(v) < r_minVolume ) then
       delete g_cavity$i
     elseif(v > 0.) then
##       printf "Shell  %d: V=%f A=%f\n", i, v, s
       CLOSED_CAVITIES.Volume[i]= v
       CLOSED_CAVITIES.Area[i]= s
       CLOSED_CAVITIES.Radius[i]=3.*v/s
       CLOSED_CAVITIES.Type[i]= "outer envelope"
     else
#       display smooth g_cavity$i color[i+2]
       set g_cavity$i reverse
       link g_cavity$i Obj( as_ )[1]
#       if l_interactive center g_cavity$i
#       printf "CAVITY %d: V=%f A=%f R~%f -------------------\n", i, -v, s, -3.*v/s
       CLOSED_CAVITIES.Volume[i]=-v
       CLOSED_CAVITIES.Area[i]=s
       CLOSED_CAVITIES.Radius[i]=-3.*v/s
       CLOSED_CAVITIES.Type[i]= "cavity"+i+ " "+ String(Res(Sphere( g_cavity$i as_ 2. )))
       as_1 = Atom(as_) & Sphere( g_cavity$i 2. )
       s_mainColor = Color( Mol( as_1 ) field )[1] ; if (s_mainColor == "") s_mainColor="lightblue"
       color g_cavity$i s_mainColor
#       show Res ( as_1 )
#       if l_interactive display residue labels Res ( as_1 )
#       if l_interactive display atom labels as_1
#       if l_interactive pause
     endif
     endif  # if for non-existing grobs
   endfor
   delete CLOSED_CAVITIES[1]
#   if(nShells==1)print "XXXXXXXX   No Cavities Found   XXXXXXXXX"
   keep grob
#   gui refresh "CLOSED_CAVITIES"
endmacro
#endif

macro sortSeqByLength
  l_info=no
  print "Sort the sequence by length for visual inspection."
  if(Nof(sequence)==0) return error
  group sequences alignm_M
  names_M = Name(alignm_M)
  length_M = Iarray(Nof(names_M))
  for i=1,Nof(names_M)
    length_M[i]=Length(sequence[i])
  endfor
  group table tab_M names_M length_M
  sort tab_M.length_M
  show tab_M
  avlen_M = Integer(Mean(tab_M.length_M))
  sigm_M  = Integer(Rmsd(tab_M.length_M))
  printf "To delete outliers, e.g.: delete sequence %d %d\n" Max(10,avlen_M-3*sigm_M), avlen_M+3*sigm_M
endmacro

macro colorConsensus l_resLabel (no)
  l_info = no
  if (!Exist(view)) return error "Error: no display"
        rs_ = Select(residue)
  if(Nof( rs_ ) ==0) return error " Error in colorConsensus> no residues linked or displayed"
  comm= {"polar,small","exactly conserved","hydrophobic","exact hydroph","negative","exact +","positive","exact +"}
  col = {"lightgreen" "green" "lightyellow"  "yellow"  "lightcoral"   "red"   "steelblue" "blue"}
  sel = {"a_*./Cps"   "a_*./CX" "a_*./Ch" "   a_*./CLVMIAFW" "a_*./Cn" "a_*./CED" "a_*./Co" "a_*./CKR"}
  res = Sarray(Nof(col))
  set label a_*./CX/cb & rs_
  for i = 1,Nof(col)
    color ribbon skin wire xstick cpk $col[i] rs_ & $sel[i]
    if (l_resLabel & i-2*(i/2)==0) display residue label $col[i] $sel[i]
  endfor

  show Mol(rs_ & a_*./CX)
  show "COLOR CODE:"
  show column col sel comm
endmacro

macro antiSuper os_template  r_margin (2.)
  l_commands = no
  if(Nof(as_graph)==0) return

# put the template atoms to as_out
  as_out = (os_template & as_graph)
  if(Nof(as_out)==0) then
    as_out = as_graph & ( Obj(as_graph)[1] )
  endif

# calculate mol dimensions xm,ym and the grid parameters nc,nr
#  amp = r_margin + Max( Abs(Box( as_out )[4:6]-Box(as_out)[1:3]) ) # to be commented out
  win_asp = View(window)[1]/(View(window)[2]+0.001)  # aspect of window
  tmp = Xyz(as_out)*View("x")  # project atom coord to screen X
  xm = Max(tmp)-Min(tmp)       # find dimensions
  tmp = Xyz(as_out)*View("y")
  ym = Max(tmp)-Min(tmp)
  mol_asp = xm/(ym +0.001)
  nob = Nof( Obj(as_graph) )
  nc = Min(nob, Integer(Ceil( Sqrt( nob / ( mol_asp / win_asp ) ))))
  nr = Integer( Ceil( nob/Real(nc) ))  # just for information, not used below
  if(nob==4 & (nc==2 & nr==3) | (nc==3 & nr==2)) then
    nc=2
    nr=2
  endif
  print " antiSuper> xm = " xm, " ym=" ym, "  win_asp=" win_asp, " nr= ",nr, " nc=",nc

# determine the index of the static object
  i_template = Index(Name(Obj(as_graph)), Name(os_template)[1])

# translate molecules. Calc ix and iy and finish the traslate vector calculation
  if(i_template==0) then
    iy0 = 0
    ix0 = 0
  else
    iy0 = 1+(i_template-1)/nc
    ix0 = 1+Mod(i_template-1,nc)
  endif

  for iob=1,nob
     iy = 1+(iob-1)/nc
     ix = 1+Mod(iob-1,nc)
     as_out = as_graph & ( Obj(as_graph)[iob] )
     if( iob != i_template ) then
        translate add Obj(as_out) \
          View("x") *(xm+r_margin) * (ix-ix0) + \
          View("y") *(ym+r_margin) * (iy-iy0)
     endif
  endfor
  center static as_graph

endmacro

#macro testgrid i_template (0) i_nc (2) i_nr (3) i_nob (5)
#  nc = i_nc
#  nr = i_nr
#  nob = i_nob
#  if(i_template==0) then
#    iy0 = 0
#    ix0 = 0
#  else
#    iy0 = 1+(i_template-1)/nc
#    ix0 = 1+Mod(i_template-1,nc)
#  endif
#  print " ix0 iy0 = "  ix0, iy0
#
#  for iob=1,nob
#     iy = 1+(iob-1)/nc
#     ix = 1+Mod(iob-1,nc)
#     print iob, ix, iy, ix0, iy0
#  endfor
#endmacro

macro dsConsensus ali_ &seq_ l_dsLabels (yes) s_graphType ("skin")
  l_info = no
  if (Nof(object)==0) return error " dsConsensus> no objects loaded."
  molSel = a_/A & seq_
  if (Nof(molSel) == 0) return error "Current object and the selected sequence do not match"
  S_graphType = {"wire" "skin" "surface" "ribbon" "cpk" "xstick" "stick" "ball"}
  if (Index(S_graphType, s_graphType) == 0) return "Incorrect display type"
  if (Index(Name(ali_) Name(seq_)) == 0) return error "Selected sequence does not belong to the alignment"
  s_cons = Consensus(ali_, seq_ )
  if (!Exist(view)) then
    display a_//!h*
    print "Rotate to select your favourite view and hit RETURN"
    pause
  endif
  set plane new name=s_graphType
  if (l_dsLabels) then
    rs_cons = molSel & Replace(s_cons, "[.~^]" ," ")
    for i=1,Nof(rs_cons)
      s_tmp = "g_" + i
      printf "%s " Sum(Label(rs_cons[i]))
      if (Nof(rs_cons[i] & a_//!ca,c,n,o,ha,hn)==0) then
        $s_tmp = Grob("label",Mean (Xyz(rs_cons[i]))-3.*View("z"),Sum(Label(rs_cons[i])))
      else
        $s_tmp = Grob("label",Mean (Xyz(a_//!ca,c,n,o,ha,hn & rs_cons[i]))-3.*View("z"),Sum(Label(rs_cons[i])))
      endif
      display $s_tmp blue
      keep $s_tmp
    endfor
    print "\n"
  endif
  set plane s_graphType on
  if (s_graphType == "skin") then
    display $s_graphType a_//!h* a_//!h* grey
  else
    display $s_graphType a_//!h* grey
  endif
  color $s_graphType magenta   molSel & Replace(s_cons, "[.~^-+#]" ," ")
  color $s_graphType orange   (molSel & Replace(s_cons, "[!C]"," ") & a_/cyss)
  color $s_graphType rgb={ 0.5 0.6 0.25 }   molSel & Replace(s_cons, "[!#]"    ," ")
  color $s_graphType yellow    molSel & Replace(s_cons, "[!LVMIAFW]"," ")
  color $s_graphType rgb={ 1. 0.25 0.25 }  molSel & Replace(Replace(s_cons, "[-]","O"), "[!O]"," ")
  color $s_graphType red       molSel & Replace(s_cons, "[!ED]"," ")
  color $s_graphType steelblue molSel & Replace(s_cons, "[!+]"," ")
  color $s_graphType blue      molSel & Replace(s_cons, "[!KR]"," ")
  print " Info> Consensus string s_cons, and consensus selection rs_cons are created"
  keep s_cons rs_cons
endmacro

macro dsSkinLabel rs_ (a_/*) s_color ("magenta")
  if(Nof(object)==0) return error " dsSkinLabel> no objects loaded."
  resLabelShift = 4.0
  set label rs_ & a_*.*/trp/cz2
  set label rs_ & a_*.*/lys/nh
  set label rs_ & a_*.*/arg*,phe,tyr/cz
  set label rs_ & a_*.*/asn,asp,leu,pro/cg
  set label rs_ & a_*.*/cys*,met/s*
  set label rs_ & a_*.*/gln,glu/cd
  set label rs_ & a_*.*/his/ce1
  set label rs_ & a_*.*/ile/cd1
  set label rs_ & a_*.*/val,thr,ser/cb
  display residue label rs_ $s_color
endmacro
#:)

macro setResLabel
  if(Nof(object)==0) return error " setResLabel> no objects loaded."
  resLabelShift = 3.0
  set label a_*.*/trp/cz2
  set label a_*.*/lys/nh
  set label a_*.*/arg*,phe,tyr/cz
  set label a_*.*/asn,asp,leu,pro/cg
  set label a_*.*/cys*,met/s*
  set label a_*.*/gln,glu/cd
  set label a_*.*/his/ce1
  set label a_*.*/ile/cd1
  set label a_*.*/val,thr,ser/cb
endmacro
#:(
macro searchPatternPdb s_pattern ("[LIV][!P]AAAA$")
  l_info = no
  if(Type(foldbank)=="unknown") read database s_icmhome + "foldbank.db" group
  for i=1,Nof(foldbank.NA)
    find pattern  s_pattern Sequence(foldbank.SE[i]) mute
    if(i_out > 0)print i, foldbank.NA[i], Length(foldbank.SE[i]), s_out, "P=",r_out
    printf "\r %d\r",i
  endfor
endmacro
#:)
macro findFuncZero s_Function_of_x ("Exp(-Exp(-x))-0.5")  r_xMin (0.) r_xMax (1.) r_eps (0.00001)
# a simple dichotomy, assuming that function is smooth and has only one solution in the interval
# if(Type(x)!="unknown") return error " findFuncZero_Error> name 'x' is already in use. Hint: rename x X # for example"
  l_info=no
  x=r_xMin
  rSy0=$s_Function_of_x
  x=r_xMax
  rSy1=$s_Function_of_x
  if(rSy0     ==0.0)return " => x=" r_xMin
  if(     rSy1==0.0)return " => x=" r_xMax
  if(rSy0*rSy1> 0.0)return " => F(r_xMin) and F(r_xMax) should have the opposite sign"
  while(Abs(r_xMax-r_xMin)>r_eps)
    x=0.5*(r_xMin+r_xMax)
    rSy=$s_Function_of_x
    if(rSy0*rSy>=0.0)r_xMin=x
    if(rSy1*rSy>=0.0)r_xMax=x
    printf " => x=%f  F=%f\n" x rSy
  endwhile
endmacro
macro findFuncMin s_Function_of_x ("Sin(x)*x-1.") r_xMin (-1.) r_xMax (2.) r_eps (0.00001)
# a simple dichotomy, assuming that function derivative is smooth and has only one solution in the interval
# if(Type(x)!="unknown") return error " findFuncMin_Error> name 'x' is already in use. Hint: rename x X # for example"
  l_info=no
  x=r_xMin-0.5*r_eps
  rSy=$s_Function_of_x
  x=r_xMin+0.5*r_eps
  rSy0=$s_Function_of_x-rSy
  x=r_xMax-0.5*r_eps
  rSy=$s_Function_of_x
  x=r_xMax+0.5*r_eps
  rSy1=$s_Function_of_x-rSy
  if(rSy0*rSy1> 0.0)return error " => bad choice of [r_xMin,r_xMax] interval"
  if(rSy0*rSy1==0.0)return error " findFuncMin_Error> one of borders has zero slope"
  while(Abs(r_xMax-r_xMin)>r_eps)
    x=0.5*(r_xMin+r_xMax-r_eps)
    rSy=$s_Function_of_x
    x=0.5*(r_xMin+r_xMax+r_eps)
    rSy=$s_Function_of_x-rSy
    if(rSy0*rSy>=0.0)r_xMin=0.5*(r_xMin+r_xMax)
    if(rSy1*rSy>=0.0)r_xMax=0.5*(r_xMin+r_xMax)
    printf " %f < x < %f\n" r_xMin r_xMax
  endwhile
endmacro

#ifdef Product >= browser

macro optimizeH_zeroOcc rs_ l_optimize_his l_dyn_prot
# assumes current object
  #l_commands = yes
  l_info = no
  l_minRedraw = no
  GRAPHICS.l_redraw = no
  electroMethod = "distance dependent"
  if(Nof(rs_ & a_A/*) > 100) printf " Warning> hydrogen optimization for this %d-res. object may take a few minutes. Please wait...\n", Nof(rs_ & a_A/*)
  as2_out = Select(rs_ & a_A//!h* "o<0.01" )
  delete stack
  if( Nof(v_//x* & as2_out)>0) then
    printf " convertObject> optimizing %d missing or zero occupancy side-chains..\n"  Nof(Res(as2_out))
    ssearch residue  fast v_//x* & as2_out "vw,14,hb,to,ss,el" vwCutoff=6.5
  endif
  printf " convertObject> optimizing %d polar hydrogens..\n" Nof(Res( Atom( v_//P & rs_ ) ))
  if(Nof(v_//P & (rs_ & a_A//h* ) )>0)ssearch residue fast v_//P & ( rs_ & a_A//h* )  "vw,14,hb,to,ss,el" dielConst=2.  # in AMINO
  for i=1,Nof( v_//P & ( rs_ & a_!A//h* ) )   # in nonamino/Hetatms
    ssearch fast ( v_//P & (rs_ & a_!A//h* ) ) [i] "vw,14,hb,to,ss,el"
  endfor
  if( Nof( rs_ & a_W ) > 0 ) then
     set a_W//vt1 Xyz( a_W//o )  # sets the position of the first virtual atom
     minimize v_W//!?vt1 & rs_ "vw,14,hb,to,ss,el" 500
  endif
  if ( l_optimize_his )then
    if(!l_dyn_prot) optimizeHisProAsnGlnCys a_/hi*,asn,gln,cys         # was his
    if( l_dyn_prot) optimizeHisProAsnGlnCys a_/hi*,asn,gln,cys,asp,glu
  endif
  if(Nof(v_//x* & as2_out)>0)then
    set vrestraint a_/*  # optimized missing and added heavy atoms
    minimize v_//x* & as2_out 1000 "vw,14,hb,to,ss,el"
    if(Nof(Res(as2_out))<Nof(rs_ & a_/A)/10) then
      montecarlo fast mute v_//x* & as2_out  v_//x* & as2_out "vw,14,hb,to,ss,el"
    else
      print " Warning> Too many heavy atoms were absent from pdb and were added with zero occupancies. \n Requires special optimization\n"
    endif
  endif
endmacro

macro deleteWeakWaters os_obj (a_) s_water ("")
  l_commands = l_info = no
  s_curObj = Name( a_ )[1]
  set object Obj( os_obj )[1]
  if(Nof(a_W)>0)then
    # very loose
    show area surface a_W//o* a_!W//!h* vwExpand=0.7
    delete Select( a_W//o* "A>36.") # remove those with less than 1/3 of the area in contact, usually about half
    # weak
    show hbond exact a_W a_!W   # calculate empiric hydrogen bonding energy between water molecules and the rest
    set field a_W//o* Sum(Transpose(Matrix(Rarray( a_W//o*,h* ) 3))) # accumulate totals on oxygens (transerred from hydrogen )
    # show column Name( a_W ) Field( a_W//o* )
    r_wCutoff = 5.
    if(Length(s_water)>5) r_wCutoff = Real( s_water[6:$] )
    if( Index( s_water "hetero" )!=0)then
      delete a_W & ( ! Mol(Sphere( a_H//!h*,vt* a_W//!h*,vt* 7. ))  )  & !Mol(Select( a_W//o* "u>" + r_wCutoff )) # far from heteros
      r_wCutoff = Real( s_water[Index( s_water "hetero" )+6:$] ) # different cutoff
    endif
    delete a_W & !Mol(Select( a_W//o* "u>" + r_wCutoff )) # delete those with empiric hbond energy less than 5
  endif
  set object a_$s_curObj.
endmacro
#
macro convertObject ms_ (a_) l_delete_water (yes) l_optimize_hydrogens (no) l_replace_the_original (no) l_display (no) l_optimize_his (yes) l_maskMissing (no) l_assignHeteroCharges (yes) s_options ("") auto
  #l_commands = yes
  l_info = no
  l_minRedraw = no

  ms_ = Mol( ms_ )
  if (Nof(ms_) == 0) return error " Error> Converting object: No molecules selected"
  os_ = Obj( ms_ )[1]
  if Type( os_ 2)=="ICM" return error " Error> Converting object: the object does not need convertion"
#  for i=1,Nof( ms_ & a_*.A )
#    if( Nof( Atom(ms_))/Nof(Res(ms_)) < 2.) then
#      serror =  " Error> Can not convert chain "+String(Res(ms_[i])) +" It may be a Ca-only model."
#      show Atom(ms_[i]) [1:5]
#      return error serror
#    endif
#  endfor
  set object os_
  if Nof(a_TRACE)>0 & l_warn print " Warning> trace-only molecules "+ Sum(Name(a_TRACE full)) + " are unconvertable and will be ignored"
  # check for some problematic sugar entries
  if ( Index( { "3bwh" "3ca0," "1g9f" "2gyu" "4cvu" "4uoj" "1q6d" "3kzh" "1us2" "1h4h" "4qbz" "4ln8" "1dot" "2hor" "3m5j" "2ve0" "2ebs" "4r0a" "1mwa" "1hx0" "3s5y" "3s5z" "1fv2" "1fv3" "4jzz" "3wn4" "2wrb" } Sum(Name(a_)) ) != 0 ) then
    if (l_warn) printf " Warning> %s contains unconvertable sugar entries which will be deleted\n", Sum(Name(a_))
    delete a_S
  endif
  #
  hydrFraction = Nof( a_//h*,d* )/Real(Nof(a_//* ))  # usually ~40%
# if original is kept, make a copy to avoid mutilating the original with W, alternatives, H on ligands, etc.
  if(!l_replace_the_original ) then
    copy a_ stack "TMPCONVERT" delete
    ms_ = Select(ms_ a_TMPCONVERT. )
    set object a_TMPCONVERT.
  endif
# mse -> met, in 99% cases mse is just an X-ray trick, an irrelevant nuisance. provide option "keepMSE" if needed.
  if(Index(s_options "keepMSE")==0)then
    as2_out = a_/mse/Se
    for i = Nof( as2_out ) 1,-1
      rename  as2_out [i]  "sd"
      rename Res( as2_out [i] ) "met" type
    endfor
  endif
#
  set type a_J1:1 & a_A "H"  # single amino-acids treated as hetero
  l_dyn_prot=no
  if(Index(s_options "dyn_prot")!=0)l_dyn_prot=yes
  s_heavy=""
  if(Field(s_options "convert=" 1)=="heavy") s_heavy="heavy"
  s_water = Field(s_options "water=" 1)
  if(s_water~"tight*") l_delete_water=no
  if( l_delete_water ) ms_ = ms_ & a_!W
  if( Nof(ms_) != Nof( a_* ) ) delete a_ & ! ms_
  if(s_water~"tight*")then # here delete very loose water; later after convert - weakly bonded
    show area surface a_W//o* a_!W//!h* vwExpand=0.7
    delete Select( a_W//o* "A>36.") # remove those with less than 1/3 of the area in contact, usually about half
  endif
  delete a_TRACE | a_//AS # Ca or trace only molecules and secondary alternatives
  set comment a_//:b " "  # sometimes there is a single :b left over, e.g. 2hxc
  if( l_assignHeteroCharges & Nof( a_H )>0 ) set charge formal a_H auto
  build hydrogen  a_H | a_A,N/U | Next( a_A,N/U bond )  # a_/U selection for residues without library entries
  for i=1,Nof(a_A)
    if (Sum( Charge( Res(a_A [i])[1] & a_//n formal ) ) == 1) build hydrogen Res(a_A [i])[1]
  endfor
  set type   mmff a_H | a_A,N/U

  # now treated as coordination,  was: remove covalent bonds to metal in heme
  #s_metals = "Fe*,Pt*"
  # s_metals = "Fe"
  # for iml=1,Nof( Mol( a_ ) )
  #   while Nof( Next( a_$iml//$s_metals bond  )) > 0
  #     delete bond Next( a_$iml//$s_metals bond )[1]  a_$iml//$s_metals
  #   endwhile
  # endfor
  #set formal charge Select( Sphere( a_//$s_metals a_//n* 2.5 ) "f>0" ) 0.
  # carbon in cyn (charge and delete hydrogen). ?? ask Max
  if Nof( Sphere( a_//$s_metals a_//M4 2.2 ) ) > 0 then
    set formal charge -1.  Sphere( a_//$s_metals a_//M4 2.2  )
    delete Next( Sphere( a_//$s_metals a_//M4 2.2  ) bond ) & a_//h*
    set type mmff a_H
  endif
  #
  if Nof( Sphere( a_//$s_metals a_//M28,M23 1.5 ) ) > 0 then
    # delete hydrogens in hemes
    set formal charge -1.  Next( Sphere( a_//$s_metals a_//M28,M23 1.5  ) bond ) & a_//n*
    delete Sphere( a_//$s_metals a_//M28,M23 1.5  )
    set type mmff a_H
  endif
  as_chel = Sphere( a_//Zn,Mn a_//M43 2.3 ) | Sphere( a_//Zn,Mn a_//C252 2.5 )
  if Nof( as_chel ) > 0 then         # sulfonamide  S(O2)NH must be -1 near Zinc
    set formal charge -1. as_chel
    delete Next( as_chel bond ) & a_//h*
    build hydrogen as_chel
    set type mmff a_H
  endif

  set charge mmff a_H
  s_newname = Name(os_)[1]
  if(!l_replace_the_original)s_newname = Name(s_newname object)

  errorAction=1
  convert a_  s_newname selection graphic selftether $s_heavy
  mxdev = r_2out          # maximal deviation
  r_residualRmsd = r_out  # average deviation
  keep r_residualRmsd
  if Error() goto endconvert:
  if(Nof(a_// selftether)>0) then
    if(mxdev>0.1) then
      for i=1,3
        r_out = Srmsd(a_// selftether)  # returns r_2out maximal deviation
        if(r_2out>0.1) then; minimize 1000 "ts" v_H//* ; minimize 1000 "ts" v_// ; endif
      endfor
    endif
    delete selftether a_//
  endif
  if(l_display) display new
  if(l_optimize_hydrogens | hydrFraction < 0.1 ) then  # if pdb has hydrogens, do not optimize them with l_opt.. = no
    rs_opt = Res( a_ )
    nn =  Nof(Res( Select( rs_opt & a_A//!h* "o<0.1" )))
    if(nn>0 & !l_optimize_hydrogens & l_warn) printf " convertObject> %d missing or zero occupancy residues found. Set l_optimize_hydrogens flag on\n"  nn
    if(l_maskMissing) rs_opt = rs_opt & ! Res(Select(rs_opt  & a_A//!h* "o<0.01" ))
    set a_W//vt1 Xyz( a_W//o )  # sets the position of the first virtual atom
    minimize v_W//!?vt1 | ( v_//!V & a_//h* )  "bb,to,el" 500   l_warn=no vwMethod="soft" a_ a_!W
    minimize v_W//!?vt1 | ( v_//!V & a_//h* )  "bb,to,el" 500   l_warn=no vwMethod="soft"
    minimize v_W//!?vt1 | ( v_//!V & a_//h* )  "bb,vw,14,hb,to,ss,el" 500   l_warn=no vwMethod="soft"
    if(  l_optimize_hydrogens ) then
      optimizeH_zeroOcc rs_opt l_optimize_his l_dyn_prot
    else
      minimize v_//P & a_//h* "el,hb" l_warn=no
      if( l_optimize_his )then
        if(!l_dyn_prot) optimizeHisProAsnGlnCys a_/hi*,asn,gln,cys  # was his
        if( l_dyn_prot) optimizeHisProAsnGlnCys a_/hi*,asn,gln,cys,asp,glu
      endif
    endif

    minimize v_W//!?vt1 | ( v_//!V & a_//h* )  "bb,vw,14,hb,to,ss,el" 500 l_warn=no
  endif
  if( s_options ~ "*tautomer*" ) optimizeHeteroTautomer a_H
  if(s_water~"tight*" & Nof(a_W)>0)then
    show hbond exact a_W a_!W   # calculate empiric hydrogen bonding energy between water molecules and the rest
    set field a_W//o* Sum(Transpose(Matrix(Rarray( a_W//o*,h* ) 3))) # accumulate totals on oxygens (transerred from hydrogen )
    # show column Name( a_W ) Field( a_W//o* )
    r_wCutoff = 5.
    if(Length(s_water)>5) r_wCutoff = Real( s_water[6:$] )
    if( Index( s_water "hetero" )!=0)then
      delete a_W & ( ! Mol(Sphere( a_H//!h*,vt* a_W//!h*,vt* 7. ))  )  & !Mol(Select( a_W//o* "u>" + r_wCutoff )) # far from heteros
      r_wCutoff = Real( s_water[Index( s_water "hetero" )+6:$] ) # different cutoff
    endif
    delete a_W & !Mol(Select( a_W//o* "u>" + r_wCutoff )) # delete those with empiric hbond energy less than 5
  endif
  if(Nof(os_ stack)!=0)then
    ms_ = ms_ & !a_
    set tether a_ ms_
    os_newob = a_
    for i = 1, Nof(os_ stack)
      set object Obj( ms_ )
      load conf a_ i
      set object os_newob
      set a_ tree
      if(Nof(v_//P & ! a_//T)!=0) minimize v_//P & ! a_//T "el,to" dielConst=1.
      store conf a_
    endfor
    delete tether
  endif
  #if (l_maskZeroOcc) set Select( a_// "o==0" ) off
  if (l_maskMissing) then
    set Select( a_A,N// "_ADDED" ) | ( Next( Select( a_// "_ADDED" ) bond ) & a_//h* ) off
    if( Sum(Charge( Select( a_//  off ) formal )) != 0. ) printf " Warning_ConvertObject> some formal charge are masked, electrostatic properties will be distorted. Unclick 'Hide missing' to restore\n"
  endif
  r_out = r_residualRmsd
  delete stack
  keep r_out
endconvert:
  delete a_TMPCONVERT.
endmacro

# OBSOLETE
macro convertObjectOld auto ms_ (a_) l_delete_water (yes) l_optimize_hydrogens (no) l_replace_the_original (no) l_display (no)
  l_commands = no
  l_info = no
  l_minRedraw = no
  l_improveHetatm = yes
  s_skipMessages = "[103]"
  if (Nof(Mol(ms_)) == 0) return error " Error_convertObject> No molecules selected"
  os_ = Obj( ms_ )[1]
  if Type( os_ 2)=="ICM" return error " Error_convertObject> the object does not need convertion"
  ms_ = Mol( os_ & ms_ )
  for i=1,Nof( ms_ & a_*.A )
    if( Nof( Atom(ms_))/Nof(Res(ms_)) < 2.) then
      serror =  " Error> Can not convert chain "+String(Res(ms_[i])) +" It may be a Ca-only model."
      show Atom(ms_[i]) [1:5]
      return error serror
    endif
  endfor
  set object os_
  s_originalName = Sum(Name( os_ ) )
  if( ! l_replace_the_original ) then
     copy os_ "tmpconvert" delete
     os_ = a_tmpconvert.
     set object os_
     ms_ = Select( ms_ a_tmpconvert. ) # /$sss
  endif
  if( Nof(ms_) != Nof( a_* ) ) delete os_ & ! ms_
  if( l_delete_water ) delete os_ & a_W
#  delete os_ & a_//Ab,Ac,Ad,Ae,Af,Ag,A2,A3,A4,A5,A6,A7 # alternatives
  delete os_ & a_*.//AS # alternatives
  if( l_improveHetatm ) then
    build hydrogen  a_H | a_A/"X"
    set type   mmff a_H # | a_A/"X"
    set charge mmff a_H # | a_A/"X"
  endif
  convert os_ "tmpconvert1"
  r_residualRmsd = r_out
  nn =  Nof(Res( Select( a_A//!h* "o<0.1" )))
  if(nn>0 & !l_optimize_hydrogens & l_warn) printf " convertObject> %d missing or zero occupancy residues found. Set l_optimize_hydrogens flag on\n"  nn
  for i = 1, Nof( a_W )
    set a_W//vt1 [i] Xyz(a_W//o  [i])  # sets the position of the first virtual atom
  endfor
  if( l_optimize_hydrogens ) then
    if(Nof(a_A/*) > 300) printf " Warning> hydrogen optimization for this %d-res. object may take a few minutes. Please wait...\n", Nof(a_A/*)
    minimize (v_//M,P | v_//T11) & a_//h* "vw,14,hb,to,ss,el" 500
    if(nn>0 & Nof(v_//x* & Select(a_A//!h* "o<0.01" ))>0) then
      printf " convertObject> optimizing %d missing or zero occupancy side-chains..\n"  nn
      ssearch residue  fast v_//x* & Select( a_A//!h* "o<0.1" ) "vw,14,hb,to,ss,el"
    endif
    printf " convertObject> optimizing %d polar hydrogens..\n" Nof(Res( Atom( v_//P) ))
    if(Nof(v_//P & a_A//h* )>0)ssearch residue fast v_//P & a_A//h* "vw,14,hb,to,ss,el"
    for i=1,Nof( v_//P & a_!A//h* )
      ssearch fast ( v_//P & a_!A//h* ) [i] "vw,14,hb,to,ss,el"
    endfor
    if( Nof( a_W ) > 0 ) minimize v_W//?vt2,?vt3 "vw,14,hb,to,ss,el" 500
    optimizeHisProAsnGlnCys a_/his,asn,gln,cys
    if(Nof(v_//x* & Select(a_A//!h* "o<0.01" ))>0)then
      set vrestraint a_/*  # optimized missing and added heavy atoms
      minimize v_//x* & Select(a_A//!h* "o<0.01" ) 1000 "vw,14,hb,to,ss,el"
      if(Nof(Res(Select(a_A//!h* "o<0.01" )))<Nof(a_/A)/10) then
        montecarlo fast v_//x* & Select(a_A//!h* "o<0.01" ) v_//x* & Select(a_A//!h* "o<0.01" ) "vw,14,hb,to,ss,el"
      else
        print " Warning> Too many heavy atoms were absent from pdb and were added with zero occupancies. \n Requires special optimization\n"
      endif
    endif
  endif
  if( l_replace_the_original ) then
    delete a_$s_originalName,tmpconvert.
    rename a_ s_originalName
    if (l_display) cool a_ no
  else
    delete a_tmpconvert.
    sss = Name( s_originalName object unique )
    delete a_$sss.
    rename a_tmpconvert1. sss
    if (l_display) cool a_$sss. no
  endif
  keep r_residualRmsd
endmacro
#endif

macro makeCaTrace os_
  os_ = os_ & ! a_*_ca.
  for iob=1,Nof(os_)
    s_out = Name( os_ [ iob ] )[1] + "_ca"
    copy os_ [iob] s_out strip delete
    set object a_$s_out.
#    set type a_ "Ca-trace"
    delete a_A//!ca | a_W
    for iml = 1,Nof( a_A )
      make bond chain ( a_A [iml] ) & a_//ca
    endfor
  endfor
endmacro

#:(
macro makeSimpleModel &seq_ ali_ os_
  l_minRedraw=no
  build string "se "+Replace(Replace(Replace(Replace(String(seq_),"[!GP]","A"),"A","alas "),"G","glys "),"P","pros ")
  fix v_//omg
  resLabelStyle =" A"
  for i=1,Length(seq_)
    rename a_/$i Trim(Tr123(Sequence(seq_[i])))
  endfor
  #l_commands=yes
  display os_ & a_*.//ca,c,n  Count(Nof(Res(os_)))
  display a_//ca,c,n yellow
  display residue label a_/*
  set plane 2
  display os_ & a_1.//!ca,c,n
  set plane 3
  display ribbon os_ & a_*.//!h* cpk
  set plane 2
  set plane 3
  color residue label a_ magenta
  link a_ | os_ ali_
  set tether a_ Residue(os_) ali_
  minimize tether
  display tether a_//ca
endmacro

macro makePdbFromStereo R_xl R_xr R_yl R_yr r_stereoAngle ( 6. )
  l_commands = no
  x = R_xl
  y = 0.5*(R_yl+R_yr)
  z =(R_xr - R_xl)/Sin( r_stereoAngle )
  z = z - Mean(z)
  n = Nof(x)
  x1 = x[1:n-1] - x[2:n]
  y1 = y[1:n-1] - y[2:n]
  z1 = z[1:n-1] - z[2:n]
  d = Mean( Sqrt( x1*x1+y1*y1+z1*z1 ))
  qf = 3.8/d
  x = x*qf
  y = y*qf
  z = z*qf
  for i = 1,Nof(x)
    printf "ATOM   %4d  CA  ALA  %4d     %7.3f %7.3f %7.3f",i,i,x[i],y[i],z[i]
  endfor
endmacro

#macro makeObjCa os_pdbCa_Object i_mncallsMC (500000)
#  convert os_
#  unfix only V_//phi,psi
#  minimize tether
#  unfix only V_//H,P,M
#  mncallsMC= i_mncallsMC
#  set vrestraints a_/*
#  montecarlo v_//x*
#  write object a_ Sum(Name(os_[1]))+"A"
#endmacro
#
macro calcProtUnfoldingEnergyW ms_ ( a_1 ) i_mncalls (100)
   l_commands = no
   l_info = no
   if (Nof(object) > 1) s_obna = Sum(Name(a_))
   set object Obj(ms_)
   if (Nof(v_//*) == 0) return error "No free variables"
   fixOld = v_//*
   varOld = Value(v_//*)
   surfaceMethod = "apolar"
   if (Nof( v_/S_/phi,psi) == 0) then
     print "No free phi,psi in S_ residues"
     if (Nof(object) > 1) set object a_$s_obna.
     return error
   endif
   unfix only V_//S & ms_
   show energy ms_ ms_ mute "sf"
   e1 = Energy("sf")
   set v_/S_/phi,psi 180.
   minimize i_mncalls "vw,14,hb,to"
   show energy ms_ ms_ mute "sf"
   e2 = Energy("sf")
   printf "Solvation energy (kcal/mol)= %.2f: E_folded( %.2f) - E_unfolded( %.2f)\n", \
          e1-e2, e1, e2
# return current object status
   unfix only fixOld
   set v_//* varOld
   print "bbb"
   show energy ms_ ms_ "sf"
   if (Nof(object) > 1) set object a_$s_obna.
endmacro
#
macro calcProtUnfoldingEnergy ms_ ( a_1 ) i_mncalls (100)
# macro assumes that you have an object loaded
# it gives an octanol/water transfer solvation energy for the given
# conformation as compared to an extended chain conformation
   l_info     = no
   currObj = Index(object)
   set object Obj(ms_)
   surfaceMethod = "apolar"
   show energy ms_ ms_ mute "sf"
   unfix only V_//S & ms_
   fixOld = v_//*
   varOld = Value(v_//*)
   e1 = Energy("sf")
   set v_/S_/phi,psi 180.
   minimize i_mncalls "vw,14,hb,to"
   show energy ms_ ms_ mute "sf"
   e2 = Energy("sf")
   printf "Solvation energy (kcal/mol)= %.2f: E_folded( %.2f) - E_unfolded( %.2f)\n", \
          e1-e2, e1, e2
# return current object status
   set v_//* varOld
   unfix only fixOld
   set object a_$currObj.
endmacro
#
function PredictSeq s_seq s_prop
#            A  B   C    D    E    F    G     H     I   J   K     L     M    N   O   P    Q     R   S    T   U    V     W   X    Y   Z
  flexInd ={1.2,0.,0.37,0.95,0.2,-1.33,1.75,-0.09,-1.02,0.,0.04,-0.81,-0.74,0.65,0.,0.76,0.12,-0.6,1.31,0.83,0.,-0.39,-2.04,0.,-1.16,0.}
  hPhobInd={1.8,0.,2.5,-3.5,-3.5, 2.8 ,-0.4,-3.2,  4.5 ,0.,-3.9, 3.8 , 1.9 ,-3.5,0.,-1.6,-3.5,-4.5,-0.8,-0.7,0., 4.2 ,-0.9 ,0.,-1.3 ,0.}
  i_windowSize = 7
  if (s_prop == "Flexibility") then
    return Smooth (Rarray($s_seq, flexInd), i_windowSize)/Sqrt(i_windowSize)
  elseif (s_prop == "Hydrophobicity") then
    return Smooth (Rarray($s_seq,hPhobInd), i_windowSize)/Sqrt(i_windowSize)
  elseif (s_prop == "Turn") then
    return Turn($s_seq)-1.
  else
    return Rarray()
  endif
  return prop;
endfunction
#
macro predictSeq s_seq ("1crn_m") s_fileName ("plot") l_predictSstr (no) i_numPerLine (100)
  l_commands = no
#            A  B   C    D    E    F    G     H     I   J   K     L     M    N   O   P    Q     R   S    T   U    V     W   X    Y   Z
  # flexInd ={1.2,0.,0.37,0.95,0.2,-1.33,1.75,-0.09,-1.02,0.,0.04,-0.81,-0.74,0.65,0.,0.76,0.12,-0.6,1.31,0.83,0.,-0.39,-2.04,0.,-1.16,0.}
  # hPhobInd={1.8,0.,2.5,-3.5,-3.5, 2.8 ,-0.4,-3.2,  4.5 ,0.,-3.9, 3.8 , 1.9 ,-3.5,0.,-1.6,-3.5,-4.5,-0.8,-0.7,0., 4.2 ,-0.9 ,0.,-1.3 ,0.}
  # s_seq = Field( s_seq 1 ) # get rid of trailing and leading spaces
  # i_windowSize = 7
  # M_prop=        Transpose(Smooth (Rarray($s_seq, flexInd), i_windowSize)/Sqrt(i_windowSize) )
  # M_prop=M_prop//Transpose(Smooth (Rarray($s_seq,hPhobInd), i_windowSize)/Sqrt(i_windowSize) )
  # M_prop=M_prop//Transpose(Turn($s_seq)-1.)
  #
  M_prop = Transpose(PredictSeq(s_seq,"Flexibility")) // Transpose(PredictSeq(s_seq,"Hydrophobicity")) // Transpose(PredictSeq(s_seq,"Turn"))

# i_numPerLine = 100
  PLOT.Yratio = 0.      # auto: preserve Yratio of PLOT.box
  PLOT.orientation = 1  # "landscape"
  S_titles={ "" ,"Sequence","","Flexibility","Hydrophobicity","Turn"}
  S_titles[1] = "Properties and sec.structure prediction for " + s_seq
  se = String($s_seq)
  if(l_predictSstr)then
    ss = Sstructure($s_seq)
    set sstructure $s_seq ss
    keep ss
    if( Length( M_out ) == Length( $s_seq ) & Nof( M_out ) == 4 ) then
      sr = String(M_out[4] "0123456789")
    else
      sr = String( " ", Length( $s_seq ) )
    endif
  else
    ss = String(" " Length($s_seq))
    sr = ss
  endif
  if (Extension(s_fileName)!=".eps") s_fileName = s_fileName+".eps"
  if (Exist(s_fileName)) sys $s_sysRm $s_fileName
  ns=(Nof( M_prop )+i_numPerLine-1)/i_numPerLine
  PLOT.box   = {0. 0.05 1. } // .9/ns
  for i=1,Nof( M_prop ),i_numPerLine
    PLOT.numberOffset = i-1
    PLOT.Yratio = 0.2
    PLOT.box[2]= .95 - .9/ns*(i/i_numPerLine+1.)
    i2=Min(i-1+i_numPerLine,Nof( M_prop ))
    if(i>1)S_titles[1]=""
    if(i>1)PLOT.logo=no
    plot comment=sr[i:i2]+ss[i:i2]+se[i:i2] number M_prop[i:i2,?] Rarray(2,i-1.,i+i_numPerLine)//{50.,10., -1.,1.,.5,.25} s_fileName S_titles grid append
  endfor
endmacro

macro calcRmsd rs_1 (a_1/*) rs_2 (a_2/*)
  l_info=no
  rs_1=Res(rs_1) & a_*.*/A
  rs_2=Res(rs_2) & a_*.*/A
  n=Nof(rs_1)

  s_error="" ; keep s_error
# add info about the fact that it is being superimposed and atoms renamed
  if (n != Nof(rs_2)) then ; s_error="rs_1 and rs_2 select different nof.residues" ; return error s_error ; endif
  if (Tr321(Sum(Sarray(Name(rs_1), 1, 3), " ")) != Tr321(Sum(Sarray(Name(rs_2), 1, 3), " "))) then ; s_error = "rs_1 and rs_2 select different sequences" ; return error s_error ; endif

  #if(n!=Nof(rs_2))return error "rs_1 and rs_2 select different nof.residues"
  #if(Name(rs_1)!=Name(rs_2))return error "rs_1 and rs_2 select different sequences"

  ress={"tyr"   "phe"   "val" "leu" "arg" "asp" "glu"}
  asna={"cd,ce" "cd,ce" "cg"  "cd"  "nh"  "od"  "oe" }
  rmsdCa=Rmsd(rs_1 & a_*.//ca rs_2 & a_*.//ca)
  l_warn=no
  rmsdBb=Rmsd(rs_1 & a_*.//ca,c,n rs_2 & a_*.//ca,c,n)
  rmsdHe=Rmsd(rs_1 & a_*.//!h* rs_2 & a_*.//!h*)
  sym= a_*./val/cg* | a_*./leu,tyr,phe/c[de]* | a_*./asp,glu,arg/o[de]*,nh*
  sym= a_*.//!h* & !sym
  superimpose rs_1 & sym rs_2 & sym
  printf " rmsdCa=%.3f  rmsdBb=%.3f  rmsdHeavy=%.3f  rmsdHNsym=%.3f  (%d atoms) . Before\n" rmsdCa rmsdBb rmsdHe r_out i_out
  for i=1,n
    j=Index(ress Sum(Name(rs_1[i])))
    if(j==0)continue
    cds=Split(asna[j] ",")
    r1=0.0
    r2=0.0
    for k=1,Nof(cds)
      cd1=cds[k]+"1"
      cd2=cds[k]+"2"
      if(Nof(rs_1[i]&a_*.//$cd1,$cd2 )!=2)goto SkipIt
      r1=r1+Power(Distance(rs_1[i]&a_*.//$cd1 rs_2[i]&a_*.//$cd1 ) ,2)
      r1=r1+Power(Distance(rs_1[i]&a_*.//$cd2 rs_2[i]&a_*.//$cd2 ) ,2)
      r2=r2+Power(Distance(rs_1[i]&a_*.//$cd1 rs_2[i]&a_*.//$cd2 ) ,2)
      r2=r2+Power(Distance(rs_1[i]&a_*.//$cd2 rs_2[i]&a_*.//$cd1 ) ,2)
    endfor
    if(r1<=r2)continue
    for k=1,Nof(cds)
      cd1=cds[k]+"1"
      cd2=cds[k]+"2"
      rename rs_1[i]&a_*.//$cd2 "dumm"
      rename rs_1[i]&a_*.//$cd1  cd2
      rename rs_1[i]&a_*.//dumm  cd1
    endfor
    SkipIt:
  endfor
  rmsdHe=Rmsd(rs_1 & a_*.//!h* rs_2 & a_*.//!h*)
  printf " rmsdCa=%.3f  rmsdBb=%.3f  rmsdHeavy=%.3f  (%d atoms) . After symmetry optimization\n" rmsdCa rmsdBb rmsdHe i_out
  keep rmsdCa rmsdBb rmsdHe i_out
endmacro

macro calcSrmsd rs_1 (a_1/*) rs_2 (a_2/*)
  l_info=no
  rs_1=Res(rs_1) & a_*.*/A
  rs_2=Res(rs_2) & a_*.*/A
  n=Nof(rs_1)
  s_error="" ; keep s_error
  if (n != Nof(rs_2)) then ; s_error="rs_1 and rs_2 select different nof.residues" ; return error s_error ; endif
  if (Tr321(Sum(Sarray(Name(rs_1), 1, 3), " ")) != Tr321(Sum(Sarray(Name(rs_2), 1, 3), " "))) then ; s_error = "rs_1 and rs_2 select different sequences" ; return error s_error ; endif
  ress={"tyr"   "phe"   "val" "leu" "arg" "asp" "glu"}
  asna={"cd,ce" "cd,ce" "cg"  "cd"  "nh"  "od"  "oe" }
  rmsdCa=Srmsd(rs_1 & a_*.//ca rs_2 & a_*.//ca)
  l_warn=no
  rmsdBb=Srmsd(rs_1 & a_*.//ca,c,n rs_2 & a_*.//ca,c,n)
  rmsdHe=Srmsd(rs_1 & a_*.//!h* rs_2 & a_*.//!h*)
  sym= a_*./val/cg* | a_*./leu,tyr,phe/c[de]* | a_*./asp,glu,arg/o[de]*,nh*
  sym= a_*.//!h* & !sym
#  superimpose rs_1 & sym rs_2 & sym
  r_out = Srmsd(rs_1 & sym rs_2 & sym) ;
#  print Nof(rs_1 & sym) Nof(rs_2 & sym)
  printf " srmsdCa=%.3f  srmsdBb=%.3f  srmsdHeavy=%.3f  srmsdHNsym=%.3f  (%d atoms)\n" rmsdCa rmsdBb rmsdHe r_out i_out
  for i=1,n
    j=Index(ress Sum(Name(rs_1[i])))
    if(j==0)continue
    cds=Split(asna[j] ",")
    r1=0.0
    r2=0.0
    for k=1,Nof(cds)
      cd1=cds[k]+"1"
      cd2=cds[k]+"2"
      if(Nof(rs_1[i]&a_*.//$cd1,$cd2 )!=2)goto SkipIt
      r1=r1+Power(Distance(rs_1[i]&a_*.//$cd1 rs_2[i]&a_*.//$cd1 ) ,2)
      r1=r1+Power(Distance(rs_1[i]&a_*.//$cd2 rs_2[i]&a_*.//$cd2 ) ,2)
      r2=r2+Power(Distance(rs_1[i]&a_*.//$cd1 rs_2[i]&a_*.//$cd2 ) ,2)
      r2=r2+Power(Distance(rs_1[i]&a_*.//$cd2 rs_2[i]&a_*.//$cd1 ) ,2)
    endfor
    if(r1<=r2)continue
    for k=1,Nof(cds)
      cd1=cds[k]+"1"
      cd2=cds[k]+"2"
      rename rs_1[i]&a_*.//$cd2 "dumm"
      rename rs_1[i]&a_*.//$cd1  cd2
      rename rs_1[i]&a_*.//dumm  cd1
    endfor
    SkipIt:
  endfor
  rmsdHe=Srmsd(rs_1 & a_*.//!h* rs_2 & a_*.//!h*)
  printf " srmsdCa=%.3f  srmsdBb=%.3f  srmsdHeavy=%.3f  (%d atoms)\n" rmsdCa rmsdBb rmsdHe i_out
  keep rmsdCa rmsdBb rmsdHe i_out
endmacro

#macro calcRmsd rs_1 (a_1/*) rs_2 (a_2/*)  # old code without his-hise recognition
#  l_info=no
#  rs_1=Res(rs_1) & a_*.*/A
#  rs_2=Res(rs_2) & a_*.*/A
#  n=Nof(rs_1)
#  if(n!=Nof(rs_2))return error "rs_1 and rs_2 select different nof.residues"
#  if(Name(rs_1)!=Name(rs_2))return error "rs_1 and rs_2 select different sequences"
#  ress={"tyr"   "phe"   "val" "leu" "arg" "asp" "glu"}
#  asna={"cd,ce" "cd,ce" "cg"  "cd"  "nh"  "od"  "oe" }
#  rmsdCa=Rmsd(rs_1 & a_*.//ca rs_2 & a_*.//ca)
#  l_warn=no
#  rmsdBb=Rmsd(rs_1 & a_*.//ca,c,n rs_2 & a_*.//ca,c,n)
#  rmsdHe=Rmsd(rs_1 & a_*.//!h* rs_2 & a_*.//!h*)
#  sym= a_*./val/cg* | a_*./leu,tyr,phe/c[de]* | a_*./asp,glu,arg/o[de]*,nh*
#  sym= a_*.//!h* & !sym
#  superimpose rs_1 & sym rs_2 & sym
#  printf " rmsdCa=%.3f  rmsdBb=%.3f  rmsdHeavy=%.3f  rmsdHNsym=%.3f  (%d atoms)\n" rmsdCa rmsdBb rmsdHe r_out i_out
#
#  for i=1,n
#    j=Index(ress Sum(Name(rs_1[i])))
#    if(j==0)continue
#    cds=Split(asna[j] ",")
#    r1=0.0
#    r2=0.0
#    for k=1,Nof(cds)
#      cd1=cds[k]+"1"
#      cd2=cds[k]+"2"
#      if(Nof(rs_1[i]&a_*.//$cd1,$cd2 )!=2)goto SkipIt
#      r1=r1+Power(Distance(rs_1[i]&a_*.//$cd1 rs_2[i]&a_*.//$cd1 ) ,2)
#      r1=r1+Power(Distance(rs_1[i]&a_*.//$cd2 rs_2[i]&a_*.//$cd2 ) ,2)
#      r2=r2+Power(Distance(rs_1[i]&a_*.//$cd1 rs_2[i]&a_*.//$cd2 ) ,2)
#      r2=r2+Power(Distance(rs_1[i]&a_*.//$cd2 rs_2[i]&a_*.//$cd1 ) ,2)
#    endfor
#    if(r1<=r2)continue
#    for k=1,Nof(cds)
#      cd1=cds[k]+"1"
#      cd2=cds[k]+"2"
#      rename rs_1[i]&a_*.//$cd2 "dumm"
#      rename rs_1[i]&a_*.//$cd1  cd2
#      rename rs_1[i]&a_*.//dumm  cd1
#    endfor
#    SkipIt:
#  endfor
#  rmsdHe=Rmsd(rs_1 & a_*.//!h* rs_2 & a_*.//!h*)
#  printf " rmsdCa=%.3f  rmsdBb=%.3f  rmsdHeavy=%.3f  (%d atoms)\n" rmsdCa rmsdBb rmsdHe i_out
#  keep rmsdCa rmsdBb rmsdHe i_out
#endmacro

macro dsCustom as_ (a_) s_dsMode ("wire") s_colorBy ("atom") l_color_only (no)
#---------------------------------------------------------------------------
# s_dsMode:  "wire","cpk","ball","stick","xstick","surface","ribbon","skin","all"
# s_colorBy:      atom, residue, molecule, sstructure, NtoC, bfactor, charge,
#                  polarity, hydrophobicity, accessibility
# l_color_only:    color only mode, do not display (if display is already ready)
# ---------------  s_colorBy :
# polarity:  yellow hydrophobic: ala,val,phe,pro,met,ile,leu
#            pink   polar      : ser,thr,tyr,his,cys,cyss,asn,gln,trp,gly
#            blue   charged (+): lys,arg
#            red    charged (-): asp,glu
# hydrophobicity:    A    B    C    D    E    F    G    H    I    J
#                    K    L    M    N    O    P    Q    R    S    T
#                    U    V    W    X    Y    Z
#                   1.8, 0.0, 2.5,-3.5,-3.5, 2.8,-0.4,-3.2, 4.5, 0.0,
#                  -3.9, 3.8, 1.9,-3.5, 0.0,-1.6,-3.5,-4.5,-0.8,-0.7,
#                   0.,  4.2,-0.9,  0.,-1.3, 0.0
#---------------------------------------------------------------------------
  l_commands=no
  l_info = no
  l_warn = no
  GRAPHICS.l_redraw=no
  errorAction = "break"
  GRAPHICS.atomRainbow = "blue/white/red"
  clTypes = {"atom","backbone","residue","residueall","molecule","molecule_C","sstructure","NtoC","bfactor", \
             "charge","accessibility", "polarity", "hydrophobicity"}
  dsTypes = {"wire","cpk","ball","stick","xstick","surface","ribbon","skin","all"}
  if (Nof(as_)==0) return error "selection not found or not defined"
  if (Index(clTypes, s_colorBy)==0) then
    show clTypes
    return error "ERROR> only listed coloring types are allowed"
  endif
  if (Index(dsTypes, s_dsMode)==0 & Index(Name(grob),s_dsMode)==0 ) then
    show dsTypes
    return error "ERROR> only listed display modes are allowed"
  endif
  if (s_dsMode == "all") s_dsMode = "wire cpk ball stick xstick surface skin "+ ((s_colorBy=="residue")?"":"ribbon" )
# exclude water molecules
  as_=as_ & a_*.!W
  if (!l_color_only) then
     if Index( "skin,surface",s_dsMode) >0  display grey $s_dsMode as_ Mol( as_ )
     if Index( "skin,surface",s_dsMode)==0  display grey $s_dsMode as_
  endif
# ---------------------------------------------------------------------------------
  if (s_colorBy=="atom"|s_colorBy=="backbone") then
    if (s_dsMode == "ribbon") then
      printf "Wrong combination of display mode '%s' and coloring mode '%s'\n" s_dsMode, s_colorBy
      break
    endif
    color $s_dsMode as_
    if(s_colorBy=="backbone") color $s_dsMode as_ & a_*.//c,ca,n green
    goto enddscustom;
  endif
# ---------------------------------------------------------------------------------
  if (s_colorBy[1:7]=="residue") then
S_rekr={ "leu green", "asp red", "glu firebrick", "asn pink", "gln orange", "lys dodgerblue ", "arg royalblue", "hi* teal", "cys* yellow", "phe peru", "gly lightgreen", "ile lime", "ala chartreuse", "met yellowgreen", "pro* palegreen", "ser orchid", "thr mediumorchid", "val springgreen", "trp sienna", "tyr darkorange", }
    ribbonColorStyle = 1; GROB.atomSphereRadius=2.36  # brushsize
    for irekr = 1,Nof(S_rekr)
      s_out = "a_*.*/"+Field(S_rekr[irekr],1)
      srekr = Field( S_rekr[irekr], 2)
      color $s_dsMode as_ & $s_out $srekr
    endfor
    if(Type(COLORS_AMINOACID)=="unknown") then
      global add column COLORS_AMINOACID Field(S_rekr,1) Field(S_rekr,1) Sarray(Nof(S_rekr),"  ") Field(S_rekr,2) name={"residue","res2","color","color_name"}
      set format COLORS_AMINOACID.color_name "%C"
      set format COLORS_AMINOACID.color color="color_name"
      set format COLORS_AMINOACID.res2 color="color_name"
      sort COLORS_AMINOACID.residue
      keep COLORS_AMINOACID
    endif
    if(Length(s_colorBy)==7 & s_dsMode!="ribbon")  color $s_dsMode as_ & ( a_*.A,H/!ala,gly,pro/ca,ha,c,o,n,hn,cb,hb* | a_*.A,H/ala,pro/ca,ha,c,o,n,hn | a_*.A,H/gly/c,o,n,nh ) white
    color $s_dsMode as_ & a_*.//o mistyrose
    color $s_dsMode as_ & a_*.//n lightcyan
    color $s_dsMode as_ & ( a_*.*/asp,glu/oe*,od* | a_*.//oxt ) crimson
    color $s_dsMode as_ & a_*.*/arg,lys/n?* blue
    # color $s_dsMode as_ & a_*.N
    color $s_dsMode as_ & a_*.N base
  endif
# ---------------------------------------------------------------------------------
  if (s_colorBy=="molecule") then
    color molecule $s_dsMode as_
    goto enddscustom;
  endif
  if (s_colorBy=="molecule_C") then
    color molecule $s_dsMode as_ & a_*.//c*
    goto enddscustom;
  endif
# ---------------------------------------------------------------------------------
  if (s_colorBy=="sstructure") then
    ribbonColorStyle = 1
    color $s_dsMode Res(as_ )
    goto enddscustom;
  endif
# ---------------------------------------------------------------------------------
  if (s_colorBy=="NtoC") then
    GRAPHICS.atomRainbow = GRAPHICS.NtoCRainbow
    currSel = Mol(as_)
    for iml = 1, Nof(currSel)
      if (s_dsMode != "ribbon") then
        if(Nof(Atom(currSel[iml] & as_)) > 1) \
          color $s_dsMode Atom(currSel[iml] & as_) Count(Nof(Atom(currSel[iml] & as_)))
      endif
      if (Index(s_dsMode, "ribbon") != 0 & Nof(a_*./D) != 0) then
        if (Nof(Res(currSel[iml] & as_)) > 1) \
          color ribbon Res(currSel[iml] & as_) Count(Nof(Res(currSel[iml] & as_)))
      endif
    endfor
    goto enddscustom;
  endif
# ---------------------------------------------------------------------------------
  if (s_colorBy=="bfactor") then
    if (Rmsd(Bfactor(Atom(as_)))<0.1) printf "\n Warning> Bfactors are identical [=%.1f] or undefined\n" Mean(Bfactor(Atom(as_)))
    if (s_dsMode != "ribbon")  color $s_dsMode Atom(as_) Bfactor(Atom(as_))
    if (Index(s_dsMode, "ribbon") != 0)  color ribbon Res(as_) Bfactor(Res(as_))
    goto enddscustom;
  endif
# ---------------------------------------------------------------------------------
  if (s_colorBy=="charge") then
    if( Max(Abs(Charge(Obj(as_)))) == 0.) then
      print " Warning> Assigning simple charges, +lys,+arg,-asp,-glu, .. "
      assignSimpleCharges as_
    endif
    if (s_dsMode != "ribbon") then
      color $s_dsMode Atom(as_) Trim(Charge(Atom(as_)),-1.,1.)//{-1.,1.}
    else
      currSel = Res(as_)
      if (Nof(currSel) <= 0) return error "no residues found in the selection"
      Rcol = Rarray(Nof(currSel))
      for ires = 1, Nof(currSel)
        Rcol[ires] = Sum(Charge(currSel[ires]))
      endfor
      color $s_dsMode currSel Rcol
      delete currSel Rcol
    endif
    goto enddscustom;
  endif
# ----------------------------------------------------------------------------
  if (s_colorBy=="accessibility") then
    show area surface Obj(as_) Obj(as_) mute
    if (s_dsMode!="ribbon") then
      color $s_dsMode Atom(as_) Area(Atom(as_))
    else
      color $s_dsMode Res(as_) Smooth(Area(Res(as_))/Area(Res(as_) type) 5)
    endif
    goto enddscustom;
  endif
# ----------------------------------------------------------------------------
# polarity:  yellow hydrophobic: ala,val,phe,pro,met,ile,leu
#            pink   polar      : ser,thr,tyr,his,cys,cyss,asn,gln,trp,gly
#            blue   charged (+): lys,arg
#            red    charged (-): asp,glu
  if (s_colorBy=="polarity") then
    Scol = {"lightyellow", "pink", "blue", "red"}
    Sres = {"ala,val,phe,pro,met,ile,leu", "ser,thr,tyr,his,cys,cyss,asn,gln,trp,gly", \
               "lys,arg", "asp,glu"}
    Stxt = {"hydrophobic", "polar   ", "charged (+)", "charged(-)"}
    for ii = 1, Nof(Sres)
      color $s_dsMode a_*.*/$Sres[ii] & as_ $Scol[ii]
      print Stxt[ii],"\t", Scol[ii],"\t", Sres[ii]
    endfor
    delete Scol Sres Stxt
    goto enddscustom;
  endif
# ----------------------------------------------------------------------------
  if (s_colorBy=="hydrophobicity") then
#                  A    B    C    D    E    F    G    H    I    J
#                  K    L    M    N    O    P    Q    R    S    T
#                  U    V    W    X    Y    Z
    hbindexCurr={ 1.8, 0.0, 2.5,-3.5,-3.5, 2.8,-0.4,-3.2, 4.5, 0.0, \
                 -3.9, 3.8, 1.9,-3.5, 0.0,-1.6,-3.5,-4.5,-0.8,-0.7, \
                  0.,  4.2,-0.9,  0.,-1.3, 0.0}

    color $s_dsMode Res(as_ & a_*./A) Rarray(Sequence(as_ & a_*./A), -hbindexCurr)//-8.//6. GRAPHICS.NtoCRainbow = "blue/white/red"
    goto enddscustom;
  endif
# ---------------------------------------------------------------------------------
enddscustom:
  GRAPHICS.l_redraw=yes
  display new
endmacro

macro regul rs_ (a_!W) s_ngroup ("nh3+") s_cgroup ("coo-") l_delete_water (yes) l_shortOutput (yes)
  l_commands     = no
  l_minRedraw=no
  errorAction = "break"
  interruptAction = "exit macro"
  electroMethod = "distance dependent"
  surfaceMethod = "atomic solvation"
  dielConst = 4.0
  vwCutoff = 7.5
  hbCutoff = 3.0
  ssWeight = 1.
  mncalls = 500
  sTermsVacuum   = "vw,14,hb,to,ss,el"
  sTermsAll      = "vw,14,hb,to,ss,el,tz,sf,en"
  if(ffMethod == "icmff" & LIBRARY.res[1]=="icmff" ) then
    vwMethod="soft"
    dielConst = 2.
    sTermsVacuum += ",bb"
    sTermsAll    += ",bb"
  endif
  nIterAnn   = 40   # max number of iterations for annealing
  nIterRelax = 40   # max number of iterations for relaxation
  eThreshold = 0.5  # if energy changes during the current step is less, skip the rest of the loop
  s_oldterms = Info(term) # memorize old terms to restore at the end (for set term)

# creating pdb template /*-------------------------------------------*/
  pdb_name = Name(Obj(rs_ ))[1]
        ixModel  = pdb_name+"_reg"
  copy Obj( rs_ )[1] "tmpregul" delete
  os_ = a_tmpregul.
  set object os_
  rs_ = Select( rs_ a_tmpregul. )
  if Nof(rs_) != Nof( a_*/* )  delete os_ & ! rs_
  if l_delete_water delete a_tmpregul. & a_W

# creating a regularized object and tethering

  build string IcmSequence( a_tmpregul. Trim(s_ngroup,all) Trim(s_cgroup,all) ) name=ixModel
  set tethers a_//!h* a_tmpregul.*//!h*

# controls and complaints
   if (Nof(as_out) != 0) as_out = !a_*.*
   if (Error) then
     delete a_tmpregul,$ixModel.
     return error "ERROR: cannot set tethers"
   endif
   nTz  = Nof(a_//T)
# If not all residues of the model are tethered
   nResNonTz = Nof(a_*/* & !Res(a_*//T))
   if (nResNonTz > 0) then
     printf "# tethering : WARNING: %d residues NOT TETHERED:\n", nResNonTz
     show a_*/* & !Res(a_*//T)
   endif

   if Nof(a_/arg) > 0 unfix V_/arg/xi5
# Special precautions are necessary as concerns chi-5 (xi5) torsion of *arg* residue.
# In a PDB file this torsion may have a non-standard value equal to 0 deg instead of
# assumed 180 deg. It is necessary to unfix all these torsions in the object.

   minimize tether

   if Nof(a_/arg) > 0 then
      set v_/arg/xi5 Abs(Iarray(Value(v_/arg/xi5)/180.)*180.)  # normalize xi5
      fix v_/arg/xi5    # restore the normal fixation
   endif

   set terms sTermsVacuum only
   show energy mute v_//M
   eBefore = Energy(sTermsVacuum)
   if (Nof(v_//M) > 0) minimize v_//M
   eAfter  = Energy(sTermsVacuum)
   printf "#_methyl    : energy before/after: %.1f %.1f\n", eBefore, eAfter

   show energy mute v_//P
   eBefore = Energy(sTermsVacuum)
   if (Nof(v_//P) > 0) minimize v_//P
   eAfter  = Energy(sTermsVacuum)
   printf "#_polar    : energy before/after: %.1f %.1f\n", eBefore, eAfter

   sfmt ="#_annealing :%3d%11.1f%11.1f%10.2f%10.2f  %8.1f%8.1f%8.1f%8.1f%8.1f%8.1f%10.1f\n"
   set terms sTermsVacuum+",tz" only
   tzWeight = 1.
   printf "#_annealing : energy terms used in annealing = %-s\n",  sTermsVacuum+",tz"
   show energy mute
   eCurr = Energy(sTermsVacuum+",tz")
   ePrev = eCurr
   rmsd  = Rmsd(a_//!h* a_tmpregul.*//!h* )
   if (Nof(as_out) > 0) as_out = !a_*.
   if (Energy("tz") == 0) then
      delete a_tmpregul,$ixModel.
      return error "# ERROR: tether term energy = 0."
   endif
   tzAnneal = 1.  # previously it was 2.
   for iIterAnn = 1, nIterAnn
     tzWeight = tzWeight*tzAnneal*Energy(sTermsVacuum)/Energy("tz")
     if (tzWeight < 1.) tzWeight = 1.0/(2.0 - tzWeight)
     minimize
#     if (Interrupt()) return  # obsolete
     eCurr = Energy(sTermsVacuum+",tz")
     rmsd  = Rmsd(a_//!h* a_tmpregul.*//!h* )
     if (Nof(as_out) > 0) as_out = !a_*.
     if !(l_shortOutput) printf sfmt iIterAnn Energy(sTermsVacuum) Gradient() tzWeight rmsd Energy("vw") \
              Energy("14") Energy("hb") Energy("to") Energy("el") Energy("ss") Energy("tz")
     if (Abs(eCurr - ePrev) <= eThreshold) then
       if !(l_shortOutput) printf "# annealing : quit: iteration = %d; energy change (actual/threshold) = %.3f %.3f\n", \
                 iIterAnn, Abs(eCurr - ePrev), eThreshold
       break
     endif
     ePrev = eCurr
   endfor
   print "# polar     : #---------------------------------------------------"
   set terms sTermsAll only               # add the solvation and the entropy terms
   if (Nof(Res(Atom(v_//P))) <= 0) then   # Select all the residues with polar hydrogens
     print "# polar     : no residues with polar hydrogens, polar hydrogen placement step skipped"
   endif
   vsPolarH = v_//P
   for iPolarH = 1, Nof(vsPolarH)
     vsCurr = vsPolarH[iPolarH]
     angBefore = Remainder(Sum(Value(vsCurr)))
     ssearch vsCurr
#     if (Interrupt()) return  # obsolete
     angAfter  = Remainder(Sum(Value(vsCurr)))
     show energy mute
   endfor

# For removing strain which may remain  after previous steps, an additional relaxation
# may be helpful. Tether weight is equal to that from the last step of annealing.
   print "# relaxation: #---------------------------------------------------"
   set terms sTermsAll only
   show energy mute
   eCurr = Energy(sTermsAll)
   ePrev = eCurr
   rmsd = Rmsd(a_//!h* a_tmpregul.*//!h* )
   if (Nof(as_out) > 0) as_out = !a_*.
   sfmt ="#_relaxation: %3d %10.2f%10.2f%10.2f%10.2f%10.2f%10.2f%10.2f\n"
   if !(l_shortOutput) printf sfmt, 0, eCurr, Gradient(), rmsd, \
          Energy(sTermsVacuum),Energy("tz"),Energy("sf"),Energy("en")
   for iIterRelax = 1, nIterRelax
     minimize
#     if (Interrupt()) return  # obsolete
     eCurr = Energy(sTermsAll)
     rmsd = Rmsd(a_//!h* a_tmpregul.*//!h* )
     if (Nof(as_out) > 0) as_out = !a_*.
     if !(l_shortOutput) printf sfmt, iIterRelax, eCurr, Gradient(), rmsd, \
            Energy(sTermsVacuum), Energy("tz"),Energy("sf"),Energy("en")
     if (Abs(eCurr - ePrev) <= eThreshold) then
       if !(l_shortOutput) printf "# relaxation: quit: iteration = %d; energy change (actual/threshold) = %.3f %.3f\n", \
               iIterRelax, Abs(eCurr - ePrev), eThreshold
       break
     else
       ePrev = eCurr
     endif
   endfor
   set term s_oldterms only
   l_info=no
endmacro

macro settzparam as_ r_radius r_weight
  if Nof(as_)==0  return error " Error> empty selection"
  if Type(Obj(as_)[1],2)!="ICM"  return error " Error> you selected atoms in a non-ICM object"
  if Nof( as_ & a_*.//T ) return error " Error> atoms you have selected are not tethered"
  as_ = as_ & a_*.//T
  asZ = Select(as_ "Z") # have not tested this, selecting destination atoms
  set bfactor asZ r_weight
  set area asZ r_radius
  set charge asZ 0.
  set charge formal asZ 0.
endmacro

macro mkAtomsFromXyz M_xyz
  nat = Nof(M_xyz)
  if(nat<=0) return error " Error> empty matrix"
  if(Length(M_xyz)!=3) return error " Error> expecting matrix [N,3] "
  #
  build string "se "+Sum(Sarray(nat," o")) name=Name("dots",object)
  set a_//o M_xyz
endmacro

macro settz as_ M_xyz r_radius r_weight
  if Nof(as_ ) == 0 return error " Error> empty selection"
  oscu = Obj(as_)[1]
  build string "se o" name=Name("tz",object)
  strip a_
  translate a_ Mean(M_xyz)
  set tether as_ a_//o
  set bfactor a_//o r_weight
  set area a_//o r_radius
  set charge a_//o 0.
  set charge formal a_//o 0.
#
# Restore current object and force the method to "function"
#
  set object oscu
  if(tzMethod!=4 & l_warn) print " Warning> tzMethod is now set to 4"
  tzMethod = 4
  keep tzMethod
endmacro

#:)
macro setResLabel
  if(Nof(object)==0) return error " setResLabel> no objects loaded."
  resLabelShift = 3.0
  if (Nof(a_*.*/trp/cz2) > 0) set label a_*.*/trp/cz2
  if (Nof(a_*.*/lys/nh) > 0) set label a_*.*/lys/nh
  if (Nof(a_*.*/arg*,phe,tyr/cz) > 0) set label a_*.*/arg*,phe,tyr/cz
  if (Nof(a_*.*/asn,asp,leu,pro/cg) > 0) set label a_*.*/asn,asp,leu,pro/cg
  if (Nof(a_*.*/cys*,met/s*) > 0) set label a_*.*/cys*,met/s*
  if (Nof(a_*.*/gln,glu/cd) > 0) set label a_*.*/gln,glu/cd
  if (Nof(a_*.*/hi*/ce1) > 0) set label a_*.*/his/ce1
  if (Nof(a_*.*/ile/cd1) > 0) set label a_*.*/ile/cd1
  if (Nof(a_*.*/val,thr,ser/cb) > 0) set label a_*.*/val,thr,ser/cb
endmacro
#:(
macro rdAllObj s_obna
  s_obnaex = s_obna + ".ob"
  read sarray "obfina" sys $s_sysLst $s_obnaex
  if( Nof(obfina)<=0)return
  nObOld = Nof( a_*. )
  for i=1,Nof(obfina)
    read object obfina[i]
  endfor
  print " INFO> " Nof( a_*. )-nObOld " objects read"
endmacro
#
# operates on the current object
macro remarkObj
  s=Sum(Namex(a_))
  edit s
  set comment a_ s
endmacro
#
macro plotSeqDotMatrix &seq_1 &seq_2 s_seqName1 ("Sequence1") s_seqName2 ("Sequence2") i_mi (5) i_mx (20)
 m=Probability(seq_1 seq_2 i_mi i_mx)
 print "Min,Max,Mean",Min(Min(m)),Max(Max(m)),Mean(Mean(m))
 PLOT.rainbowStyle = 4
 show Align(seq_1 seq_2)
 plot area Log(m,0.1) ds comment=String(seq_1)//String(seq_2)//String(seq_1)//String(seq_2) grid link transparent={0.,0.7} color={0.7,3.0} "Alternative Local Alignments"//s_seqName1//s_seqName2
endmacro
#
macro plotSeqDotMatrix2 &seq_1 &seq_2 s_seqName1 ("Sequence1") s_seqName2 ("Sequence2") i_mi (5) i_mx (20)
 m=Probability(seq_1 seq_2 i_mi i_mx)
 print "Min,Max,Mean",Min(Min(m)),Max(Max(m)),Mean(Mean(m))
 PLOT.rainbowStyle = 4
 show Align(seq_1 seq_2)
 plot area 1.-m ds comment=String(seq_1)//String(seq_2)//String(seq_1)//String(seq_2) grid link transparent={0.,0.7} color={0.7,0.99} "Alternative Local Alignments"//s_seqName1//s_seqName2
 l_info=no
endmacro
#
macro dsChem as_ ( a_ )
  lineWidth = 4
  atomLabelStyle = "[C]"
  wireStyle = "chemistry"
  display as_ only
  set font label atom 18 bold
  display atom label black
  color background white
  color a_//c* black wire ribbon xstick
  keep lineWidth atomLabelStyle wireStyle
endmacro
#
function chem3dto2d ms_lig
  l_commands = l_info = no
  s_curObj = Sum(Name(a_))

  copyMol ms_lig "tmplig3d"
  set object a_tmplig3d.

  l_rmhyd = no
  if ( Type( a_ 2) != "ICM" ) then
    build hydrogen
    set type charge mmff
    convert auto
    l_rmhyd = yes
  endif

  set tether a_//
  minimize v_//?vt* "tz" tzMethod = "z_only"
  minimize "tz,vw" tzMethod = "z_only" vwWeight=tzWeight*0.1

  if (l_rmhyd) then
    strip virtual a_
    delete a_//h*
  endif
  ch = Chemical( a_ superimpose  )

  delete a_
  set object a_$s_curObj.

  return ch
endfunction
#
macro ligDiagCalcAccSurface ms_lig os_rec
  l_commands = l_info = no
  #
  if ( Obj( ms_lig ) != Obj( os_rec ) ) then
    s_molName = Sum(Name(ms_lig))
    copy Obj( os_rec ) "tmpligplot_rec"
    copy Obj( ms_lig ) "tmpligplot_lig"
    move a_tmpligplot_lig. a_tmpligplot_rec.

    show surface area a_tmpligplot_rec.$s_molName & a_*.//!h* a_tmpligplot_rec. & a_*.//!h*
    R_area = Area( a_tmpligplot_rec.$s_molName & a_*.//!h* )

    delete  a_tmpligplot_rec.
    set area ms_lig & a_*.//!h* R_area
  else
    show surface area ms_lig & a_*.//!h* (ms_lig | os_rec) & a_*.//!h*
  endif
  #
endmacro
#
macro ligDiagInteraction2D ms_lig os_rec (a_none.)  P_chemTempl (Chemical()) r_hphobDist (4.5) r_hbStrength (0.8) i_labelStyle (1) l_assignSites (no) l_makeContactTable (no) auto
  l_commands = l_info = no

  if ( Nof(P_chemTempl)==0 ) P_chemTempl = chem3dto2d( ms_lig )
  if ( Nof(os_rec)==0 ) os_rec = Nof( Obj( ms_lig ) & a_*.N,A ) > 0 ? Obj( ms_lig ) & a_*.N,A : Obj( Sphere( ms_lig a_*.N,A 5.) )
  ligDiagCalcAccSurface  ms_lig os_rec
  s_res = Name( Sum( Name( Mol( ms_lig ) ) ) + "_" + Sum( Name( Obj( os_rec  ) ) ) + "_diagram" unique )
  resLabelStyle = i_labelStyle
  delete $s_res l_warn=no
  make view chemical ms_lig os_rec P_chemTempl name=s_res distance=r_hphobDist GRAPHICS.hbondMinStrength=r_hbStrength
  #make view chemical ms_lig os_rec name=s_res distance=r_hphobDist GRAPHICS.hbondMinStrength=r_hbStrength enumerate

  if (l_assignSites) then
    T_cont = Table(c_out)
    delete T_cont.type != "hbond" & T_cont.type != "hydrophob" & T_cont.type != "covalent"
    mn = Min( T_cont.size )
    mx = Max( T_cont.size )
    for i=1,Nof(T_cont)
      s_rs  = "^" + T_cont.res[i]
      rs = Res( os_rec ) & a_*./$s_rs
      if (Nof(rs)==0) continue
      s_site = "Circle";
      sz = (T_cont.size[i] - mn) / (mx - mn)
      if (T_cont.type[i] == "covalent") sz = 1
      s_site += sz <= 0.3 ? "_small" : sz <= 0.6 ? "_medium" : "_large"
      s_site += "_" + T_cont.color[i]
      set site rs s_site
    endfor
  endif
  #
  if (l_makeContactTable) then
    s_cont_tab = s_res + "_contacts"
    $s_cont_tab = Table(c_out)
    delete $s_cont_tab.type != "hbond" & $s_cont_tab.type != "hydrophob" & $s_cont_tab.type != "covalent"
    set format $s_cont_tab.color color="color"
    set foreground $s_cont_tab right
    keep $s_cont_tab
  endif
  #
  keep $s_res
endmacro
macro makeAxisArrow rs_ i_length (10) r_radius ( 0.12 ) r_head_width_ratio ( 2. )
  l_info=l_commands=no
  rs_ = Select(Res( rs_ ), 2)  # patch small omissions
  cas = rs_ & a_*.//ca
  n=Nof(rs_)
  if(n<3) return error "Helix too short or object does not exist"
  R1=Mean(Xyz( rs_ & a_*.//ca ) )
  show Rmsd(cas[1:n-1] cas[2:n] exact )
  vv=R_out
  aa=Axis(vv)
  print "The rotation angle per residue is ",Integer(r_out) " deg. "
  s_name = Name( "axis_"+Name(Mol( rs_ ))[1] unique  )
#
  if( i_length ==0 ) i_length = Nof(rs_)
  if( i_length < 0 ) i_length = Nof(rs_)
  GROB.arrowRadius = r_radius
  if(r_head_width_ratio<1.) r_head_width_ratio = 2.
  GROB.relArrowHead = r_head_width_ratio
#
  $s_name = Grob("ARROW20", -aa * i_length )
  s_out = s_name
  translate $s_name Mean( Xyz( rs_ & a_*.//ca,c,n ))
  display $s_name
  keep $s_name s_out
endmacro
#
macro dec s_ipaddress ("" )
  dec_a=Split(s_ipaddress,".")
  if(Nof(dec_a)!=4) return error " Error in dec> four sections are expected, e.g. \"123.4.34.2\""
  dec_b=Iarray(dec_a)
  print "standard= ", dec_b[1]+256.*(dec_b[2] + 256.*(dec_b[3] + 256.*dec_b[4]))
  print "reversed= ", dec_b[4]+256.*(dec_b[3] + 256.*(dec_b[2] + 256.*dec_b[1]))
endmacro
#
macro rdec s_inet_dec ("3488253803")
  a1=Integer(Floor(Real(s_inet_dec)/16777216))
  a0=Integer(Real(s_inet_dec)-16777216.*a1)
  a2=    a0/65536
  a3=Mod(a0/256  ,256)
  a4=Mod(a0      ,256)
  print s_inet_dec+" = "+a1+"."+a2+"."+a3+"."+a4+"  OR  "+a4+"."+a3+"."+a2+"."+a1
endmacro
#
macro setBPcnNA rs_1A rs_1B
  rs_1A = Res(rs_1A)
  rs_1B = Res(rs_1B)
  if(Nof(rs_1A)!=1 | Nof(rs_1B)!=1) return error "Select one base in each of the two selections"
  naA = Name( rs_1A )[1]
  naB = Name( rs_1B )[1]
  ixA = Index({"ra","rc","rg","ru","da","dc","dg","dt"} naA)
  ixB = Index({"ra","rc","rg","ru","da","dc","dg","dt"} naB)
  ixA = Mod(ixA-1 4)+1 ; ixB = Mod(ixB-1 4)+1
  if(ixA == 3 & ixB == 2) then
    set drestraint 10 a_.//h22 & rs_1A a_.//o2 & rs_1B ; set drestraint 10 a_.//h1 & rs_1A a_.//n3 & rs_1B ; set drestraint 10 a_.//o6 & rs_1A a_.//h42 & rs_1B
  elseif(ixA == 2 & ixB == 3) then
    set drestraint 10 a_.//h22 & rs_1B a_.//o2 & rs_1A ; set drestraint 10 a_.//h1 & rs_1B a_.//n3 & rs_1A ; set drestraint 10 a_.//o6 & rs_1B a_.//h42 & rs_1A
  elseif(ixA == 1 & ixB == 4) then
    set drestraint 10 a_.//h62 & rs_1A a_.//o4 & rs_1B ; set drestraint 10 a_.//n1 & rs_1A a_.//h3 & rs_1B
  elseif(ixA == 4 & ixB == 1) then
    set drestraint 10 a_.//h62 & rs_1B a_.//o4 & rs_1A ; set drestraint 10 a_.//n1 & rs_1B a_.//h3 & rs_1A
  else
    return error "One of the selections is not a standard nucleic base"
  endif
endmacro
#
macro makeDnaRna s_sequence ("ACTG") s_molName ("na") l_duplex (yes) l_min (yes) s_dna_rna ("dna")
  l_confirm  = no
  errorAction = "break"
  if(l_duplex & s_dna_rna == "rna" ) return error "Can not created a double stranded RNA, find a PDB entry and convert it"
  l_dna_rna = s_dna_rna[4:6]=="rna"
  if s_dna_rna[1:3]=="dna" then
    S_NUCL3={"da ","dc ","dg ","dt "}
    S_NUCL1={"A","C","G","T"}
    s_seq = Replace(s_sequence,"U","T")
    s_seq_rna = Replace(s_sequence,"T","U")
    S_NUCL3_rna={"ra ","rc ","rg ","ru "}
    S_NUCL1_rna={"A","C","G","U"}
  else
    S_NUCL3={"ra ","rc ","rg ","ru "}
    S_NUCL1={"A","C","G","U"}
    s_seq = Replace(s_sequence,"T","U")
  endif
  s_seq = Trim(Toupper(s_seq),"ACGTU")
  if(l_duplex) then
    if (l_dna_rna) then
      s_seq = "ml dna\nse "+ Replace( s_seq,S_NUCL1,S_NUCL3)+"\nml rna\nse "+ Replace( String(0,1,s_seq_rna),S_NUCL1_rna,Sarray(S_NUCL3_rna,reverse))
    else
      s_seq = "ml watson\nse "+ Replace( s_seq,S_NUCL1,S_NUCL3)+"\nml crick\nse "+ Replace( String(0,1,s_seq),S_NUCL1,Sarray(S_NUCL3,reverse))
    endif
  else
    s_seq = "ml watson\nse "+ Replace( s_seq,S_NUCL1,S_NUCL3)
  endif
  build string s_seq name= s_molName
  if(!l_duplex) return
  Rmsd(a_1/1/1,2,3 a_1/1/c4',c3',c2' exact virtual)
  transform a_ R_out
  ilsnu=Nof(a_/*)
  Rmsd(a_/1/c4',c3',c2' a_/$ilsnu/c4',c3',c2' exact)
  transform a_2 R_out
  R_flip={-0.215998,-0.964523,-0.151787,8.810215,-0.960576,0.182047,0.210125,8.299304,-0.175038,0.191189,-0.96582,-4.513048}
  transform a_2 R_flip
  if (l_min) then

    pairs = Array()
    pairs //= { "T"  "o4"  "h62" "h3"  "n1" }  # TA
    pairs //= { "A"  "h62" "o4"  "n1"  "h3" }  # AT
    pairs //= { "C"  "n3"  "h1"  "h42" "o6" }  # CG
    pairs //= { "G"  "h1"  "n3"  "o6"  "h42"}  # GC

    if (l_duplex) then
      for i=1,Nof(pairs)
        if pairs[i][1] == s_sequence[1] then
           i_fr = 1; i_to = Nof( a_/ )
           s_at1 =  pairs[i][2];  s_at2 =  pairs[i][3]
           set drestraint 10 a_1/$i_fr/$s_at1 a_2/$i_to/$s_at2
           s_at1 =  pairs[i][4];  s_at2 =  pairs[i][5]
           set drestraint 10 a_1/$i_fr/$s_at1 a_2/$i_to/$s_at2
        endif
        if pairs[i][1] == s_sequence[Length(s_sequence)] then
           i_fr = Nof(a_/)/2; i_to = i_fr+1
           s_at1 =  pairs[i][2];  s_at2 =  pairs[i][3]
           set drestraint 10 a_1/$i_fr/$s_at1 a_2/$i_to/$s_at2
           s_at1 =  pairs[i][4];  s_at2 =  pairs[i][5]
           set drestraint 10 a_1/$i_fr/$s_at1 a_2/$i_to/$s_at2
        endif
      endfor
      i_fr = Nof(a_/)/2; i_to = i_fr+1; i_nof = Nof(a_/)
      minimize v_2//V "cn,vw,hb" a_/1,$i_fr,$i_to,$i_nof a_/1,$i_fr,$i_to,$i_nof  minimizeMethod = "conjugate" vwMethod = "soft" vwCutoff = 5.
    endif

    #copy a_ "xxx"
    #set tether a_ a_xxx.
    #tzWeight = 100.
    #minimize 100 "hb,tz" v_//*vt*
    #tzWeight = 10.
    #minimize 200 "vw,14,hb,tz" v_//*vt*
    #delete a_xxx.
  endif
  l_info=no
endmacro
#
macro makeMultiSuper as_
  l_undo=yes
  l_commands=no
  l_info = no
  l_warn = no
  errorAction = "break"
  os_ = Obj(as_)
  nobj = Nof(os_)
  if (nobj<=1) return
  for i=2,nobj
    superimpose as_ & os_ [1]  as_ & os_ [i]
  endfor
endmacro

macro superimposeSelection os_templateObj l_all
  l_undo=yes
#  l_commands = yes
  if(Nof(Obj(as_graph))<2) then
    if(Type(distpairs)=="parray" & Type(distpairs 1)=="label3d") then
       os_super = Obj(Atom(distpairs)) & Obj(a_*.//DD); nobj = Nof(os_super)
       if(nobj >= 2) then

         buf  = "#dialog{\"Static Object :\"}\n#1 {"
         for iobj =1,nobj; buf += " o_"+ iobj + "_"+Name(os_super)[iobj] ; endfor
         buf += " }\n"

         if(Askg( buf ) == "yes" ) then
          kobj = Integer(Getarg(1 gui) )
          for iobj=1,nobj
             if(kobj!=iobj) superimpose os_super [ iobj ] distpairs
          endfor
         endif
       endif
    else
      print "\n Hint: Select two molecules in two objects with Ctrl-Click in Workspace or specify pairs with the distance tool\n"
    endif

  else
    s_opt = ""; if (l_all) s_opt = "all"
    os_super = Obj(as_graph); nobj = Nof(os_super)

    buf  = "#dialog{\"Static Object :\"}\n#1 {"
    for iobj =1,nobj; buf += " o_"+ iobj + "_"+Name(os_super)[iobj] ; endfor
    buf += " }\n"

    if(Askg( buf ) == "yes" ) then
      kobj = Integer(Getarg(1 gui) )
      if (Nof(Mol(as_graph)) >= 2 & Type( Mol(as_graph)[1], 2) == "Hetatm" ) then
        for iobj=1,nobj
          if(kobj!=iobj) superimpose Atom( as_graph ) & os_super[kobj],  Atom( as_graph ) & os_super[iobj] chemical $s_opt
        endfor
      else
        for iobj=1,nobj
          if(kobj!=iobj) then
             kbbat = (Res( as_graph ) & (a_.A,H//ca,c,n,o | a_*.N//p,c[345][*],o[35][*]) ) & os_super[kobj] # from as_graph -> res -> bb
             ibbat = (Res( as_graph ) & (a_.A,H//ca,c,n,o | a_*.N//p,c[345][*],o[35][*]) ) & os_super[iobj]
             nkbbat = Nof(kbbat); nibbat = Nof(ibbat)
             icnoali = (nkbbat==nibbat) & (nkbbat < 30)  # less than 30 atoms of ca,c,n,o (7 res)
             superimpose kbbat ibbat icnoali?exact:align minimize
          endif
        endfor
        center Res( as_graph )
       endif  # for Askg
     endif
  endif
  l_info = no
endmacro
#
macro ligandProtonation ms_ligand
  copy Obj(ms_ligand) "TEMPLIG"
  delete Select( Mol( Obj(ms_ligand) & !ms_ligand ) a_TEMPLIG. )
  set object Obj(ms_ligand)
  make born
  make born a_TEMPLIG.
  set area a_TEMPLIG.//!vt*,h*  (332./8.) * (1./Rarray( a_TEMPLIG.//!vt*,h* ) - 1./Rarray( ms_ligand & a_//!vt*,h* )) # store desolvation energies
  make boundary
  set field a_TEMPLIG.//!vt*,h* Potential( a_//!vt*,h* & ms_ligand  a_ & !ms_ligand )
  strip a_TEMPLIG.
  set object a_TEMPLIG.
  delete a_//vt*,h*
  print "   Atom        dPka        dPkb       "
  show column Name(a_//) (-Field(a_//)+Area(a_//))/1.38 (-Field(a_//)-Area(a_//))/1.38
  set charge formal a_ 0
  set charge formal auto field a_
  build hydrogen
  set type mmff
  set charge mmff
  convert
  delete a_TEMPLIG.
  move a_ Obj( ms_ligand )
  delete Mol(ms_ligand)
endmacro
#
macro optimizeProtonation rs_DEKHres
  l_info = no
  s_skipMessages = "[225],[226]"
  dGCarboxy = 30.
  dGLys = 40.
  dGHis = 7.
  dGHip = 20.
  rs_DEKHres = rs_DEKHres & a_*./glu,asp,hie,his,lys
  if( Nof(rs_DEKHres) == 0 ) return
  if(Type(Obj(rs_DEKHres),2) != "ICM") return error "bad residue selection in optimizeAspGluProton"
  set object Obj(rs_DEKHres)
# first pass: protonate some histidines
  while(yes)
    print " Evaluating dGp for " + Nof( a_/hie,his ) + " histidines..."
    if( Nof( a_/hie,his ) == 0 ) break
    make born
    bR = Sum(Transpose(Matrix(1./(Rarray( a_/hie,his/ne2,nd1 )) 2))) # Born to predict solvation
#
    copy a_ "tmp"
    set object a_tmp.
    randomize a_//* 0.001
    make boundary
    delete a_tmp.
    set object Obj(rs_DEKHres)
#
    dGe = -12.5*bR + 0.9*Potential( a_/hie/nd1 | a_/his/ne2 a_//* ) - 6.
    if(Min(dGe+dGHis)>0.)break
    group table "POTENTIALS" dGe Sarray( a_/hie/nd1| a_/his/ne2 )
    sort POTENTIALS.dGe
    s_sel = "a_" + POTENTIALS.B[1]
    delete POTENTIALS
    modify Res( $s_sel ) "hip"
    minimize v_//P & Sphere( $s_sel 8 ) "el,hb,to,vw,14" 100
    print " Info> optimizeProtonation: histidine " + s_sel + " was protonated"
  endwhile
  if(Nof( rs_DEKHres & a_./!his,hie )==0)then
    return
  endif
# second pass: discharge unstable charged residues (deprotonate K/H and protonate D/E)
  while(no)
    make boundary
    rA =  Sum(Transpose(Matrix(Potential( a_/glu,asp/oe*,od* a_//* ) 2))) - dGCarboxy # total potential on O2 of the acid
    rK = -Sum(Transpose(Matrix(Potential( a_/lys/hz* a_//* ) 3))) - dGLys     # total potential on H3 of ammonium
    rH = -Sum(Transpose(Matrix(Potential( a_/hip/hd1,he2 a_//* ) 2))) - dGHip         # total potential on two NH hydrogens of hip
    r = rA//rK//rH
    if(Min(r)>0.)break
    group table "POTENTIALS" r Sarray( a_/glu,asp ) // Sarray( a_/lys ) // Sarray( a_/hip )
    sort POTENTIALS.r
    s_sel = "a_" + POTENTIALS.B[1]
    delete POTENTIALS
    r_variables = Value( V_* & Res( $s_sel ) & a_//!h* )
#    center Res( $s_sel )
    if( Index(s_sel "E")) then
      p12 = Potential( $s_sel & a_//oe* )
      modify $s_sel "glh"
      if( p12[1] > p12[2] ) set v_//xi3 & $s_sel add 180.
    elseif( Index(s_sel "D")) then
      p12 = Potential( $s_sel & a_//od* )
      modify $s_sel "ash"
      if( p12[1] > p12[2] ) set v_//xi2 & $s_sel add 180.
    elseif( Index(s_sel "K")) then
      p123 = Potential( $s_sel & a_//hz* )
      modify $s_sel "lyn"
      if( p123[1] > p123[2] & p123[1] > p123[3] ) set v_//xi5 & $s_sel 180.
      if( p123[2] > p123[1] & p123[2] > p123[3] ) set v_//xi5 & $s_sel -60.
    elseif( Index(s_sel "H")) then
      p12 = Potential( $s_sel & a_//hd1,he2 )
      if(p12[1] > p12[2] )modify $s_sel "his"
      if(p12[1] < p12[2] )modify $s_sel "hie"
    else
      print "Absurd"
    endif
  endwhile
endmacro
#
macro optimizeHeteroTautomer ms_hetero
  electroMethod = "distance dependent"
  vwMethod = "soft"
  ms_hetero = Mol(ms_hetero)
  for i = 1, Nof(ms_hetero)
    build tautomer ms_hetero[i] 10.
    if(Nof( ms_hetero[i] tautomer )[1]>1)then
      ecurr = 999999999.
      jbest = 1
      for j = 1 Nof( ms_hetero[i] tautomer )[1]
        set tautomer ms_hetero[i] j
        show energy "hb,vw,14,el" ms_hetero[i] a_ & ! ms_hetero[i] mute
        e_j=Energy("hb,vw,14,el")
        if( ecurr > e_j+1 )then # margin 1. kcal/mol to avoid pointless changes
          jbest = j
          ecurr = e_j
        endif
      endfor
      set tautomer ms_hetero[i] jbest
    endif
  endfor
endmacro
#
macro optimize1His s_selection l_old (yes)
#  l_old=no
  if(l_old)then
      unfix V_* & ( $s_selection & a_//!h* )
      r_variables = Value( v_* & $s_selection )
      fix ( v_* & $s_selection ) & ! v_//S
      show energy "hb,vw,14,el" $s_selection mute dielConst=2. # MT increase electrostatic contrib 2017
      r_1=Energy("hb,vw,14,el")
      modify $s_selection Replace( s_curres+"t" {"hist","hiet"},{"hie","his"} )  # swap his <--> hise
      unfix V_* & ( $s_selection & a_//!h* )
      set v_* & $s_selection r_variables
      fix ( v_* & $s_selection ) & ! v_//S
      show energy "hb,vw,14,el" $s_selection mute dielConst=2.
      r_2=Energy("hb,vw,14,el")
      if(r_1<=r_2)s_bestres=s_curres
      if(r_1> r_2)s_bestres=Name ( $s_selection )[1]
      if( no & r_1<10. & r_2<10. )then # no hisp for now
        modify $s_selection  "hisp"  # try hisp
        unfix V_* & ( $s_selection & a_//!h* )
        set v_* & $s_selection r_variables
        fix ( v_* & $s_selection ) & ! v_//S
        show energy "hb,vw,14,el" $s_selection mute
        r_3=Energy("hb,vw,14,el")
        if(r_3<Min(r_1 r_2)-1.5)s_bestres=Name ( $s_selection )[1]
      endif
      if( s_bestres != Name ( $s_selection )[1] ) then
        modify $s_selection s_bestres # restore old residue
        unfix V_* & ( $s_selection & a_//!h* )
        set v_* & $s_selection r_variables
      endif
      if(l_warn & s_bestres != s_curres) print " Warning> histidine " s_selection " was changed to " s_bestres
      fix ( v_* & $s_selection ) & ! v_//S
  else # new embedded tautomers
    build tautomer $s_selection charge
    xi2 = Value( v_//xi2 & $s_selection )
    for i = 0,5
      set tautomer $s_selection i/2 + 1
      set  v_//xi2 & $s_selection   xi2 + Mod(i 2)*180.
      show energy "hb,vw,14,el,sf" $s_selection mute dielConst=2.
      eyof = (i>4)?6.:0. # intrinsic offset for his+, may need correction for ICMFF?
      eycu = Energy( "hb,vw,14,el" ) + eyof
      if(i==0 | eymi > eycu)then
        eymi = eycu
        imi = i
      endif
    endfor
    set tautomer $s_selection imi/2 + 1
    set  v_//xi2 & $s_selection   xi2 + Mod(imi 2)*180.
    print " Info> histidine " s_selection " was set to " {"his","hie","hip"}[imi/2 + 1] Mod(imi 2)==1 ? "and flipped" : ""
  endif
endmacro
#
macro optimizeHisProAsnGlnCys rs_HPNQCres
  #l_commands = yes
  l_info = no  # can be cleaned up with new modify memoryzing xi1,xi2
  rs_HPNQCres = rs_HPNQCres & a_*./hi*,pro,asn,gln,cys,asp,glu
  rs_HPNQCres = rs_HPNQCres & ! Res( a_/hi*/vt* )
  if( Nof(rs_HPNQCres) == 0 ) return
  if(Type(Obj(rs_HPNQCres),2) != "ICM") return error "bad residue selection in optimizeHisProAsnGlnCys"
  set object Obj(rs_HPNQCres)

# find histidines near METALS and move hydrogens away from the metal
  rs_HIS = Res(Sphere( ( a_//!vt* & a_//C281:298,C331:400 )   rs_HPNQCres & a_/hi*/nd1,ne2 3. ))
  nMeHis = Nof(rs_HIS)
  nMeHisMod = 0

  for i = 1, Nof(rs_HIS)
    s_selection = String( rs_HIS[i] )
    if Nof( Sphere( $s_selection & a_//hd1 , a_//!vt* & a_//C281:298,C331:400 3.) ) then
      modify $s_selection "hie"; nMeHisMod += 1
      if(l_warn) print " Warning> histidine " s_selection " was changed to hie"
    endif
    rs_HIS = rs_HIS | $s_selection
  endfor
# skip metal-coordinated in sampling
  rs_HPNQCres = rs_HPNQCres & !rs_HIS
  electroMethod = "distance dependent"
  vwMethod = "soft"
  nOptRes = Nof(rs_HPNQCres); nOptResMod=0
  for i = 1, Nof(rs_HPNQCres)
    s_selection = String( rs_HPNQCres[i] )
    s_curres = Name ( $s_selection )[1]
    if(Mol(Next( $s_selection bond)) != Mol( $s_selection ))continue # skip covalently modified residues
    if( s_curres [1:3] == "hie" | s_curres [1:3] == "his" )then
      optimize1His s_selection yes
      rs_HPNQCres = rs_HPNQCres | $s_selection
    elseif( s_curres [1:3] == "pro") then # change hydrogen orientation if proline is "up",  should be moved to 'convert' command
      if( Value( V_//xi2 & $s_selection )[1] > 0 ) set   V_//xi3 & $s_selection , -155.4
    elseif( s_curres [1:3] == "cys" ) then
      if( Nof(Sphere( $s_selection & a_//sg  a_//Zn*,Cu*,Fe*,Co*,Ni* 3. ) ) > 0 ) modify $s_selection "cym"
    elseif( s_curres [1:3] == "gln" | s_curres [1:3] == "asn") then
      # should be just ssearch local mncalls=1 ssearchStep = 180. nSsearchStep = 2 "hb,vw,14,el" (v_/asn/xi2 | v_/gln/xi3 ) & $s_selection
      show energy "hb,vw,14,el" (v_/asn/xi2 | v_/gln/xi3 ) & $s_selection mute
      r_1=Energy("hb,vw,14,el")
      set (v_/asn/xi2 | v_/gln/xi3 ) & $s_selection Value((v_/asn/xi2 | v_/gln/xi3 ) & $s_selection ) + 180.
      show energy "hb,vw,14,el" (v_/asn/xi2 | v_/gln/xi3 ) & $s_selection mute
      if( Energy("hb,vw,14,el") > r_1 ) then
        set (v_/asn/xi2 | v_/gln/xi3 ) & $s_selection Value((v_/asn/xi2 | v_/gln/xi3 ) & $s_selection ) - 180.
      else
        if(l_warn) print " Warning> amide group of " s_selection " was flipped"
      endif
    endif
  endfor
  for i = 1, Nof(rs_HPNQCres & a_/asp,glu )
    rs1_DE = (rs_HPNQCres & a_/asp,glu )[i]
    if(Sum(Charge(Sphere( rs1_DE & a_//oe*,od* a_ & ! rs1_DE 3.2 ) formal)) > 0)continue # skip salt-bridged or metal coordinating
    show surface area rs1_DE & a_//oe*,od* a_!W mute
    if(r_out > 10.)continue # skip solvent-exposed, cutoff TBD
    print " Adding dynamic protonation to " + String( rs1_DE )
    build tautomer charge rs1_DE
# code to be developed for more precise selection of potentially protonating asp/glu
  endfor
endmacro

macro optimizeHetTautomer auto ms_ r_dHcutoff ( 15. )
  ms_ = ms_ & a_*.H
  if( Nof(ms_) == 0 ) return
  if(Type(Obj(ms_),2) != "ICM") return error "molecule selection for optimizeHetTautomer should be in ICM object"
  set object Obj(ms_)
  for i = 1, Nof( Mol(ms_))
    ms_het1 = Mol(ms_) [i]
    build tautomer ms_het1 r_dHcutoff
    nTauto = i_out
    for i = 1, nTauto
      set tautomer ms_het1 i
      show energy "hb,vw,el" ms_het1 a_
      E = Energy("hb,vw,el")
      if(i==1 | E<Emin)then
        Emin = E
        iMin = i
      endif
    endfor
    set tautomer ms_het1 iMin
  endfor
endmacro

macro optimizeHbonds as_  l_rotatable_hydrogens (yes) l_optimizeHisAsnGln (yes)
   l_minRedraw = no # don't forget, otherwise it is painful!!!!!!
   if(Nof(Obj(as_ & a_ICM.))!=1 ) return error " Error> select atoms in one ICM object "
   as_ = as_ & a_ICM.
   set object Obj(as_ )
   if( l_rotatable_hydrogens )  then
     delete stack
     minimize v_//M & Res(as_) "vw,14,hb,to,ss,el" 500
     ssearch residue fast v_//P & a_//h* & Res(as_) "vw,14,hb,to,ss,el"
     delete stack
     as1_ = Mol(a_W & as_ )
     if( Nof( as1_ )  > 0 ) then
       for i = 1, Nof( as1_ )
           set as1_ [i] & a_//vt1 Xyz( as1_ [i] & a_W//o )  # sets the position of the first virtual atom
       endfor
       minimize v_W//?vt2,?vt3 & Res(as1_) "vw,14,hb,to,el" 500
     endif
   endif
   if( l_optimizeHisAsnGln ) then
     optimizeHisProAsnGlnCys Res(as_)
   endif
endmacro

macro shakeLoop as_loop s_args ("") l_keep (no)
  l_info=no
  #l_commands=yes
  l_omg=yes
  s_oldterms = Info(term) # to re- set terms at the end
  set terms only "vw,14,hb,el,to,ss"
  as_loop = Select(Res( as_loop ) , 2) # patch small gaps
  os_ = Obj( as_loop )
  if ( Nof( os_ ) != 1 ) return " Error> select a loop within ONE ICM object"
  if ( Type(os_ 2)!="ICM") return " Error> use Convert PDB to convert object to ICM type"
  if(Nof(Sarray(as_loop))!=1) then
    n=Nof(Sarray(as_loop))
    printf " Error> %d loops selected. %s \n",n, String(Res(as_loop))
    return " Error> can not shake multiple or disconnected loops, select one contige"
  endif
  set object os_
  delete stack
  if( s_args ~ "*db*" )then
    unfix V_//S & as_loop
    compare static as_loop & a_//!h*
    vicinity = 1.
    build loop stack as_loop l_info=yes # group / has a problem
    vwMethod = "soft"
    printf " Found %d conformations. Compressing stack...\n" Nof(conf)
    set stack energy Rarray(Nof(conf),0.)
    set stack energy 1 1 {-1.}
    keep compareMethod
    vicinity = 1.5
    compress stack tree
    printf " Compressed to %d conformations. Evaluating stack...\n" Nof(conf)
    minimize stack 1 "vw,14,el,hb,to,ss" Sphere( as_loop 15. ) Sphere( as_loop 15. ) v_ & as_loop
    load conf 1
    sort stack
    if(s_args ~ "*embed*" )then
      store stack a_
    elseif(s_args ~ "*stack*" )then
      print " Generating stack table "
      if(Type(confStack)!="unknown")delete confStack  # necessary to prevent crash
      confStack = Table( stack )
      keep confStack
    endif
    return
  endif
#
  llen = Nof( as_loop )
  s_st = Field( String( as_loop [1] ) 2 "/" )
  s_st1= Field( String(Res(Next(  as_loop [1] & a_*.//n  bond)[1])) 2 "/" )
  s_en = Field( String( as_loop [llen] ) 2 "/" )
  s_en1= Field( String( Next( as_loop [llen] )) 2 "/" )
# prepare the part before
  copy os_ "loop" delete
  set object a_loop.
  strip
delete a_ & !( a_/$s_st1:$s_en1 )
  convert
# cleanup
  delete a_loop.
  rename a_loop_1. "wkobj"
# connect the loop to the rest
  set tether a_/$s_st1/c,ca,n,hn,o,ha os_ & a_*./$s_st1
  set tether a_/$s_en1/c,ca,n,hn,o,ha os_ & a_*./$s_en1
#
  tzWeight = 100.
  set term "tz"
# maps for the rest of the protein
  set object os_
  make map potential "gc,gh,gb,ge,gs" a_/!$s_st1:$s_en1 Box( a_wkobj. 10. )
  m_gb = 4.*m_gb
  m_gs = 4.*m_gs
  set terms "gc,gh,gb,ge,gs"
  set object a_wkobj.
# done
  mncalls= 400
  mncallsMC =50000*Nof( a_/* )*Nof( a_/* )
  print "mncallsMC =" mncallsMC
  temperature = 600
  ssWeight=100.
  vwMethod = "soft"
  vwSoftMaxEnergy = 20.
#set term "sf"
#surfaceMethod = "apolar"
  if(!l_omg)then
    set v_//omg 180.
    fix v_//omg
  endif
  randomize v_//!omg
  visitsAction = 1
  mnvisits = 40
  autoSavePeriod=10
  mcShake = 4.
  vicinity = 1.5
  flipStepPb = 0.25
  compare static a_//c,ca,n,o # OBJ-DEP
  set vrestraint a_/*
#
  if(Exist(view))then
    display a_
    display tether
    display a_1. grey
    l_minRedraw = no
  endif
#
  montecarlo v_//!?vt1,?vt3 v_//* reverse append
  mva = Matrix( Nof(conf) Nof( v_/!$s_st1 ))
  tzWeight = 10000. # force good closure
  for i=1,Nof(conf)
    load conf i
    minimize
    mva[i,?]=Value( v_/$s_st:$s_en1 )
  endfor
  if(l_keep)then
    return
  endif
  delete stack
  delete object a_
  set object os_
  vold = v_
  unfix V_//S
  vwSoftMaxEnergy = 2.
  for i=1,Nof(mva)
    if(!l_omg)then
      set v_/$s_st:$s_en1 & ! v_//omg mva[i,?]
      set v_/$s_st:$s_en1 & v_//omg 180.
    else
      set v_/$s_st:$s_en1 mva[i,?]
    endif
    show energy "vw,14,hb,el,to,sf"  v_/$s_st:$s_en1
    store conf
  endfor
  unfix only vold
  set terms s_oldterms only
endmacro

macro makeAllLoopTemplates as_
  rs_all = Res(Mol(as_) & a_.A )
  S_loop = Sarray( rs_all & ! Res( as_ & a_.//T ) )
  for i=1,Nof(S_loop)
    sloop = S_loop[i]
    rsLoop = a_$sloop
    if( Nof( rsLoop & rs_all [1] ) !=0 )then
      print " Skipping free N-terminus " + sloop
      continue
    endif
    if( Nof( rsLoop & rs_all [Nof(rs_all)] ) !=0 )then
      print " Skipping free N-terminus " + sloop
      continue
    endif
    print " Loop " + sloop
    rsLoop =  Res(Next( rsLoop bond ))
    makeLoopTemplate rsLoop yes yes yes yes
  endfor
  set object Obj(as_)
endmacro

macro makeLoopTemplate as_ l_loopDB (no) l_GAP (yes) l_context (yes) l_display (no)
#
  if( Nof( as_ )==0)then
    l_direct = yes
    rs_loop = Res( a_ )  # assume current object is the loop to be sampled
  else
   l_direct = no
    rs_loop = Res( as_ ) & a_.A
  endif
  llength = Nof(rs_loop)
  if(llength<6) print "Loop may be too short"  # return "Loop too short"
  if(!l_loopDB & llength>18) return "Loop too long"
#
  if(l_context)then
    set object Obj( rs_loop )
    make map potential simple "gc" Sphere( rs_loop a_//c,ca,n,o,cb 10. ) & ! Next(Next( rs_loop bond) bond ) Box( rs_loop 10. )
    m_gc = Trim( m_gc 0. 4. )
    GRID.gcghExteriorPenalty = "zero"
#    keep m_gc
  endif
#
#  l_united = l_loopDB
  l_united = no # !l_loopDB
#
  if(!l_united) s_icmseq = Replace(IcmSequence(rs_loop) { "ala" "arg" "asn" "asp" "cys" "gln" "glu" "gly" "his" "ile" "leu" "lys" "met" "mse" "phe" "pro" "ser" "thr" "trp" "tyr" "val" } { "ala" "ala" "ala" "ala" "ala" "ala" "ala" "gly" "ala" "ala" "ala" "ala" "ala" "ala" "ala" "pro" "ala" "ala" "ala" "ala" "ala" } )
  if( l_united) s_icmseq = Replace(IcmSequence(rs_loop) { "ala" "arg" "asn" "asp" "cys" "gln" "glu" "gly" "his" "ile" "leu" "lys" "met" "mse" "phe" "pro" "ser" "thr" "trp" "tyr" "val" } { "ala" "ala" "ala" "ala" "ala" "ala" "ala" "gly" "his" "ile" "leu" "ala" "ala" "ala" "phe" "pro" "ala" "ala" "trp" "tyr" "val" } + Sarray(21 "x") )
  if(!l_direct) build string s_icmseq name = "LOOP_"+ Replace(Split(Sarray(rs_loop)[1] "/" )[2] ":" "_")
  if(l_direct) rename a_ "LOOP_"+ Replace(Split(Sarray(rs_loop)[1] "/" )[2] ":" "_")
  rs_Nttz = Res(Select( rs_loop[1] "tz" ))[1]
  if(Nof(rs_Nttz)!=1) then
    print " Warning> N-terminus of the loop has no tethers, constraining to itself"
    rs_Nttz = rs_loop[1]
  endif
  rs_Cttz = Res(Select( rs_loop[llength] "tz" ))[1]
  if(Nof(rs_Cttz)!=1) then
    print " Warning> C-terminus of the loop has no tethers, constraining to itself"
    rs_Cttz = rs_loop[llength]
  endif
# tether termini
  set tether exact a_/* [1]       & a_//c,ca,n rs_Nttz & a_.//c,ca,n & ! a_.//AS
  set tether exact a_/* [llength] & a_//c,ca,n rs_Cttz & a_.//c,ca,n & ! a_.//AS
#
  l_minRedraw=no
  autoSavePeriod = 0 # turn off stack writing in MC
  temperature = 1000.
  tzWeight = 10.
  mncallsMC = 50000*(llength-4)*(llength-4)
  mncalls   = Integer(200*llength/6.)
  mnconf    = 10*(llength-5)*(llength-5)
  flipStepPb = 0.25
  visitsAction = "random"
  mnvisits = 25
  mcJump = 90.0
  set term only "vw,14,to,hb,el,tz"
  if(l_united)then
    delete term "14"
    set term "sf"
    set term "bb"
    unfix V_//ac
  endif
  if(l_context) set term "gc"
#
  set vrestraint a_/*
#
  compare static a_//c,ca,n,o,cb # v_//psi | (v_//phi & ! (a_/* [1]) )
  vicinity=0.07*llength
#
  s_skipMessages="[206]"
  if(l_loopDB)then
    delete tether a_/* [1] & a_//o
    mncallsMC=10*mncalls
    tzWeight = 25.
    montecarlo reverse mute v_//!?vt* v_ "tz"
    load conf 0
    if(Energy("tz")>1.)then
      delete a_
      return "Could not find even initial loop closure"
    endif
    delete stack
    if(!l_direct) build loop stack a_/* 1000 0.05
    if( l_direct) build loop stack a_/* 1000 0.05 index
    vwMethod = "soft"
    printf " Found %d conformations. Compressing stack...\n" Nof(conf)
    set stack energy Rarray(Nof(conf),0.)
    set stack energy 1 1 {-1.}
    compress stack tree
    if(Nof(conf)>100) compress stack tree number=100
    printf " Compressed to %d conformations. Evaluating stack...\n" Nof(conf)
    if(l_context) minimize stack # 100
  else
    montecarlo reverse mute v_//!?vt* v_
    tzWeight=25.
    minimize stack
  endif
# remove poor fits
  minimize stack "tz" 1
  sort stack
  compress stack 0.3*tzWeight
  minimize stack  1
  sort stack
#
  if(!l_GAP)then
    mVar = Matrix(Nof(conf),Nof( v_//!xi* ))
    for i = 1,Nof(conf)
      load conf i
      mVar[i,?] = Value( v_//!xi* )
    endfor
    delete a_
    build string IcmSequence(rs_loop) name = "LOOP_"+ Replace(Split(Sarray(rs_loop)[1] "/" )[2] ":" "_")
    # tether termini
    set tether exact a_/* [1]       & a_//c,ca,n,o rs_Nttz & a_.//c,ca,n,o
    set tether exact a_/* [llength] & a_//c,ca,n,o rs_Cttz & a_.//c,ca,n,o
#
    delete stack
    for i = 1,Nof(mVar)
      set v_//!xi* mVar[i,?]
      store conf
    endfor
    minimize stack v_//xi*
  endif
# tether the model to template
  if(!l_direct) set tether rs_loop [2:llength-1]  a_//!h*
#
  load conf 1
  store stack a_
#
  if(l_display)then
    display a_//c,ca,n xstick
    color molecule xstick a_LOOP*.*
  endif
#
endmacro
#
macro makeLoopStackTable
  os_loop = a_
  LOOPS = Table(stack)
  delete LOOPS.naft LOOPS.nvis
  add column LOOPS Sarray(Nof(LOOPS) ) name="PDBloop"
  add column LOOPS Rarray(Nof(LOOPS) ) name="Resolution"
  add column LOOPS Iarray(Nof(LOOPS) Nof(Res(Atom(os_loop on))) - 2 ) name="Length"
  add column LOOPS Parray( object Nof(LOOPS)  ) name="OBJ"
  LOOPS.doubleClick = "if(Nof(a_PDBLOOP.))delete a_PDBLOOP.\nload object %@.OBJ [%@.i [ %# ]] name=\"PDBLOOP\"\ndisplay a_ xstick\ncolor a_//c* magenta"
  LOOPS.cursor = "load conf a_ %@.i [ %# ] "
  set format show off LOOPS.OBJ
  for i = Nof(LOOPS) 1, -1 # to finish with #1
    set object os_loop
    load conf i
    if(grid4Dlayer==1)continue
    LOOPS.PDBloop[i] = String(loop grid4Dlayer)
    read pdb LOOPS.PDBloop[i] [3:6]
    os_pdb = a_
    LOOPS.Resolution[i] = Resolution( a_ )
    delete a_//:b,:c,:d,:2,:3
    s_out = LOOPS.PDBloop[i]
    s_out
    delete os_pdb & ! ( $s_out )
    if(Nof(os_pdb)==0)continue
    superimpose exact os_loop & a_.//ca a_//ca
    LOOPS.rmsd[i] = r_out
    LOOPS.OBJ [i] = Parray( object a_ )
    delete Obj(os_pdb)
  endfor
  keep LOOPS
endmacro
#
macro designLoop rs_Nter rs_Cter i_minL (4) i_maxL (4)
  pvar = Parray(Matrix(1,1))
  s_tna = "LOOPS_" + (Name( a_ )[1])
  for l = i_minL, i_maxL
    if(l>i_minL)delete a_
    build string "se " + Sum(Sarray( l + 2 "gly "))
    set tether exact a_/1/c,ca,n Res( rs_Nter )[1] & a_.//c,ca,n
    set tether exact a_/* [ l + 2 ] & a_//c,ca,n Res( rs_Cter )[1] & a_.//c,ca,n
    minimize "tz" 1000 l_minRedraw = no
    makeLoopTemplate a_ & ! a_ yes yes no yes
    makeLoopStackTable
    add column LOOPS Parray(Matrix( V_* stack )) name="VAR"
    if(l==i_minL) rename LOOPS s_tna
    if(l>i_minL) then
      add $s_tna LOOPS
      delete LOOPS
    endif
  endfor
  if(i_minL<i_maxL)then
    delete a_
    delete stack
    if(Nof( $s_tna.PDBloop != "")==0)then
      print " No solutions found, sorry. Try different loop length range."
      return
    endif
    delete $s_tna.PDBloop == ""
    if(Nof( $s_tna.ener < 20. )==0)then
      print " Warning> Only poor matches found. Loop length range may be inappropriate."
    else
      delete $s_tna.ener > 20.
    endif
    build string "se " + Sum(Sarray( i_maxL + 2 "gly ")) name = "LOOP_"+ Split(Sarray(rs_Nter)[1] "/" )[2] + Split(Sarray(rs_Cter)[1] "/" )[2]
    display xstick a_//c,ca,n,o,hn
    for i = 1,Nof( $s_tna )
      $s_tna.i [i] = i
      set V_* [1:Nof( $s_tna.VAR [i] )] $s_tna.VAR [i]
      set a_/* off
      set a_/* [1: $s_tna.Length [i] +2] on
      store conf atom $s_tna.ener [i]
    endfor
    $s_tna.cursor = "set object a_" + Name(a_)[1] + ".\n" + $s_tna.cursor
    store stack a_
    load conf 1
    make plot $s_tna "x=Length;y=ener;color=rmsd;rainbow=darkblue/blue/green/gold/orange/red;size=8;title=Loops;;"
  endif
  if( Type(Obj(rs_Nter)) == "ICM" && Mol(rs_Nter)==Mol(rs_Cter) ) $s_tna.doubleClick = "installLoop " + String(Res( rs_Nter )) + " " + String(Res( rs_Cter )) + " " + String( a_ )
  keep $s_tna
endmacro
#
macro installLoop auto rs_Nter rs_Cter rs_loop s_seq ("All ala") l_refine (no)
  rs_Nter = Res( rs_Nter )
  rs_Cter = Res( rs_Cter )
  rs_loop = Res( rs_loop )
  if(Mol(rs_Nter)!=Mol(rs_Cter) | Nof(rs_Nter) !=1 | Nof(rs_Cter) !=1 ) return error "Expected two single residue selections within one target molecule"
  llength = Nof( rs_loop )
  if( s_seq != "All ala" & s_seq != "As in Source" & Length(s_seq) != llength-2 & llength!=0) return error 'Sequence argument should either be one-letter code of the same length as source not including termini, or set to "All ala" or "As in Source"'
  l_source = yes
  if(llength==0)then
    if(s_seq == "As in Source" | s_seq == "All ala" | s_seq=="") return error "No source loop and no sequence provided"
    llength = Length(s_seq)+2
    l_source = no
  endif
  set object Obj(rs_Nter)
  s_static = "static"
  if(l_refine)then
    set separator rs_Cter
    rs_Cter = Res(rs_Cter)
    fix v_//tvt*,avt*,bvt* & rs_Cter
    s_static = ""
  endif
  while( Next(rs_Nter) != rs_Cter )
    delete $s_static Next(rs_Nter)
  endwhile
  rs_2append = rs_Nter
  rs_new = a_ & !a_
  for i = 2, llength - 1
    s_res = ""
    if(s_seq == "All ala")       s_res = "ala"
    if(s_seq == "As in Source")  s_res = Name( rs_loop[i])[1]
    if(s_res == "")              s_res =  Tr123(s_seq[i-1])[1:3]
    modify append $s_static rs_2append s_res
    rs_2append = Next( rs_2append )
    rs_new = rs_new | rs_2append
    if(l_source)set tether name rs_2append & a_//c,ca,n  rs_loop [i] & a_.//c,ca,n
    if(s_seq == "As in Source") set tether name rs_2append & a_//!h*,vt*,c,ca,n rs_loop [i] & a_.//!h*,vt*,c,ca,n
  endfor
# this is needed to prevent 'set tree' from disturbing things outside the loop
  if(l_source)set tether name rs_Nter & a_//c,ca,n rs_loop [1] & a_.//c,ca,n
  if(l_source)set tether name rs_Cter & a_//c,ca,n rs_loop [llength] & a_.//c,ca,n
  if(l_refine)then
    if(l_source)set tether name rs_Cter & a_//!h*,vt*,c,ca,n rs_loop [llength] & a_.//!h*,vt*,c,ca,n
    set V_//an,bn,aca & rs_Cter { 115. 1.325 121. }
    if(l_source) minimize tether v_//!omg & rs_new
    minimize v_//!omg & ( rs_new | rs_Cter ) "tz,cn"
    minimize v_//!omg & ( rs_new | rs_Cter ) "cn"
    delete separator rs_Cter
  elseif(l_source)then
    old_xyz = Xyz( ((Res(os_loop) [1]) | (rs_loop [llength])) & a_.//c,ca,n)
    set rs_loop [1] & a_.//c,ca,n Xyz( rs_Nter & a_//c,ca,n )
    set rs_loop [llength] & a_.//c,ca,n Xyz( rs_Cter & a_//c,ca,n )
#
    set a_ tree
    set V_//fhn,ahn,bhn & rs_Cter  { 180. 124. 1. }
# restore
    set (rs_loop [1]) | (rs_loop [llength])) & a_.//c,ca,n old_xyz
#
  endif
  set V_//fo & rs_Nter 180.
endmacro
#
#----------------------------------------- Homology
macro SetLoop s_Loop i_Candidate
# ----- Macro to build loop using pdb-ofset from table
  l_info=no

  i_LoopNumber =1
  while ( s_Loop != LoopTable.1_Loop[i_LoopNumber ] )
     i_LoopNumber  = i_LoopNumber +1
     if ( i_LoopNumber  > Nof( LoopTable ) ) return error " Unrecognized loop"
  endwhile
      build loop  $LoopTable.1_Loop[i_LoopNumber] LOOP$i_LoopNumber.offset [i_Candidate]

      s_name = "a_"+LoopTable.ObjectName[1] + "."
      display ribbon $s_name white
      color ribbon $LoopTable.1_Loop[i_LoopNumber]  red
endmacro

#--------------------------------------

macro RebuildLoop s_Loop r_rms
# ----- Macro to rebuild loop using different rmsd criterium
  l_info=no

  build loop  $s_Loop r_rms
  show LoopTable
endmacro

#--------------------------------------
macro buildModel1 auto &seq_hm ms_ ms_extra ( a_NONE. ) s_ali ("") i_max_looplen (100) i_Nterm_extension (0) i_Cterm_extension (0) i_Gap_extension (1)  l_sample_side_chains (no) l_multiLoops (no) S_NCterms ({"",""})
  l_commands = l_info = no
  ms1 = Mol(ms_ & a_*.A) [1]
  if( s_ali == "align" & Nof( Name( ms1 alignment ))==1 ) s_ali = Name( ms1 alignment )[1]
  if( Type( $s_ali )=="alignment" & Index( Name( $s_ali ), Name( seq_hm ))==0 ) s_ali = ""
  printf " Info> using alignment '%s' \n", s_ali
  build model seq_hm ms1 $s_ali margin=i_max_looplen//i_Nterm_extension//i_Cterm_extension//i_Gap_extension  # creates new seq & ali
  set a_//* Xyz(a_//*)  # bug fix
  s_seq_hm1 = Name(a_A sequence)[1]
  rename a_ Name("mdl",object);
  make ssbond
  if( $s_seq_hm1 != seq_hm ) then
    $s_ali = Align( $s_seq_hm1, seq_hm ) //  $s_ali # and link
    keep $s_ali  $s_seq_hm1
  endif
  link a_A [$] $s_ali
  if( Nof(S_NCterms)==2 & S_NCterms[1] !="" ) then  # N
    set charge formal 1. a_A/ [1] & a_//n
    build hydrogen a_A/ [1] & a_//n
  endif
  if( Nof(S_NCterms)==2 & S_NCterms[2] !="" ) modify a_A/ [$] S_NCterms[2]  # replace C=O by C-terminus
  if ( l_multiLoops ) then
    dsLoops yes
    LoopTable.1_Loop = Replace( LoopTable.1_Loop, "a_seq_hm","a_"+Name(a_)[1])
    LoopTable.ObjectName[1]=Name(a_)[1]
    adjustLoopTables
    keep table map
  endif
#  show Mol( ms_extra ) & ! Mol( ms1 )
  appendMol Mol( ms_extra ) & ! Mol( ms1 )  Name( a_ )[1]
  vwMethod="soft";  electroMethod = "distance dependent"
  vwSoftMaxEnergy = 1.; dielConst = 4.
  set term "vw,14,hb,to,ss,el,ts" only l_info=no
  minimize v_//xi* & a_/!I ""
  if ( l_sample_side_chains ) then
    set vrestraint a_/*
    montecarlo fast v_//x* & a_/!I "vw,14,hb,el,to,sf,en" l_info=no
  endif
  assign sstructure
  l_info = l_warn = no
endmacro

macro buildNuclModel s_sena s_alina ms_tmpl ( a_1 )
 l_minRedraw = no
 S_lr = LIBRARY.res
 LIBRARY.res = {"icmff" }
 dielConst = 2.
 ffMethod = "icmff"
 read library
 build string IcmSequence( $s_sena ) name = "model_" + s_sena
# makeDnaRna String( $s_sena ) "model_" + s_sena  no no "dna"
 link a_ $s_sena
 set tether $s_alina a_ ms_tmpl
 minimize tether
 minimize 1000 "tz"
 minimize 1000 v_//xi vwMethod = "soft" "vw,14,to,el,hb,bb,tz"
 LIBRARY.res = S_lr
 read library
endmacro

macro buildModel auto as_ ( a_ ) I_params ({100,0,0,1}) s_modname ('hm') l_sample_side_chains (no) l_multiLoops (no) l_overwrite ( no)
HELP = """
  Building simple multimolecular model based on a homologous object with assigned 'homseqname' sequence names
"""
  l_commands = l_info = no
  l_autoLink = no
#  l_multiLoops = no
  if(Nof(Obj(as_ & a_ICM. ))!=1) return error ' Error_bm> incorrect input template selection. One ICM-converted object is needed'
  mshm = Mol( as_ ) & a_*.A & (Select( Mol( as_ ), "homseqname" ) | a_*.K )
  assign sstructure mshm
  msex = Mol( as_ ) & ! mshm
  if(Nof(mshm)==0) return error " Error_bm> No molecules with 'homseqname' sequence tag found"
  show surface area mshm | msex

# test seq/ali/ molecules and standardize to field
  for iml = 1,Nof(mshm)
    ms1 = mshm[iml]
    hmseqna = Trim(Field( ms1 , "homseqname" )[1],all)
    hmalina = Trim(Field( ms1 , "homaliname" )[1],all)
    slkal = Name( ms1 alignment )[1]  # linked al
    if( hmseqna!='' & Type( $hmseqna )=='sequence' ) then
       if( hmalina=='' & slkal == '' ) then # no alignment or linked ali
         make sequence ms1 l_warn = no
         sxrse = s_out; s_out = 'hmali' + iml ; hmalina = s_out
         $hmalina = AlignSS( $hmseqna $sxrse 0.1 )
         set field ms1 name='homaliname' hmalina
         link ms1 $hmalina
       elseif( slkal != "" ) then  # select find which chain to model from multiple alignment
         hmalina = slkal
         set field ms1 name='homaliname' hmalina
         ixrse = Index(Name( $hmalina )  , hmseqna )
         if(ixrse==0) then
           show $hmalina
           print " XXXXXXXXXX " , Name( $hmalina ), hmseqna
           return error " Error_bm> requested homologous sequence is not included in the linked alignment "
         endif
       else
         print " Unfinished, aliname-field only "
       endif
    elseif( slkal != "" ) then  # no sequence, but there is linked ali
      hmalina = slkal  # ? or keep it
      if(Nof( $hmalina )!= 2 ) return error " Error_bm> alignment contains more than 2 sequences. Can not guess which sequence to model.\n Hint: set field <ms> name='homseqname' <model_seq_name> (or make the linked alignment pairwise)"
      set field ms1 name='homaliname' hmalina
      ixrse = Index(Name( $hmalina )  , Name( ms1 sequence )[1])
      if(ixrse==0) then
           print " Info> " , Name(ms1 full)[1], hmalina
           show Name( ms1 sequence )[1], Name( $hmalina )
           return error " Error_bm> requested homologous sequence is not included in the linked alignment "
      endif
      hmseqna = Name( $hmalina ) [3-ixrse]
      set field ms1 name='homseqname' hmseqna
    endif
    if(hmseqna=='' | Type( $hmseqna )!='sequence' ) return error ' Error_bm> empty or nonexistent homologous sequence name'
    if(hmalina=='' | Type( $hmalina )!='alignment') return error ' Error_bm> empty or nonexistent alignment linked'
    printf " Info> sequence '%s' and alignment '%s' on template '%s' marked for building\n", hmseqna,hmalina,Name(ms1 full)[1]
  endfor

  printf " Info_buildModel> building model a_%s. from %d chain(s) and %d extra molecule(s)\n",s_modname,Nof(mshm),Nof(msex)
  s_modname = Trim(s_modname all)
  if(s_modname!='' & l_overwrite) delete a_$s_modname.
  s_modname = Name( s_modname==''?'hm':s_modname object unique )
  build string "se vtre" name=s_modname  # create a_$s_modname.  object
# build mol by mol and move
  for iml = 1,Nof(mshm)
    ms1 = mshm[iml]
    hmseqna = Field( ms1 , "homseqname" )[1]
    hmalina = Field( ms1 , "homaliname" )[1]
    build model $hmseqna ms1 $hmalina margin=I_params
    if(Error()) continue
    set a_//* Xyz(a_//*)  # bug fix
    make ssbond

    s_seq_hm1 = Name(a_A sequence)[1]
    if( $s_seq_hm1 != $hmseqna ) then
      $hmalina = Align( $s_seq_hm1, $hmseqna ) //  $hmalina # and link
      link $hmalina ms1
      keep $hmalina
    endif
    link a_A $hmalina

    if ( l_multiLoops & Nof(mshm)==1 ) then
      dsLoops yes
      LoopTable.1_Loop = Replace( LoopTable.1_Loop, "a_seq_hm","a_"+Name(a_)[1])
      LoopTable.ObjectName[1]=Name(a_)[1]
      adjustLoopTables
      keep table map
    endif
    move a_ a_$s_modname.
  endfor
l_commands = l_info = yes
  appendMol msex s_modname
  set object a_$s_modname.
  delete field  mshm name="homseqname"  # cleanup the invisibles
  delete field  mshm name="homaliname"  # cleanup the invisibles
  delete Mol(a_/vtre)  # get rid of the birthmark
  make ssbond

# refinement
  vwMethod="soft";  electroMethod = "distance dependent"
  vwSoftMaxEnergy = 1.; dielConst = 4.
  set term "vw,14,hb,to,ss,el,ts" only l_info=no
  minimize v_//xi* & a_/!I ""   # warning: relink sequences and alignments to model or use different mechanism
  if ( l_sample_side_chains ) then
    set vrestraint a_/*
    montecarlo fast v_//x* & a_/!I "vw,14,hb,el,to,sf,en" l_info=no
  endif
  assign sstructure a_
  l_info = l_warn = no

endmacro

macro buildModelCleanup
HELP = """
  Remove tables and maps produced by Quick Model (build model)
"""
   l_info = no
   if(Type(LoopTable)=="table") delete LoopTable
   tabna = Match(Name(table),"^LOOP.*?" only)
   for i=1,Nof(tabna); delete $tabna[i]; endfor
   mapna = Match(Name(map),"^LOOPMAP.*?" only)
   for i=1,Nof(mapna); delete $mapna[i]; endfor
   printf " %d tables and %d maps deleted\n", Nof(tabna), Nof(mapna)
endmacro

macro dsLoops l_dsTemplate (yes)
# ----- Macro to display loops
  l_info=no

  if ( Type ( LoopTable ) != "unknown" ) then

    s_name = "a_"+LoopTable.ObjectName[1] + "."
    display ribbon $s_name white
    center static a_
    if(l_dsTemplate) then
      s_name = "a_"+LoopTable.ObjectName[2] + ".//ca,c,n"
      display wire $s_name yellow
    endif

    for i=1, Nof ( LoopTable )
# ----- correction 08.may.2002 - not to display loops not built
       if ( LoopTable.4_Nof[i] > 0 ) then
         color ribbon $LoopTable.1_Loop[i]  red
       else
         undisplay ribbon $LoopTable.1_Loop[i]
       endif
    endfor
  else
    print "\n\nNo loops found\n\n"
  endif
endmacro
#--------------------------------------

macro ScanLoops  s_Loop_arg
# ----- Macro to apply variant of loop
  l_info=no

  i_LoNu=1
  while ( s_Loop_arg != LoopTable.1_Loop[ i_LoNu ]  )
     i_LoNu  = i_LoNu + 1
     if ( i_LoNu  > Nof( LoopTable ) ) return error " Unrecognized loop"
  endwhile

  i_max = Nof( LOOP$i_LoNu )
  s_sw="n"
  i_Cnd=1

  while ( yes )
    SetLoop s_Loop_arg i_Cnd

    if (i_Cnd == 1) then
       s_sw = Ask  ("next/stop (n/s)", "s", simple )
    elseif (i_Cnd == i_max ) then
        s_sw = Ask ("prev/stop (p/s)", "s", simple )
    else
        s_sw = Ask ("next/prev/stop (n/p/s)", "s", simple )
    endif

    if (  s_sw == "s" )  then
        return
    elseif ( s_sw == "n" ) then
        i_Cnd = i_Cnd + 1
    else
        i_Cnd = i_Cnd - 1
    endif
  endwhile

endmacro
#--------------------------------------

macro BuildVariantList  S_xxx  s_Loop
# ----- Macro to build list of variants for selected loop
# ----- to be displayed in menue "Show List"
l_info=no

  i_LoNu=1
  while ( s_Loop != LoopTable.1_Loop[ i_LoNu ]  )
     i_LoNu  = i_LoNu + 1
     if ( i_LoNu  > Nof( LoopTable ) ) return error " Unrecognized loop"
  endwhile

  i_max = Nof( LOOP$i_LoNu )
  S_xxx = LOOP$i_LoNu.Conf

  for i=1, i_max
    S_xxx[i] = String( i ) + " Conf: " +  LOOP$i_LoNu.Conf [i] + " En.: " +  String( LOOP$i_LoNu.energy [i])
  endfor
endmacro

macro cursorBrowseLoops i_LoopNumber
  l_info=no
  l_commands=no
  if Type(LOOP$i_LoopNumber)=="unknown" return
  if Type(LOOPMAP$i_LoopNumber)=="unknown" return
  lct="LOOP"+i_LoopNumber # loop conformation table
  build loop $LoopTable.1_Loop[i_LoopNumber] $lct.offset [$lct.cur_conf]
  s_name = "a_"+LoopTable.ObjectName[1] + "."
  display ribbon $s_name white
  color ribbon $LoopTable.1_Loop[i_LoopNumber]  red
  #center $LoopTable.1_Loop[i_LoopNumber]
  for i=1,Nof(LoopTable)
    if(Type(LOOP$i)=="table" & i_LoopNumber!=i) set property LOOP$i show off
  endfor
endmacro

macro cursorBrowseLoopsDoubleClick i_doubleClicked
  l_info=no
  l_commands=no
  if Type(LOOP$i_doubleClicked)=="unknown" return
  for i=1,Nof(LoopTable)
    if(Type(LOOP$i)=="table" & i!=i_doubleClicked) set property LOOP$i show off
  endfor
  set property LOOP$i_doubleClicked show
endmacro

macro cursorBrowseLoopConfs i_confNum s_tabName
  l_info=no
  l_commands=no
  if Type($s_tabName)=="unknown" return
  $s_tabName.cur_conf = i_confNum
#  keep $s_tabName
  s_lsel=$s_tabName.1_Loop
  build loop $s_lsel $s_tabName.offset [$s_tabName.cur_conf]
  s_name = "a_"+LoopTable.ObjectName[1] + "."
  display ribbon $s_name white
  color ribbon $s_lsel red
endmacro

macro cursorBrowseLoopConfs_1loop i_confNum s_tabName
  l_info=no
  l_commands=no
  if Type($s_tabName)=="unknown" return
  s_lsel=$s_tabName.1_Loop
  s_name = Field( $s_tabName.1_Loop, 1, "/" )
  build loop $s_lsel $s_tabName.offset [i_confNum]
  display ribbon $s_name white
  color ribbon $s_lsel red
endmacro

macro adjustLoopTables
  l_info=no
  l_commands=no
  if(Nof(Name(LoopTable)~"LoopTable.cursor")==0) then
     add header LoopTable "cursorBrowseLoops %#" name="cursor"
     add header LoopTable "cursorBrowseLoopsDoubleClick %#" name="doubleClick"
    set property LoopTable.doubleClick show off
#    keep LoopTable
  endif
  for i=1,Nof(LoopTable)
    tn="LOOP"+i
    if(Type($tn)=="table"& Nof(Name($tn)~"$tn.cursor")==0) then
       add header $tn 1 name="cur_conf"
       add header $tn LoopTable.1_Loop[i] name="1_Loop"
       add header $tn "cursorBrowseLoopConfs %# \"%@\"" name="cursor"
       set property $tn.cur_conf $tn.1_Loop $tn.cursor show off
       set property $tn show off
#      keep $tn
    endif
  endfor
endmacro

macro name2Mol s_molname ("octanol") l_min (yes)
  s_oldterms = Info(term)
  read string "http://webbook.nist.gov/cgi/cbook.cgi?Name="+s_molname+"&Units=CAL" # http ok R2017
  ist=Index(s_out,"CAS Registry Number:</strong> ")
  ien=ist+50
  s_cas=Split(String(ist,ien,s_out),"\n")[1]
  s_cas=Split(s_cas,">")[2]
  s_cas=Split(s_cas,"<")[1]
  s_cas=Replace(s_cas,"[- ]","")
  "CAS#"+s_cas
#read string "http://webbook.nist.gov/cgi/cbook.cgi/nist-3d.mol?Str2File=C"+s_cas
#mol3d=s_out
  read string "http://webbook.nist.gov/cgi/cbook.cgi/nist-2d.mol?Str2File=C"+s_cas
  mol2d=s_out
  read mol delete input=mol2d name=s_cas
  build hydrogen
  set type mmff
  set charge mmff
#keep mol3d, mol2d
  if(l_min) then
    if( Nof( mmff ) == 0) read library mmff s_icmhome+"mmff"
     electroMethod=1
     ffMethod=1
     set term "vw,14,hb,el,to"
     convert
     tolgrad=0.01
     minimize cartesian
  endif
  set term s_oldterms only
endmacro

macro refineLigandSphere auto rs_ligand r_effort (1.) r_sphere (6.) i_mode (2)
  HELP="""
    Action: restrained optimization of a ligand with flexible side chains
    Prerequisites: an approximately placed ligand in a converted ICM object.
    Arguments and Options:
     rs_ligand: selection of refined ligand, e.g. a_2.lig
     r_effort : (1.) sampling time factor. Scale it up for longer simulation.
     r_sphere : distance from the ligand to find movable side-chains
     i_mode   : 1 - local optimization
              : 2 - (default) global sampling
  """
  mn_pervar =Integer( 50*r_effort )
  s_oldterms = Info(term)
  sterms = "vw,14,hb,to,hb,ss,el,sf,bs,bb,af,ts"
  electroMethod = "distance dependent"
  surfaceMethod = "atomic solvation"
  autoSavePeriod = 0; s_skipMessages = "[66][67]"
  temperature = 700.
  vside = "v_//!phi*,psi*,omg,V"
  if(Type( Obj( rs_ligand )[1] 2) != "ICM") return error " Error_refineLigandSphere> object needs convertion"
  set object Obj( rs_ligand )[1]
  if(Nof(drestraint)>0) sterms += ",cn"
  if(Nof(tether    )>0) sterms += ",tz"
  set terms only sterms
  delete stack a_
  selectMinGrad = 1.5
  as_out = Res(Sphere( rs_ligand a_//!ca,ha,c,o,n,hn,cb & !rs_ligand r_sphere )) & a_//!ca,ha,c,o,n,hn,cb
  mncallsMC = 200 + (Nof(v_// & rs_ligand ) + Nof( $vside & Res( as_out ) )) * mn_pervar
  set vrestraint Res( as_out )
  ms_misc = Mol(as_out & a_H,M,W) # todo, add sampling of waters, cofactors, etc.
  set selftether ( rs_ligand | as_out ) & a_//!h*  only
  minimize (v_// & Mol(rs_ligand)) | ( $vside & as_out ) sterms  TOOLS.tsRmsdThreshold=0. TOOLS.tsWeight=10.
  store conf
  if(i_mode==1) then
    minimize v_//V & Mol(rs_ligand) | ( $vside & as_out )  sterms  TOOLS.tsRmsdThreshold=2.5 TOOLS.tsWeight=2.
    store conf
  elseif (i_mode == 2) then
    if(Nof(as_out & a_//DD )>0) display variable label  $vside & as_out | ( v_// & Mol(rs_ligand)) varLabelStyle=5
    pause 1; undisplay variable label
    set a_// & ! ( Res(Sphere(Res(as_out) a_ , 6. )) | Mol(rs_ligand)) off

    montecarlo ( $vside & as_out ) ( $vside & as_out | ( v_// & Mol(rs_ligand))) store TOOLS.tsRmsdThreshold=2.5 TOOLS.tsWeight=2.
  endif
  set a_// on
  delete selftether a_
  set term s_oldterms only
endmacro

macro refineModel i_nRegIter (5) l_sideChainRefinement (no)
  l_info = no
  tzWeight = 1.
  tzMethod="weighted"
  vwMethod=2
  b_old = Bfactor(a_//!vt*)
  print bar "Start refinement "
  if( Nof( a_//T ) == 0 ) then
    print " Warning> the model is NOT TETHERED. Copying to a_beforeRef. and tethering to it.."
    if( Nof(a_beforeRef.//*) != Nof( a_//* ) ) copy a_ "beforeRef"
    set tether only a_//!vt*,h* a_beforeRef.//!vt*,h*
  else
    if(Nof( a_//T ) < 0.2 * Nof( a_//!h* )) print " Warning> the number of tethers is too small"
    if l_info printf " Info> using %s. object as a template to which the model is tethered\n" Name(Obj(a_//Z))[1]
  endif
  bb = Bfactor( a_//!vt* )
  if( Min(bb) < 1. ) print " Warning> some b-factors are too small or negative. Review and reset"
  if( Mean(bb)< 5. & Rmsd(bb) < 1. ) set bfactor 20. a_//!vt*
  if l_sideChainRefinement then
     vs_ = v_//x* & a_//!T
     set vrestraint a_/*
     mncallsMC = Nof(vs_) * mncalls
     selectMinGrad = 1.5
     montecarlo fast vs_ mute
  endif
  if( i_nRegIter > 0 ) then
    s_header= "#_annealing : iter nMi  eVacuum       grad  tzWeight   Rmsd       vw      hb      to      ss     tz"
    sFormat = "#_annealing :%3d %3d %11.1f%11.1f%10.2f%7.2f %8.1f%8.1f%8.1f%8.1f%7.1f\n"
    s_terms1 = "vw,14,hb,to,ss"
    tzcalls = 2*Nof( a_/* )
    show energy mute s_terms1 + ",tz"
    ePrev=Energy(s_terms1)
    print "Initial energy: ",ePrev
    print s_header
    for iRegIter = 1, i_nRegIter  # use original B-factor to weight tethers
      show energy mute s_terms1 + ",tz"
      if( Energy(s_terms1) > 10. ) then               # is strained
        if(Energy("tz")>0.01) tzWeight = tzWeight*0.2*Energy(s_terms1)/Energy("tz")
        if (tzWeight < 1.) tzWeight = 1./(2.0 - tzWeight)  # 0.5 is the lowest
      else
        tzWeight = 0.5
      endif
      minimize tzcalls s_terms1 + ",tz"
      printf sFormat iRegIter,i_out,Energy(s_terms1),Gradient(),tzWeight,Srmsd(a_//T),Energy("vw"),Energy("hb"),Energy("to"),Energy("ss"),Energy("tz")/tzWeight
      if(Abs(Energy(s_terms1) - ePrev)< 0.5 | iRegIter==i_nRegIter) break
      ePrev = Energy(s_terms1)
    endfor
    if l_sideChainRefinement then  # use residue energies as B-factors for mc bfactor
       show energy   # optimize strained residues
       set bfactor a_/* Sqrt(Trim(Energy( a_/* ),4.,10000.))
       montecarlo fast bfactor vs_ mute
    endif
  endif
  set bfactor a_//!vt* b_old    # restore b-factors
endmacro

macro dsXyz M_3coor
   n_at = Nof(M_3coor)
   build string Sum(Sarray(n_at,"\nml ")+Sarray(n_at,"\nse o")) name="dots"
   set a_//o M_3coor [?,1:3]
   display ball blue
   if(Length(M_3coor)==4)color a_//o M_3coor [?,4] // Max(Abs(M_3coor[?,4]))//-Max(Abs(M_3coor[?,4]))
endmacro

macro clusterTableColumns S_cols l_reverse (no) auto
  l_commands = l_info = no

  s_tab   = Field(S_cols,1,".")[1]

  group table T_trasp Count(Nof(S_cols)) "N" S_cols "cols" Sarray(Nof(S_cols)) "ty"

  for i=1,Nof(T_trasp)
    s_col = T_trasp.cols[i]
    T_trasp.ty[i] = Type( $s_col )
  endfor

  delete T_trasp.ty != "iarray" & T_trasp.ty != "rarray"

  if (Nof(T_trasp)==0) return error "no numerical columns provided"

  S_cols = T_trasp.cols
  S_cols2 = Field(S_cols,2,".")

  dm = Distance(Transpose(Matrix($s_tab[S_cols2])))
  group table T_trasp append header dm "dm"
  make tree T_trasp distance = "dm"
  #
  for i=1,Nof(S_cols2)
    s_col = S_cols2[i]
    $s_tab.$s_col ["O"] = T_trasp.ord[i]
  endfor
  sort column $s_tab field="O" name=S_cols (!l_reverse ? : reverse) #l_info = yes
endmacro

macro clusterChemObjFiles s_inObjects ("*.ob") s_outObject ("clustered.ob")
  s_obnaex = s_inObjects
  if(Exist(s_outObject)) return error "Object already exists"
  if(Extension(s_obnaex)=="")s_obnaex = s_inObjects + ".ob"
  read sarray "obfina" sys $s_sysLst $s_obnaex
  nobOld1 = Nof( a_*. ) + 1
  for k=1,Nof(obfina)
    read object obfina[k]
  endfor
  keys = Iarray(3*(Nof( a_$nobOld1:999999. )) )
  for i=nobOld1, Nof( a_*. )
    make key a_$i.//*
    keys[3*i-2:3*i] = I_out
  endfor
  dd = Distance( keys keys 96 )
  dd = 1. - dd
  CL = Cluster( dd 0.3 )
  group table T_1 Count(Nof( a_$nobOld1:999999. ) ) "IX" CL
  for i=1, Nof( T_1 )
    if( T_1.CL[i] == 0 ) T_1.CL[i] = 999999
  endfor
  sort T_1.CL
  show T_1
  for i=1, Nof( T_1 )
    j = T_1.IX[i] + nobOld1-1
    set comment append  a_$j. " Cluster #" + T_1.CL[i]
    write object append s_outObject a_$j.
  endfor
endmacro

macro mergeTwoSetsByRow s_t1 s_t2 s_tres
   l_info = l_commands = no

   S_cols1 = Name( $s_t1 column name )
   S_cols2 = Name( $s_t2 column name )
   S_newcols = S_cols2[ Index( S_cols1 S_cols2 compare )["B"] ]

   empty = Iarray()

   for i=1,Nof( S_cols1 )
     s_col = S_cols1[i]
     add column T_tmp $s_t1.$s_col [ empty ] name = s_col
   endfor

   for i=1,Nof( S_newcols )
     s_col = S_newcols[i]
     add column T_tmp $s_t2.$s_col [ empty ] name = s_col
   endfor

  add T_tmp $s_t1
  add T_tmp $s_t2

  if (s_tres == s_t1) delete $s_t1
  if (s_tres == s_t2) delete $s_t2
  $s_tres = T_tmp

  keep global $s_tres
endmacro

macro mergeMultipleSetsByRow S_tabs s_tres l_removeMerged (no) auto
  if Nof(S_tabs) == 0 return error " Error> nothing to merge"
  $s_tres = $S_tabs[1]
  print bar "Merging tables" Nof(S_tabs) l_info = yes
  if Nof(S_tabs) > 1 then
    for i=2,Nof(S_tabs)
      mergeTwoSetsByRow s_tres S_tabs[i] s_tres
      print bar Nof(S_tabs) l_info = yes
    endfor
  endif
  print bar "End\n" l_info = yes
  keep global  $s_tres
  if (l_removeMerged) delete $S_tabs
endmacro

macro mergeObj s_os ( "a_1,2." ) s_name ("merged")
  os = s_os
  cp $os [1] s_name delete
  errorAction = "none"
  print Nof( $os )
  for i=2, Nof( $os )
    copy $os [i] "tm" delete
    print " moving object ",i
    move a_tm. a_$s_name.
  endfor
  set object a_$s_name.
endmacro

macro mergePdb rs_source ( a_1.1/20:25 ) rs_graft ( a_2.1/20:25 ) s_combo ("combo")
### Replaces a loop with "rs_graft" from another object
### "rs_source" should include residues flanking the loop to replace
### Also use it to "graft" a fragment to Cterm of the source molecule
  return error "UNFINISHED"
  if(Nof(rs_source)==0) return error " empty 1-st selection"
  if(Nof(rs_graft)==0) return error " empty 2-nd selection"
  set obj Obj(rs_source)
  s_tmp= Name(Mol(rs_graft))[1]     # remember mol2 chain name
  rename Mol(rs_graft) Name(Mol(rs_source))[1]  # rename mol2
  n1= Nof(Mol(rs_source))
  n2= Nof(Mol(rs_graft ))
  rsoinv = Obj( rs_source ) & ! rs_source # multiple chain
  if n1 != 1) return error "More than one chain selected"
  if n2 != 1) return error "More than one chain selected"
  noverlap = Nof(Sphere( isoinv , rs_graft, 0.1))
  if noverlap >=1 printf " Warning> %d overlapping atoms",noverlap
  if no return error "Non-matching source and graft number of loops"
  if( ?? ) return error "More than one chain selected"
  write pdb rs_before "combo.brk"
  write pdb append rs_graft "combo.brk"
  write pdb append rs_after "combo.brk"
  read pdb s_combo
  align number a_ 1
  rename Mol(rs_graft) s_tmp
endmacro

macro wrSeqAli ali_ s_file ("seq.fasta")
  l_showSstructure = no
  seqname = Name(ali_) # Name returns sarray of sequence names
  for i=1,Nof(seqname)
    write sequence fasta append $seqname[i] s_file
  endfor
endmacro

macro renumberResBySeq auto ms_ (a_1) &seq_ i_extraOffset (0)
HELP = """
  renumbers residues of the visible crystallographic construct according to the full
  sequence of the chains
  Example:
"""
  ms_ = Mol( ms_ & a_*.A  )
  for iml = 1, Nof( ms_ )
    make sequence ms_ [iml] name="tmpxseq"
    alignMethod = 2
    tmpxali = Align( tmpxseq , seq_ )
    tmpsid = Score( tmpxali identity )
    if(tmpsid<90.) printf " Warning_renumberResBySeq> chain '%s' seq.id to the sequence only %.1f %% \n", Name(ms_[iml] full)[1],tmpsid
    link ms_ [iml] tmpxali l_info=no
    if(tmpsid>50.) align number ms_ [iml] seq_ i_extraOffset
    delete tmpxseq l_warn=no
  endfor
  l_info=no
endmacro

macro renumberBySeqres ms_
HELP = """
  renumbers residues of the visible crystallographic construct according to the full
  sequence of the chains from SEQRES fields of PDB entries.
  Example:
"""
  l_info=no
  GRAPHICS.l_redraw=no
  ms_ = Mol( ms_ & a_*.A  )
  for iml = 1, Nof( ms_ )
    sname = Name( Replace(Replace( Name(ms_ [iml] full )[1], "a_","se"),".","") unique )
    make sequence ms_ [iml] name=sname
    aname = Name( Replace(Replace( Name(ms_ [iml] full )[1], "a_","al"),".","") unique )
    alignMethod = 2
    tmpseq = Sequence( Field( ms_ [iml] "_SEQ_" )[1] )
    if(Length(tmpseq)>= Length( $sname )) then
      $aname = Align( $sname ,tmpseq)
      link ms_ [iml] $aname
      tmpnum = Iarray( Res( ms_ [iml]) number)
      if( Min( tmpnum[2:$] - tmpnum[1:$-1] )< 0 ) set field ms_ [iml] & a_*./1000:1999 name="graft" # irregular numbering
      align number ms_ [iml] tmpseq
      assign sstructure ms_ [iml] l_warn = no
    endif
    delete $sname
  endfor
  GRAPHICS.l_redraw=yes
  display new
endmacro

#----------------------------------------------
macro icmPmfProfile os_ ( a_ ) l_accessibilityCorrection (yes) l_display ( no )
# uncorrected for accessibility.
  l_info=no
  res={"ala","arg","asn","asp","cys","gln","glu","gly","his","ile","leu","lys","met","mse","phe","pro","ser","thr","trp","tyr","val"}
  if !l_accessibilityCorrection  then
   A=Rarray(21)
   B={0.,-12.8,-5.8,-6.2,-10.6,-10.1,-6.7,-2.5,-16.2,-24.9,-25.0,-9.3,-20.3,-0.5,-40.9,-5.6,-4.6,-6.9,-49.1,-37.5,-17.8}
   sde={11.8,17.6,14.4,15.1,13.6,15.3,15.5,9.3,20.6,18.7,19.4,15.1,17.9,13.9,24.5,14.4,12.8,14.7,30.8,24.8,17.2}
  else
   A ={8.33,34.98,16.3,26.45,24.92,26.05,29.38,8.67,45.32,56.32,54.00,30.83,40.73,11.56,71.2,22.99,14.44,19.15,88.66,68.18,41.8}
   B ={-1.80,-26.24,-11.76,-16.10,-13.33,-19.82,-18.54,-5.18,-27.98,-30.74,-31.18,-24.94,-25.78,-1.96,-48.58,-14.01,-9.61,-12.43,-60.9,-48.,-22.9}
   sde ={11.61,15.3,13.74,13.48,13.47,13.93,13.81,8.9,17.42,16.37,17.0,13.31,15.90,13.75,21.47,12.88,12.08,13.85,26.91,21.58,15.4}
  endif
  mfMethod = 2
  vwCutoff = 9.5
  os_ = os_ [1]
  set object os_
  if(Nof(pmf)==0) read pmf s_icmhome+"ident.pmf"
  if( Type( a_ 2) != "ICM" ) return error " Error> a non-ICM object. Use: convertObject "
  n=Nof( a_A/A )
  if( n == 0 ) return error " Error> a non-peptide object type."
  show surface area a_A/A a_!W mute
  group table t Count(n) "i" Rarray(n) "ey" Area(a_A/A)/Area(a_A/A type) "ac" Name(a_A/A) "ty" Sarray(n) "na"
  printf " Info> Processing %d residues: ",n
  for i=1, n
     rsi = a_A/A [i]
     rena = Name(rsi)[1]
     t.na[i] = String(rsi)
     ire  = Index(res,rena[1:3])
     if ire==0 ire=1
     rsenv = a_!W & ! rsi
     show energy "mf" rsi rsenv mute
     e=(Energy("mf")-(t.ac[i]*A[ire]+B[ire]))/sde[ire]
     t.ey[i]=e
     if e >  2. c= "+"
     if e < -2. c= "-"
     if e <=2. & e >= -2. c="."
     printf c
  endfor
  printf "\n Info> Mean: %.1f Max: %.1f Min: %.1f N_badRes: %d. Results in table 't'.\n",Mean(t.ey), Max(t.ey),Min(t.ey),Nof(t.ey>3.)
  printf   " Info> To find the bad residues type: t.ey > 2.\n"
  printf   " Info> To display bad residues: color a_A/A Trim(t.ey,-3.,3.)//3.//-3. ribbon # or skin\n"
  keep t
endmacro
#:)
# Initialzation of Shell wariables used by Menue

#S_LoopString = {"No Loops loaded"}
#S_LoopVar = {"No Loops loaded"}

macro cursorFindByPatternRes i_num l_showAlignment
  l_info=no
  if(!Exist(s_xpdbDir+"mini/"+PDBSearchResults.IDS[i_num]+".ob")) return
  undisplay
  if (PDBSearchResults.NA2[i_num][1:4]==PDBSearchResults.IDS[i_num]) then
    s=Tolower(PDBSearchResults.NA2[i_num])
  else
    s=Tolower(PDBSearchResults.NA3[i_num])
  endif
  sel=s[Index(s,"_"):Length(s)]
  if(Length(sel)==1) sel="_m"
  sel="a_tempMiniObj"+Replace(sel,"_",".")

  read object delete name="tempMiniObj" s_xpdbDir+"mini/"+PDBSearchResults.IDS[i_num]

  if (Type(a_ 2 )!="Ca-trace") then
    display ribbon a_tempMiniObj. grey
    s= sel + "/\""+PDBSearchResults.Query +"\""
    color ribbon $s Count(1,PDBSearchResults.MX[i_num]-PDBSearchResults.MI[i_num])
    display cpk Mol( Sphere( $sel a_H ) )
    color cpk a_//c* grey
    color cpk a_//o* pink
    center $sel static
  else
    make bond chain a_//ca
    display
  endif
endmacro

macro cursorFindBySeqRes i_num l_showAlignment
  l_info=no
  l_commands=no
  if(!Exist(s_xpdbDir+"mini/"+PDBSearchResults.IDS[i_num]+".ob")) return
  undisplay
  if(Type(alitmp)=="alignment") delete alitmp

  if (PDBSearchResults.NA2[i_num][1:4]==PDBSearchResults.IDS[i_num]) then
    local_s=Tolower(PDBSearchResults.NA2[i_num])
  else
    local_s=Tolower(PDBSearchResults.NA3[i_num])
  endif
  local_sel=local_s[Index(local_s,"_"):Length(local_s)]
  if(Length(local_sel)==1) local_sel="_m"
  local_sel = Replace(local_sel,"_","")

  ibest = 1
  if(PDBSearchResults.RES[ibest] > 2.6 & Nof(PDBSearchResults)>1) ibest=2
  if(PDBSearchResults.RES[ibest] > 2.6 & Nof(PDBSearchResults)>2) ibest=3
  local_s=Tolower(PDBSearchResults.NA3[ibest])

  local_s=Tolower(PDBSearchResults.NA2[ibest])
  local_best=local_s[Index(local_s,"_"):Length(local_s)]
  if(Length(local_best)==1) local_best="_m"
  local_best="a_tempMiniOBJ"+Replace(local_best,"_",".")     # e.g. best = a_tempMiniOBJ.a
  local_best_file=s_xpdbDir+"mini/"+PDBSearchResults.IDS[ibest]+".ob"
  if !Exist(local_best_file) local_best_file=""
  if local_best_file!="" & PDBSearchResults.IDS[ibest] != Name(File( a_tempMiniOBJ. )) read object delete name="tempMiniOBJ" local_best_file

  read object delete name="tempMiniObj" s_xpdbDir+"mini/"+PDBSearchResults.IDS[i_num]

  # if molecular with name in 'local_sel' not presented in readed object
  # as last chanse let us take the first one
  obj_mols = Name(Mol(a_tempMiniObj.!W,H))
  if(Index(obj_mols,local_sel)==0 & Nof(obj_mols)>0)local_sel=obj_mols[1]

  local_sel="a_tempMiniObj."+local_sel
  if (Type(a_ 2 )!="Ca-trace" ) then
    if(local_best_file!="")superimpose $local_best $local_sel align
    display ribbon a_tempMiniObj. gray
    imx = PDBSearchResults.MX[i_num]
    if( imx==0 | Nof( $local_sel/* ) < imx ) then  # still wrong since it makes shifts
      local_s=""
    else
      local_s="["+PDBSearchResults.MI[i_num]+":"+PDBSearchResults.MX[i_num]+"]"
    endif
    color ribbon $local_sel/* $local_s
    display cpk Mol(Sphere( $local_sel a_H ))
    center as2_out static
  else
    make bond chain a_//ca
    display
  endif

  if(l_showAlignment & no) then
    local_cur_obj_seq = Name(File(a_tempMiniObj.))
    if(Length(local_cur_obj_seq)!=4) local_cur_obj_seq="local_cur_obj_seq"

    local_linked_seqs = Name( $local_sel sequence )
    if( Nof( local_linked_seqs ) > 0 ) then
      local_cur_obj_seq = local_linked_seqs[1]
    else
      global make sequence $local_sel name=local_cur_obj_seq
    endif

    local_ssss = PDBSearchResults.Query
    if( Type( $local_ssss ) != "sequence" ) then
      print "\n\n Error> Query sequence " + local_ssss + " is not found\n\n"
    else
      keep $local_cur_obj_seq
      alitmp = Align( $local_ssss $local_cur_obj_seq )
      #global group sequence alitmp $local_ssss $local_cur_obj_seq
      #align alitmp
      keep alitmp
    endif
  endif
endmacro

function PubchemStruct2Name P_mol s_result ("cid")    # cid/name/cas
  I_cid = Iarray(Nof(P_mol))
  S_cas = Sarray(Nof(P_mol))
  errorAction = "none"
  interruptAction = "break all loops"
  print bar "Fetching cids" Nof(S_cas) l_info = yes
  for i=1,Nof(P_mol)
    read json "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/" + String(Smiles(P_mol[i] unique)[1],html) + "/cids/JSON" name="result"
    print bar Nof(P_mol) l_info = yes
    if (Error()) continue
    if ( Exist( result "IdentifierList" ) & Nof(result["IdentifierList","CID"]) > 0 ) then
      I_cid[i] = result["IdentifierList","CID"][1]
      if (s_result == "name" | s_result == "cas") then
        read json "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + I_cid[i] + "/synonyms/JSON" name="result"
        if (!Error() & Exist( result "InformationList" )) then
          if (s_result == "cas") then
            cas = Match( result["InformationList","Information",1,"Synonym"], "[\\d]{2,10}-[\\d][\\d]-[\\d]" only )
          else
            cas = result["InformationList","Information",1,"Synonym"]
          endif
          if (Nof(cas)>0) S_cas[i] = cas[1]
        endif
      else
        S_cas[i] = String(I_cid[i])
      endif
    endif
  endfor
  print bar "End\n" l_info = yes
  return S_cas
endfunction

function PubchemName2Struct S_name
  P_mol = Chemical( Nof(S_name) )
  errorAction = "none"
  print bar "Fetching compounds" Nof(S_name) l_info = yes
  for i=1,Nof(S_name)
    print bar Nof(S_name) l_info = yes
    if (Trim(S_name[i]) == "") continue
    if (Length(Match(S_name[i],"^[\\d]+$")) > 0) then
      result = Collection( "IdentifierList", Collection( "CID", Iarray(1,Integer(S_name[i]))))
    elseif (Length(Match(S_name[i],"^[A-Z]{14,14}-[A-Z]{10,10}-[A-Z]$")) > 0) then
      read json "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/inchikey/" + String(Trim(S_name[i]),html) + "/cids/JSON" name="result"
    else
      S_ = Split( S_name[i], "\n")
      for j=1,Nof(S_)
        read json "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/" + String(Trim(S_[j]),html) + "/cids/JSON" name="result"
        if (Error()) continue
        if ( Exist( result "IdentifierList" ) & Nof(result["IdentifierList","CID"]) > 0 ) break
      endfor
    endif
    if ( Exist( result "IdentifierList" ) & Nof(result["IdentifierList","CID"]) > 0 ) then
      cid = result["IdentifierList","CID"][1]
      read table mol "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + String(String(cid),html) + "/SDF" name = "tmpmoltab"
      if (Error()) continue
      delete hydrogen tmpmoltab.mol
      P_mol[i] = tmpmoltab.mol[1]
    endif
  endfor
  print bar "End\n" l_info = yes
  return P_mol
endfunction

macro findEnamineRealBG s_what s_type ("sss") r_maxDist (0.5) i_maxHits (1000) auto
  l_commands = l_info = no

  s_script_name    =  Name( system s_tempDir + "fetchEnamineXXXX.icm" )
  s_script_output  =  Name( system s_tempDir + "fetchEnamineXXXX.sdf" )

  s_script = """
  c_out = Collection('smiles',':s_what','maxHits',:i_maxHits,'type',':s_type','maxDist',:r_maxDist)
  read table header separator=',' ':s_url?' + String(c_out html ) name='t' l_info = yes
  if (Nof(t)) then
     add column t Chemical(t.smiles) index=1
     write table mol t delete ':s_script_output'
  endif
  quit
"""

  s_script = Replace( s_script, ":s_url"//":s_what"//":i_maxHits"//":s_script_output"//":s_type"//":r_maxDist", TOOLS.gigaSearchUrl//s_what//String(i_maxHits)//s_script_output//s_type//String(r_maxDist)  )
  write string s_script s_script_name

  s_cmd = Path( origin, "-s" // s_script_name )
  sprintf "if (!Exist('%s')) Askg('No hits found','Ok',simple)\nif (Exist('%s')) read table mol '%s'\ndelete system '%s'\ndelete system '%s'" s_script_output, s_script_output, s_script_output, s_script_output, s_script_name

  make background s_cmd command=s_out
  print " Info> Enamine REAL search started in background. You will be notified when the job is complete."

endmacro

macro findPubchem s_what l_append (no) l_3d (no) i_maxHits (100) auto
  l_commands = no;  l_info = no

  if (!l_append) delete pubchem_hits l_warn = no

  if (s_what ~ "smiles:*") then
    s_tblnm = "pubchem_" + Formula(Chemical(s_what[8:$] smiles))[1]
  else
    s_tblnm = "pubchem_" + Name(s_what simple)
  endif

  if (Length(Match( s_what "^(\\d+\\s*)+$"))>0) then
    cids = Split( s_what, "\\s+" regexp )
  else
    if (s_what ~ "smiles:*") then
      s_what = s_what[8:$]
      read json "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/substructure/smiles/" + String(s_what,html) + "/JSON?MaxRecords="+i_maxHits name="result"
    else
      read json "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/" + String(s_what,html) + "/cids/JSON?MaxRecords="+i_maxHits name="result"
    endif

    if (Exist(result "Fault")) then
      s_message = result["Fault","Message"]
      return error s_message
    endif

    while ( Exist( result "Waiting" ) )
      pause 2
      read json "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/listkey/" + result["Waiting","ListKey"] + "/cids/JSON" name="result"
    endwhile

    if ( !Exist( result "IdentifierList" ) | Nof(result["IdentifierList","CID"]) == 0 ) return error "no hits found"

    cids = result["IdentifierList","CID"]
  endif

  xstep = 1
  print bar "Fetching compounds" Nof(cids)/xstep l_info = yes
  for xx=1,Min(Nof(cids),i_maxHits),xstep
    print bar Nof(cids)/xstep l_info = yes
    xs = cids[xx:Min(Nof(cids),xx+xstep-1)]
    read json "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + String(Sum(Sarray(xs) ","),html) + "/synonyms/JSON" name="syn"
    delete xtinfo l_warn = no
    if (i_out != 200) break
    add column xtinfo syn["InformationList","Information"] name="syn"

    read string "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + String(Sum(Sarray(xs) ","),html) + "/SDF" + (l_3d?"?record_type=3d":"") name = "tmpbuf"
    if (Index(tmpbuf,"PUGREST.NotFound") == 0) then
      read table mol input=tmpbuf name="xt"
    else
      read table mol "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + String(Sum(Sarray(xs) ","),html) + "/SDF" name = "xt"
      if (l_3d) then
        read binary object "http://mars.molsoft.com/cgi-bin/conv2d3d.cgi mol=" + String(String(xt.mol) html)
        xt.mol[1] = Chemical( a_ exact hydrogen )
        delete a_
      endif
    endif

    add column xt index=2  Sarray(Eval( xtinfo "syn.Synonym[1]" )) name="NAME_"
    rename xt.PUBCHEM_COMPOUND_CID "CID"
    add pubchem_hits xt
  endfor
  print bar "End\n" l_info = yes

  if (!l_3d) delete hydrogen pubchem_hits.mol

  set format pubchem_hits.CID "<a href=https://pubchem.ncbi.nlm.nih.gov/summary/summary.cgi?cid=%1>%1</a>"

  add column pubchem_hits pubchem_hits.CID name="Activity" index=3
  set format pubchem_hits.Activity """
  <!--icmscript name="1"
   read csv header 'https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/%1/assaysummary/CSV' name=Name('act_' + %@.NAME_[%#], simple)
   stabac = s_out
   scolum = stabac + ".Activity_Value_uM"
   R_out = Toreal( $scolum )
   delete $scolum
   add column $stabac R_out name='Activity_Value_uM' index=10
   add column $stabac (-Log(R_out,10)+6) name='pAct' index=11
   sort $stabac.pAct reverse
   set format $stabac.pAct color="rainbow='#FFFFFF/#FFFF00/#FF0000/magenta,5.:10.,pinwheel'"
   delete column $stabac 2 6
--><a href=#_>Activities</a>
"""
  delete column pubchem_hits 5 99999
  if (l_3d) set property display pubchem_hits

  if (Nof($s_tblnm)!=0) delete $s_tblnm
  rename pubchem_hits s_tblnm
  keep $s_tblnm global

endmacro


#ifdef Product >= bio

macro fixBlastGiSeqNames
  sna = Name(sequence) ~ "gi_*"
  for i=1,Nof(sna)
    ssena1 = sna[i]
    nafd = Split(ssena1,"_")
    nfd = Nof(nafd)
    if(nfd>3&Tolower(nafd[3])=="pdb") then
      ssena2 = Tolower(Sum(nafd[3:$],"_"))
    else
      ssena2 = (nfd>4)? Sum(nafd[4:$],"_") : ssena1
    endif
    rename $ssena1 Name(ssena2, unique)
  endfor
endmacro

macro loadAlignmentBlast P_entry
  l_info = l_commands = no
  s_ali = ">" + P_entry["Hit_id"] + "\n"
  s_ali += Sarray(P_entry["Hit_hsps","Hsp","Hsp_hseq"])[1] + "\n"
  s_ali += ">qseq\n"
  s_ali += Sarray(P_entry["Hit_hsps","Hsp","Hsp_qseq"])[1] + "\n"
  s_aliname = "ali_" + P_entry["Hit_num"]
  read alignment fasta input=s_ali name=s_aliname
  keep $s_aliname global
endmacro

macro loadSequenceBlast s_accession
  l_commands = l_info = no
  if Length(Match(s_accession,"^P\\d+")) then  # fix to "^[OPQ][0-9][A-Z0-9]{3}[0-9]|[A-NR-Z][0-9]([A-Z][A-Z0-9]{2}[0-9]){1,2}"  ?
    read sequence swiss "http://www.uniprot.org/uniprot/" + s_accession + ".txt" # ok17
  else
    read sequence fasta "https://www.ncbi.nlm.nih.gov/sviewer/viewer.fcgi?sendto=on&dopt=fasta&val=" + s_accession
    fixBlastGiSeqNames
  endif
  keep sequence
endmacro

macro findHomology s_what s_type l_split l_loadSequences (no) l_fast (no) l_append (no)
  l_commands=no  # 144 lines of KS code.
  l_info=no
  l_warn=no
  if (Exist(s_inxDir+"PDB.tab") | Exist(s_userDir+"inx/PDB.tab")) then
    if (Exist(s_userDir+"inx/PDB.tab") & Type(PDBIDX)=="unknown") then
      read table s_userDir+"inx/PDB.tab" name="PDBIDX"
      set property PDBIDX show edit delete write off
      print " Info> PDB index loaded from "+s_userDir+"inx/PDB.tab"
    keep PDBIDX
    else
      if ( Exist(s_inxDir+"PDB.tab") & Type(PDBIDX)=="unknown" ) then
        read table s_inxDir+"PDB.tab" name="PDBIDX"
        set property PDBIDX show edit delete write off
        print " Info> PDB index loaded from "+s_inxDir+"PDB.tab"
        keep PDBIDX
      endif
    endif
  endif
  if(s_type=="")s_type="type"

  if (Type( $s_what ) == "unknown" &  Length(Match( s_what "^[GPAVLIMCFYWHKRQNEDST]+$" )) != 0) then
    seq_tmp = Sequence( s_what )
    s_what = "seq_tmp"
  endif

  if(Type( $s_what ) =="sequence") then
    if(Exist(s_userDir+"blastdb/pdbseq.psq"))then
      s_blast_pdb_db=s_userDir+"blastdb/pdbseq"
    else
      if(Exist(s_blastdbDir+"pdbseq.psq"))then
        s_blast_pdb_db=s_blastdbDir+"pdbseq"
      else
        Alert "pdbseq DB not found. Try update PDB Blast Index ..."
        return
      endif
    endif
    printf " Info_findHomology> searching in '%s'* \n", s_blast_pdb_db
    l_caseSensitivity=no
    if (Type(r_expect_r)=="unknown") r_expect_r = 0.01
    r_pr=r_expect_r/(File(s_blast_pdb_db+".pin","length")/8-8)
    print " Info> r_probabilityThreshold="+r_pr
    if(Nof(gapFunction)>2) gapFunction=gapFunction[1:2]
    if(!l_append & Type(PDBSearchResults)!="unknown") delete PDBSearchResults
    if( l_append & Type(PDBSearchResults)=="unknown") l_append = no
    if l_fast then
      l_loadSequences=no
      find database fast=90 $s_what s_blast_pdb_db margin=Integer(Length($s_what)/5) $s_type name="PDBSearchResults"
    else
      l_warn = yes
      find database $s_type delete $s_what s_blast_pdb_db name="PDBSearchResults" r_pr
      l_warn = no
    endif
    if(Type(PDBSearchResults)=="table") then
      delete S_NA3 s_IDS S_DE1 s j
      S_NA3=Field(PDBSearchResults.DE,1," ")
      S_IDS=PDBSearchResults.NA2
      S_DE1=Sarray(Nof(PDBSearchResults))
      for i=1,Nof(PDBSearchResults)
        S_IDS[i]=S_IDS[i][1:4]
        s=PDBSearchResults.DE[i]
        j=Index(s," length:")
        if(j>0) then
          j=Index(s," ",j)
          if(j>0&j<Length(s)) S_DE1[i]=Trim(s[j:Length(s)] all)
        endif
      endfor
      group table append PDBSearchResults S_NA3 "NA3" S_IDS "IDS" S_DE1 "DE2"
      move PDBSearchResults.DE2 3
      move PDBSearchResults.Ident 4
# create actions.

# split identical entries to separate lines
      if (l_split) then
        delete PDBSearchResults.doubleClick nas denof s a b names codes tmp_pdbsr i j l
        split PDBSearchResults
        nas=Split(s_out)
        denof=Nof(DE)
        for i=1,denof
          s=DE[i]
          if(s[1]=="[" & Index(s,"] ")>0) then
            a=Split(s," ")[1]
            b=a[2:Length(a)-1]
            names=Split(b,";")
            codes=Split(b,";")
            for j=1,Nof(names)
              if(names[j][1]=="^" & Length(names[j])>1) names[j]=names[j][2:Length(names[j])]
              if(codes[j][1]=="^" & Length(codes[j])>1) codes[j]=codes[j][2:Length(codes[j])]
              if(Length(codes[j])>4) codes[j]=codes[j][1:4]
            endfor
            for j=1,Nof(names)
              tmp_pdbsr=(PDBIDX.ID==codes[j])
              for l=1,Nof(nas)
                if (nas[l]=="IDS") then
                  $nas[l]=$nas[l]//codes[j]
                elseif (nas[l]=="DE1" & Nof(tmp_pdbsr)==1) then
                  $nas[l]=$nas[l]//tmp_pdbsr.head[1]
                elseif (nas[l]=="NA2") then
                  $nas[l]=$nas[l]//names[j]
                elseif (nas[l]=="NA3") then
                  $nas[l]=$nas[l]//names[j]
                elseif (nas[l]=="MI"|nas[l]=="MX") then
                  # $nas[l]=$nas[l]//0
                  $nas[l]=$nas[l]//$nas[l][i]
                else
                  $nas[l]=$nas[l]//$nas[l][i]
                endif
              endfor
            endfor
          endif
        endfor
        group table PDBSearchResults $nas[1] nas[1]
        for i=2,Nof(nas)
          group table append PDBSearchResults $nas[i] nas[i]
        endfor
      endif
      S_colFmt = { "IDS;<a href=\"http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=%s\">%s</a>" "pP;%.1f" "SC;%.1f" "Ident;%.1f"  "LMIN;%d" "LN;%.2f" "H;%.2f" "DE1;%s" "DE;%s" "NA1;%s" "NA2;%s" "QMI;%d" "QMX;%d" "MI;%d" "MX;%d" "NA3;%s"}
      if(l_fast) S_colFmt = { "IDS;<a href=\"http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=%s\">%s</a>" \
                              "NA2;%s" "Ident;%.1f" "LMIN;%d" "LN;%.2f" "H;%.2f" "DE1;%s" "DE;%s" "NA1;%s" \
                              "QMI;%d" "QMX;%d" "MI;%d" "MX;%d" "NA3;%s"}
      if(Type( PDBIDX ) =="table") then
        restab=(PDBIDX.ID==PDBSearchResults.IDS)
        R_RES=Rarray(Nof(PDBSearchResults))
        S_EXP=Sarray(Nof(PDBSearchResults))
        S_HET=Sarray(Nof(PDBSearchResults))
        group table append PDBSearchResults R_RES "RES" S_EXP "EXP" S_HET "HET"
        # change column format with new data
        S_colFmt = {"IDS;<a href=\"http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=%s\">%s</a>" "pP;%.1f" "SC;%.1f" "Ident;%.1f"  "LMIN;%d" "LN;%.1f" "H;%.2f" "RES;%.1f" "EXP;%s" "HET;%s" "DE1;%s" "DE;%s" "NA1;%s" "NA2;%s" "QMI;%d" "QMX;%d" "MI;%d" "MX;%d" "NA3;%s"}
        if(l_fast) S_colFmt = {"IDS;<a href=\"http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=%s\">%s</a>" \
                               "NA2;%s" "Ident;%.1f"  "LMIN;%d" "LN;%.1f" "H;%.2f" "RES;%.1f" "EXP;%s" "HET;%s" \
                               "DE1;%s" "DE;%s" "NA1;%s" "QMI;%d" "QMX;%d" "MI;%d" "MX;%d" "NA3;%s"}
        for i=1,Nof(PDBSearchResults)
          l=Index(restab.ID,PDBSearchResults.IDS[i])
          if(l>0) then
            PDBSearchResults.RES[i]=Real(restab.res[l])
            PDBSearchResults.EXP[i]=restab.exp[l]
            PDBSearchResults.HET[i]=restab.het[l]
          endif
        endfor
      endif
      group table PDBSearchResults append header String(s_what) "Query" \
         S_colFmt                                  "columnFormat" \
         "PDB Search results for '<b>" + s_what + "</b>'" "tableTitle" \
         "cursorFindBySeqRes %# yes"               "cursor" \
         yes                                       "separateTab"
      set property  show off
      set property  PDBSearchResults write  # otherwise 'write off' is inherited from PDBIDX
      PDBSearchResults.doubleClick = "nice \"%IDS\" no no no no\ndelete a_*MiniObj."
      PDBSearchResults.Query = s_what
      HDR_PROP_OFF
      delete PDBSearchResults.NA3 # delete RA: NA3 is the 1st field of DE, did not make any sense. Need to rewrite the whole monstrosity. Looks like Kostya gadil.
      keep PDBSearchResults
    endif
  endif
endmacro

macro findSequence s_what s_type l_split l_append (no)
  l_info=no
  if (Exist(s_inxDir+"PDB.tab") | Exist(s_userDir+"inx/PDB.tab")) then
    if (Exist(s_userDir+"inx/PDB.tab") & Type(PDBIDX)=="unknown") then
      read table s_userDir+"inx/PDB.tab" name="PDBIDX"
      set property PDBIDX show edit delete write off
      print " Info> PDB index loaded from "+s_userDir+"inx/PDB.tab"
      keep PDBIDX
    else
      if ( Exist(s_inxDir+"PDB.tab") & Type(PDBIDX)=="unknown" ) then
        read table s_inxDir+"PDB.tab" name="PDBIDX"
        set property PDBIDX show edit delete write off
        print " Info> PDB index loaded from "+s_inxDir+"PDB.tab"
        keep PDBIDX
      endif
    endif
  endif
  if(s_type=="")s_type="protein"
  s_what = Trim(s_what all)
  if( Length(s_what)!=0 ) then
    if(Exist(s_userDir+"blastdb/pdbseq.psq"))then
      s_blast_pdb_db=s_userDir+"blastdb/pdbseq"
    else
      if(Exist(s_blastdbDir+"pdbseq.psq"))then
        s_blast_pdb_db=s_blastdbDir+"pdbseq"
      else
        Alert "pdbseq DB not found. Try update PDB Blast Index ..."
        return
      endif
    endif
    l_caseSensitivity=no
    mnSolutions=Nof(PDBIDX)
    seq_pattern = s_what
    find database delete $s_type pattern=seq_pattern s_blast_pdb_db output=s_tempDir+"pdbseq"
    nHits = i_out
    if(!l_append & Type(PDBSearchResults)!="unknown") delete PDBSearchResults
    if( l_append & Type(PDBSearchResults)=="unknown") l_append = no
    if (nHits>0 & Exist(s_tempDir+"pdbseq.tab")) then
      read table s_tempDir+"pdbseq.tab" name="PDBSearchResults"
      if(Type( PDBSearchResults ) =="table" & Nof(PDBSearchResults)>0) then
        S_NA3=Field(PDBSearchResults.DE,1," ")
        S_IDS=PDBSearchResults.NA2   #Field(PDBSearchResults.DE,1," ")
        S_DE1=Sarray(Nof(PDBSearchResults))
        for i=1,Nof(PDBSearchResults)
          S_IDS[i]=S_IDS[i][1:4]
          s=PDBSearchResults.DE[i]
          j=Index(s," length:")
          if(j>0) then
            j=Index(s," ",j)
            if(j>0&j<Length(s)) S_DE1[i]=Trim(s[j:Length(s)] all)
          endif
        endfor
        group table append PDBSearchResults Sarray(S_NA3) "NA3" Sarray(S_IDS) "IDS" Sarray(S_DE1) "DE1"

# split identical entries to separate lines
        if (l_split) then
          split PDBSearchResults
          nas=Split(s_out)
          thesame=Sarray(Nof($nas[1]))
          denof=Nof(DE)
          for i=1,denof
            s=DE[i]
            iFrom=Index(s,"[")
            iTo  =Index(s,"] ")
            if(iFrom>0 & iTo > iFrom+3) then
              b=s[iFrom+1:iTo-1]
              names=Split(b,";")
              codes=names
              for j=1,Nof(names)
                if(names[j][1]=="^" & Length(names[j])>1) names[j]=names[j][2:Length(names[j])]
                if(codes[j][1]=="^" & Length(codes[j])>1) codes[j]=codes[j][2:Length(codes[j])]
                if(Length(codes[j])>4) codes[j]=codes[j][1:4]
              endfor
              for j=1,Nof(names)
                tt=(PDBIDX.ID==codes[j])
                for l=1,Nof(nas)
                  if (nas[l]=="IDS") then
                    $nas[l]=$nas[l]//codes[j]
                  elseif (nas[l]=="DE1" & Nof(tt)==1) then
                    $nas[l]=$nas[l]//tt.head[1]
                  elseif (nas[l]=="NA3") then
                    $nas[l]=$nas[l]//names[j]
                  elseif (nas[l]=="MI"|nas[l]=="MX") then
                    $nas[l]=$nas[l]//0
                  else
                    $nas[l]=$nas[l]//$nas[l][i]
                  endif
                endfor
              endfor
            endif
          endfor
          group table PDBSearchResults $nas[1] nas[1]
          for i=2,Nof(nas)
            group table append PDBSearchResults $nas[i] nas[i]
          endfor
        endif

        if(Type( PDBIDX ) =="table") then
          restab=(PDBIDX.ID==PDBSearchResults.IDS)
          R_RES=Rarray(Nof(PDBSearchResults))
          S_EXP=Sarray(Nof(PDBSearchResults))
          S_HET=Sarray(Nof(PDBSearchResults))
          group table append PDBSearchResults R_RES "RES" S_EXP "EXP" S_HET "HET"
          for i=1,Nof(PDBSearchResults)
            l=Index(restab.ID,PDBSearchResults.IDS[i])
            if(l>0) then
              PDBSearchResults.RES[i]=Real(restab.res[l])
              PDBSearchResults.EXP[i]=restab.exp[l]
              PDBSearchResults.HET[i]=restab.het[l]
            endif
          endfor
        endif
        group table PDBSearchResults header append String(s_what) "Query"
# S_colFmt "columnFormat"
        group table PDBSearchResults header append "PDB Search results for '<b>" + s_what + "</b>'" "tableTitle" "nice \"%IDS\" no no no no\ndelete a_*MiniObj." "doubleClick" "cursorFindByPatternRes %# no" "cursor" yes "separateTab"
        HDR_PROP_OFF
        set property  PDBSearchResults write  # otherwise 'write off' is inherited from PDBIDX
        keep PDBSearchResults
      endif
    endif
    s_file = s_tempDir + "/pdbseq.*"
    sys $s_sysRm $s_file

  endif
endmacro

#endif

#macro cursorFindPDB i_num
#  l_info=no
#  if !Exist(s_xpdbDir+"mini/"+PDBSearchResults.ID[i_num]+".ob") return
#  undisplay
#  read object delete name="tempMiniObj" s_xpdbDir+"mini/"+PDBSearchResults.ID[i_num]
#  cool a_tempMiniObj. 1
#  l_confirm=no
#  delete grob "xpdbmini_*"
#  GRAPHICS.quality = 2
#  s_out = "xpdbmini_" + PDBSearchResults.ID[i_num]
#  global make grob image name=s_out
#  display $s_out smooth
#  delete a_tempMiniObj.
#endmacro

macro cursorFindPDB i_num s_tableName
  l_info=no
  if !Exist(s_xpdbDir+"mini/"+ $s_tableName.ID [i_num] +".ob") return
  undisplay
  read object delete name="tempMiniObj" s_xpdbDir+"mini/"+ $s_tableName.ID [i_num]
  comboDisplayStyle = "ribbon+cpk"
  cool a_tempMiniObj. no
endmacro

macro findPocketome s_what s_where ("proteinname") auto
  l_commands = l_info = no
  #read string "http://pocketome.org/index.cgi " + "searchType=" + s_where + "&searchTerm=" + String(s_what,html) + "&act=Go"  name="s_res"
  #read table separator="|" header "http://pocketome.ucsd.edu/index.cgi " + "searchType=" + s_where + "&searchTerm=" + String(s_what,html) + "&act=Go&format=plain"  name="POCKETOME_HITS"
  read table separator="|" header "http://ablab.ucsd.edu/pocketome/index.cgi " + "searchType=" + s_where + "&searchTerm=" + String(s_what,html) + "&act=Go&format=plain"  name="POCKETOME_HITS"

  #
  #entryLinkID      =  Match( all s_res '<p class="entryLinkID">(.*?)</p>' 1)
  #entryLinkDetails =  Match( all s_res '<p class="entryLinkDetails">(.*?)</p>' 1)
  #
  #entryLinkID = Replace( entryLinkID, 'target="_blank"' "" simple )
  #files = Match( entryLinkID, '<a href="files/(.*?)"' 1)
  #entryLinkID = Replace( entryLinkID, "<a href=\"files/" "<a href=\"http://pocketome.org/files/" simple )
  #
  #files = Name( files ) + ".icb"
  #
  #group table POCKETOME_HITS entryLinkID "Entry" files "ICB" entryLinkDetails "Details"

  rename POCKETOME_HITS.id "Entry"
  add column POCKETOME_HITS POCKETOME_HITS.Entry + ".icb" name="ICB" index=2

  set format 30 POCKETOME_HITS.ICB """<!--icmscript name="1"
  make background simple Path(origin,"http://ablab.ucsd.edu/pocketome/icb/%1")
--><a href=#_>View</a>
  """
  add header POCKETOME_HITS name="doubleClick" "openFile \"http://ablab.ucsd.edu/pocketome/icb/\" + " + "%@.ICB[%#]\ndelete ENTRY"
  set label POCKETOME_HITS 0 size=60 # row height

  keep POCKETOME_HITS
endmacro

macro findICB s_what s_db ("") auto
# s_what - space separated search terms [field:]word  (field: is optional name
# of the field. Possible field values are:
#     - file    : filename
#     - objdesc : object description Namex(a_)
#     - objname : object name
#     - moldesc : Namex( Mol(a_) )
#     - html    : html document
#     - table   : text columns from tables
#     - smiles  : chemical substruture search
#
#  findICB "smiles:C(C=NC(C(N)=O)=C1)=N1 kinase"
#

  l_commands = l_info = l_warn = no

  #connect molcart "icbindex" off
  if (s_db == "") s_db = s_userDir + "icbindex.molt"

  if (!Exist(s_db)) then
    s_cmd = Path( origin s_icmhome + "mkicbindex.icm" )
    printf " Info> to create an ICB index file run\n\t%s <dir1> <dir2> ..\n", s_cmd
    return error  " Error> Cannot find ICB index file " + s_db;
  endif


  connect molcart filename=s_db

  delete ICBHits

  S_words = Split( s_what, "\\s+" regexp )

  S_chemWords = Sarray()
  S_fieldTextWords = Sarray()
  S_textWords = Sarray()
  #
  for i=1,Nof( S_words )
    if (Field( S_words[i], 1, ":" ) == "smiles") then
      S_chemWords //= Field( S_words[i], 2, ":" )
    elseif Index(  S_words[i], ":" ) != 0 | S_words[i][1] == "*" then
      S_fieldTextWords //= S_words[i]
    else
      S_textWords //= S_words[i]
    endif
  endfor
  #
  delete t t1 l_warn = no
  if Nof(S_chemWords)>0 then
    find molcart table="docschem" sstructure Chemical(S_chemWords) name="t1" field="docschem.*" l_info = yes
    if (Nof(t1) == 0) return
    t = t1
    #print Sum(S_chemWords), Nof(t);
  endif
  #
  S_hightLightWords = Sarray()
  if Nof(S_fieldTextWords)>0|Nof(S_textWords)>0 then
    ids = Iarray()

    if (Nof(S_textWords)>0) then
      s_what = Sum(S_textWords," ")
      query molcart "select rowid from docstext where docstext.rowid in (select docid from docstext_fullts where docstext_fullts MATCH :s_what )" name="tmp"
      if Nof(tmp) > 0 then
        ids = tmp.rowid
        S_hightLightWords //= S_textWords
      endif
    endif

    if (Nof(S_textWords)==0 | Nof(ids)>0 ) then
      for i=1,Nof(S_fieldTextWords)
        s_what = S_fieldTextWords[i]
        s_what =  Field( S_words[i], 2, ":" )
        s_field = Field( S_words[i], 1, ":" )
        if (s_what == "") then
          s_what = s_field
          s_field = ""
        endif

        if (s_what[1] == "*") then
          s_what = Replace( s_what, "*", "%" simple )
          if (s_field != "") then
            query molcart "select rowid from docstext where field_text LIKE :s_what and field_type = :s_field" name="tmp"
          else
            query molcart "select rowid from docstext where field_text LIKE :s_what" name="tmp"
          endif
        else
          if (s_field != "") then
            query molcart "select rowid from docstext where docstext.rowid in (select docid from docstext_fullts where docstext_fullts MATCH :s_what ) and field_type = :s_field" name="tmp"
          else
            query molcart "select rowid from docstext where docstext.rowid in (select docid from docstext_fullts where docstext_fullts MATCH :s_what )" name="tmp"
          endif
        endif

        if (Nof(tmp)==0) break

        S_hightLightWords //= s_what

        if (i==1 & Nof(S_textWords)==0) then
          ids = tmp.rowid
        else
          ids = ids[ Index( ids, tmp.rowid compare )["AB"] ]
        endif
        if (Nof(ids) == 0) break
      endfor
    endif
    print s_what, Nof(ids)
    query molcart "select docid,field_type,field_name,field_text from docstext where rowid in :ids " name="t2"
    if ( Nof(S_chemWords)>0 ) then
      cc = Index( t1.docid, t2.docid compare )
      t = t1[ cc["AB"] ]
      add column t Sarray(Nof(t)) name="field_text" index=2
      add t t2[ cc["BA"] ]
    else
      t = t2
    endif
  endif
  #
  docIds = t.docid
  query molcart "select id,rootpath||filename as filename,modified from docs where id in :docIds" name="ICBHits"
  join t.docid ICBHits.id  name="ICBHits"
  add column ICBHits ICBHits.field_type + ":" + ICBHits.field_name name="field"
  delete ICBHits.field_type ICBHits.field_name ICBHits.molid
  s_regExp = "(?i)(" + Sum(S_hightLightWords,"|") + ")"
  if Type(  ICBHits.field_text ) == "sarray" then
    ICBHits.field_text = Replace( Trim( ICBHits.field_text, s_regExp, 100, ".." ) s_regExp, "<b>\\1</b>" regexp )
    group ICBHits.docid ICBHits.field "unique," ICBHits.field_text "unique," all "first"  name="ICBHits"
  else
    group ICBHits.docid ICBHits.field "unique," all "first"  name="ICBHits"
  endif
  set format ICBHits.filename "<!--icmscript name=\"1\"\nmake background simple Path(macro,\"%1\")\n--><a href=#_>%1</a>"
  #
  nof_docs = Sql("select count(id) as n from docs").n
  printf " Info> %d documents searched. %d hits found\n", nof_docs[1], Nof(ICBHits)
  #
  connect molcart off
  keep global ICBHits
endmacro

macro findPDB_db s_db s_what ("") s_het ("") l_oneHitDisplay (no) l_append (no) l_advancedSyntax (no) auto
#
  S_hetIon   =  { "cl" "ca" "na" "k" "zn" "fe" "po4" "so4"  }
  S_hetSug   =  { "nag" "man" "bma" "fuc" }
  S_hetCrysta = { "bme" "dms" "eoh" "edo" "epe" "gol" "mes" "peg" "po4" "so4" }
#
  l_info=no
  l_commands=no
  errorAction = 1

  if (Length(Match(s_what,"^[\\w\\d+]:"))>0) l_advancedSyntax = yes

  s_chemType = "sstructure"
  if (s_what ~ "smiles:*") then
    icSmiles = yes
    s_what = s_what[8:$];
  elseif (s_what ~ "smilessim:*") then
    icSmiles = yes
    s_what = s_what[8+3:$];
    s_chemType = "similarity 0.5"
  elseif (s_what ~ "smilesexact:*") then
    icSmiles = yes
    s_what = s_what[8+5:$];
    s_chemType = "exact"
  else
    icSmiles = Length(s_what)>4 & Nof(Index( Sarray(1,s_what) smiles problem ))==0 & Nof(Chemical(s_what),atom)[1] > 0
  endif

  connect molcart filename=s_db

  if (icSmiles & !Exist( "PDBLIG" sql table )) then
    return error "PDB ligand table 'PDBLIG' does not exist. Run: \n\tmakeIndexPdb \"\" yes"
    connect molcart off
  endif

  delete tmp tmplig l_warn=no
  if (!l_append) delete PDBSearchResults l_warn=no

  if (icSmiles) then
     find molcart table="PDBLIG" $s_chemType s_what number=100000 name="tmplig" field="PDBLIG.HETID,PDBLIG.mol" l_info = yes
     if (Nof(tmplig) > 0) then
       tmplig.HETID = Tolower(tmplig.HETID)
       query molcart "select PDBLIG.HETID,PDBLIG.mol,PDBIDX.* from PDBIDX,PDB2HET,PDBLIG where PDBIDX.PDBID=PDB2HET.PDBID and PDB2HET.HETID = PDBLIG.HETID and PDBLIG.HETID in :tmplig.HETID"  name="tmp"
     endif
  else
    if (s_what != "") then
    # PDBID,head,date,title,source,auth,exp,res,het,swiss
      if (s_what ~ "PDBID:*") then
        S_out = Tolower(Split( s_what[7:$], "\\W+" regexp ))
        query molcart "select * from PDBIDX where PDBID in :S_out" name="tmp"
      else
        if (!l_advancedSyntax & Length(s_what)!=4 ) then
          S_out = Split(Trim(s_what,all),"[ ]+",regexp)
          s_what = Sum(Sarray( Nof(S_out), "\"" ) + S_out + "\""," ")
        endif
        query molcart "select * from PDBIDX where rowid in (select rowid from PDBIDX_fullts where PDBIDX_fullts MATCH '" + s_what + "')" name="tmp"
      endif
    else
      find molcart table="PDBIDX" query=" t.het LIKE '%" + s_het + "%'  " number=10000 name="tmp" field="PDBIDX.*"
    endif
    group table "tmplig"  Split( Sum( tmp.het ";" )  ";" ) "HETID"
    delete tmplig.HETID == ""
    if(Nof(tmplig) > 0)then
      query molcart "select PDBLIG.HETID,PDBLIG.mol from PDBLIG where PDBLIG.HETID in :tmplig.HETID"  name="tmphet"
      add column tmp Chemical(Nof(tmp)) name="mol"
      for i = 1 Nof(tmp)
        het1 = tmphet.HETID == Split( tmp.het [i] ";" )
        if(Nof(het1)>0)then
          sort het1.mol reverse
          tmp.mol[i] = het1.mol[1]
        endif
      endfor
    endif
  endif

  connect molcart off

  if (Nof(tmp) == 0) then
    if (!icSmiles & Length(s_what)==4) then
      nice s_what no no no no
      return
    endif
    PopMessage "No hits found in the local PDB header database.\n Refresh via Edit/PDB Search/Update menu"
    return
  endif

  delete tmp.id
  rename tmp.PDBID "ID"

  if (l_oneHitDisplay & Nof(tmp) == 1 & !icSmiles & Length(s_what)==4) then
    nice tmp.ID[1] no no no no
    return
  endif

  if (Type(tmp.date) == "sarray") then
    rename tmp.date "tmp"
    add column tmp Date( tmp.tmp, "%m/%d/%y" ) name="date" index=4
    delete tmp.tmp
  endif

  s_doubleClick = "nice %@.ID[%#] no no no no"
  if (icSmiles) then
    if (s_chemType != "similarity") s_doubleClick += "\nhighlightLigandBySubstructure a_H,M '" + s_what + "'"
    add column tmp Distance( tmp.mol Chemical( s_what ) )[?,1] name="dist"
    sort tmp.dist
  endif

  if (!l_append | Nof(PDBSearchResults) == 0) then
    PDBSearchResults = tmp
  else
    add PDBSearchResults tmp
  endif
  move PDBSearchResults.head index=10
  move PDBSearchResults.exp index=4
  move PDBSearchResults.res index=5
  move PDBSearchResults.het index=6
  move PDBSearchResults.swiss index=7
  move PDBSearchResults.ID index=1
  move PDBSearchResults.exp index=2
  move PDBSearchResults.res index=3

  add header PDBSearchResults s_doubleClick, name="doubleClick"
  set format PDBSearchResults.ID "<a href=http://www.rcsb.org/pdb/explore/explore.do?structureId=%1>%1</a>"
  set format PDBSearchResults.swiss "<a href=http://www.uniprot.org/uniprot/%1>%1</a>"

  keep PDBSearchResults global

endmacro
#
macro highlightLigandBySubstructure as_obj s_smiles
 l_commands = l_info = no
 find chemical as_obj s_smiles
 if (Nof(as_out)>0) then
    center static Mol( as_out )[1] margin=5.
    display xstick Res(Sphere(as_out Obj(as_out) -1.15)) GRAPHICS.l_redraw=no
    display cpk Sphere( as_out Obj( as_out) & a_*.//DX -1.15 ) GRAPHICS.l_redraw=no
    display restore plane GRAPHICS.l_redraw=no
    display residue label Sphere( as_out Obj(as_out ) 4.) GRAPHICS.l_redraw=no
    set label Obj(as_out) & a_*.//cb
    display new GRAPHICS.l_redraw=yes
 endif
endmacro
#
macro findPDB auto s_what ("") s_auth ("*") s_title ("") s_exp ("*") s_head ("*") r_res (9.9) s_het ("*") l_update_pdb_index (no)  l_append (no) l_advSearch (no)
# search s_what in table s_inxDir+"PDB.tab" returns table with two columns ID and comp
# also may search in advanced mode by a keyword in a column of the PDB.tab
  l_info=no
  l_commands=no
  errorAction = 1

  s_userloc = s_userDir+"inx/PDB.molt"
  s_defloc  = s_icmhome+"data/inx/PDB.molt"
  s_db = ""

  l_suggestUpdate = !Exist(s_userloc);
  if (Exist(s_userloc)) then
    connect molcart filename=s_userloc
    l_suggestUpdate = !Exist("PDB2HET",sql,table)
    connect molcart off
  endif

  if (l_suggestUpdate & Askg( "Your PDB index seems to be old. Do you want update it?" "Yes/No" simple ) == "Yes" ) then
    makeIndexPdb "" yes
  endif

  if Exist(s_defloc ) s_db = s_defloc
  if Exist(s_userloc) s_db = s_userloc

  if (s_db != "" & s_what != "ADVANCED SEARCH") then
    print " Info> using " + s_db + " database"
    findPDB_db s_db s_what s_het yes l_append l_advSearch
    return
  endif

  s_userloc = s_userDir+"inx/PDB.tab"
  s_defloc  = s_icmhome+"data/inx/PDB.tab"
  if (Exist(s_userloc) | Exist(s_defloc)) then
    if (Exist(s_userloc) & Type(PDBIDX)=="unknown") then
      read table s_userloc name="PDBIDX"
      set property PDBIDX show edit delete write off
      print " Info> PDB index loaded from "+ s_userloc
      keep PDBIDX
    else
      if ( Exist(s_defloc) & Type(PDBIDX)=="unknown" ) then
        read table s_defloc name="PDBIDX"
        set property PDBIDX show edit delete write off
        print " Info> PDB index loaded from "+ s_defloc
        keep PDBIDX
      endif
    endif
  endif

  one_hit=no

  if(l_append==no & Type(PDBSearchResults)!="unknown") delete PDBSearchResults
  if(l_append==yes & Type(PDBSearchResults)=="unknown") l_append = no
  if(s_what!="") then
    if (Type(PDBIDX)=="table") then
      if (s_what=="ADVANCED SEARCH") then
        l_caseSensitivity=no
        restab=PDBIDX.auth~("*"+s_auth+"*")&PDBIDX.title~("*"+s_title+"*")&PDBIDX.exp~("*"+s_exp+"*")&PDBIDX.head~("*"+s_head+"*")&PDBIDX.res<=r_res&PDBIDX.het~("*"+s_het+"*")
      else
        if( Length(s_what)==4 & s_what[1]~"[0-9]" ) then
          if ( s_what[2]~"[0-9]" & s_what[3]~"[0-9]" & s_what[4]~"[0-9]") then
            find_year = "*"+s_what+"*"
            restab = PDBIDX.date ~ find_year
          else
            restab=PDBIDX.ID==s_what
            if (Nof(restab)<=1) then
              nice s_what no no no no
              one_hit=Nof(a_$s_what.)>0
            endif
          endif
        else
          l_caseSensitivity=no
          restab=Find(PDBIDX,s_what)
        endif
      endif
      if(Type(restab)!="unknown") then
        if(l_append==no) PDBSearchResults = restab
        if(l_append    )  add PDBSearchResults restab
      else
        group table "PDBSearchResults"
      endif
      if Nof(PDBSearchResults)>0 | one_hit then
        if (!one_hit&!l_append) then
          group table PDBSearchResults header append "PDB Search results for '<b>" + s_what + "'</b>" "tableTitle" "nice \"%1\" no no no no\ndelete a_*MiniObj.", "doubleClick" "cursorFindPDB %# \"%@\"" "cursor" yes "separateTab"
          S_SearchPDBhits = restab.ID
          HDR_PROP_OFF
          PDBSearchResults.title = Tolower(PDBSearchResults.title)
          set property  PDBSearchResults write  # otherwise 'write off' is inherited from PDBIDX
          set format PDBSearchResults.ID "<a href=http://www.rcsb.org/pdb/explore/explore.do?structureId=%1>%1</a>"
          set format PDBSearchResults.swiss "<a href=http://www.uniprot.org/uniprot/%1>%1</a>"
          if (Type(PDBSearchResults.date) == "sarray") then
            rename PDBSearchResults.date "tmp"
            add column PDBSearchResults Date( PDBSearchResults.tmp, "%m/%d/%y" ) name="date" index=4
            delete PDBSearchResults.tmp
          endif
          move PDBSearchResults.head index=10
          move PDBSearchResults.exp index=4
          move PDBSearchResults.res index=5
          move PDBSearchResults.het index=6
          move PDBSearchResults.swiss index=7
          keep PDBSearchResults
        endif
      else
        if (Length(s_what)==4) then
          nice s_what no no no no
          return
        endif
        PopMessage "No hits found"
      endif
    else
      print " Error> table 'PDB.tab' not found neither in '"+s_userloc+"' nor in '"+s_defloc+"'"
    endif
  endif
endmacro

macro Alert s_message
# will show a popup error/warning messsage
  if Exist(gui) then
    answ = Askg( "Error\n"+s_message ,"",simple)
  else
    print " Error> "+s_message
  endif
endmacro

macro PopMessage s_message
# will show a popup error/warning messsage
  if Exist(gui) then
    answ = Askg( s_message ,"",simple)
  else
    print s_message
  endif
endmacro

macro EAlert s_message
# will show a popup INTERNAL ERROR MESSAGES
  s=Error(string)
  if (Length(s)==0) s="Error"
  s = s + "\n"
  if Exist(gui) then
    answ = Askg( s+s_message ,"",simple)
  else
    print s+s_message
  endif
endmacro
#
macro openFile s_fls i_type (0) l_display (yes) l_rmothers (no) l_rmall (no) l_listOnly (no) s_extras ("") auto
  l_info=no
  #l_warn=no
  l_commands=no

  l_table=no

  S_files = Split( s_fls, "<?>" exact )

  for fileno=1,Nof(S_files)

    s_file = S_files[fileno]

    if (Length(s_file)==0) return

    type_index=0 ## type found if >0
    j=0
    fi=""
    fiex=""
    if (Type(S_RecentFiles) == "unknown") S_RecentFiles = Sarray()
    if (Type(S_RecentPDBs)  == "unknown") S_RecentPDBs  = Sarray()

    if(l_rmall) then
      delete all
    endif

    if (i_type<=0) then ### if type was not specified let us try to find it
      fiex = Extension(s_file)
      if (fiex!="") then
        fiex = Tolower(fiex[2:Length(fiex)])
        for j=1,Nof(ICMEXTENSIONS.name)
          if( fiex ~ "*.fa*" ) fiex = ".fa" # fasta fix
          if ( Index(Split(ICMEXTENSIONS.extension[j],","),fiex)!=0 ) then
            type_index=j
            break
          endif
        endfor
        if(type_index<=0 & s_file ~ "*.icb.bak") type_index = 1
      else
        type_index=0
      endif
    else ### if type was specified - just use is
      if (i_type <= Nof(ICMEXTENSIONS.name)) type_index=i_type
    endif
    if (type_index<=0) then
      s_testType = File(s_file,type)
      if (s_testType != "unknown") then
        for j=1,Nof(ICMEXTENSIONS.name)
          if ( Index(Split(ICMEXTENSIONS.extension[j],","),s_testType)!=0 ) then
            type_index=j
            break
          endif
        endfor
      endif
    endif

    if (type_index <= 0) then
      Alert "Unsupported file type"
      return
    endif

    s_fls_ext = Trim(Extension(s_file),all)

    if Exist(s_file) | s_file ~ "http://*" | s_file ~ "ftp://*" then
      cmd=Split(ICMEXTENSIONS.command[type_index],";")
      if (l_rmothers & cmd[3]!="NA") then
        s_out=cmd[3]
        $s_out
      endif
      ### special case for table
      if (Index(cmd[1],"read column") != 0 &  s_fls_ext==".tab") then
        cmd[1] = "read table \"%s\"";
      endif
      s_thecmd = cmd[1]
      s_thecmd = Replace(s_thecmd,"%s",s_file) #there may be many %s -- sprintf cmd[1] s_file
      s_thecmd = Replace(s_thecmd,"\\","\\\\" )
      ercd=Error()
      errorAction=1
      if (s_thecmd ~ "read *")  s_thecmd = "global " + s_thecmd
      if (l_listOnly) s_thecmd += " list"
      if (ICMEXTENSIONS.extension[type_index] == "icb") s_thecmd += s_extras # for options like edit

      if (s_fls_ext==".csv" | s_fls_ext==".tsv" | s_fls_ext==".bsv" ) then
        buf =  "#dialog{\""
        buf += Toupper( s_fls_ext[2:100] )
        #l_commands = yes
        read sarray number=2 s_file name="tmp" # new
        tmp = Replace( Replace( tmp, "(", "{" ), ")", "}" )
        buf += " reading options\"}\n"
        buf += "# txt_top_two_lines ("+Trim(tmp[1],60,"..") + "<br>"+Trim(tmp[Max(2,Nof(tmp))],60,"..")+ ")\n" # new
        buf += "# o_header_Read_First_Row_as_Column_Names\n"
        buf += "# o_comment_Ignore_text_in_lines_after_hash\n"
        buf += "# o_number_Treat_empty_fields_in_num_columns_as_ND\n"
        buf += "# o_TOOLS.parseDatesOnImport=yes_Automatically_parse_date_fields\n"
        buf += "# i_Skip_first_lines (0)\n"
        if Askg( buf )!="yes" return
        s_thecmd += " "+Getarg(2 gui)+" "+Getarg( 3 gui )+" "+Getarg(4 gui)+" "+Getarg(5 gui)
        if (Tointeger(Getarg(5 gui))>0) s_thecmd += " underline=" + Getarg(6 gui)
        l_table=yes
      elseif (s_fls_ext==".xlsx") then
        buf =  "#dialog{\""
        buf += Toupper( s_fls_ext[2:100] )
        buf += " reading options\"}\n"
        buf += "# o_header_Read_First_Row_as_Column_Names (yes)\n"
        buf += "# o_allws_Read_All_Worksheets (yes)\n"
        buf += "# o_readstyle_Read_Cell_Colors (no)\n"
        if Askg( buf )!="yes" return
        s_thecmd += " "+String(Getarg(1 gui) + "," + Getarg(2 gui) + "," + Getarg(3 gui), string)
      endif
      if(s_thecmd ~ "* table *") l_table=yes
      if s_fls_ext == ".csvh" s_thecmd += " header "

      l_info=yes
      s_thecmd
      $s_thecmd
      s_out = s_thecmd
      l_info=no
      errorAction=2
      if Error() then
        EAlert "There were errors when reading '"+s_file+"'"
      else
        if(s_fls_ext==".icb" & s_currentProject == "") then
          s_currentProject=Path(s_file full)
          if TOOLS.onProjectLoadMacro != "" then
            if Type($TOOLS.onProjectLoadMacro) == "macro" $TOOLS.onProjectLoadMacro
          endif
        endif
        ### <add to recent file history>
        addToRecent "S_RecentFiles" s_file + "::::" + i_type
        ### </add to recent file history>
        if (cmd[2]!="NA" & l_display) then
          s_out=cmd[2]
          $s_out
        endif
      endif
    else
      if(s_fls_ext==".icb" & s_currentProject == "") s_currentProject=Path(s_file full)
      Alert "File '"+s_file+"' not found"
    endif

  endfor

  # if(l_table & Nof( a_. )==0 & Nof(grob) ==0 & !Exist(view)) undisplay window = "properties"

  set property S_RecentFiles read off # mark as a system variable
  keep S_RecentFiles
endmacro

# macro tab2str s_tab
#   l_info=no
#   s=""
#   mk_tab="if(Type("+s_tab+")==\"unknown\") group table \""+s_tab+"\""
#   mk_tab_hdr=""
#   na=Name( $s_tab )
#   for i=1,Nof(na)
#     item=$na[i]
#     ss=""
#     if(Type(item)~"*array") then
#       mk_tab+=" "+ Toupper(Type(item)[1:1])+"array("+Nof(item)+") \""+na[i]+"\""
#       for j=1,Nof(item)
#         val=String(item[j])
#         if(Type(item[j])=="string") val = String(val all)
#         ss+=val
#         if(j<Nof(item)) ss+=","
#       endfor
#       s+= na[i]+"={"+ss+"}\n"
#     else
#       if (Type(item)=="preference") then
#         val=String(Integer(item))
#       else
#         val=String(item)
#       endif
#       if(Type(item)=="string") val = String(val all)
#       s+= na[i]+"="+val+"\n"
#       mk_tab_hdr+=" "+val+" "+na[i]
#     endif
#     delete item
#   endfor
#   if(mk_tab_hdr!="") mk_tab+=" header"+mk_tab_hdr
#   s_out=s_out+mk_tab+"\n"+s
#   keep s_out
# endmacro
#
# macro arr2str s_ar
#   l_info=no
#   s=""
#   item=$s_ar
#   for j=1,Nof(item)
#     val=String(item[j])
#     if(Type(item[j])=="string") val = String(val all)
#     s+=val
#     if(j<Nof(item)) s+=","
#   endfor
#   if(s=="") then
#     s_out +=s_ar +"="+Toupper(Type(item)[1:1])+"array("+0+")\n"
#   else
#     s_out += s_ar+"={"+s+"}\n"
#   endif
#   keep s_out
# endmacro
#
# macro vals2str s_names
#   l_info=no
#   s=""
#   na=Split(s_names,"|")
#   for i=1,Nof(na)
#     item=$na[i]
#     if (Type(item)=="preference") then
#       val=String(Integer(item))
#     else
#       val=String(item)
#     endif
#     if(Type(item)=="string") val = String(val all)
#     s+= na[i]+"="+val+"\n"
#     delete item
#   endfor
#   s_out+=s
#   keep s_out
# endmacro

macro loadResources
  l_info=no

  ### recent files
  if (Exist(s_userDir+ "/config/.icmrc.rf")) then
    read all s_userDir+ "/config/.icmrc.rf"
    if (Type(s_RecentFiles) == "unknown") s_RecentFiles = ""
    S_RecentFiles=Split(s_RecentFiles,";")
    if (Type(s_RecentPDBs) == "unknown") s_RecentPDBs = ""
    S_RecentPDBs=Split(s_RecentPDBs,";")
  endif
  if (Type(S_RecentFiles) == "unknown") S_RecentFiles = Sarray(0)

  # clean recent files
  S_S_S=Sarray(0)
  for j=1,Nof(S_RecentFiles)
    if(Exist(Split(S_RecentFiles[j],"::::",exact)[1])) S_S_S=S_S_S//S_RecentFiles[j]
  endfor
  S_RecentFiles=S_S_S

  set property S_RecentFiles read delete off # mark as a system variable
  set property S_RecentPDBs  read delete off # mark as a system variable
  keep S_RecentFiles S_RecentPDBs
endmacro

macro addToRecent s_ArrayName s_what
  l_info = no
  li = $s_ArrayName
  ### <add to recent file history>
  if (Index(li,s_what) == 0) then
    if ( Nof(li) > GUI.maxNofRecentFiles ) li=Sarray(li[ 1 : GUI.maxNofRecentFiles ] )
    li = Sarray(s_what) // li
  else
    group table T_RecentFiles Count(Nof(li)) "n" Sarray(li) "f"
    T_RecentFiles.n[Index(T_RecentFiles.f,s_what)]=-1
    sort T_RecentFiles.n
    li = T_RecentFiles.f
  endif
  ### </add to recent file history>
  $s_ArrayName = li
  s_RecentFiles=Sum(S_RecentFiles,";")
  s_RecentPDBs =Sum(S_RecentPDBs,";")
  if Exist(gui) write delete all s_RecentFiles s_RecentPDBs s_userDir+"config/.icmrc.rf"
  keep $s_ArrayName
endmacro

#   s_projName: the name of the project with the path
#   l_force: means do not ask - overwrite autamatically
#
macro writeProject s_projName ("newProject1") l_force (no) l_system (no) s_args ("") i_ver (0) auto
  if (Type(S_RecentFiles) == "unknown") S_RecentFiles = Sarray(0)
  s_projName=Trim(s_projName all)
  ext=Extension(s_projName)
  path=Path(s_projName)
  if (Version() ~ "*UNIX*" & Version() !~ "*MacOSX*") s_projName=path + Replace(Name(s_projName)," ","_") + ext
  if(ext=="") ext=".icb"
  s_name=Name(s_projName)

  write session mute
#  s_last_session=s_out
#  set property command s_last_session

  l_confirm=!l_force
  if(Exist(path+s_name+ext)) then
    bname=path+s_name+ext+".bak"
    fname=path+s_name+ext
#ifdef WIN32
    fname="\""+Replace(fname,"[\\/]","\\\\" regexp)+"\""
    bname="\""+Replace(bname,"[\\/]","\\\\" regexp)+"\""
#else
    fname="\""+Replace(fname,"\\","\\\\")+"\""
    bname="\""+Replace(bname,"\\","\\\\")+"\""
#endif
    if(Exist(bname)) sys $s_sysRm $bname
    sys $s_sysCp $fname $bname
  endif
  if(s_args!="" & Trim(USER.fullName all)=="") then
    # does not work inside macro
    #USER.fullName = Askg(" Please Enter Your Full Name: ","")
    #write system preference
  endif
  if (l_system) then
#    write binary all s_last_session path+s_name system
    write binary all path+s_name system
  else
#    write binary all s_last_session path+s_name $s_args version=i_ver # to allow write with the password
    write binary all preview path+s_name+ext $s_args version=i_ver # to allow write with the password
  endif
  if (!l_out) return
  s_currentProject = s_projName

  s_fls=path+s_name+ext
  ### <add to recent file history>
  addToRecent "S_RecentFiles" s_fls + "::::0"
  #if (Index(S_RecentFiles,s_fls) == 0) then
  #  if ( Nof(S_RecentFiles) > GUI.maxNofRecentFiles ) S_RecentFiles=Sarray(S_RecentFiles[ 1 : GUI.maxNofRecentFiles ] )
  #  S_RecentFiles = Sarray(s_fls) // S_RecentFiles
  #  s_RecentFiles=Sum(S_RecentFiles,";")
  #  write delete all s_RecentFiles s_userDir+"config/.icmrc.rf"
  #else
  #  group table T_RecentFiles Count(Nof(S_RecentFiles)) "n" Sarray(S_RecentFiles) "f"
  #  T_RecentFiles.n[Index(S_RecentFiles,s_fls)]=-1
  #  sort T_RecentFiles.n
  #  S_RecentFiles = T_RecentFiles.f
  #  s_RecentFiles=Sum(S_RecentFiles,";")
  #  write delete all s_RecentFiles s_userDir+"config/.icmrc.rf"
  #endif
  ### </add to recent file history>
  set property S_RecentFiles read off # mark as a system variable
  keep S_RecentFiles
  l_info=no
endmacro

macro makeIndexPdb s_entriesFile ("http://ftp.wwpdb.org/pub/pdb/derived_data/index/entries.idx") l_updateLigands (no) auto

  l_commands = no
  l_info = no
  l_warn=no

  s_seqresFile = ""
  if(s_entriesFile=="") then
    if Exist(s_pdbDir+"derived_data/index/entries.idx") then
      s_entriesFile=s_pdbDir+"derived_data/index/entries.idx"
      s_seqresFile=s_pdbDir+"derived_data/pdb_seqres.txt.gz"
    else
      s_entriesFile="http://ftp.wwpdb.org/pub/pdb/derived_data/index/entries.idx"
    endif
  endif

  if (Type(PDBIDX)!="unknown") then
    set property PDBIDX show edit delete
    delete PDBIDX
  endif

  s_indexName="PDB.tab"
  print "Downloading/reading PDB entries index..."
  read table separator="\t" s_entriesFile name="PDB" underline=2 simple

  n=Nof(PDB)

# ID, HEADER,DATE, COMPOUND,SOURCE,AUTHORS
  rename PDB.A "ID"
  transform sarray PDB.ID "tolower"
  rename PDB.B "head"
  rename PDB.C "date"
  delete PDB.C
  tmp = PDB.D
  tmp = Replace(tmp,"(?i)(the )?crystal structure of","",regexp)
  tmp = Replace(tmp,"(?i)(the )?solution structure of","",regexp)
  tmp = Replace(tmp,"(?i)(the )?x-ray structure of","",regexp)
  tmp = Replace(tmp,"(?i)(the )?three-dimensional structure of","",regexp)
  tmp = Replace(tmp,"(?i)(the )?structure of","",regexp)
  tmp = Replace(tmp,"(?i)(the )?discovery of","",regexp)
  tmp = Replace(tmp,"(?i)(the )?idenfitication of","",regexp)
  tmp = Replace(tmp,"(?i)crystal structure analysis of","",regexp)
  tmp = Replace(tmp,"(?i)structural characterization of","",regexp)
  PDB.D = Trim(tmp,all)
  rename PDB.D "title"
  rename PDB.E "source"
  rename PDB.F "auth"
  res_col =  Trim(PDB.G,all)
  res_col =  Replace(res_col,"NOT","9.9")
  res_col =  Replace(res_col,"0.0","9.9")
  add column PDB Toreal(res_col) name="res"
  delete PDB.G
  PDB.H = Replace(Replace(PDB.H,"X-RAY DIFFRACTION","X-RAY"),"SOLUTION NMR","NMR")
  rename PDB.H "exp"

  # adding het information
  read table name="het" "http://molsoft.com/addons/PDB/pdb2het.csv" separator="," header
  join PDB.ID het.ID left name="PDB"

  # adding swiss information
  read table name="sprot" "http://ruben.ucsd.edu/ix/pdb_uniprot.csv"  separator="," header  # new location
  group sprot.ID
  join left PDB.ID sprot.ID name="PDB"
  #
  s_desc  = ""
  if s_seqresFile != "" then
    read sarray s_seqresFile pattern="^>" name="pdb_seqres"
    add column tt Sarray( Field( pdb_seqres 1) 2, 5 ) Match( pdb_seqres, "length:\\d+ (.*)" 1 ) name={"ID","desc"}
    group tt.ID all "uniq"  name="tt"

    join left PDB.ID tt.ID name="PDB"
    move PDB.desc 3
    s_desc = "desc,"
  endif

  #clean and fix convert resolutions
  n=Nof(PDB) #join may change the table size

  sort PDB.date
  pdbtabname = s_userDir+"inx/PDB.tab"
  write table PDB pdbtabname delete
  print " Info> Database index successfully saved to file", "\""+pdbtabname+"\""

  # molt stuff

   pdbdbname = s_userDir+"inx/PDB.molt"
   delete system pdbdbname
   rename PDB.ID PDB.PDBID
   make molcart table PDB name="PDBIDX" filename=pdbdbname l_confirm = no
   query molcart "CREATE VIRTUAL TABLE PDBIDX_fullts USING fts3(PDBID,head," + s_desc + "date,title,source,auth,exp,res,het,swiss)" filename=pdbdbname
   query molcart "insert into PDBIDX_fullts select PDBID,head," + s_desc + "date,title,source,auth,exp,res,het,swiss from PDBIDX" filename=pdbdbname

   # ligands
   if (l_updateLigands) then
     l_info = yes
     read table mmcif "http://ftp.wwpdb.org/pub/pdb/data/monomers/components.cif.gz" name="lig"
     delete column lig 6 999
     make flat lig.mol
     rename lig.id lig.HETID
     lig.HETID = Tolower(lig.HETID)
     make molcart table lig name="PDBLIG" filename=pdbdbname l_confirm = no
     build molcart filename=pdbdbname sstructure similarity unique "PDBLIG"
     add column PDB function="Split(het,';')" name="B"
     add column PDB function="Nof(B)" name="nhet"
     add column PDB2HET PDB.PDBID[ Count( PDB.nhet all ) ] Sarray( PDB.B ) name={"PDBID","HETID"}
     make molcart table  PDB2HET name="PDB2HET" filename=pdbdbname l_confirm = no
     query molcart "create index PDB2HET_PDBID on PDB2HET(PDBID)" filename=pdbdbname
     query molcart "create index PDB2HET_HETID on PDB2HET(HETID)" filename=pdbdbname
     query molcart "create index PDBLIG_HETID on PDBLIG(HETID)"   filename=pdbdbname
     query molcart "create index PDBIDX_PDBID on PDBIDX(PDBID)"   filename=pdbdbname
   endif

  print " Info> Local database index successfully saved to file", "\""+pdbdbname+"\""

endmacro

macro makeIndexBlastPdb
#  if (Version() ~ "*mini*") then
#    print "Error> updating of index file for search by sequence is not available in ICM Lite"
#    return
#  endif
#  l_info=no
#  original_path=Path(directory)
#  if (Version() ~ "*WIN*") then
#    set directory s_icmhome
#    s=Split(Path(unix),"\\")
#    cmd=s[Nof(s)]+" _updateBLASTidx"
#  else
#    cmd=Path(unix)+" "+s_icmhome+"_updateBLASTidx&"
#  endif
#  sys $cmd
#  set directory original_path
#  print " Info> Database successfully indexed"

  l_info = no
  job=Name( Name( system, "icmjobXXXin.icb" ) )
  make background name=job[1:Length(job)-2] Path( macro, s_icmhome + "_updateBLASTidx" ) command="" info="Database indexing is completed"
  print " Info> Database indexing started in background. You will be notified when the job is complete."
endmacro
#
macro siteScanBG as_site s_tag s_db ("") l_rapid (yes)
  fname_in  =  Name( system s_tempDir + "siteScanXXXX.ob" )
  fname_out = s_tempDir + Name( fname_in ) + "_out.icb"
  if( Type( Obj(as_site) 2) != "ICM" ) return error "Please provide ICM object. Convert if necessary."
  write object Obj(as_site) fname_in
  S_args = Sarray()
  if ( s_tag=="" | s_tag=="ligand" ) then
    #s_cmd = Path( macro, s_icmhome + "pcktmScan.icm","select="+String(Mol(as_site)), "output=" + fname_out , fname_in)
    S_args = s_icmhome + "pcktmScan.icm" // "select="+String(Mol(as_site)) // "output=" + fname_out // fname_in
  elseif s_tag=="exact" |  s_tag=="EXACT" then
# implement
  else
    #s_cmd = Path( macro, s_icmhome + "pcktmScan.icm","site="+s_tag , "output=" + fname_out , fname_in)
    S_args = s_icmhome + "pcktmScan.icm" // "site="+s_tag // "output=" + fname_out // fname_in
  endif
  if(s_db!="") then
    if (Path(s_db) == "") s_db = s_icmhome + s_db
    S_args  = S_args // "db=" + s_db
  endif
  if(l_rapid) S_args  = S_args // "-r"
  s_cmd = Path( macro S_args )
  make background s_cmd info="Pocketome site scan finished for " + Name( Obj(as_site))[1] command="read binary " + String(fname_out string)
  print " Info> Pocketome site scan started in background. You will be notified when the job is complete."
endmacro
#
macro apf3DqsarBG s_table s_activityColumn s_extraDesc ("") auto
  fname_in  =  Name( system s_tempDir + "apf3DqsarXXXX.sdf" )
  fname_out = s_tempDir + Name( fname_in ) + "_out.icb"
  write table mol  $s_table fname_in delete
#  S_cmdargs = "train="+fname_in+" field=" + s_activityColumn + " icb=" + fname_out
  s_cmd = Path( macro, s_icmhome + "_apf3Dqsar", "atomContrib=yes",  "train="+fname_in , "field=" + s_activityColumn , Sarray(1 "icb=" + fname_out) )
  if (Length(s_extraDesc)) s_cmd = s_cmd + " extra=" + s_extraDesc
  make background s_cmd info="APF 3D QSAR model generation finished for table " + s_table command="read binary " + String(fname_out string)
  print " Info> APF 3D QSAR model generation started in background. You will be notified when the job is complete."
endmacro
#
function ligQSAR_apf P_chem   # function is used in 'add column function="ligQSAR_apf(mol)"
  read mol P_chem name="LIGQSAR"
  build hydrogen
  set type charge mmff
  convert auto
  show energy "gp" mute
  gpey = Energy("ener")
  delete a_
  return gpey
endfunction
#
macro aquaFloodBG os_in (a_) R_6box (Box()) i_Nconf (100) l_density (no) l_mesh (no)
  fname_in  =  Name( system s_tempDir + "aquaFloodXXXX.ob" )
  fname_out = s_tempDir + Name( fname_in ) + "_out.icb"
  os_in = Obj( os_in )
  write object os_in fname_in
  s_cmd = Path( macro, s_icmhome + "_aquaFlood", "box="+Sum(Sarray(Box()) ",") , "nconf=" + i_Nconf, fname_in, fname_out)
  if(l_density) s_cmd = s_cmd + " -d"
  if(l_mesh)    s_cmd = s_cmd + " -m"
  make background s_cmd info="Explicit water sampling finished for " + Name(os_in)[1] command="read binary " + String(fname_out string)
  print " Info> Explicit water sampling started in background. You will be notified when the job is complete."
endmacro
#
macro fftProtDockBG os_rec os_lig i_accuracy (0) os_refCmplx (a_none.) rs_focusRec (a_none.)  rs_focusLig (a_none.) l_crossCont (no) r_contCutoff (10.) i_nproc (1)
  fname_inA  =  Name( system s_tempDir + "fftProtDockAXXXX.ob" )
  fname_inB  =  Name( system s_tempDir + "fftProtDockBXXXX.ob" )
  fname_inC  =  Name( system s_tempDir + "fftProtDockCXXXX.ob" )
  fname_out = s_tempDir + Name( fname_inC ) + "_out.icb"
  os_rec = Obj( os_rec )
  os_lig = Obj( os_lig )
  os_refCmplx = Obj(os_refCmplx)
  if( Nof(os_rec) != 1 | Nof(os_lig) != 1 | os_lig==os_rec | Type(os_rec 2)!="ICM" | Type(os_lig 2)!="ICM") return error "Input must be two ICM-converted objects"
  if( Nof(os_refCmplx) > 1 | Nof(os_refCmplx) != 0 & Nof(Mol(os_rec))+Nof(Mol(os_lig))!=Nof(Mol(os_refCmplx)) ) return error "Reference object is expected to contain "+(Nof(Mol(os_rec))+Nof(Mol(os_lig)))+" molecules"
  if( Nof(rs_focusRec)!=0 & Nof(rs_focusRec&os_rec)==0 ) return error "Receptor focus residues selected not in the receptor object"
  if( Nof(rs_focusLig)!=0 & Nof(rs_focusLig&os_lig)==0 ) return error "Ligand focus residues selected not in the ligand object"
#
  write object os_rec fname_inA
  write object os_lig fname_inB
  if( Nof(os_refCmplx) == 1) write object os_refCmplx fname_inC
#
  s_cmd = Path( macro, s_icmhome + "bin/fftProtDock.icm", fname_inA, fname_inB, fname_out)
  if(i_accuracy==0)              s_cmd = s_cmd + " -d"
  if(i_accuracy==1)              s_cmd = s_cmd + " -f"
  if(i_accuracy==2)              s_cmd = s_cmd + " -m"
  if(l_crossCont)                s_cmd = s_cmd + " -x"
  if(r_contCutoff!=10.)          s_cmd = s_cmd + " cutFocus=" + r_contCutoff
  if(Nof(os_rec&rs_focusRec)>0)  s_cmd = s_cmd + " recFocus=" + Replace(String(Res(os_rec&rs_focusRec)) {"a_*.","|","[^][A-Z]"} {"","_",""})
  if(Nof(os_lig&rs_focusLig)>0)  s_cmd = s_cmd + " ligFocus=" + Replace(String(Res(os_lig&rs_focusLig)) {"a_*.","|","[^][A-Z]"} {"","_",""})
  if( Nof(os_refCmplx) == 1)   s_cmd = s_cmd + " reference=" + fname_inC
  if(i_nproc!=1)               s_cmd = s_cmd + " nproc=" + i_nproc
  s_cmd
  make background s_cmd info="FFT protein-protein docking simulation finished for "+Name(os_rec)[1]+" - "+Name(os_lig)[1] + " complex" command = "read binary " + String(fname_out string)
  print " Info> FFT protein-protein docking simulation started in background. You will be notified when the job is complete."
endmacro
#
macro homPrepAlignments ms_tplts s_seqLi
  ms_tplts = Mol(a_.A & ms_tplts)
  if(Nof(ms_tplts) != Nof(Split(s_seqLi,",")))then
    print " Error> number of selected template chains and sequences does not match"
    return
  endif
#
  R_weight = {1.6 1.8}
  r_stickiness = 0.
  i_window = 3
  l_mute   = yes
  gapFunction[1:2]= {2.15 0.25}
  accFunction={0.333,2.35,0.211}
  alignMethod = "H-align"
#
  show area surface ms_tplts ms_tplts
  assign sstructure
#
  for i = 1, Nof(Split(s_seqLi,","))
    make sequence ms_tplts [i]
    s_seq1 = s_out
    s_seq2 = Split(s_seqLi,",")[i]
    s_alna = "ali_"+s_seq1+"_"+s_seq2
    a1=Smooth(Rarray(Split(Replace(Sstructure($s_seq1),{"H","[!H]"},{"1","0"}),"")) i_window)
    a2=Smooth(Rarray(Split(Replace(Sstructure($s_seq2),{"H","[!H]"},{"1","0"}),"")) i_window)
    b1=Smooth(Rarray(Split(Replace(Sstructure($s_seq1),{"E","[!E]"},{"1","0"}),"")) i_window)
    b2=Smooth(Rarray(Split(Replace(Sstructure($s_seq2),{"E","[!E]"},{"1","0"}),"")) i_window)
    M_out=R_weight[1]*Matrix(a1,a2)+R_weight[2]*Matrix(b1,b2)
    M_out = M_out - Mean(Mean(M_out )) + r_stickiness
    $s_alna = Align( $s_seq1 $s_seq2 area M_out)
    keep $s_alna $s_seq1
  endfor
endmacro
#
macro homModelBG os_in (a_) ms_hetero s_seqName s_aliName i_loopSampleLevel (0) I_indelExpand ({2,3}) r_effort (1.) s_opt ("")
  l_icmff     = Index(s_opt "icmff ")!=0
  l_trim      = Index(s_opt "trim ") !=0
  l_oligomer  = Index(s_opt "oligo ")!=0
  l_quickTest = Index(s_opt "test ") !=0
  fname_in  = Name( system s_tempDir + "homModelXXXX_in.icb" )
  fname_out = Replace(fname_in ,"_in.icb", "_out.icb", simple)
  set object Obj( os_in )
  S_args = Sarray(1,s_icmhome + "homModel.icm")
  S_args //= fname_in
  S_args //= "output="+fname_out
  if(l_oligomer) S_args //= "-o"
  if(l_icmff) S_args //= "-i"
  if(r_effort!=1.) S_args //= "effort=" + r_effort
  if(s_seqName=="")then # refinement
    if(Nof(Atom(a_ tether))==0) return error "Model does not seem to have any template tethers"
    set field a_ name="TO_REFINE_"
    write binary a_ | Obj(Atom(a_ tether)) tether fname_in
    delete field a_ name="TO_REFINE_"
    S_args //= "-r"
    if(l_quickTest) S_args //= " loopSample=0" # in refinement mode quickTest = only sidechains
    s_cmd = Path( macro, S_args)
    make background s_cmd info="Homology model refinement finished for " + Name(os_in)[1] command="read binary object " + String( fname_out string )
    print " Info> Homology model refinement started in background. You will be notified when the job is complete."
  else  # full modeling
    if( Nof(Split(s_aliName,",")) != Nof(Split(s_seqName,",")))then
      printf " Error> number of sequences (%d) doesn't match number of alignments (%d)\n", Nof(Split(s_seqName,",")), Nof(Split(s_aliName,","))
      return
    endif
# more extensive check for each sequence?
    for i = 1,Nof(Split(s_seqName,","))
#      s_ali1 = Split(s_aliName,",") [i]
      s_seq1 = Split(s_seqName,",") [i]
      if(Index(String( $s_seq1 ),"[BOJXZ?]" regexp)!=0)then
        printf " Error> Sequence %s contains unknown modified residues, can not model. Change to a standard aminoacid residue and retry.\n", s_seq1
        return
      endif
    endfor
    if(l_trim)then
#make trimmed alignment and sequence
      s_aliName1 = ""
      s_seqName1 = ""
      for i = 1,Nof(Split(s_aliName,","))
        s_ali1 = Split(s_aliName,",") [i]
        s_seq1 = Split(s_seqName,",") [i]
        if(Nof( Name( Mol( $s_ali1 ) & os_in sequence ))==0) link os_in  $s_ali1 # try to link automatically
        s_seqt = Name( Mol( $s_ali1 ) & os_in sequence )[1]
        tmal = $s_ali1 [Index( $s_ali1 $s_seqt 1 ) : Index( $s_ali1 $s_seqt Length( $s_seqt ) )]
        make sequence tmal
        delete tmal
        rename tmal_1 s_ali1 + "_trm"
        s_aliName1 = s_aliName1 + s_ali1 + "_trm,"
        s_seqName1 = s_seqName1 + s_seq1 + "_trm,"
      endfor
      s_aliName = s_aliName1[1:Length(s_aliName1)-1]
      s_seqName = s_seqName1[1:Length(s_seqName1)-1]
    endif
    if(Nof(Mol(ms_hetero))>0)then
      copyMol ms_hetero "model_hetero" yes
      if(Type(a_model_hetero. 2)!="ICM") convert3Dto3D a_model_hetero. yes yes yes
      set object Obj( os_in )
      write binary a_ | a_model_hetero. $s_aliName fname_in
      delete a_model_hetero.
    else
      write binary a_ $s_aliName fname_in
    endif
    S_args //= s_seqName
    if(l_quickTest) S_args //= "-t"
    S_args //= "loopSample=" + i_loopSampleLevel
    S_args //= "insMargin=" + I_indelExpand[1]
    S_args //= "delMargin=" + I_indelExpand[2]
    s_cmd = Path( macro, S_args )
    make background s_cmd info="Homology modeling finished for " + Name(os_in)[1] command="read binary " + String(fname_out string)
    printf " Info> Homology model construction started in background. You will be notified when the job is complete.\n"
    printf " Info> Command: '%s'.Output file in '%s'\n" s_cmd, fname_out
  endif
  l_info=no
endmacro
#
macro predictRxn s_tab ("") s_tag ("prodrug") I_rxnrow (Iarray()) i_mode (1) auto
HELP = """
  applies ICM reaction prediction to the chemicals from the input table
  Arguments and options:
    <s_tab> : string with table name, e.g. 't'
    <s_tag> : reaction selected by tag column
    <I_rxnrow> : reaction table row selection, mutually exclusive with <s_tag> argument
               : Alternatively, one can manually select reactions from the MolRxn panel, the tag will then be ignored
    <i_mode> : 1 replace the original compound with the transformed compound
               2 add transformed compounds after the original compound

  Example:
    predictRxn 't' 'prodrug'
"""
  l_commands = no; l_warn = no; l_info = no
  S_smilesfilter = {"C(C(O)=O)O","C(CO)CO","C(CO)O","C(O)(O)=O","C(O)[Cl]","C1CCC(CC1)O","C=O","CC(C)C=O",\
  "CC(C)O","CC(O)=O","CC=O","CCC(O)=O","CCO","CNC","CO","N","O","[O-]P([O-])(O)=O","C1COC[C@H]1O","CC(C)(C)CC(O)=O",\
  "C1CCC(C1)CCC(O)=O","C(CC(O)=O)C(O)=O","C1CCC(C1)CCC(O)=O","CC(C)(C)C(O)=O","CCCCCCC(O)=O","CCCCCCCCCC(O)=O","CCCCC(O)=O",\
  "CCCC(O)=O","CCN(CC)CC(O)=O","C1CCC(C1)=O","CC(C)=O","C(Cc1ccccc1)C(O)=O","CC1=C(CO)OC(=O)O1","C(C[Cl])NCC[Cl]"\
  "CC(C)[C@@H](C(O)=O)N","C1CCN(CC1)C1CCNCC1","Cc1ccc(cc1)C(O)=O","c1cc(C(O)=O)oc1","C(CO)N1CCOCC1","CCCCCCCCCCCCCCCC(O)=O",\
  "CCCCCCO","CC(C)C(O)=O","c1ccc(cc1)C(O)=O","CC(C(O)=O)N","c1ccc(cc1)O","C1Cc2ccc(cc2C1)O","CC(C)N","c1cc(cnc1)C(O)=O","CC(C)C(O)=O",\
  "CCCCN","C(CN1CCN(CC1)CCO)CO","CCCCCO","C(CC(O)=O)Cc1ccccc1","C(C(CO)O)O","C(O)O","C(N)(O)=O","CC(O)O","CC(C)[C@@H](O)O","CN(C)C(O)=O"}

  if (s_tab == "") return "Table not specified"
  if (Type($s_tab)!="table") return "Table not found"
  if (Type(MolRxn)!="table") then
    l_loaded = no
    if (!Exist(s_icmhome+"/models/MolRxn.icb")) return s_icmhome+"/models/MolRxn.icb not found"
    read binary s_icmhome+"/models/MolRxn.icb"
  else
    l_loaded = yes
  endif
  if (I_rxnrow == Iarray()) then
    I_rxnrow = Index(MolRxn.sel==1)
  endif
  if ((I_rxnrow==Iarray()) & (s_tag=="")) return "Please specify either reaction row selection or tag"
  if (I_rxnrow==Iarray()) I_rxnrow = Index(MolRxn.subset ~"*"+s_tag+"*")
  if (I_rxnrow==Iarray()) return "Please specify either reaction row selection or tag"
  T_tmprxntab = $s_tab
  M = Nof(T_tmprxntab)
  N = Nof(I_rxnrow)
  sprintf " Info> predicting %d chemicals vs %d reactions in table '%s' ",M,N,s_tab
  print bar s_out  M l_info=yes
  add column T_tmprxntab Count(Nof(T_tmprxntab)) name="tmprxnidx" index=2
  for i_cpd = 1, Max(T_tmprxntab.tmprxnidx)
    if (T_tmprxntab.mol[Index(T_tmprxntab.tmprxnidx==i_cpd)] == Chemical("")) continue
    group table "T_tmprxnin" T_tmprxntab.mol[Index(T_tmprxntab.tmprxnidx==i_cpd)] "mol"
    for i_rxn = 1, Nof(I_rxnrow)
      i_rxnrow = I_rxnrow[i_rxn]
      for i_trial = 1, 5
        if (MolRxn.chiral[i_rxnrow]==0) then
          make reaction T_tmprxnin MolRxn.rxn[i_rxnrow] all name="tmprxnout"
        else
          make reaction T_tmprxnin MolRxn.rxn[i_rxnrow] name="tmprxnout"
        endif
        if (Type(tmprxnout)=="unknown") continue
        if (Nof(tmprxnout)==0) then
          delete tmprxnout l_warn=no
          continue
        endif
        for i_tmp = 1, 10
          s_mol = "mol"+i_tmp
          if (Type(tmprxnout.$s_mol)!="parray") break
          if (Type(tmprxnouttmp)=="unknown") then
            group table tmprxnouttmp tmprxnout.$s_mol "mol" tmprxnout.rct1 "rct1"
          else
            group table tmprxnouttmp2 tmprxnout.$s_mol "mol" tmprxnout.rct1 "rct1"
            add tmprxnouttmp tmprxnouttmp2
            delete tmprxnouttmp2
          endif
        endfor
        if (Type(tmprxnouttmp)!="unknown") then
          add tmprxnout tmprxnouttmp
          delete tmprxnouttmp
        endif
        delete T_tmprxnin[Unique(Sort(tmprxnout.rct1))]
        add T_tmprxnin tmprxnout
        delete tmprxnout l_warn=no
      endfor
    endfor
    if (Nof(T_tmprxnin)==1) then
      if (T_tmprxntab.mol[Index(T_tmprxntab.tmprxnidx==i_cpd)] == T_tmprxnin.mol[1]) then
        delete T_tmprxnin l_warn=no
        continue
      endif
    endif
    group T_tmprxnin.mol all "first"  name="T_tmprxnintmp"
    T_tmprxnin = T_tmprxnintmp.mol!=Chemical(S_smilesfilter)
    delete T_tmprxnintmp l_warn=no
    if (Nof(T_tmprxnin)==0) then
      delete T_tmprxnin l_warn=no
      continue
    endif
    add column T_tmprxnin Iarray(Nof(T_tmprxnin) i_cpd) name="tmprxnidx"
    join left T_tmprxnin.tmprxnidx T_tmprxntab.tmprxnidx
    delete T_join.T_tmprxntab_mol
    if (i_mode == 1) then
      i_position = Index(T_tmprxntab.tmprxnidx==i_cpd)[1]
      delete T_tmprxntab[i_position]
    elseif (i_mode == 2) then
      i_position = Index(T_tmprxntab.tmprxnidx==i_cpd)[1]+1
    endif
    add T_tmprxntab T_join i_position
    delete T_tmprxnin T_join l_warn=no
    print bar M  l_info=yes
  endfor
  delete $s_tab
  if (Type(T_tmprxntab.OrigID)!="unknown") delete T_tmprxntab.OrigID
  rename T_tmprxntab.tmprxnidx "OrigID"
  rename T_tmprxntab s_tab
  if (!l_loaded) delete MolRxn l_warn=no
  keep $s_tab
  print bar "done\n"  l_info=yes
endmacro
#
macro predictProdrug s_tab ("") s_tag ("carboxylate") I_rxnrow (Iarray()) i_mode (2) auto
HELP = """
  convert functional group into its prodrug form
  Arguments and options:
    <s_tab> : string with table name, e.g. 't'
    <s_tag> : functional group selected by tag column
    <I_rxnrow> : reaction table row selection, mutually exclusive with <s_tag> argument
               : Alternatively, one can manually select reactions from the MolProdrug panel, the tag will then be ignored
    <i_mode> : 1 replace the original compound with the transformed compound
               2 add transformed compounds after the original compound

  Example:
    predictProdrug 't' 'carboxylate'
"""
  l_commands = no; l_warn = no; l_info = no

  if (s_tab == "") return "Table not specified"
  if (Type($s_tab)!="table") return "Table not found"
  if (Type(MolProdrug)!="table") then
    l_loaded = no
    if (!Exist(s_icmhome+"/models/MolProdrug.icb")) return s_icmhome+"/models/MolProdrug.icb not found"
    read binary s_icmhome+"/models/MolProdrug.icb"
  else
    l_loaded = yes
  endif
  if (I_rxnrow == Iarray()) then
    I_rxnrow = Index(MolProdrug.sel==1)
  endif
  if ((I_rxnrow==Iarray()) & (s_tag=="")) return "Please specify either reaction row selection or tag"
  if (I_rxnrow==Iarray()) I_rxnrow = Index(MolProdrug.subset ~"*"+s_tag+"*")
  if (I_rxnrow==Iarray()) return "Please specify either reaction row selection or tag"
  T_tmprxntab = $s_tab
  M = Nof(T_tmprxntab)
  N = Nof(I_rxnrow)
  sprintf " Info> predicting %d chemicals vs %d reactions in table '%s' ",M,N,s_tab
  print bar s_out  M l_info=yes
  add column T_tmprxntab Count(Nof(T_tmprxntab)) name="tmprxnidx" index=2
  if (Type(T_tmprxntab.ProdrugID)!="unknown") delete T_tmprxntab.ProdrugID
  add column T_tmprxntab Iarray(Nof(T_tmprxntab) 0) name="ProdrugID" index=3
  for i_cpd = 1, Max(T_tmprxntab.tmprxnidx)
    if (T_tmprxntab.mol[Index(T_tmprxntab.tmprxnidx==i_cpd)] == Chemical("")) continue
    group table "T_tmprxnin" T_tmprxntab.mol[Index(T_tmprxntab.tmprxnidx==i_cpd)] "mol"
    for i_rxn = 1, Nof(I_rxnrow)
      i_rxnrow = I_rxnrow[i_rxn]
      make reaction T_tmprxnin MolProdrug.rxn[i_rxnrow] all name="tmprxnouttmp"
      if (Nof(tmprxnouttmp)==0) then
        delete tmprxnouttmp l_warn=no
        continue
      endif
      if  (Type(tmprxnout)=="unknown") then
        rename tmprxnouttmp tmprxnout
      else
        add tmprxnout tmprxnouttmp
        delete tmprxnouttmp
      endif
    endfor
    if (Type(tmprxnout)=="unknown") continue
    tmprxnout.rct1 = Iarray(Nof(tmprxnout) i_cpd)
    add column tmprxnout tmprxnout.rct1 name="tmprxnidx"
    join left tmprxnout.rct1 T_tmprxntab.tmprxnidx
    delete T_join.T_tmprxntab_mol
    T_join.ProdrugID = Count(Nof(T_join))
    add T_tmprxntab T_join Index(T_tmprxntab.tmprxnidx == i_cpd)[1]+1
    if (i_mode==1) delete T_tmprxntab[Index(T_tmprxntab.tmprxnidx == i_cpd)[1]]
    delete T_tmprxnin tmprxnout T_join l_warn=no
    print bar M  l_info=yes
  endfor
  if (Type(T_tmprxntab.OrigID)!="unknown") delete T_tmprxntab.OrigID
  rename T_tmprxntab.tmprxnidx "OrigID"
  add column T_tmprxntab function="Nof_RotB(mol)" index=2 name="nof_RotB" append
  add column T_tmprxntab function="MolPSA(mol)" index=2 name="molPSA" append format="%.2f"
  add column T_tmprxntab function="MolLogS(mol)" index=2 name="molLogS" append format="%.2f"
  add column T_tmprxntab function="MolLogP(mol)" index=2 name="molLogP" append format="%.2f"
  add column T_tmprxntab function="MolWeight(mol)" index=2 name="molWeight" append format="%.3f"
  add column T_tmprxntab function="predictModelsCol(mol,\"mcpCACO2\")" index=2 name="molCACO2" append vector
  R_tmpmacro = Rarray(Nof(T_tmprxntab) 0.)
  R_tmpmacro = R_tmpmacro + Power((T_tmprxntab.molCACO2+5.05841)/0.363481 2)
  R_tmpmacro = R_tmpmacro + Power((T_tmprxntab.molWeight-345.3)/121.9 2)
  R_tmpmacro = R_tmpmacro + Power((T_tmprxntab.molLogP - 2.045)/2.652 2)
  R_tmpmacro = R_tmpmacro + Power((T_tmprxntab.molLogS + 3.531)/1.986 2)
  R_tmpmacro = R_tmpmacro + Power((T_tmprxntab.molPSA - 66.22)/44.63 2)
  R_tmpmacro = R_tmpmacro + Power((Toreal(T_tmprxntab.nof_RotB) - 5.43)/4.087 2)
  R_tmpmacro = Sqrt(R_tmpmacro/6.)
  add column T_tmprxntab R_tmpmacro name="drugprop_dev" index=2
  add column T_tmprxntab index=2 Array( T_tmprxntab [{"drugprop_dev","molCACO2","molWeight","molLogP","molLogS","molPSA","nof_RotB"} ] ) \
  name="drug_properties"
  set format T_tmprxntab.drug_properties color="rainbow='#DCFFDC/#FFFFDC/#FFDCDC,1.:3.,pinwheel'" \
comment="drugprop_dev is the RMS deviation from average approved drug's properties\n0: closely resemble approved drug's properties\n2: 2 standard deviation away from approved drug's properties"
  delete T_tmprxntab.drugprop_dev T_tmprxntab.molWeight T_tmprxntab.molLogS T_tmprxntab.nof_RotB
  delete $s_tab
  rename T_tmprxntab s_tab
  if (!l_loaded) delete MolProdrug l_warn=no
  keep $s_tab
  print bar "done\n"  l_info=yes
endmacro
#
macro predCov s_tab ("")
HELP = """
  Usage:
    predicts the potential covalent group(s) in a chemical table

  Syntax:
    predCov <s_tab>

  Output:
    returns a column named 'MolCovalent' with name of potential covalent group(s) for each chemical
"""
  l_info = l_commands = l_warn = no
  s_tab = Trim(s_tab all)
  if (s_tab == "") return "Please specify table name"
  if (Type($s_tab)!="table") return "Table specified not found"
  if (Type(MolCovalent) == "unknown") then
    if (Exist(s_icmhome+"models/MolCovalent.icb")) then
      read binary s_icmhome+"models/MolCovalent.icb"
    elseif Exist("MolCovalent.icb") then
      read binary "MolCovalent.icb"
    else
      return error "table MolCovalent not found"
    endif
  endif
  T_tmpmacro = $s_tab
  MolCovalent1 = MolCovalent.Covalent != 0
  add column T_tmpmacro Find(T_tmpmacro.mol MolCovalent1.mol MolCovalent1.Name) name="MolCovalent"
  MolCovalent2 = MolCovalent.Prodrug != 0
  add column T_tmpmacro Find(T_tmpmacro.mol MolCovalent2.mol MolCovalent2.Name) name="MolProdrug"
  set format T_tmpmacro.MolCovalent comment="Potential Covalent group(s)"
  set format T_tmpmacro.MolProdrug comment="Potential Prodrug group(s)"
  delete MolCovalent1 MolCovalent2 l_warn=no
  delete $s_tab
  rename T_tmpmacro s_tab
  keep $s_tab
endmacro
#
function predCovfunc P_chem
  if (Type(MolCovalent) == "unknown") then
    if (Exist(s_icmhome+"models/MolCovalent.icb")) then
      read binary s_icmhome+"models/MolCovalent.icb"
    elseif Exist("MolCovalent.icb") then
      read binary "MolCovalent.icb"
    else
      return error "table MolCovalent not found"
    endif
  endif
  add column T_macrotmp P_chem
  MolCovalent1 = MolCovalent.Covalent != 0
  add column T_macrotmp Find(T_macrotmp.mol MolCovalent1.mol MolCovalent1.Name) name="MolCovalent"
  MolCovalent2 = MolCovalent.Prodrug != 0
  add column T_macrotmp Find(T_macrotmp.mol MolCovalent2.mol MolCovalent2.Name) name="MolProdrug"
  return  Collection( "MolCovalent" T_macrotmp.MolCovalent "MolProdrug" T_macrotmp.MolProdrug )
endfunction
#
macro predmcp s_tab ("")
HELP = """
  Usage:
    predicts the toxicity using all user-accessible ADMET (mcp) models

  Syntax:
    predmcp <s_tab>

  Output:
    add columns from ADMET (mcp) models to the original table
    add a MolToxSummary column to summarize significant predicted toxicity
"""
  l_info = l_commands = l_warn = no
  s_tab = Trim(s_tab all)
  if (s_tab == "") return "Please specify chemical table"
  if (Type($s_tab)!="table") return "Table specified not found"
  if (Type(ADMET_properties)!="table") readModelPanel "ADMET_properties" no no
  predictModels s_tab ADMET_properties.model yes no no no
  T_toxmacro = $s_tab
  add column T_toxmacro Sarray(Nof(T_toxmacro) "") name="MolToxSummary"
  add column T_toxmacro Sarray(Nof(T_toxmacro) "") name="MolToxSummarytargetname"; set format T_toxmacro.MolToxSummarytargetname show off
  if (Type(T_toxmacro.LD50_mcp)=="rarray") then
    I_tmpmacro = Index(T_toxmacro.LD50_mcp < 50.)
    T_toxmacro.MolToxSummary[I_tmpmacro] = Sarray(Nof(I_tmpmacro) "LD50 (mg/kg): ")+ Tostring(Tointeger(T_toxmacro.LD50_mcp [I_tmpmacro]*100.)/100.)\
     +Sarray(Nof(I_tmpmacro) "\n")
    T_toxmacro.MolToxSummarytargetname[I_tmpmacro] = Sarray(Nof(I_tmpmacro) "LD50 (mg/kg)\n")
  endif
  S_toxclass = {"HERG","CYP*","PGP*","Tox21*"}
  for i_toxclass = 1, Nof(S_toxclass)
    s_toxclass = S_toxclass[i_toxclass]
    I_tmpmacro2 = Index(Index(ADMET_properties.model "mcp"+s_toxclass regexp) 1 all)
    if (Nof(I_tmpmacro2)==0) continue
    for i_tmpmacro2 = 1, Nof(I_tmpmacro2)
      s_modname = Replace(ADMET_properties.model[I_tmpmacro2[i_tmpmacro2]] "^mcp" "")+" Class: "
      s_modname2 = ADMET_properties.NAME[I_tmpmacro2[i_tmpmacro2]]
      s_col = "T_toxmacro."+Replace(ADMET_properties.model[I_tmpmacro2[i_tmpmacro2]] "^mcp" "")+"_mcp"
      if (Type($s_col)=="rarray") then
        I_tmpmacro = Index($s_col > 0.5)
        T_toxmacro.MolToxSummary[I_tmpmacro] = T_toxmacro.MolToxSummary[I_tmpmacro]+Sarray(Nof(I_tmpmacro) s_modname)\
         +Tostring(Tointeger($s_col[I_tmpmacro]*100.)/100.)+Sarray(Nof(I_tmpmacro) "\n")
        T_toxmacro.MolToxSummarytargetname[I_tmpmacro] = T_toxmacro.MolToxSummarytargetname[I_tmpmacro]+Sarray(Nof(I_tmpmacro) s_modname2+"\n")
      endif
    endfor
  endfor
  set format T_toxmacro.MolToxSummary comment="LD50: Predicted in mg/kg\nClass: 0.5-1.0 is considered active\nPlease hover over individual column header for explanation"
  if (Type(T_toxmacro.toolsPanel)=="unknown") then
    add header T_toxmacro String("") name="toolsPanel" append
    T_toxmacro.toolsPanel = """
# X_This_Table (*) [RDONLY]
# C_Unique_Compound_ID_Column () [IARRAY,SARRAY,TABLE:1]
# b_Generate_Html_Report (msReport Name(variable %@) Field(Name(variable $2) 2 "."))
"""
  endif
  delete $s_tab; rename T_toxmacro s_tab
  keep $s_tab
endmacro
#
function readPredictionModels s_prefix l_checked
  S_modelsDir = Split(TOOLS.modelsDir ";")
  li = Sarray(0)
  if (s_prefix == "panel") then
    for i_modelsDir=1,Nof(S_modelsDir)
      li //= Name(Sarray( S_modelsDir[i_modelsDir] + "*.icb" directory ))
    endfor
    delete li index=Index(li "kcc" regexp all)//Index(li "dfa" regexp all)//Index(li "dfz" regexp all)//Index(li "dpc" regexp all)//Index(li "mcp" regexp all)//Index(li "ncc" regexp all)
  elseif (s_prefix == "") then
    for i_modelsDir=1,Nof(S_modelsDir)
      li //= Name(Sarray( S_modelsDir[i_modelsDir] + s_prefix + "*.icb" directory ))
    endfor
    li = li[Index(li "kcc" regexp all)//Index(li "dfa" regexp all)//Index(li "dfz" regexp all)//Index(li "dpc" regexp all)//Index(li "mcp" regexp all)//Index(li "ncc" regexp all)]
  else
    li = Name(Sarray( s_icmhome+"models/" + s_prefix + "*.icb" directory ))
  endif
  mm = Collection()
  for i=1,Nof(li)
    mm[ li[i] ] = l_checked
  endfor
  return mm
endfunction
#
macro msSettings l_read (no) auto
HELP = """
  Load the molScreenSettings file or use it to set the P_mspara for predictModels or _molScreen
  Syntax:
    msSettings <l_read>

    <l_read>: if yes, read the molScreenSettings.icb file from s_userDir+'inx' or s_icmhome+'models' directory
              if user modified this file and want to use the modified settings for subsequent run, they can save it in s_userDir+'inx' directory so that it will be loaded from there next time

    <l_read>: if no, return P_mspara to be used by predictModels or _molScreen accordingly:
                 if molScreenSettings is loaded in current ICM session and some of the rows in the Override column have been checked, P_mspara will return the selected rows as a collection
                 if molScreenSettings is not loaded in current ICM session, or none of the rows have been chekced, an empty collection P_mspara will be returned
"""
  l_info=no;l_commands=no;l_warn=no
  if (l_read) then
    if Exist(s_userDir+"inx/molScreenSettings.icb") then
      read binary s_userDir+"inx/molScreenSettings.icb"
    elseif Exist(s_icmhome+"models/molScreenSettings.icb") then
      read binary s_icmhome+"models/molScreenSettings.icb"
    else
      return "molScreenSettings file not found"
    endif
    keep molScreenSettings
  else
    if (Type(P_mspara)!="unknown") delete P_mspara l_warn=no
    P_mspara = Collection()
    keep P_mspara
    if (Type(molScreenSettings)!="table") return
    I_tmpmacro = Index(molScreenSettings.Override 1 all)

    for i_para = 1, Nof(I_tmpmacro)
      s_field = molScreenSettings.Field_Name[I_tmpmacro[i_para]]
      if (s_field=="") return "Empty field name, please specify a proper name"
      if (molScreenSettings.Field_Value[I_tmpmacro[i_para]]=="") return "Empty field value, please specify a proper value"
      if (molScreenSettings.Field_Type[I_tmpmacro[i_para]]=="real") then
        if (Toreal(molScreenSettings.Field_Value[I_tmpmacro[i_para]])!=Toreal("ND")) then
          P_mspara[s_field] = Toreal(molScreenSettings.Field_Value[I_tmpmacro[i_para]])
        else
          return "Value and type for row "+Tostring(I_tmpmacro[i_para])+" are incompatible"
        endif
      elseif  (molScreenSettings.Field_Type[I_tmpmacro[i_para]]=="integer") then
        if (Toreal(molScreenSettings.Field_Value[I_tmpmacro[i_para]])!=Toreal("ND")) then
          P_mspara[s_field] = Tointeger(molScreenSettings.Field_Value[I_tmpmacro[i_para]])
        else
          return "Value and type for row "+Tostring(I_tmpmacro[i_para])+" are incompatible"
        endif
      elseif  (molScreenSettings.Field_Type[I_tmpmacro[i_para]]=="logical") then
        if ((molScreenSettings.Field_Value[I_tmpmacro[i_para]]=="yes")|(molScreenSettings.Field_Value[I_tmpmacro[i_para]]=="1")) then
          P_mspara[s_field] = yes
        elseif ((molScreenSettings.Field_Value[I_tmpmacro[i_para]]=="no")|(molScreenSettings.Field_Value[I_tmpmacro[i_para]]=="0")) then
          P_mspara[s_field] = no
        else
          return "Value and type for row "+String(I_tmpmacro[i_para])+" are incompatible"
        endif
      else
         return "Type: "+molScreenSettings.Field_Type[I_tmpmacro[i_para]]+" not supported"
      endif
    endfor
    keep P_mspara
  endif
endmacro
#
macro predictModels s_tab ("") S_models  l_color (yes) l_lookuponly (no) l_deleteEmptyCol (no) l_pose (yes) l_progress (yes) s_modelsDir ("") l_removeinactives (no) l_charge (yes) l_cluster (no) P_parameters (Collection()) i_start (0) i_end (0) auto
HELP = """
  applies ICM models to the chemicals from the input table and
  appends columns for each model to the chemical table.
  Arguments and options:
    <s_tab> : string with table name, e.g. 't'
    <S_models> : string array with model names or model file names,
      if the model directory location is different from $ICMHOME/models/
      append the path to the model array, e.g. {'andr','estro','/home/don/mod/'}
    <l_removeinactives> : Remove compounds from the resultant msLigandModel table if they are predicted to be inactive
    <l_charge> : Set auto pKa charge before prediction
    <l_cluster> : If yes, turn off multi-core for dpc models
    <P_parameters> : Set parameter of model in the current session

  Example:
    add column t Chemical('Oc1ccc(cc1)C(c2ccc(O)cc2)(C)C') 'Bisphenol A'
    predictModels 't' 'dfaESR1'//'dfaESR2'
    predictModels 't' 'dfaANDR'//'dfaESR1'//'/home/don/mymodels/'
    predictModels 't' '/home/jon/tmp/a.icb'//'./b.icb'//'./c.icb'
    predictModels 't' 'dfaESR1'//'dpcESR1' Collection('effort',10.,'dock.effort',10.) # Set effort in dfa and dock.effort in dpc to 10
"""
 #
 l_info = l_commands = no
 l_tmp = Error()
 s_moddir = s_modelsDir == "" ? s_icmhome+"models/" : s_modelsDir
 s_tab = Trim(s_tab all)
 if (s_tab == "") return " Warning> no chemical table specified. Nothing to do"
 s_taborig = s_tab
 s_tab = Name(Field(s_taborig 1 " "))
 if ((Type($s_tab)=="table")&(Extension(s_taborig)=="")) then	#table loaded in icm,
   if (i_start!=0) then
     if (i_end==0) i_end=i_start
     s_tabold = s_tab
     s_tab = Name(s_tab unique)
     $s_tab = $s_tabold[i_start:i_end]
     keep $s_tab
   endif
 else					#icb, sdf, inx, molt, or molcart
   if Exist(s_taborig) then
     s_tabnam = Name(s_taborig)
     if (Type($s_tabnam)!="unknown") delete $s_tabnam l_warn=no
     s_tab = s_taborig
     if (Extension(s_tab)==".icb") then
       read binary s_tab
       s_tab = Name(s_tab)
       if (Type($s_tab)!="table") return "Binary file should contain chemical table with the same name"
       add column $s_tab Count(Nof($s_tab)) name="idxtmp"
       if (i_start!=0) then
         if (i_end==0) i_end=i_start
         $s_tab = $s_tab[Min(i_start Nof($s_tab)):Min(i_end Nof($s_tab))]
         keep $s_tab
       endif
     elseif (Extension(s_tab)==".sdf") then
       read table mol s_tab
       s_tab = Name(s_tab)
       if (Type($s_tab)!="table") return "sdf should contain chemical table with the same name"
       add column $s_tab Count(Nof($s_tab)) name="idxtmp"
       if (i_start!=0) then
         if (i_end==0) i_end=i_start
         $s_tab = $s_tab[Min(i_start Nof($s_tab)):Min(i_end Nof($s_tab))]
         keep $s_tab
       endif
     elseif (Extension(s_tab)==".inx") then
       read index s_tab name="LIGINP"
       if (i_start==0) then
         i_start = 1; i_end = Nof(LIGINP)
       else
         if (i_end==0) i_end = i_start
       endif
       s_tab = Name(s_tab)
       read table mol LIGINP [Min(i_start Nof(LIGINP)):Min(i_end Nof(LIGINP))] name=s_tab
       add column $s_tab Count(Min(i_start Nof(LIGINP)) Min(i_end Nof(LIGINP))) name="idxtmp"
       keep $s_tab
     elseif (Extension(s_tab)==".molt") then
       connect molcart filename=s_tab
       if (!Exist(s_tabnam sql table)) return "cannot find table " + s_tabnam + " in molt:" + s_tab
       I_molids = Sql("select molid as molid from " + s_tabnam ).molid
       n_total = Nof( I_molids )
       if (i_start == 0) then
         i_start = 1; i_end = n_total
       else
         i_start = Min(i_start n_total)
         if (i_end == 0) then
           i_end = i_start
         else
           i_end = Min(i_end n_total)
         endif
       endif
       I_molids = I_molids[i_start:i_end]
       find molcart table=s_tabnam filename=s_tab query=" `t`.`molid` >= "+Tostring(i_start) +" AND  `t`.`molid` <= "+Tostring(i_end)+"  " number=100000 name=s_tabnam field=s_tabnam+".*"
       s_tab = Name(s_tab)
       add column $s_tab I_molids name="idxtmp"; delete $s_tab.molid l_warn=no
       $s_tab = $s_tab.mol != Chemical("")
       keep $s_tab
       connect molcart s_tabnam off
     endif
   else
     if (Nof(Split(s_taborig " "))==5) then
       if !Sql( connect, Field(s_taborig,1), Field(s_taborig,2), Field(s_taborig,3), Field(s_taborig,4) ) return "Molcart table specified not found"
       s_tab = Field(s_taborig,5)
       s_tabnam = Field(s_taborig,5)
       maxmolid = Sql("select max(molid) as molid from " + Field(s_taborig,5)).molid[1]
       if (i_start == 0) then
         i_start = 1; i_end = maxmolid
       else
         i_start = Min(i_start maxmolid)
         if (i_end == 0) then
           i_end = i_start
         else
           i_end = Min(i_end maxmolid)
         endif
       endif
       I_molids = Count(Max(1,i_start), Min(maxmolid,i_end))
       delete $s_tabnam l_warn=no
       find molcart table=Field(s_taborig,4)+"."+Field(s_taborig,5)  query=" `t`.`molid` >= "+Tostring(i_start)+" AND  `t`.`molid` <= "+Tostring(i_end)+"  " number=100000 name=s_tabnam field=Field(s_taborig,5)+".*"
       I_molids = Tointeger($s_tab.molid)
       add column $s_tab I_molids name="idxtmp"; delete $s_tab.molid l_warn=no
       $s_tab = $s_tab.mol != Chemical("")
       keep $s_tab
       connect molcart off
     else
       return "Table not found, plesase specify either an ICM table, an icb/sdf/inx/molt file or a molcart table"
     endif
   endif
 endif
 if ((Type($s_tab) != "table") | (s_tab == ""))return " Warning> no chemical table specified. Nothing to do"
 N = Nof( S_models ); if(N==0) return " Warning>  no models specified"
# if Type(  $s_tab.Mod_Summary ) == "unknown" add column $s_tab Array( Nof( $s_tab ) ,Collection()) name="Mod_Summary"
# set format $s_tab.Mod_Summary show off
 if Type(  $s_tab.mol ) != "parray" return " Warning> chemical .mol column not found in the table. Nothing to do"
 if (Nof($s_tab.mol==Chemical(""))!=0) return " Warning> empty chemical entries in .mol column found. Please remove those entries"
 P_tabmol = $s_tab.mol
 modify $s_tab.mol delete salt
 modify $s_tab.mol delete salt simple
 delete hydrogen $s_tab.mol
 modify $s_tab.mol auto
 if (Nof(Index(Name(S_models) "[dm][cfp][acz]" regexp all))==0) then
 else
   if (l_charge) set charge formal auto $s_tab.mol 7.0
 endif
 if (Nof($s_tab.mol==Chemical(""))!=0) return " Warning> empty chemical entries in .mol column after standardizing. Please remove salt and standardize your table and remove those entries"
 if( N>1 & Exist( S_models[$] directory) ) then
   if (S_models[$][1:3] !~ "[dkmnr][cfp][acpz]") then
     s_moddir = S_models[$]
     S_models = S_models[1:$-1]
   endif
 endif
 M=Nof( $s_tab )
 sprintf " Info> screening %d chemicals vs %d models in table '%s' ",M,N,s_tab
 if(l_progress) print bar s_out  N l_info=yes
 if (Nof(S_models)>100) l_pose = yes
 if (Nof(Index(Index(Name(S_models) "d[fp][zac]" regexp) 1 all))>2000) then;print "More than 2000 docking models, inactives will be removed";l_removeinactives = yes;endif
 if ((Nof(Index(Index(Name(S_models) "ncc" regexp) 1 all))>0) & M>1) then
   print " Info> Neural Network model used, inactives will be removed"
   l_removeinactives=yes
 endif
 if ((M*N)>2000000) then;print " Info> More than 2M row in result Pairwise tables, inactives will be removed";l_removeinactives = yes;endif
 S_cols = Sarray()
 for i = 1, Nof(S_models)
   s_mod = S_models[i]
   s_mod1=Trim(Name(s_mod) all)
   l_loaded = no
   if (Type($s_mod1)!="unknown") then
     l_loaded = yes
   elseif ((Exist(s_mod))&(Extension(s_mod)==".icb")) then
     read binary s_mod
   elseif (Exist(s_moddir+s_mod1+".icb")) then
     read binary s_moddir+s_mod1+".icb"
   elseif (Exist(s_mod1+".icb")) then
     read binary s_mod1+".icb"
   elseif (Exist(s_icmhome+"models/"+s_mod1+".icb")) then
     read binary s_icmhome+"models/"+s_mod1+".icb"
   else
     S_modelsDir = Split(TOOLS.modelsDir ";")
     for i_modelsDir = 1, Nof(S_modelsDir)
       if (Exist(S_modelsDir[i_modelsDir]+s_mod1+".icb")) then
         read binary S_modelsDir[i_modelsDir]+s_mod1+".icb"
         break
       endif
     endfor
   endif
   s_mod = s_mod1
   if (Type($s_mod)=="unknown") then
     print " Warning> cannot find file " + s_mod
     continue
   endif
   if (Type($s_mod )!="parray") then
     print " Warning> "+s_mod+" is not a model file"
     delete $s_mod
     continue
   endif
   if (s_mod[1:3]=="kcc"|s_mod[1:3]=="mcp") then
     if ($s_mod["version"]==Toreal("ND")) then
       print " Warning> "+s_mod+" is incompatible with the latest ICM, please download the latest model and/or remake model"
       delete $s_mod
       continue
     endif
   endif
   s_modname = Replace(s_mod s_mod[1:3] "")+"_"+s_mod[1:3]
   s_col = s_tab + "." + s_modname
   if (l_lookuponly) s_col = s_tab + "." + s_modname + "_lookup"
   if (Type($s_col) != "unknown") delete $s_col
   if (!l_lookuponly) then
     if (l_pose) $s_mod["l_pose"] = yes
     if (!l_charge) $s_mod["l_charge"] = no
     if ((l_cluster) & s_mod[1:3]=="dpc") $s_mod["dock.n_parallel"] = 1
     if ((l_cluster) & s_mod[1:3]=="dfa") $s_mod["n_parallel"] = 1
#     if ((Field(Version() 2 "/")~"Win*") & s_mod[1:3]=="dpc") $s_mod["dock.n_parallel"] = 1
     s_currDir = Path()
     set directory s_tempDir
     s_colATOMCONTRIB = s_tab+".ATOM_CONTRIB"
     s_colMolSim = s_tab+".MolSim"
     s_colMolnn = s_tab+".Molnn"
     delete $s_colATOMCONTRIB l_warn=no l_info=no
#     if ((P_parameters == Collection())&(Type(molScreenSettings)!="table")) then
     if (P_parameters == Collection()) then
       if (Type(molScreenSettings)!="table") msSettings yes
       msSettings no
       P_parameters = P_mspara
     endif
     for i_collection = 1, Nof(P_parameters)
       s_parameter = Name(P_parameters)[i_collection]
       $s_mod[s_parameter] = P_parameters[s_parameter]
     endfor
     if (Type($s_tab.$s_mod)!="unknown") delete $s_tab.$s_mod
     if (s_mod[1:3] == "kcc") then
       s_modname2 = Replace(s_mod s_mod[1:3] "")+"_"+Replace(s_mod[1:3] "kcc" "kca")
       delete $s_tab.$s_modname $s_tab.$s_modname2 l_warn=no
     elseif (s_mod[1:3] == "dfa") then
       s_modname2 = Replace(s_mod s_mod[1:3] "")+"_"+Replace(s_mod[1:3] "dfa" "dfc")
       delete $s_tab.$s_modname $s_tab.$s_modname2 l_warn=no
     elseif (s_mod[1:3] == "dpc") then
       s_modname2 = Replace(s_mod s_mod[1:3] "")+"_"+Replace(s_mod[1:3] "dpc" "dpa")
       delete $s_tab.$s_modname $s_tab.$s_modname2 l_warn=no
     endif
     if ((s_mod[1:3] == "ncc")|($s_mod["modeltype"]=="ncc")) then
       s_colncctop = s_tab+".0"+s_mod+"_tophit"
       s_colncctop2 = s_tab+"."+s_mod+"_tophit"
       s_colmcpall = s_tab+".0"+s_mod+"_all"
       s_colmcpall2 = s_tab+"."+s_mod+"_all"
       delete $s_colncctop $s_colncctop2 $s_colmcpall $s_colmcpall2 l_warn=no
       for i_target = 1, Nof($s_mod["S_targetlist"])
         s_rmcol = s_tab+"."+$s_mod["S_targetlist"][i_target]+"_"+s_mod
         delete $s_rmcol l_warn=no
         if (s_mod[1:3]=="ncc") then
           s_rmcol = s_tab+"."+$s_mod["S_targetlist"][i_target]+"_"+Replace(s_mod "ncc" "nca")
           delete $s_rmcol l_warn=no
         endif
       endfor
     endif
     add column $s_tab Predict($s_tab.mol $s_mod) name=s_modname
     if (Type(a_tmpqsarlig.)!="unknown") delete a_tmpqsarlig.
     set directory s_currDir
     if (Type($s_col) == "unknown") rename $s_tab.$s_mod s_modname
     if ((s_mod[1:3] == "ncc")|($s_mod["modeltype"]=="ncc")) then
       s_colncctop = s_tab+".0"+s_mod+"_tophit"
       s_colncctop2 = s_tab+"."+s_mod+"_tophit"
       s_colmcpall = s_tab+".0"+s_mod+"_all"
       s_colmcpall2 = s_tab+"."+s_mod+"_all"
       if (Type($s_colncctop)=="sarray") then
         delete $s_colncctop2 l_warn=no
         rename $s_colncctop s_mod+"_tophit"
         s_colncctop = s_tab+"."+s_mod+"_tophit"
         set format $s_colncctop name=Field(Field(s_colncctop 2 ".") 1 "_")+"_Class" \
         comment="Top targets predicted for model: "+s_mod+"\nScore: Probability of being a positive, assume 0.5% hitrate in the population\nRange: 0-1, suggested threshold 0.2"
       endif
       if (Type($s_colmcpall)=="sarray") then
         delete $s_colmcpall2 l_warn=no
         rename $s_colmcpall s_mod+"_all"
         s_colmcpall = s_tab+"."+s_mod+"_all"
         set format $s_colmcpall name=Field(Field(s_colmcpall 2 ".") 1 "_") comment="All predicted results for model: "+s_mod
       endif
       s_colncatop = s_tab+".0"+Replace(s_mod "ncc" "nca")+"_tophit"
       s_colncatop2 = s_tab+"."+Replace(s_mod "ncc" "nca")+"_tophit"
       if (Type($s_colncatop)=="sarray") then
         delete $s_colncatop2 l_warn=no
         rename $s_colncatop Replace(s_mod "ncc" "nca")+"_tophit"
         s_colncatop = s_tab+"."+Replace(s_mod "ncc" "nca")+"_tophit"
         set format $s_colncatop name=Field(Field(s_colncatop 2 ".") 1 "_")+"_cpKd" \
         comment="Top targets predicted for model: "+s_mod+"\nScore: Predicted pKd, pKi, pIC50, pEC50, etc\nND or empty cell indicates inactive or disimilarity to known binders"
       endif
     endif
     if (l_pose) then
       predictModelPose s_tab s_mod yes l_removeinactives
       s_colcl = s_tab+"."+s_modname+"_cl"
       s_colpose = s_tab+"."+s_modname+"_pose"
       s_colnearest = s_tab+"."+s_modname+"_nearest"
       delete $s_colcl $s_colpose $s_colnearest l_warn=no l_info=no
       delete $s_colATOMCONTRIB l_warn=no l_info=no
       if (s_mod[1:3]!="mcp") delete $s_colMolSim $s_colMolnn l_warn=no l_info=no
       if (s_mod[1:3]=="dpc") then
         s_dockScore = s_tab+"."+Replace(s_modname "_dpc" "_dockScore")
         if (Type($s_dockScore)!="unknown") delete $s_dockScore l_warn=no l_info=no
         s_dockNNScore = s_tab+"."+Replace(s_modname "_dpc" "_dockNNScore")
         if (Type($s_dockNNScore)!="unknown") delete $s_dockNNScore l_warn=no l_info=no
       endif
       if (Type(msLigandModel)=="unknown") print " Info> No msLigandModel table after removing inactives"
     endif
     s_colMolTmplScore = s_tab+".MolTmplScore"
     delete $s_colMolTmplScore l_warn=no l_info=no
   else
     if (s_mod[1:3]=="mcp") then
       if ($s_mod["PREDCOL"] != Toreal("ND")) then
         s_PREDCOL = $s_mod["PREDCOL"]
         if (!Exist($s_mod[s_PREDCOL])) then
           print " Warning> Cannot find embedded data for" s_mod
           if (!l_loaded) delete $s_mod
           continue
         endif
       else
         print " Warning> Cannot find embedded data for" s_mod
         if (!l_loaded) delete $s_mod
         continue
       endif
     elseif  (s_mod[1:3]!="mcp") then
       if(!Exist($s_mod["SMILES"]) | !Exist($s_mod["PKD"])) then
         print " Warning> Cannot find embedded data for" s_mod
         if (!l_loaded) delete $s_mod
         continue
       endif
     endif
     if (s_mod[1:3]=="mcp") then
       group table T_tmpmacro Chemical($s_mod["SMILES"]) "mol" Toreal($s_mod[s_PREDCOL]) "pkdmacro"
     else
       group table T_tmpmacro Chemical($s_mod["SMILES"]) "mol" Toreal($s_mod["PKD"]) "pkdmacro"
     endif
     join left $s_tab.mol T_tmpmacro.mol name="T_joinmacro"
     add column $s_tab T_joinmacro.pkdmacro name=s_modname+"_lookup"
     delete T_tmpmacro T_joinmacro
   endif
   if (l_deleteEmptyCol) then
     if Nof($s_col == Toreal("ND"))==Nof($s_tab) then
       delete $s_col
       if (!l_loaded) delete $s_mod
       continue
     endif
   endif
   S_cols //= s_modname
   #
#   for j=1,Nof( $s_col )
#     if ( $s_col[j] != ND ) $s_tab.Mod_Summary [j,s_modname] =  $s_col[j]
#   endfor
   #
   if (s_mod[1:3]=="kcc")  s_colkca = s_tab+"."+Replace(s_modname "kcc" "kca")
   if (s_mod[1:3]=="dfa")  s_coldfc = s_tab+"."+Replace(s_modname "dfa" "dfc")
   if (s_mod[1:3]=="dpc")  s_coldpa = s_tab+"."+Replace(s_modname "dpc" "dpa")
   s_coltani = s_col+"_TANIsim"
  if (Nof(S_models) > 500) then
   delete $s_col $s_colkca $s_coldfc $s_coltani l_warn=no l_info=no
  else
   if (l_color & ($s_mod ["COLOR"] != Toreal("ND"))) then
     set format $s_col "%.2f" name="" color=$s_mod["COLOR"]
     if (s_mod[1:3]=="rca") then
       set format $s_col "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
     endif
     if (s_mod[1:3]=="eca") then
       set format $s_col "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
     endif
     if (s_mod[1:3]=="kcc") then
       set format $s_col "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'"
       set format $s_colkca "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
     endif
     if ((s_mod[1:3]=="ncc")|(s_mod[1:3]=="mcp"& $s_mod["modeltype"]=="ncc")) then
       set format $s_col "%.1f" name="" color=$s_mod["COLOR"]
       S_ncccol =  Name($s_tab column)[Index(Name($s_tab column) s_tab+".*_"+s_mod regexp all)]
       S_ncacol =  Name($s_tab column)[Index(Name($s_tab column) s_tab+".*_"+Replace(s_mod "ncc" "nca") regexp all)]
       S_mcpcol =  Name($s_tab column)[Index(Name($s_tab column) s_tab+".*_"+s_mod regexp all)]
       if (s_mod[1:3]=="ncc") then
         for i_ncccol = 1, Nof(S_ncccol)
           s_ncccol = S_ncccol[i_ncccol]
           set format $s_ncccol "%.1f" name=Field(Field(s_ncccol 2 ".") 1 "_")+"_Class" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'"
         endfor
         if (Nof(S_ncacol)>0) then
           i_colidx = Index( Name($s_tab column) S_ncccol[1])
           S_ncacol = Sort(S_ncacol reverse)
           for i_ncacol = 1, Nof(S_ncacol)
             s_ncacol = S_ncacol[i_ncacol]
             set format $s_ncacol "%.1f" name=Field(Field(s_ncacol 2 ".") 1 "_")+"_cpKd" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
             move $s_ncacol i_colidx
           endfor
         endif
       elseif (s_mod[1:3]=="mcp") then
         for i_mcpcol = 1, Nof(S_mcpcol)
           s_mcpcol = S_mcpcol[i_mcpcol]
           S_mcpcolname = Split(Field(s_mcpcol 2 ".") "_")
           s_mcpcolname = Sum(S_mcpcolname[1:Min(2 Nof(S_mcpcolname))] "_")
#           set format $s_mcpcol "%.1f" name=Field(Field(s_mcpcol 2 ".") 1 "_") color=$s_mod["COLOR"]
           set format $s_mcpcol "%.1f" name=s_mcpcolname color=$s_mod["COLOR"]
         endfor
       endif
     endif
     if (s_mod[1:3]=="dfa") then
       set format $s_col "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
       if (Type($s_coldfc)!="unknown") set format $s_coldfc "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'"
     endif
     if (s_mod[1:3]=="dpc") then
       set format $s_col "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'"
       if (Type($s_coldpa)!="unknown") set format $s_coldpa "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
     endif
     if (s_mod[1:3]=="dfz") then
       set format $s_col "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,1.:3.,pinwheel'"
     endif
     if ((l_lookuponly)&(s_mod[1:3]=="dfz")) set format $s_col "%.2f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
   endif
   if (l_lookuponly) then
     if (!l_loaded) delete $s_mod
     continue
   endif
   s_comment = ""
   if ($s_mod ["NAME"] != Toreal("ND")) s_comment = $s_mod["NAME"]
   s_rcacomment = "Random Forests Regression model of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value"
   s_ecacomment = "Extended 2D Fingerprint Kernel Regression model of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value"
   s_kcccomment = "Kernel Classification model, Score:\nProbability of being a positive, assume 0.5% hitrate in the population\nRange: 0-1, suggested threshold: 0.2"
   s_kcacomment = "Hybrid Regression model of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND or empty cell indicates inactive or disimilarity to known binders"
   s_dfacomment = "Hybrid 4D/2D Regression model of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND or empty cell indicates inactive or disimilarity to known binders"
   s_dfccomment = "4D Classification model, Score:\nProbability of being a positive, assume 0.5% hitrate in the population\nRange: 0-1, suggested threshold: 0.2"
   s_dfzcomment = "Pocketome APF Z-Score model\n>3. indicates 3 standard deviation above approved drugs decoy"
   s_dpccomment = "Hybrid 4D docking Classification model, Score:\nProbability of being a positive, assume 0.5% hitrate in the population\nRange: 0-1, suggested threshold: 0.2"
   s_dpccomment2 = "Hybrid 4D docking Z-Score model\n>3. indicates 3 standard deviation above approved drugs decoy"
   s_dpccomment3 = "Hybrid 4D docking Score\n<-32. generally indicates significance, although score cutoff varies from structure to structure"
   s_dpccomment4 = "Hybrid 4D docking Convoluted Neural Network Score\n<-32. generally indicates significance, although score cutoff varies from structure to structure"
   s_dpacomment = "Hybrid 4D docking Regression model of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND or empty cell indicates inactive or disimilarity to known binders"
   s_ncccomment = "Neural Network Classification Model, Score:\nProbability of being a positive, assume 0.5% hitrate in the population\nRange: 0-1: suggested threshold: 0.2"
   s_ncacomment = "Hybrid Regression model of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND or empty cell indicates inactive or disimilarity to known binders"
   if (s_mod[1:3] == "rca") then
     s_comment = s_comment+"\n"+s_rcacomment
   elseif (s_mod[1:3] == "eca") then
     s_comment = s_comment+"\n"+s_ecacomment
   elseif (s_mod[1:3] == "kcc") then
     s_commentkca = s_comment+"\n"+s_kcacomment
     s_comment = s_comment+"\n"+s_kcccomment
   elseif (s_mod[1:3] == "ncc") then
     s_commentnca = s_comment+"\n"+s_ncacomment
     s_comment = s_comment+"\n"+s_ncccomment
   elseif (s_mod[1:3] == "dfa") then
     s_commentdfc = s_comment+"\n"+s_dfccomment
     s_comment = s_comment+"\n"+s_dfacomment
   elseif (s_mod[1:3] == "dfz") then
     s_comment = s_comment+"\n"+s_dfzcomment
   elseif (s_mod[1:3] == "dpc") then
     s_commentdpa = s_comment+"\n"+s_dpacomment
     if ($s_mod["l_ZScore"] == yes) then
       s_comment = s_comment+"\n"+s_dpccomment2
     else
       if ($s_mod["l_qsar"]!=yes) then
         s_comment = s_comment+"\n"+s_dpccomment3
       else
         s_comment = s_comment+"\n"+s_dpccomment
       endif
     endif
   elseif ($s_mod ["COMMENT"] != Toreal("ND")) then
     s_comment = s_comment+"\n"+$s_mod["COMMENT"]
   endif
   if (s_mod[1:3] == "rca") then
     if (Type($s_mod["SMILES"]) == "sarray") then
       s_comment = s_comment+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" compounds"
     endif
     if ($s_mod["pKdAUC"] != Toreal("ND")) s_comment = s_comment+"\nAUC for external test set using rca score: "+String($s_mod["pKdAUC"])[1:4]
     if ($s_mod["RMSE"] != Toreal("ND")) then
       s_comment = s_comment+"\nRMSE for external test set: "+String($s_mod["RMSE"])[1:4]
     else
       if ($s_mod["Q2"] != Toreal("ND")) s_comment = s_comment+"\nQ2 for external test set: "+String($s_mod["Q2"])[1:4]
     endif
   elseif (s_mod[1:3] == "eca") then
     if (Type($s_mod["SMILES"]) == "sarray") then
       s_comment = s_comment+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" compounds"
     endif
     if ($s_mod["pKdAUC"] != Toreal("ND")) s_comment = s_comment+"\nAUC for external test set using eca score: "+String($s_mod["pKdAUC"])[1:4]
     if ($s_mod["RMSE"] != Toreal("ND")) then
       s_comment = s_comment+"\nRMSE for external test set: "+String($s_mod["RMSE"])[1:4]
     else
       if ($s_mod["Q2"] != Toreal("ND")) s_comment = s_comment+"\nQ2 for external test set: "+String($s_mod["Q2"])[1:4]
     endif
   elseif (s_mod[1:3] == "kcc") then
     if (Type($s_mod["SMILES"]) == "sarray") then
       s_comment = s_comment+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" compounds"
       s_commentkca = s_commentkca+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" compounds"
     endif
     if ($s_mod["AUC"] != Toreal("ND")) s_comment = s_comment+"\nAUC for external test set using kcc score: "+String($s_mod["AUC"])[1:4]
     if ($s_mod["pKdAUC"] != Toreal("ND")) s_commentkca = s_commentkca+"\nAUC for external test set using kca score: "+String($s_mod["pKdAUC"])[1:4]
     if ($s_mod["RMSE"] != Toreal("ND")) then
       s_commentkca = s_commentkca+"\nRMSE for external test set: "+String($s_mod["RMSE"])[1:4]
     else
       if ($s_mod["Q2"] != Toreal("ND")) s_commentkca = s_commentkca+"\nQ2 for external test set: "+String($s_mod["Q2"])[1:4]
     endif
   elseif (s_mod[1:3] == "ncc") then
     if (Type($s_mod["SMILES"]) == "sarray") then
       s_comment = s_comment+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" known compounds and 35008 decoys"
       s_commentnca = s_commentnca+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" compounds"
     endif
   elseif (s_mod[1:3] == "dpc") then
     if ($s_mod["l_qsar"]==yes) then
       if (Type($s_mod["SMILES"]) == "sarray") then
         s_comment = s_comment+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" compounds"
         s_commentdpa = s_commentdpa+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" compounds"
       endif
       if ($s_mod["AUC"] != Toreal("ND")) s_comment = s_comment+"\nAUC for external test set using dpc score: "+String($s_mod["AUC"])[1:4]
       if ($s_mod["pKdAUC"] != Toreal("ND")) s_commentdpa = s_commentdpa+"\nAUC for external test set using dpa score: "+String($s_mod["pKdAUC"])[1:4]
       if ($s_mod["Q2"] != Toreal("ND")) s_commentdpa = s_commentdpa+"\nQ2 for external test set: "+String($s_mod["Q2"])[1:4]
     endif
   elseif (s_mod[1:3] == "dfa") then
     if (Type($s_mod["SMILES"]) == "sarray") then
       s_comment = s_comment+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" compounds"
       s_commentdfc = s_commentdfc+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" compounds"
     endif
     if (Exist( $s_mod["PKDext"])) then
       if ($s_mod["AUC"] != Toreal("ND")) s_comment = s_comment+"\nAUC for external test set using dfa score: "+String($s_mod["AUC"])[1:4]
       if ($s_mod["Q2"] != Toreal("ND")) s_comment = s_comment+"\nQ2 for external test set: "+String($s_mod["Q2"])[1:4]
       if ($s_mod["ClassAUC"] != Toreal("ND")) s_commentdfc = s_commentdfc+"\nAUC for external test set using dfc score: "+String($s_mod["ClassAUC"])[1:4]
     endif
   elseif (s_mod[1:3]== "mcp") then
     if (Type($s_mod["SMILES"]) == "sarray") s_comment = s_comment+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" compounds"
     if (($s_mod["AUC"] != Toreal("ND"))& ($s_mod["AUC"] != 0.)) s_comment = s_comment+"\nAUC for external test set: "+String($s_mod["AUC"])[1:4]
     if (($s_mod["Q2"] != Toreal("ND"))&($s_mod["Q2"] != 0.)) s_comment = s_comment+"\nQ2 for external test set: "+String($s_mod["Q2"])[1:4]
   endif
   if (s_comment != "") set format $s_col "%.2f" name=Field(Field(s_col 2 ".") 1 "_") comment=s_comment
   if (s_comment != "" & s_mod[1:3]=="dfa") then
     set format $s_col "%.1f" name=Field(Field(s_col 2 ".") 1 "_")+"_dfa_cpKd" comment=s_comment
     set format $s_coldfc "%.2f" name=Field(Field(s_col 2 ".") 1 "_")+"_dfa_Class" comment=s_commentdfc
   elseif (s_mod[1:3]=="kcc") then
     set format $s_col "%.2f" name=Field(Field(s_col 2 ".") 1 "_")+"_kcc_Class" comment=s_comment
     set format $s_colkca "%.1f" name=Field(Field(s_col 2 ".") 1 "_")+"_kcc_cpKd" comment=s_commentkca
   elseif (s_mod[1:3]=="dpc") then
     set format $s_col "%.2f" name=Field(Field(s_col 2 ".") 1 "_")+"_dpc_Class" comment=s_comment
     if (Type($s_coldpa)!="unknown") set format $s_coldpa "%.1f" name=Field(Field(s_col 2 ".") 1 "_")+"_dpc_cpKd" comment=s_commentdpa
   elseif (s_mod[1:3]=="dfz") then
     set format $s_col "%.2f" name=Field(Field(s_col 2 ".") 1 "_")+"_dfz_ZScore" comment=s_comment
   endif

   if ((s_mod[1:3]=="ncc")|(s_mod[1:3]=="mcp"& $s_mod["modeltype"]=="ncc")) then
     S_targetlist = $s_mod["S_targetlist"]
     S_Fullname = $s_mod["S_Fullname"]
     if (s_mod[1:3]=="ncc") then
       set format $s_col "%.1f" name=Field(Field(s_col 2 ".") 1 "_")+"_Class" comment=s_comment+"\nProbability score for Top 90 percentile Hit"
       S_ncccol =  Name($s_tab column)[Index(Name($s_tab column) s_tab+".*_"+s_mod regexp all)]
       S_ncacol =  Name($s_tab column)[Index(Name($s_tab column) s_tab+".*_"+Replace(s_mod "ncc" "nca") regexp all)]
       R_AUC = Toreal(Tointeger(Toreal($s_mod["R_AUC"])*100.)/100.)
       group table t_commenttab S_targetlist "Target" Tostring(R_AUC) "AUC" S_Fullname "Fullname"
       if Exist($s_mod["R_Q2"]) then
         R_Q2 = Toreal(Tointeger(Toreal($s_mod["R_Q2"])*100.)/100.)
         add column t_commenttab Tostring(R_Q2) name="Q2" index=3
       endif
       for i_ncccol = 1, Nof(S_ncccol)
         s_ncccol = S_ncccol[i_ncccol]
         s_target = Field(Field(s_ncccol 2 ".") 1 "_")
         s_comment2 = s_comment
         if (Index(t_commenttab.Target s_target)!=0) then
           i_target = Index(t_commenttab.Target s_target)
           s_comment2 = s_comment2+"\n"+t_commenttab.Target[i_target]+": "+t_commenttab.Fullname[i_target]+"\nAUC for external test set: "\
           +t_commenttab.AUC[i_target]
         endif
         set format $s_ncccol "%.1f" name=Field(Field(s_ncccol 2 ".") 1 "_")+"_Class" comment=s_comment2
       endfor
       if (Nof(S_ncacol)>0) then
         for i_ncacol = 1, Nof(S_ncacol)
           s_ncacol = S_ncacol[i_ncacol]
           s_target = Field(Field(s_ncacol 2 ".") 1 "_")
           s_comment2 = s_commentnca
           if (Index(t_commenttab.Target s_target)!=0) then
             i_target = Index(t_commenttab.Target s_target)
             s_comment2 = s_comment2+"\n"+t_commenttab.Target[i_target]+": "+t_commenttab.Fullname[i_target]
             if (Type(t_commenttab.Q2)!="unknown") s_comment2 = s_comment2+"\nQ2 for external test set: "+t_commenttab.Q2[i_target]
           endif
           set format $s_ncacol "%.1f" name=Field(Field(s_ncacol 2 ".") 1 "_")+"_cpKd" comment=s_comment2
         endfor
       endif
     elseif (s_mod[1:3]=="mcp") then
       S_mcpcol =  Name($s_tab column)[Index(Name($s_tab column) s_tab+".*_"+s_mod regexp all)]
       group table t_commenttab S_targetlist "Target" S_Fullname "Fullname"
       if (Exist($s_mod "R_AUC")) then
         R_AUC = Toreal(Tointeger(Toreal($s_mod["R_AUC"])*100.)/100.)
         add column t_commenttab Tostring(R_AUC) name="AUC" index=3
       endif
       if (Exist($s_mod "R_Q2")) then
         R_Q2 = Toreal(Tointeger(Toreal($s_mod["R_Q2"])*100.)/100.)
         add column t_commenttab Tostring(R_Q2) name="Q2" index=3
       endif
       for i_mcpcol = 1, Nof(S_mcpcol)
         s_mcpcol = S_mcpcol[i_mcpcol]
         s_target = Field(Field(s_mcpcol 2 ".") 1 "_")
         s_target = Replace(Field(s_mcpcol 2 ".") "_"+s_mod "")
         s_comment2 = s_comment
         if (Index(t_commenttab.Target s_target)!=0) then
           i_target = Index(t_commenttab.Target s_target)
           if (Exist($s_mod "R_AUC")) then
             s_comment2 = s_comment2+"\n"+t_commenttab.Target[i_target]+": "+t_commenttab.Fullname[i_target]+"\nAUC for external test set: "\
             +t_commenttab.AUC[i_target]
           endif
           if (Exist($s_mod "R_Q2")) then
             s_comment2 = s_comment2+"\n"+t_commenttab.Target[i_target]+": "+t_commenttab.Fullname[i_target]+"\nQ2 for external test set: "\
             +t_commenttab.Q2[i_target]
           endif
         endif
         S_mcpcolname = Split(Field(s_mcpcol 2 ".") "_")
         s_mcpcolname = Sum(S_mcpcolname[1:Min(2 Nof(S_mcpcolname))] "_")
#         set format $s_mcpcol "%.1f" name=Field(Field(s_mcpcol 2 ".") 1 "_") comment=s_comment2
         set format $s_mcpcol "%.1f" name=s_mcpcolname comment=s_comment2
       endfor
     endif
     delete t_commenttab l_warn=no
   endif
#   if ((s_mod[1:3]=="dpc")&(Type($s_coldpa)!="unknown")) set format $s_coldpa "%.1f" comment=s_commentdpa
#   if ((s_mod[1:3]=="dfa")&(Type($s_coldfc)!="unknown")) set format "%.2f" $s_coldfc comment=s_commentdfc
   if (Exist($s_mod["FP"])) then
     s_comment = "Tanimoto similarity:\n1. means identical cpd is in training set\n>0.7 indicates cpd is reasonably similar to training set cpd"
     if (Type($s_coltani)!="unknown") set format "%.2f" $s_coltani comment=s_comment
     s_coltaninew = Replace(s_coltani "TANIsim" "TS")
     if (Type($s_coltaninew)!="unknown") delete $s_coltaninew
     if (Type($s_coltani)!="unknown") rename $s_coltani Field(s_coltaninew 2 ".")
     if (Type($s_coltaninew)!="unknown") set format $s_coltaninew show off
     if (Type($s_coltaninew)!="unknown") delete $s_coltaninew
   endif
  endif
   if (!l_loaded) delete $s_mod
   if(l_progress) print bar N  l_info=yes
 endfor
# sort column $s_tab function = "Icm::Nof(COL,ND)" name=S_cols
 $s_tab.mol = P_tabmol
 if(l_progress) print bar "done\n"  l_info=yes
endmacro
#
macro predictModelsBG s_tab ("") S_models i_processor (4) l_removeinactives (no) l_charge (yes) P_parameters (Collection()) i_start (0) i_end (0) auto
  s_tab = Trim(s_tab all)
  if (s_tab == "") return "Table name not specified"
  if (Nof(S_models)==0) return "Please specify one or more models"
  if (Type($s_tab)!="unknown") then
    s_tabin = s_tab+"_"+Iproc( )
    fname_in = s_tempDir + s_tabin+".sdf"
    fname_out = s_tempDir + s_tabin+".icb"
    l_write = yes
  else
    l_write = no
    if Exist(s_tab) then
      if (Path(s_tab)=="") s_tab = Path()+s_tab
      s_tabin = Name(s_tab)+"_"+Iproc( )
    elseif (Nof(Split(s_tab " "))==5) then
      if !Sql( connect, Field(s_tab,1), Field(s_tab,2), Field(s_tab,3), Field(s_tab,4) ) return "Molcart table specified not found"
      s_tabin = Field(s_tab 5 " ")+"_"+Iproc()
      s_tab = Replace(s_tab " " ":")
    else
      return "Table specified not found"
    endif
    fname_in = s_tab
    fname_out = s_tempDir + s_tabin+".icb"
  endif
  S_cmdargs = Sarray(1 "-f")
  if (i_processor>1) S_cmdargs //= "jobs="+String(i_processor)
  S_cmdargs //= S_models
#  S_cmdargs //= "modelsdir="+TOOLS.modelsDir
  if (l_removeinactives) S_cmdargs //= "-removeinactives"
  if (!l_charge) S_cmdargs //= "-nocharge"
#  S_cmdargs //= "from="+String(i_start)
#  S_cmdargs //= "to="+String(i_end)
  if (P_parameters != Collection()) then
    fname_P = s_tempDir + "msPara_"+Iproc()+".json"
    write P_parameters fname_P delete
    S_cmdargs //= "parameters="+fname_P
  endif
  if (l_write) write table mol $s_tab fname_in delete
  s_cmd = Path( macro, "-P"+s_icmhome, s_icmhome + "_molScreen", fname_in,  "output="+fname_out, S_cmdargs )
  s_origdir = Path()
  set directory s_tempDir
  if (l_write) then
    if (P_parameters==Collection()) then
      sprintf "read binary %s\ndelete %s l_warn=no\nrename %s \"%s\"\ndelete system \"%s\" \"%s\"", String(fname_out string), s_tab, s_tabin, s_tab, fname_in fname_out
    else
      sprintf "read binary %s\ndelete %s l_warn=no\nrename %s \"%s\"\ndelete system \"%s\" \"%s\" \"%s\"", String( fname_out string), s_tab, s_tabin, s_tab, fname_in fname_out fname_P
    endif
  else
    if (P_parameters==Collection()) then
      sprintf "read binary %s\ndelete %s l_warn=no\nrename %s \"%s\"\ndelete system \"%s\"", String( fname_out string), s_tab, s_tabin, s_tab, fname_out
    else
      sprintf "read binary %s\ndelete %s l_warn=no\nrename %s \"%s\"\ndelete system \"%s\" \"%s\"", String( fname_out string ), s_tab, s_tabin, s_tab, fname_out fname_P
    endif
  endif
  make background s_cmd command=s_out info="MolScreen finished. Press OK to load the result"
  print " Info> MolScreen started in background. You will be notified when the job is complete."
  printf "Info> bg_cmd:  %s\n", s_cmd
  printf "Info> output:  %s\n", fname_out
  set directory s_origdir
  l_info=no
endmacro
#
macro predictModelsCluster s_tab ("") S_models s_dir ("") s_sshcommand ("ssh vls.molsoft.com") s_qsubarg ("-q all.q") s_remotedir ("") s_remoteicmdir ("") s_remotemoddir ("") i_mode (2) l_removeinactives (no) l_charge (yes) i_ligperjob (1000) l_shortoutput (no) P_parameters (Collection()) i_start (0) i_end (0) i_queuemode (1) auto
  l_info=no; l_commands=no; l_warn=no
  s_tab = Trim(s_tab all)
  i_ligperjob = Max(1 i_ligperjob)
  if (s_tab == "") return "Table name not specified"
  s_taborig = s_tab
  s_tab = Name(Field(s_taborig 1 " "))
  if ((Type($s_tab)=="table")&(Extension(s_taborig)=="")) then
    if (Nof($s_tab.mol==Chemical(""))!=0) return "Some chemical fields are empty, please remove them and try again"
    l_write = yes
  else
    l_write = no
    if Exist(s_taborig) then
      if (Path(s_taborig)=="") s_tab = Path()+s_tab
    elseif (Nof(Split(s_taborig " "))==5) then
      if !Sql( connect, Field(s_taborig,1), Field(s_taborig,2), Field(s_taborig,3), Field(s_taborig,4) ) return "Molcart table specified not found"
      s_tab = Field(s_taborig,5)
    else
      return "Table specified not found"
    endif
  endif
  if (Nof(S_models)==0) return "Model not specified"
  if (l_shortoutput) l_removeinactives = yes
#  if (s_sshcommand=="") return "Please specify ssh command and name of head node"
  if (s_dir == "") s_dir = Path()
  s_origdir = Path()
  set directory s_dir
  if (l_write) then
    T_input = $s_tab
    delete T_input.idxtmp l_warn=no
    if (Type(T_input.idxtmp)=="unknown") add column T_input Count(Nof(T_input)) name="idxtmp"
    set format T_input.idxtmp show off
    delete $s_tab
    rename T_input s_tab
    keep $s_tab
    T_input = $s_tab
    modify T_input.mol delete salt
    modify T_input.mol delete salt simple
    delete hydrogen T_input.mol
    modify T_input.mol auto
    if (l_charge) set charge formal auto T_input.mol 7.0
    if (Nof(T_input.mol==Chemical(""))!=0) return "Some chemical fields are empty after removing salt, please remove them and try again"
    if (!Exist("T_input.icb")) then
      write binary T_input delete
      write table mol T_input delete
    else
      l_continue = Ask("Previous chemical table T_input.icb exist, please do not overwrite with different chemical table, continue?(yes/no)",no)
      if (l_continue==yes) then
        write binary T_input delete
        write table mol T_input delete
      else
        return "Job was not submitted, different chemical table should use different directory"
      endif
    endif
    if (i_start == 0) then
      i_start = 1
      i_end = Nof(T_input)
      i_nofmol = Nof(T_input)
    else
      i_start = Min(i_start Nof(T_input))
      if (i_end == 0) then
        i_end = i_start
        i_nofmol = 1
      else
        i_end = Min(i_end Nof(T_input))
        i_nofmol = i_end-i_start+1
      endif
    endif
  else
    if Exist(s_taborig) then
      s_tab = s_taborig
      s_tabnam = Name(s_tab)
      if (Type($s_tabnam)!="unknown") delete $s_tabnam l_warn=no
      if (Extension(s_tab)==".molt") then
        connect molcart filename=s_taborig
        if (!Exist(s_tabnam sql table)) return "cannot find table " + s_tabnam + " in molt:" + s_tab
        I_molids = Sql("select molid as molid from " + s_tabnam ).molid
        i_nofmol = Nof( I_molids )
        connect molcart s_tabnam off
      else
        if (Extension(s_tab)==".icb") then
          read binary s_taborig
          s_tab = Name(s_tab)
          if (Type($s_tab)!="table") return "Binary file should contain chemical table with the same name"
        elseif (Extension(s_tab)==".sdf") then
          read table mol s_taborig
          s_tab = Name(s_tab)
          if (Type($s_tab)!="table") return "sdf should contain chemical table with the same name"
        elseif (Extension(s_tab)==".inx") then
          s_tab = Name(s_tab)
          read index s_taborig name=s_tab
        endif
        i_nofmol = Nof($s_tab)
      endif
      if (i_start == 0) then
        i_start = 1; i_end = i_nofmol
      else
        i_start = Min(i_start i_nofmol)
        if (i_end == 0) then
          i_end = i_start
        else
          i_end = Min(i_end i_nofmol)
        endif
      endif
      i_nofmol = i_end-i_start+1
    else
      s_tab = Field(s_taborig,5)
      maxmolid = Sql("select max(molid) as molid from " + Field(s_taborig,5)).molid[1]
      connect molcart off
      if (i_start == 0) then
        i_start = 1; i_end = maxmolid
      else
        i_start = Min(i_start maxmolid)
        if (i_end == 0) then
          i_end = i_start
        else
          i_end = Min(i_end maxmolid)
        endif
      endif
    endif
    i_nofmol = i_end-i_start+1
  endif
  N = Nof(S_models)
  M = ((i_nofmol-1)/i_ligperjob)+1
  MN = M * N
  S_tmpscript={"call _startup"}
  if (s_remotedir=="") then
    S_tmpscript//="set directory \""+s_dir+"\""
  else
    S_tmpscript//="set directory \""+s_remotedir+"\""
  endif
  if (s_remotemoddir=="") then
    S_tmpscript//="TOOLS.modelsDir=\""+TOOLS.modelsDir+"\""
  else
    S_tmpscript//="TOOLS.modelsDir=\""+s_remotemoddir+"/\""
    S_models=Sarray(Nof(S_models) s_remotemoddir+"/")+Name(S_models)+".icb"
  endif
  S_tmpscript//="i_runno=Getarg(\"run\",1,delete)"
  S_tmpscript//="S_allmodels=Sarray(1 \""+S_models[1]+"\")"
  if (Nof(S_models)>1) then
    for i_model = 2, Nof(S_models)
      S_tmpscript//="S_allmodels//=\""+S_models[i_model]+"\""
    endfor
  endif
  S_tmpscript//="P_mspara=Collection()"
  if (P_parameters!=Collection()) then
    for i_para = 1, Nof(P_parameters)
      s_field = Name(P_parameters)[i_para]
      S_tmpscript//="P_mspara[\""+s_field+"\"]="+Tostring(P_parameters[s_field])
    endfor
  endif
  S_tmpscript//="i_nofmol = "+String(i_nofmol)
  S_tmpscript//="i_globalst = "+i_start
  S_tmpscript//="i_globaled = "+i_end
#  S_tmpscript//="read table mol \"T_input.sdf\""
if (l_write)  S_tmpscript//="read binary \"T_input.icb\""
  S_tmpscript//="l_info=no; l_commands=no"
  S_tmpscript//="M = (("+i_nofmol+"-1)/"+i_ligperjob+")+1"
  S_tmpscript//="i_mod = (i_runno-1)/M+1"
  S_tmpscript//="i_tab = Mod(i_runno M)"
  S_tmpscript//="if (i_tab==0) i_tab=M"
#  S_tmpscript//="T_input = T_input[(i_tab-1)*"+i_ligperjob+"+1:i_tab*"+i_ligperjob+"]"
  S_tmpscript//="i_start = (i_tab-1)*"+i_ligperjob+"+i_globalst"
  S_tmpscript//="i_end = Min(i_tab*"+i_ligperjob+"+i_globalst-1 i_globaled)"
  S_tmpscript//="s_model = S_allmodels[i_mod]"
  S_tmpscript//="s_model"
  S_tmpscript//="s_modfolder =  Name(Replace(s_model '\\\' '/' ))"
  S_tmpscript//="if (!Exist(s_modfolder)) make directory s_modfolder"
  S_tmpscript//="set directory s_modfolder"
  if (l_write) then
    S_tmpscript//="s_taborig = \""+s_dir+"T_input.icb\""
  else
    S_tmpscript//="s_taborig = \""+s_taborig+"\""
  endif
  i_foldermax = 0
  for i_model = 1, Nof(S_models)
    s_model = Name(S_models[i_model])
    if (!Exist(s_model)) continue
    if (!Exist(s_model+"/1")) continue
    i_foldermax = Max(i_foldermax Max(Tointeger(Name(Sarray(s_model+"/*" directory )))))
  endfor
  S_tmpscript//="i_foldermax = "+i_foldermax
  S_tmpscript//="if (!Exist(Tostring(i_foldermax+i_tab))) make directory Tostring(i_foldermax+i_tab)"
  S_tmpscript//="set directory Tostring(i_foldermax+i_tab)"
  S_tmpscript//="S_models = Sarray(1 s_model)"
  if (i_mode != 0) then		#testing, write directory but don't do prediction
   if (l_write) then
    if (l_charge) then
      if (l_removeinactives) then
        S_tmpscript//="predictModels \"T_input\" S_models yes no no yes no  \"\" yes yes yes P_mspara i_start i_end"
      else
        S_tmpscript//="predictModels \"T_input\" S_models yes no no yes no  \"\" no yes yes P_mspara i_start i_end"
      endif
    else
      if (l_removeinactives) then
        S_tmpscript//="predictModels \"T_input\" S_models yes no no yes no  \"\" yes no yes P_mspara i_start i_end"
      else
        S_tmpscript//="predictModels \"T_input\" S_models yes no no yes no  \"\" no no yes P_mspara i_start i_end"
      endif
    endif
   else
    if (l_charge) then
      if (l_removeinactives) then
        S_tmpscript//="predictModels \""+s_taborig+"\" S_models yes no no yes no  \"\" yes yes yes P_mspara i_start i_end"
      else
        S_tmpscript//="predictModels \""+s_taborig+"\" S_models yes no no yes no  \"\" no yes yes P_mspara i_start i_end"
      endif
    else
      if (l_removeinactives) then
        S_tmpscript//="predictModels \""+s_taborig+"\" S_models yes no no yes no  \"\" yes no yes P_mspara i_start i_end"
      else
        S_tmpscript//="predictModels \""+s_taborig+"\" S_models yes no no yes no  \"\" no no yes P_mspara i_start i_end"
      endif
    endif
   endif
    S_tmpscript//="if (Type(msLigandModel)!=\"unknown\") then"
    if (!l_shortoutput) S_tmpscript//="  write binary msLigandModel delete"
    S_tmpscript//="  add column msLigandModel Smiles(msLigandModel.mol unique cistrans) name=\"smi\" index=2"
    S_tmpscript//="  delete msLigandModel.mol"
    S_tmpscript//="  rename msLigandModel.smi \"mol\""
    if (l_shortoutput) then
      S_tmpscript//="  S_msLigandModel = Name(msLigandModel)"
#      S_tmpscript//="  S_keepcol = {\"mol\",\"chk\",\"Target\",\"MolScore\",\"pPvalue\",\"MolpKd\",\"MolZScore\",\"MolSim\",\"predictType\",\"idxtmp\"}"
      S_tmpscript//="  S_keepcol = {\"Target\",\"MolScore\",\"pPvalue\",\"MolpKd\",\"MolClass\",\"MolZScore\",\"MolSim\",\"predictType\",\"idxtmp\"}"
      S_tmpscript//="  for i_col = 1, Nof(S_msLigandModel)"
      S_tmpscript//="    s_col = S_msLigandModel[i_col]"
      S_tmpscript//="    if (Index(S_keepcol Field(s_col 2 \".\"))==0) delete $s_col l_warn=no"
      S_tmpscript//="  endfor"
    endif
    S_tmpscript//="  write table separator=\",\" header msLigandModel \"msLigandModel.csv\" delete"
    S_tmpscript//="endif"
  endif
  S_tmpscript//="l_info = yes"
  S_tmpscript//="quit"
  S_tmpscript//="l_info = no"
  if (!Exist("_predictModelsCluster")) then
    write Sum(S_tmpscript "\n")+"\n" "_predictModelsCluster" delete
  else
    l_continue = Ask("Previous scripts exists, please do not submit new jobs until all previous jobs have started/finished, continue?(yes/no)",no)
    if (l_continue==yes) then
      write Sum(S_tmpscript "\n")+"\n" "_predictModelsCluster" delete
    else
      return "Job was not submitted, please wait until all previous jobs have started/finished"
    endif
  endif
  sys chmod 755 _predictModelsCluster

  if (i_mode<=1) then	#Local batch job, create subfolders
    S_tmpsh={"#!/bin/csh"}
    S_tmpsh//="setenv ICMHOME "+s_icmhome
    S_tmpsh//="cd "+s_dir
    S_tmpsh//="set i = 1"
    S_tmpsh//="while ( $i <= "+MN+")"
    S_tmpsh//="  "+Path(macro )+" -p"+s_icmhome+" ./_predictModelsCluster run=$i"
    S_tmpsh//="  @ i++"
    S_tmpsh//="end"
    S_tmpsh//=" "
    write Sum(S_tmpsh "\n")+"\n" "shscript" delete
    sys chmod 755 shscript

    s_cmd = "./shscript"
    if (i_mode!=0) then
      sprintf "predictModelsHit \"%s\" yes ", s_dir
    else
      s_out = "print \"Testing directories created, no prediction submitted\""
    endif
    make background s_cmd command=s_out info="MolScreen Batch Job finished. Press OK to load the result"
    print " Info> MolScreen Batch Job started in background. You will be notified when the job is complete."

  else	#submit job to cluster
    S_tmpqsub={"#!/bin/csh"}
    S_tmpqsub//="#$ -l h_rt=2880000"
    S_tmpqsub//="#$ -j y"
    if (s_remoteicmdir=="") then
      S_tmpqsub//="setenv ICMHOME "+s_icmhome
    else
      S_tmpqsub//="setenv ICMHOME "+s_remoteicmdir+"/"
    endif
    if (s_remotedir=="") then
      S_tmpqsub//="cd "+s_dir
    else
      S_tmpqsub//="mkdir -p "+s_remotedir
      S_tmpqsub//="cd "+s_remotedir
    endif
    if (s_remoteicmdir=="") then
      if (i_queuemode == 1) then
        S_tmpqsub//=Path(macro )+" -p"+s_icmhome+" ./_predictModelsCluster run=$SGE_TASK_ID"
      elseif (i_queuemode == 2) then
        S_tmpqsub//=Path(macro )+" -p"+s_icmhome+" ./_predictModelsCluster run=$SLURM_ARRAY_TASK_ID"
      endif
    else
      if (i_queuemode == 1) then
        S_tmpqsub//=s_remoteicmdir+"/icm64 ./_predictModelsCluster run=$SGE_TASK_ID"
      elseif (i_queuemode == 2) then
        S_tmpqsub//=s_remoteicmdir+"/icm64 ./_predictModelsCluster run=$SLURM_ARRAY_TASK_ID"
      endif
    endif
    S_tmpqsub//=" "
    write Sum(S_tmpqsub "\n")+"\n" "qsubscript" delete
    sys chmod 755 qsubscript

    S_tmpssh={"#!/bin/csh"}
    S_tmpssh//="cd "+s_dir
    if (i_queuemode == 1) then
      S_tmpssh//="qsub -t "+1+"-"+MN+" "+s_qsubarg+" qsubscript"
    elseif (i_queuemode == 2) then
      S_tmpssh//="sbatch --array="+1+"-"+MN+" "+s_qsubarg+" qsubscript"
    endif
    S_tmpssh//=" "
    write Sum(S_tmpssh "\n")+"\n" "sshscript" delete
    sys chmod 755 sshscript

    if (i_mode==2) then
      sprintf "%s/sshscript", s_dir name="s_command"
      sys $s_command
    elseif (i_mode==3) then
      sprintf "%s/sshscript", s_dir name="s_command"
      sys $s_sshcommand $s_command
    elseif (i_mode==4) then
      print "Making remote directory..."
      s_mkdircommand = s_sshcommand +" 'mkdir -p "+s_remotedir+"'"
      sys $s_mkdircommand

      print "Copying files to remote directory..."
      s_scpcommand = Field(Replace(s_sshcommand "ssh" "rsync") 1 " ")
      s_scpcommand = s_scpcommand +" -aruz T_input.icb T_input.sdf _predictModelsCluster qsubscript sshscript "+Field(s_sshcommand 2 " ")+":"+s_remotedir+"/"
      sys $s_scpcommand

      print "Submitting job(s) to remote directory..."
      sprintf "%s/sshscript", s_remotedir name="s_command"
      sys $s_sshcommand $s_command

    endif
  endif
  set directory s_origdir
endmacro
#
macro predictModelsResult s_dir ("") s_sshcommand ("ssh vls.molsoft.com") s_remotedir ("") i_start (0) i_end (0) auto
  l_info = l_commands = l_warn = no
  if (s_dir =="") s_dir = Path()
  if (s_remotedir!="") then
    s_scpcommand = Field(Replace(s_sshcommand "ssh" "rsync") 1 " ")
    s_scpcommand = s_scpcommand +" -aruz "+Field(s_sshcommand 2 " ")+":"+s_remotedir+"/* "+s_dir
    sys $s_scpcommand

  endif
  s_taborig = ""
  if Exist(s_dir+"/_predictModelsCluster") then
    read string s_dir+"/_predictModelsCluster" name="s_tmpstr"
    s_taborig =  Field(Match(s_tmpstr "s_taborig(.*?)" 1) 2 "\"")
  endif
  if (s_taborig == "") then
    if (!Exist(s_dir+"/T_input.sdf")) return "Table T_input not found in directory specified"
    if (Type(T_input)=="unknown") then
      if Exist(s_dir+"/T_input.icb") then
        read binary s_dir+"/T_input.icb"
      elseif Exist(s_dir+"/T_input.sdf") then
        read table mol s_dir+"/T_input.sdf" name="T_input"
      endif
    endif
    if (i_start > 0) then
      i_start = Min(i_start Nof(T_input))
      if (i_end==0) then
        i_end = i_start
      else
        i_end = Min(i_end Nof(T_input))
      endif
      T_input = T_input[i_start:i_end]
    endif
  else
    if Exist(s_taborig) then
      if (Type(T_input)!="unknown") delete T_input l_warn=no
      s_tabnam = Name(s_taborig)
      if (Extension(s_taborig)==".molt") then
        connect molcart filename=s_taborig
        if (!Exist(s_tabnam sql table)) return "cannot find table " + s_tabnam + " in molt: " + s_taborig
        I_molids = Sql("select molid as molid from " + s_tabnam ).molid
        n_total = Nof( I_molids )
        if (i_start <= 0) then
          i_start = 1; i_end = n_total
        else
          i_start = Min(i_start n_total)
          if (i_end==0) then
            i_end = i_start
          else
            i_end = Min(i_end n_total)
          endif
        endif
        find molcart table=s_tabnam filename=s_taborig query=" `t`.`molid` >= "+Tostring(i_start)+" AND  `t`.`molid` <= "+Tostring(i_end)+"  " number=10000000 name="T_input" field=s_tabnam+".*"
        connect molcart s_tabnam off
        if (Type(T_input.idxtmp)=="unknown") then
          I_idxtmp = Tointeger(T_input.molid)
          add column T_input I_idxtmp name="idxtmp"
        endif
      else
        if (Extension(s_taborig)==".icb") then
          read binary s_taborig
          if (s_tabnam!="T_input") rename $s_tabnam "T_input"
        elseif (Extension(s_taborig)==".sdf") then
          read table mol s_taborig
          if (s_tabnam!="T_input") rename $s_tabnam "T_input"
        elseif (Extension(s_taborig)==".inx") then
          read index s_taborig name="LIGINP"
          read table mol LIGINP  name="T_input"
        endif
        if (Type(T_input.idxtmp)=="unknown") add column T_input Count(Nof(T_input)) name="idxtmp"
        if (i_start > 0) then
          i_start = Min(i_start Nof(T_input))
          if (i_end==0) then
            i_end = i_start
          else
            i_end = Min(i_end Nof(T_input))
          endif
          T_input = T_input[i_start:i_end]
        endif
      endif

    elseif  (Nof(Split(s_taborig " "))==5) then
      if !Sql( connect, Field(s_taborig,1), Field(s_taborig,2), Field(s_taborig,3), Field(s_taborig,4) ) return "Molcart table specified not found"
      s_tab = Field(s_taborig,5)
      s_tabnam = Field(s_taborig,5)
      maxmolid = Sql("select max(molid) as molid from " + Field(s_taborig,5)).molid[1]
      I_molids = Count(maxmolid)
      delete $s_tabnam l_warn=no
      if (i_start <= 0) then
        i_start = 1; i_end = maxmolid
      else
        i_start = Min(i_start maxmolid)
        if (i_end==0) then
          i_end = i_start
        else
          i_end = Min(i_end maxmolid)
        endif
      endif
      find molcart table=Field(s_taborig,4)+"."+Field(s_taborig,5)  query=" `t`.`molid` >= "+Tostring(i_start)+" AND  `t`.`molid` <= "+Tostring(i_end)+"  " number=10000000 name="T_input" field=Field(s_taborig,5)+".*"
      I_molids = Tointeger(T_input.molid)
      add column T_input I_molids name="idxtmp"
    else
      return "Table not found, either an ICM table, either T_input or an icb/sdf/inx/molt file or a molcart table need to be specified in _predictModelsCluster script"
    endif
  endif
  if (Sarray(s_dir+"/*/*/msLigandModel.icb" directory) != Sarray(0)) then
    foldMolSummary "T_input" "" "idxtmp" {"MolScore","MolpKd","pPvalue","MolClass","MolSim"} s_dir+"/*/*/msLigandModel.icb"
  elseif (Sarray(s_dir+"/*/*/msLigandModel.csv" directory) != Sarray(0)) then
    foldMolSummary "T_input" "" "idxtmp" {"MolScore","MolpKd","pPvalue","MolClass","MolSim"} s_dir+"/*/*/msLigandModel.csv"
  else
    return "Neither msLigandModel.icb nor msLigandModel.csv is found in subdirectories, please wait until the runs are finished"
  endif
  if (Type(MolResult)!="unknown") delete MolResult
  rename T_input "MolResult"
  set format MolResult.idxtmp show off
  keep MolResult
  set foreground MolResult
  set property MolResult header
endmacro
#
macro predictModelsHit s_dir ("") s_sshcommand ("ssh vls.molsoft.com") s_remotedir ("") i_hit (1000) S_sortcol ({"MolScore","MolpKd"}) l_txtonly (no) i_start (0) i_end (0) auto
HELP="""
  Combine multiple msLigandModel tables into one, sort by S_sortcol and retain the top i_hit
  Arguments and options:
    <s_dir>     : Directory in which predictModelsCluster run, assume a directory structure of <s_dir>/ModelName/[1,2,3]/msLigandModel.icb
                : Alternatively, s_dir can also be the expression of the file location, e.g. /predictionresult/*/msLigandModel.icb
    <i_hit>     : Number of top hit one want to retain, specify a large number such as 99999999 if one want to keep all entries
    <S_sortcol> : Columns sorted to determine the top compounds
    <l_txtonly> : text only mode to process more compounds

  Example:
    predictModelsHit Path() 1000 {'MolScore','MolpKd'}
    predictModelsHit '/result/*/*.icb' 99999999
"""
  l_info = no; l_commands = no
  if (l_txtonly) i_hit = 99999999
  if (s_dir =="") s_dir = Path()
  if (Extension(s_dir)==".icb") then
    s_fileloc = s_dir
    s_dir = Path(s_dir)
  else
    s_fileloc = s_dir+"/*/*/msLigandModel.icb"
  endif
  if (s_remotedir!="") then
    s_scpcommand = Field(Replace(s_sshcommand "ssh" "rsync") 1 " ")
    s_scpcommand = s_scpcommand +" -aruz "+Field(s_sshcommand 2 " ")+":"+s_remotedir+"/* "+s_dir
    sys $s_scpcommand

  endif
  if (i_start <= 0) then
    i_start = 1; i_end = 99999999
  else
    if (i_end <= 0) then
      i_end = i_start
    else
    endif
  endif
  if (Type(mstmp)!="unknown") delete mstmp
  if ((!l_txtonly) &Type(msModelHit)!="unknown") delete msModelHit
  if (l_txtonly & Type(msModeltxt)!="unknown") delete msModeltxt
#  s_fileloc = s_dir+"/*/*/msLigandModel.icb"
  s_taborig = ""
  if (Version()~"*WIN*") then
    S_fileloc = Sarray(s_fileloc directory)
  else
    if (Type(S_fileloc)!="unknown") delete S_fileloc
#    read sarray "S_fileloc" sys $s_sysLs $s_fileloc
    if Exist(s_dir+"/_predictModelsCluster") then
      read string s_dir+"/_predictModelsCluster" name="s_tmpfile"
      s_taborig =  Field(Match(s_tmpfile "s_taborig(.*?)" 1) 2 "\"")
    endif
    S_fileloc = Unique(Sort(Sarray(s_dir+"/*/*/msLigandModel.icb" directory)))
    if (Nof(S_fileloc)==0) S_fileloc = Unique(Sort(Sarray(s_dir+"/*/*/msLigandModel.csv" directory)))

#    read sarray "S_fileloc" unix find . -name msLigandModel.icb

#    S_fileloc = Sarray(Nof(S_fileloc) Path()) + Replace(S_fileloc "^./" "")
#    if (Nof(S_fileloc)==0) then
#      delete S_fileloc
#      read sarray "S_fileloc" unix find . -name msLigandModel.csv

#      S_fileloc = Sarray(Nof(S_fileloc) Path()) + Replace(S_fileloc "^./" "")
#    endif
  endif
  if (Nof(S_fileloc)==0) return "msLigandModel.icb|.csv files not found, please click Retrieve Results button to rsync files back to local folder"
  l_sorted = no
  N = Nof(S_fileloc)
  sprintf " Info> Processing %d files into table",N
  print bar s_out  N l_info=yes
  for i_file = 1, Nof(S_fileloc)
    s_file = S_fileloc[i_file]
    if (l_txtonly) then
      if ((i_file!=1)&(Exist(Replace(s_file ".icb" ".csv")))) then
        read csv header Replace(s_file ".icb" ".csv")
        if (Type(msLigandModel.idxtmp)=="iarray") then
          msLigandModel = ((msLigandModel.idxtmp >= i_start & msLigandModel.idxtmp <= i_end) | msLigandModel.idxtmp == 0)
        endif
        if (Nof(msLigandModel)==0) then
          delete msLigandModel l_warn=no; continue
        endif
        if (Type(msLigandModel.mol)!="unknown") then
          add column msLigandModel msLigandModel.mol name="smi"
          add column msLigandModel Sarray(Nof(msLigandModel) s_file) name="fileloc"
        endif
      else
        if (Extension(s_file)==".icb") then
          read binary s_file
          add column msLigandModel Smiles(msLigandModel.mol unique cistrans) name="smi"
          add column msLigandModel Sarray(Nof(msLigandModel) s_file) name="fileloc"
          if Exist(Replace(s_file ".icb" ".csv")) then
            if (Nof(msLigandModel)>0) delete msLigandModel[1:$]
            msLigandModeltmp = msLigandModel; delete msLigandModel l_warn=no
            read csv header Replace(s_file ".icb" ".csv")
            add column msLigandModel msLigandModel.mol name="smi"
            add column msLigandModel Sarray(Nof(msLigandModel) s_file) name="fileloc"
            add msLigandModeltmp msLigandModel l_warn=no; msLigandModel = msLigandModeltmp; delete msLigandModeltmp l_warn=no
          endif
          if (Type(msLigandModel.idxtmp)=="iarray") then
            msLigandModel = ((msLigandModel.idxtmp >= i_start & msLigandModel.idxtmp <= i_end) |  msLigandModel.idxtmp == 0)
          endif
        elseif (Extension(s_file)==".csv") then
          read csv header Replace(s_file ".icb" ".csv")
          if (Type(msLigandModel.idxtmp)=="iarray") then
            msLigandModel = ((msLigandModel.idxtmp >= i_start & msLigandModel.idxtmp <= i_end) | msLigandModel.idxtmp == 0)
          endif
          if (Nof(msLigandModel)==0) then
            delete msLigandModel l_warn=no; continue
          endif
          if (Type(msLigandModel.mol)!="unknown") then
            add column msLigandModel msLigandModel.mol name="smi"
            add column msLigandModel Sarray(Nof(msLigandModel) s_file) name="fileloc"
          endif
        endif
      endif
#      make flat msLigandModel window = 1.5
#      add column msLigandModel Smiles(msLigandModel.mol unique cistrans) name="molsmiles" index=2
      delete msLigandModel.mol msLigandModel.modelnearestCpd l_warn=no
      delete msLigandModel.recobj l_warn=no
      delete msLigandModel.ATOM_CONTRIB l_warn=no
    else
      if (Extension(s_file)==".icb") then
        read binary s_file
      elseif (Extension(s_file)==".csv") then
        read csv header s_file
      endif
      if (Type(msLigandModel.idxtmp)=="iarray") then
        msLigandModel = ((msLigandModel.idxtmp >= i_start & msLigandModel.idxtmp <= i_end ) | msLigandModel.idxtmp == 0)
      endif
      if (Nof(msLigandModel)==0) then
        delete msLigandModel l_warn=no; continue
      endif
    endif
    if (Type(mstmp)=="unknown") then
      rename msLigandModel mstmp
    else
      add mstmp msLigandModel; delete msLigandModel
    endif
    if (Nof(mstmp)>i_hit) then
      l_sorted = yes
      for i_col = 1, Nof(S_sortcol)
        s_col = S_sortcol[Nof(S_sortcol)-i_col+1]
        if (s_col == "MolRecScore") then
          sort mstmp.$s_col
        else
          sort reverse mstmp.$s_col
        endif
      endfor
      mstmp = mstmp[1:Min(Nof(mstmp) i_hit)]
    endif
    print bar N  l_info=yes
  endfor
  print bar "done\n"  l_info=yes
  if (!l_sorted) then
    print "Sorting..."
    for i_col = 1, Nof(S_sortcol)
      s_col = S_sortcol[Nof(S_sortcol)-i_col+1]
      if (s_col == "MolRecScore") then
        sort mstmp.$s_col
      else
        sort reverse mstmp.$s_col
      endif
    endfor
  endif
  S_convertcol = {"MolScore","pPvalue","MolpKd","MolZScore","MolClass","MolSim"}
  if ((l_txtonly)|(Extension(S_fileloc[1])==".csv")) then
    S_colname = Name(mstmp column)
    for i_col = 2, Nof( S_colname )
      s_colname = S_colname[i_col]
      if (Index(S_convertcol Field(s_colname 2 "."))!=0) then
        if (Type($s_colname)!="rarray") then
          R_tmp = Toreal($s_colname)
          delete $s_colname l_warn=no
          add column mstmp R_tmp name=Field(s_colname 2 ".") index=i_col
        endif
      endif
      if (s_colname == "mstmp.modelnearestCpd") then
      elseif (Type($s_colname)=="rarray") then
        set format $s_colname show Nof( $s_colname ND ) != Nof( $s_colname ) ? : off
      elseif (Type($s_colname)=="sarray") then
        set format $s_colname show Nof( $s_colname "" ) != Nof( $s_colname ) ? : off
      endif
    endfor
    if (Type(msModeltxt)!="unknown") delete msModeltxt l_warn=no
    rename mstmp "msModeltxt"
    if (Type(msModeltxt.smi)!="unknown") set format msModeltxt.smi show off
    if (Type(msModeltxt.fileloc)!="unknown") set format msModeltxt.fileloc show off
    if (Type(msModeltxt.idxtmp)!="unknown") set format msModeltxt.idxtmp show
    S_tmpcol = Sarray(0)
    for i_tmpcol = 1, Nof(Name(msModeltxt))
      s_tmpcol = Name(msModeltxt)[i_tmpcol]
      if (Type($s_tmpcol)=="sarray"|Type($s_tmpcol)=="iarray") S_tmpcol//=Field(s_tmpcol 2 ".")
    endfor
    if (Type(msModeltxt.toolsPanel)!="unknown") then
    sprintf """# S_Unique_Compound_ID_Column (%s) [RDONLY]
# b_Compress_to_Ligand_Target_Pair (compressModelcsv Name(variable %%@) "$1" Name(Replace(Name(variable %%@) "Model" "Target") unique))
# b_Retrieve_Checked_Entries_as_Interactive_Hitlist_Table (predictModelstxt2Hit Name(variable %%@))
# b_Generate_Html_Report (msReport Name(variable %%@) "$1")
# txt_Hint (Make sure the Unique Compound ID Column is correct)
""", Sum(S_tmpcol "|") name="s_toolsPanel"
    msModeltxt.toolsPanel = s_toolsPanel
    msModeltxt.toolsPanel = msModeltxt.toolsPanel+"""
# b_Add/Update_GO_Terms (msaddGO Name(variable %@)) [ONCHANGE:REFRESH]
# i_Display_Only:GOonly (1@All|2@GO_Cellular|3@GO_Process|4@GO_Function) [RDONLY]
# s_GO_Cellular:gocellular ($%@.S_GOCellular) [VISIBLE:$GOonly==2]
# s_GO_Process:goprocess ($%@.S_GOProcess) [VISIBLE:$GOonly==3]
# s_GO_Function:gofunction ($%@.S_GOFunction) [VISIBLE:$GOonly==4]
# b_Display_All_Rows (msfilterGO Name(variable %@)) [VISIBLE:$GOonly==1]
# b_Filter_by_GO_Cellular (msfilterGO Name(variable %@) "GO_Cellular" Field($gocellular 1 ";")) [VISIBLE:$GOonly==2]
# b_Filter_by_GO_Process (msfilterGO Name(variable %@) "GO_Process" Field($goprocess 1 ";")) [VISIBLE:$GOonly==3]
# b_Filter_by_GO_Function (msfilterGO Name(variable %@) "GO_Function" Field($gofunction 1 ";")) [VISIBLE:$GOonly==4]
"""

    msModeltxt.doubleClick = """
if (Type(displayMolSummaryPose)!="unknown") displayMolSummaryPose Name(variable %@) %#
"""
    else
      s_Probcomment = "-Log(probability) relative to approved drugs decoy, capped at 10\n1: Top 10 percent\n2: Top 1 percent\n3: Top 0.1 percent"
      s_Zscorecomment = "Z-Score\n>3. indicates 3 standard deviation above approved drugs decoy"
      s_Scorecomment = "MolpKd adjusted by MolSim, \nScore of 3. or above indicates binder"
      s_pKdcomment = "Prediction of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND indicates disimilarity to known binders"
      s_Classcomment = "Classification Score:\nfor kcc models:\nProbability of being a positive, assume 0.5% hitrate\nfor others:\n1: Median value of actives\n0: Median value of inactives"
      if (Type(msModeltxt.pPvalue)=="rarray") set format msModeltxt.pPvalue "%.2f" name="" color="rainbow='#FFFFFF/#FFFF00/#FF0000,1.:3.,pinwheel'" comment=s_Probcomment
      if (Type(msModeltxt.MolScore)=="rarray") set format msModeltxt.MolScore "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,3.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_Scorecomment
      if (Type(msModeltxt.MolpKd)=="rarray") set format msModeltxt.MolpKd "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_pKdcomment
      if (Type(msModeltxt.MolZScore)=="rarray") set format msModeltxt.MolZScore "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,1.:3.,pinwheel'" comment=s_Zscorecomment
      if (Type(msModeltxt.MolSim)=="rarray") set format msModeltxt.MolSim "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'" comment="Tanimoto Similarity for nearest 2D molecule or APF Similarity for nearest 3D pose"
      if (Type(msModeltxt.MolClass)=="rarray") set format msModeltxt.MolClass "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'" comment=s_Classcomment
      add column msModeltxt Iarray(Nof(msModeltxt) 0) name="chk" index=1
      set property msModeltxt.chk logical
      add header msModeltxt name="toolsPanel" ""
      add header msModeltxt name="s_tabsource" s_taborig
      add header msModeltxt name="S_columns" Sarray(1 "idxtmp")
      msModeltxt.toolsPanel="""
# S_Unique_CompoundID_Column ($%@.S_columns) [ONCHANGE:REFRESH]
# b_Join_Original_Table_to_Checked_Rows (msorigtab Name(variable %@) Index(%@.chk==1) %@.s_tabsource)
# b_Compress_to_Ligand_Target_Pair (compressModelcsv Name(variable %@) "$1" Name(Replace(Name(variable %@) "Model" "Target") unique))
# txt_Hint (Make sure the Unique Compound ID Column is correct)
# b_Add/Update_GO_Terms (msaddGO Name(variable %@)) [ONCHANGE:REFRESH]
# i_Display_Only:GOonly (1@All|2@GO_Cellular|3@GO_Process|4@GO_Function) [RDONLY]
# s_GO_Cellular:gocellular ($%@.S_GOCellular) [VISIBLE:$GOonly==2]
# s_GO_Process:goprocess ($%@.S_GOProcess) [VISIBLE:$GOonly==3]
# s_GO_Function:gofunction ($%@.S_GOFunction) [VISIBLE:$GOonly==4]
# b_Display_All_Rows (msfilterGO Name(variable %@)) [VISIBLE:$GOonly==1]
# b_Filter_by_GO_Cellular (msfilterGO Name(variable %@) "GO_Cellular" Field($gocellular 1 ";")) [VISIBLE:$GOonly==2]
# b_Filter_by_GO_Process (msfilterGO Name(variable %@) "GO_Process" Field($goprocess 1 ";")) [VISIBLE:$GOonly==3]
# b_Filter_by_GO_Function (msfilterGO Name(variable %@) "GO_Function" Field($gofunction 1 ";")) [VISIBLE:$GOonly==4]
"""
    endif
    set property msModeltxt header
    keep msModeltxt
  else
    rename mstmp "msModelHit"
    delete msModelHit.recobj
    print "Embedding objects..."
    predictModelPoseEmbed "msModelHit"
    set property msModelHit header
    S_colname = Name(msModelHit)
    for i_col = 3, Index(Name(msModelHit) "msModelHit.Target_Name")
      s_colname = S_colname[i_col]
      if (s_colname == "msModelHit.modelnearestCpd") then
        if ( Nof($s_colname==Chemical(""))==Nof(msModelHit)) then
          set format $s_colname show off
        else
          set format $s_colname show
        endif
      elseif (Type($s_colname)=="sarray") then
        if (Nof($s_colname=="")==Nof(msModelHit)) then
          set format $s_colname show off
        else
          set format $s_colname show
        endif
      elseif (Type($s_colname)=="rarray") then
        if (Nof($s_colname==Toreal("ND"))==Nof(msModelHit)) then
          set format $s_colname show off
        else
          set format $s_colname show
        endif
      elseif (Type($s_colname)=="iarray") then
        if (Nof($s_colname==0)==Nof(msModelHit)) then
          set format $s_colname show off
        else
          set format $s_colname show
        endif
      endif
    endfor
    keep msModelHit
  endif
endmacro
#
macro predictModelstxt2Hit s_tab ("msModeltxt")
  l_commands = no ; l_info = no
  s_tab = Trim(s_tab all)
  if (Type(msModelHit)!="unknown") delete msModelHit l_warn=no
  if (Type(msLigandModel)!="unknown") delete msLigandModel l_warn=no
  if (s_tab == "") return "Please specify table name"
  if (Type($s_tab)!="table") return "It is not a table"
  if (Type($s_tab.fileloc)=="unknown") return "fileloc column is missing"
  if (Type($s_tab.smi)=="unknown") return "smi column is missing"
  if (Type($s_tab.Target)=="unknown") return "Target column is missing"
  if (Type($s_tab.predictType)=="unknown") return "predictType column is missing"
  if (Type($s_tab.chk)=="unknown") return "chk column is missing"
  I_sel = Index($s_tab.chk==1)
  if (Nof(I_sel)==0) return "Please select row by checking the chk column"
  T_tmptxt = $s_tab[I_sel]
  if ((Type(T_tmptxt.idxtmp)!="unknown")) then
    add column T_tmptxt T_tmptxt.Target+T_tmptxt.predictType+Tostring(T_tmptxt.idxtmp) name="tmptxtkey"
  else
    add column T_tmptxt T_tmptxt.Target+T_tmptxt.predictType+T_tmptxt.smi name="tmptxtkey"
  endif
  S_fileloc = Unique(Sort(T_tmptxt.fileloc))
  for i_fileloc = 1, Nof(S_fileloc)
    if (!Exist(S_fileloc[i_fileloc])) return "Underlying file is missing"
  endfor
  N = Nof(S_fileloc)
  sprintf " Info> Processing %d files",N
  print bar s_out  N l_info=yes
  for i_fileloc = 1, Nof(S_fileloc)
    T_tmptxtfile = T_tmptxt.fileloc== S_fileloc[i_fileloc]
    read binary S_fileloc[i_fileloc]
    s_origfilename =  Name(S_fileloc[i_fileloc])
    rename $s_origfilename "T_tmptxtHit"
    if ((Type(T_tmptxtHit.idxtmp)!="unknown")&(Type(T_tmptxtfile.idxtmp)!="unknown")) then
      add column T_tmptxtHit T_tmptxtHit.Target+T_tmptxtHit.predictType+Tostring(T_tmptxtHit.idxtmp) name="tmptxtkey"
    else
      add column T_tmptxtHit T_tmptxtHit.Target+T_tmptxtHit.predictType+Smiles(T_tmptxtHit.mol unique cistrans) name="tmptxtkey"
    endif
    T_tmptxtHit = T_tmptxtHit.tmptxtkey == T_tmptxtfile.tmptxtkey
    if ((Type(T_tmptxtHit.idxtmp)!="unknown")&(Type(T_tmptxtfile.idxtmp)!="unknown")) T_tmptxtHit = T_tmptxtHit.idxtmp == T_tmptxtfile.idxtmp
    if (Nof(T_tmptxtHit)!=Nof(T_tmptxtfile)) return "There is a mismatch in files"
    if (Type(msModelHit)=="unknown") then
      rename T_tmptxtHit "msModelHit"
    else
      add msModelHit T_tmptxtHit
    endif
    delete T_tmptxtHit T_tmptxtfile l_warn=no
    print bar N  l_info=yes
  endfor
  if (Nof(msModelHit)!=Nof(T_tmptxt)) return "There is a mismatch in files"
  add column T_tmptxt Count(Nof(T_tmptxt)) name="tmptxtord"
  join left msModelHit.tmptxtkey T_tmptxt.tmptxtkey name="T_join"
  add column msModelHit T_join.tmptxtord name="tmptxtord"
  sort msModelHit.tmptxtord
  delete msModelHit.tmptxtkey msModelHit.tmptxtord l_warn = no
  delete T_tmptxt T_join l_warn=no
  delete msModelHit.recobj
  print "Embedding objects..."
  predictModelPoseEmbed "msModelHit"
  set property msModelHit header
  S_colname = Name(msModelHit)
  for i_col = 3, Index(Name(msModelHit) "msModelHit.Target_Name")
    s_colname = S_colname[i_col]
    if (s_colname == "msModelHit.modelnearestCpd") then
      if ( Nof($s_colname==Chemical(""))==Nof(msModelHit)) then
        set format $s_colname show off
      else
        set format $s_colname show
      endif
    elseif (Type($s_colname)=="sarray") then
      if (Nof($s_colname=="")==Nof(msModelHit)) then
        set format $s_colname show off
      else
        set format $s_colname show
      endif
    elseif (Type($s_colname)=="rarray") then
      if (Nof($s_colname==Toreal("ND"))==Nof(msModelHit)) then
        set format $s_colname show off
      else
        set format $s_colname show
      endif
    elseif (Type($s_colname)=="iarray") then
      if (Nof($s_colname==0)==Nof(msModelHit)) then
        set format $s_colname show off
      else
        set format $s_colname show
      endif
    endif
  endfor
  print bar "done\n"  l_info=yes
  keep msModelHit
endmacro
#
macro msorigtab s_tab ("") I_row (Iarray(0)) s_tabsource ("") s_column ("") auto
  l_info = l_commands = l_warn = no
  s_tab = Trim(s_tab all)
  if (s_tab=="") return "Please specify table name"
  if (Type($s_tab)!="table") return "Table specified is not a table"
  if (Type($s_tab.idxtmp)!="iarray") return "iarray column idxtmp needed"
  if (I_row==Iarray(0)) return "Please specify table row"
  s_tabsource = Trim(s_tabsource all)
  s_column = Trim(s_column all)
  if (s_tabsource == "") return "Source table not specified"
  T_tmptab = $s_tab[I_row]
  I_idxtmp = Unique(Sort(T_tmptab.idxtmp))
  s_tabsourceorig = s_tabsource
  s_tabsourcenam = Name(Field(s_tabsource 1 " "))
  if (Nof(Split(s_tabsourceorig " ") )!=5) then
    if ((Type($s_tabsourcenam)=="table") & (Extension(s_tabsourceorig)=="")) then

    elseif Exist(s_tabsourceorig) then
      if (Type($s_tabsourcenam)=="table") delete $s_tabsourcenam l_warn=no
      if (Extension(s_tabsourceorig)==".sdf") then
        read table mol s_tabsourceorig
      elseif (Extension(s_tabsourceorig)==".icb") then
        read binary s_tabsourceorig
      elseif (Extension(s_tabsourceorig)==".inx") then
        read index s_tabsourceorig name="LIGINP"
        read table mol LIGINP [I_idxtmp] name=s_tabsourcenam
        add column $s_tabsourcenam I_idxtmp name="idxtmp"
      elseif (Extension(s_tabsourceorig)==".molt") then
        connect molcart filename=s_tabsourceorig
        if (!Exist(s_tabsourcenam sql table)) return "cannot find table " + s_tabsourcenam + " in molt:" + s_tabsourceorig
        if (Type(result)!="unknown") delete result l_warn=no
        query molcart "select * from "+s_tabsourcenam+" where molid in :I_idxtmp" name="result"
        if (Type(result.idxtmp)=="unknown") then
          I_tmp = Tointeger(result.molid)
          add column result I_tmp name="idxtmp"
        endif
        rename result s_tabsourcenam
        delete $s_tabsourcenam.molid l_warn=no
        connect molcart s_tabsourcenam off
      endif
    else
      return "Table not loaded or not found"
    endif
  else
    if !Sql( connect, Field(s_tabsourceorig,1), Field(s_tabsourceorig,2), Field(s_tabsourceorig,3), Field(s_tabsourceorig,4) ) return "Molcart table specified not found"
    s_tabsourcenam = Field(s_tabsourceorig,5)
    if (Type(result)!="unknown") delete result l_warn=no
    query molcart "select * from "+s_tabsourcenam+" where molid in :I_idxtmp" name="result"
    if (Type(result.idxtmp)=="unknown") then
      I_tmp = Tointeger(result.molid)
      add column result I_tmp name="idxtmp"
    endif
    rename result s_tabsourcenam
    delete $s_tabsourcenam.molid l_warn=no
    connect molcart off
  endif
  if (Type($s_tabsourcenam)!="table") return "Table name does not match"
  if (Type($s_tabsourcenam.idxtmp)=="unknown") add column $s_tabsourcenam Count(Nof($s_tabsourcenam)) name="idxtmp"
  $s_tabsourcenam = $s_tabsourcenam.idxtmp == T_tmptab.idxtmp

  if ((s_column!="")&(s_column!="*")) then
    if (Type($s_tabsourcenam.$s_column)=="unknown") return "Table column specified not found"
    delete result l_warn=no; group table "result" $s_tabsourcenam.$s_column s_column $s_tabsourcenam.idxtmp "idxtmp"; delete $s_tabsourcenam
  else
    rename $s_tabsourcenam "result"
  endif
  delete T_join l_warn=no; join left T_tmptab.idxtmp result.idxtmp
  for i_colnam = 1, Nof(Name(result))
    s_colnam = Field(Name(result)[i_colnam] 2 ".")
    if (Type(T_tmptab.$s_colnam)=="unknown") then
      add column T_tmptab T_join.$s_colnam name=s_colnam
      if (Type(T_tmptab.$s_colnam)=="sarray"|Type(T_tmptab.$s_colnam)=="iarray") T_tmptab.S_columns //= s_colnam
    endif
  endfor
  delete T_join result l_warn=no
  if (Type(T_tmptab.Target_Name)=="unknown") then
    if (Type(AllTargets)=="unknown") read binary s_icmhome+"models/AllTargets.icb"
    group table T_tmptab2 Replace(Replace(Replace(AllTargets.model "dpc" "") "kcc" "") "dfa" "") "model" AllTargets.NAME "Target_Name"
    join left T_tmptab.Target T_tmptab2.model name="T_join"
    add column T_tmptab T_join.Target_Name name="Target_Name" index=Index(Name(T_tmptab) "T_tmptab.predictType")+1
    delete T_tmptab2 T_join l_warn=no
  endif
  if (Type(T_tmptab.mol)!="unknown") move T_tmptab.mol 1
  if (Nof($s_tab)==Nof(I_row)) then
    delete $s_tab; rename T_tmptab s_tab
    keep $s_tab
  else
    s_tabnew = Name(s_tab unique)
    rename T_tmptab s_tabnew
    keep $s_tabnew
  endif
endmacro
#
macro calcmsprofile s_tab ("msTargettxt") s_IDcol ("idxtmp") r_targetdistcutoff (0.) r_cmpddistcutoff (0.) l_targetonly (no) l_neato (no) auto
HELP = """
  calculate Target and Compound profile of molScreen result
  output: TargetProfile/CmpdProfile table with cluster tree, graphml file, and html/json for d3
  if r_targetdistcutoff/r_cmptdistcutoff is set to 0., it will dynamically determine the optimal cluster distance so that 80% of data are grouped
  USAGE:
    calcmsprofile <tab> <Compound ID column>
"""
  l_info = no; l_commands = no
  r_distmult = 1.2      #Tanimoto distance decrease by 0.1 result in r_distmult fold increase in weight
  s_tab = Trim(s_tab all)
  if (Type($s_tab) != "table") return "Table not found"
  if (Type($s_tab.MolpKd)!="rarray") return "MolpKd column not found"
  if (Type($s_tab.Target)!="sarray") return "Target column not found"
  if (Type($s_tab.$s_IDcol)=="unknown") return "ID column not found"
  if ((Type($s_tab.$s_IDcol)!="sarray")&(Type($s_tab.$s_IDcol)!="iarray")) return "ID column need to be an sarray/iarray"
  mstmp = $s_tab.MolpKd >= 5. | $s_tab.MolScore >= 3.
  group mstmp.Target mstmp.Target 'count,count' name='mstmp2'
  sort mstmp2.Target; sort reverse mstmp2.count
  join left mstmp2.Target mstmp.Target name="T_join"
  if (Type(T_join.Target_Name)!="unknown") then
    add column mstmp2 T_join.Target_Name name="fullname"; delete T_join
  else
    add column mstmp2 T_join.Target name="fullname"; delete T_join
  endif
  add column mstmp Tostring(mstmp.$s_IDcol) name="CompoundID"
  group mstmp.CompoundID mstmp.CompoundID 'count,count' name='mstmp3'
  sort mstmp3.CompoundID; sort reverse mstmp3.count
  M_tmpmacro = Matrix(Nof(mstmp2) Nof(mstmp3))
  for i_target = 1, Nof(mstmp2)
    s_target = mstmp2.Target[i_target]
    mstmp4 = mstmp.Target == s_target
    R_tmpmacro = Rarray(Nof(mstmp3) 0.)
    R_tmpmacro[Index(mstmp3.CompoundID==mstmp4.CompoundID)]=1.
    M_tmpmacro[i_target,?] = R_tmpmacro
    delete mstmp4 l_warn=no
  endfor
  S_target = Sarray(0)
  for i_target = 1, Nof(mstmp2)
    S_target //= Sum(Sarray(Tointeger(M_tmpmacro[i_target])) "")
  endfor
  P_target = Parray(logical S_target)
  M_target = Distance(P_target)

  if (Nof(mstmp3)>2000) l_targetonly = yes

 if (!l_targetonly) then
  S_cmpd = Sarray(0)
  for i_cmpd = 1, Nof(mstmp3)
    S_cmpd //= Sum(Sarray(Tointeger(M_tmpmacro[?,i_cmpd])) "")
  endfor
  P_cmpd = Parray(logical S_cmpd)
  M_cmpd = Distance(P_cmpd)
 endif

  group table mstmp2 append header M_target
  M_target = mstmp2.M_target
  add column mstmp2 Count(Nof(mstmp2)) name="origord"
#  make tree mstmp2 distance = "M_target" label="%Target,%count" split="cl"
  make tree mstmp2 full "UPGMA" split="cl" label="%Target,%count" distance="M_target"
  if (r_targetdistcutoff == 0.) then
    for i_dist = 12, 18
      r_dist = 0.05*i_dist
#      split mstmp2.cluster r_dist
      mstmp2.cl = Cluster(mstmp2.M_target r_dist)
      if (Toreal(Nof(mstmp2.cl!=0 ))/Nof(mstmp2)>0.9) break
#      if (Toreal(Sum(mstmp2.count [Index(mstmp2.cl!=0)]))/Sum(mstmp2.count )>0.8) break
    endfor
    r_targetdistcutoff = r_dist
  endif
  split mstmp2.cluster r_targetdistcutoff
  mstmp2.cl = Cluster(mstmp2.M_target r_targetdistcutoff)

  if (l_neato) then
   read sys whereis neato
   if (Field(Split(s_out "\n")[1] 2 ":") == "") then
    print "Graphviz Neato installation cannot be found, will not make Graphviz SVG"
   else
    I_fontsizes={14}//Tointeger(Sqrt(mstmp2.count[1]))
    R_3th={0.8}//r_targetdistcutoff//r_targetdistcutoff-0.1
    r_minlen = 12.
    R_sizescale = {1.0, 0.6}
    R_sizescale[2] = Log(20.*12.)/Log(mstmp2.count[1])
    s_headfm = """
graph G {
graph [overlap=false; splines=false; model=mds; outputorder=nodesfirst, nodesep=10, size=40!]
node [shape=doublecircle; style=filled; fillcolor=white; fontsize=%d]
edge [fontsize=%d]
"""
    s_nodefm = '"%s"[label="%s" fillcolor="%s" fontsize="%s"'
    s_edgefm = '"%s" -- "%s" [len=%.2f, weight=%.1f, penwidth=%.3f, color="%s"'
    ddot=R_3th[1]; dvis=R_3th[2]; dlab=R_3th[3]
#    dvis = r_targetdistcutoff
    curdir = Path()
    nodefontsize=I_fontsizes[1]; edgefontsize=I_fontsizes[2]
    sprintf s_headfm nodefontsize, edgefontsize
    sd = s_out
    S_color = {"#c7c7c7","#9edae5","#1f77b4","#aec7e8","#ff7f0e","#ffbb78","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5","#8c564b","#c49c94","#e377c2","#f7b6d2","#7f7f7f","#bcbd22","#dbdb8d","#17becf"}
    for i_tmp2=1,Nof(mstmp2)
      s_color = S_color[Mod(mstmp2.cl[i_tmp2] 20)+1]
#      sprintf s_nodefm mstmp2.Target[i_tmp2], mstmp2.Target[i_tmp2], s_color, Tostring(14+Power(mstmp2.count[i_tmp2] 0.9))
      sprintf s_nodefm mstmp2.Target[i_tmp2], mstmp2.Target[i_tmp2], s_color, Tostring(R_sizescale[1]*(12+Power(mstmp2.count[i_tmp2] R_sizescale[2])))
      sd += (s_out+"]\n")
    endfor
    seidmi = 100; seidmx = 0; dmi = 0.; dmx = 1.; wlim=1.
    print bar " Generating nodes ", Nof(mstmp2) l_info=yes
    for i_tmp2=1,Nof(mstmp2)-1
      for j_tmp2=i_tmp2+1,Nof(mstmp2)
        d = M_target[i_tmp2,j_tmp2]; seid = Integer(100*(1-d))
        if(seid>seidmx)seidmx=seid; if(seid<seidmi)seidmi=seid
#        if(d < r_targetdistcutoff ) then
        if(d < ddot ) then
#          dd = Distance(d evolution); w = 0.1/(d*d*d*d+0.01)
          dd = Distance(d evolution); w = 0.01/(Power(d 2)+0.001)
          commonhit = Sum(P_target [i_tmp2]&P_target[j_tmp2])[1]
#          penwid = Toreal(Power(commonhit 0.9))
          penwid = R_sizescale[1]*2*Toreal(Power(commonhit R_sizescale[2]))
          sprintf s_edgefm mstmp2.Target[i_tmp2], mstmp2.Target[j_tmp2], (0.1+d)*0.2*(r_minlen+Power(mstmp2.count[1] R_sizescale[2])), w, penwid, Color(Matrix(Color(d,"#0000ff/#33ff66/#ffffaa/#ffffff",0.,ddot-0.1)))[1]
          sd += s_out
          if(d > dvis) sd += " style=invis "
          if ((d < dlab) & (commonhit>=10)) sd += (' label="'+ commonhit +' cmpds" fontsize="'+Tostring(R_sizescale[1]*(20+Power(commonhit R_sizescale[2])))+'"' )
          sd += "]\n"
        endif
      endfor
      print bar Nof(mstmp2) l_info=yes
    endfor

    sd+= "\n}\n"
    write sd s_tempDir + "sgraph.dot" delete
    set directory s_tempDir
    print bar "done. Running neato\n"  l_info=yes
    sprintf "neato sgraph.dot -T%s -osgraph.%s\n", "svg", "svg"
    unix $s_out

#    printf " Params: {%d,%d} {%.2f,%.2f,%.2f} => sgraph.dot -> '%s/sgraph.%s'\n",nodefontsize,edgefontsize, ddot, dvis, dlab,s_tempDir,"svg"
    printf " SVG is written in '%s/sgraph.svg'\n", s_tempDir
    read string s_tempDir+"sgraph.svg" name="svg"
    tsvg = Table(svg, plot)
    sort tsvg.width; sort tsvg.ty
    write Sum(tsvg.tx) s_tempDir + "sgraph.svg" delete
    set directory curdir
   endif
  endif

 if (Nof(mstmp2)<=2000) then
   mstmp4 = mstmp2
   add column mstmp4 mstmp4.Target+": "+Tostring(mstmp4.count)+" hits: "+Tostring(mstmp4.fullname) name="name" index=1
   sort mstmp4.ord
   add column mstmp4 mstmp4.ord-1 name="ord2"
   group table colortmp Count(20)-1 "cl" {"#9edae5","#1f77b4","#aec7e8","#ff7f0e","#ffbb78","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5","#8c564b","#c49c94","#e377c2","#f7b6d2","#7f7f7f","#c7c7c7","#bcbd22","#dbdb8d","#17becf"} "color"
   add column mstmp4 Mod(mstmp4.cl 20) name="mod"
   join left mstmp4.mod colortmp.cl name="T_join"
   add column mstmp4 T_join.color name="color"
   write table mstmp4 separator="\t" header "TargetTree2.tsv" delete
   mstmp4.name = Tostring(mstmp4.ord2)
   make tree mstmp4 full "UPGMA" split="cl" label="%name" distance="M_target"
   split mstmp4.cluster r_targetdistcutoff
   mstmp4.cl = Cluster(mstmp4.M_target r_targetdistcutoff)
   write string Replace( String(mstmp4.cluster ) "'" "") "TargetTree1.tre" delete

   read string s_icmhome+"/models/Tree.html" name="s_tmp"
   S_tmp = Split(s_tmp "\n")
   S_tmp[Index(Index(S_tmp ".*?\.domain" regexp) 1 )] =  "    .domain([\""+Sum(mstmp4.name "\",\"")+"\"])"
   S_tmp[Index(Index(S_tmp ".*?\.range" regexp) 1 )] =  "    .range([\""+Sum(mstmp4.color "\",\"")+"\"]);"
   S_tmp[Index(Index(S_tmp ".*?var outerRadius" regexp) 1 )] =  "var outerRadius = "+String(1200+3*Nof(mstmp4))+" / 2,"
   write string Sum(S_tmp "\n") "TargetTree.html" delete
   delete mstmp4 colortmp T_join l_warn=no
 endif

 if (!l_targetonly) then
  group table mstmp3 append header M_cmpd
  M_cmpd = mstmp3.M_cmpd
  add column mstmp3 Count(Nof(mstmp3)) name="origord"
#  make tree mstmp3 distance = "M_cmpd" label="%CompoundID,%count" split="cl"
  make tree mstmp3 full "UPGMA" split="cl" label="%CompoundID,%count" distance="M_cmpd"
  if (r_cmpddistcutoff == 0.) then
    for i_dist = 12, 18
      r_dist = 0.05*i_dist
#      split mstmp3.cluster r_dist
      mstmp3.cl = Cluster(mstmp3.M_cmpd r_dist)
      if (Toreal(Nof(mstmp3.cl!=0 ))/Nof(mstmp3)>0.9) break
#      if (Toreal(Sum(mstmp3.count [Index(mstmp3.cl!=0)]))/Sum(mstmp3.count )>0.8) break
    endfor
    r_cmpddistcutoff = r_dist
  endif
  split mstmp3.cluster r_cmpddistcutoff
  mstmp3.cl = Cluster(mstmp3.M_cmpd r_cmpddistcutoff)

  if (Nof(mstmp3)<=2000) then
   mstmp4 = mstmp3
   add column mstmp4 mstmp4.CompoundID+": "+Tostring(mstmp4.count)+" hits" name="name" index=1
   sort mstmp4.ord
   add column mstmp4 mstmp4.ord-1 name="ord2"
   group table colortmp Count(20)-1 "cl" {"#9edae5","#1f77b4","#aec7e8","#ff7f0e","#ffbb78","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5","#8c564b","#c49c94","#e377c2","#f7b6d2","#7f7f7f","#c7c7c7","#bcbd22","#dbdb8d","#17becf"} "color"
   add column mstmp4 Mod(mstmp4.cl 20) name="mod"
   join left mstmp4.mod colortmp.cl name="T_join"
   add column mstmp4 T_join.color name="color"
   write table mstmp4 separator="\t" header "CmpdTree2.tsv" delete
   mstmp4.name = Tostring(mstmp4.ord2)
   make tree mstmp4 full "UPGMA" split="cl" label="%name" distance="M_cmpd"
   split mstmp4.cluster r_cmpddistcutoff
   mstmp4.cl = Cluster(mstmp4.M_cmpd r_cmpddistcutoff)
   write string Replace( String(mstmp4.cluster ) "'" "") "CmpdTree1.tre" delete

   read string s_icmhome+"/models/Tree.html" name="s_tmp"
   s_tmp = Replace(s_tmp "TargetTree" "CmpdTree")
   S_tmp = Split(s_tmp "\n")
   S_tmp[Index(Index(S_tmp ".*?\.domain" regexp) 1 )] =  "    .domain([\""+Sum(mstmp4.name "\",\"")+"\"])"
   S_tmp[Index(Index(S_tmp ".*?\.range" regexp) 1 )] =  "    .range([\""+Sum(mstmp4.color "\",\"")+"\"]);"
   S_tmp[Index(Index(S_tmp ".*?var outerRadius" regexp) 1 )] =  "var outerRadius = "+String(1200+3*Nof(mstmp4))+" / 2,"
   write string Sum(S_tmp "\n") "CmpdTree.html" delete
   delete mstmp4 colortmp T_join l_warn=no
  endif
 endif

  group table "tmpProfile" Iarray(0) "Source" Iarray(0) "Target" Rarray(0) "TANIdist" Iarray(0) "CommonHit"
  s_mat = ""
  M_target2 = Matrix(Nof(mstmp2) Nof(mstmp2))
  for i_target = 1, Nof(mstmp2)
    group table "mstmp4" Count(Nof(M_target)) "Source" Iarray(Nof(M_target) i_target) "Target" M_target[i_target] "TANIdist" Iarray(Nof(M_target) 0) "CommonHit"
    for j_target = 1, Nof(mstmp4)
      mstmp4.CommonHit[j_target] = Sum(P_target[i_target]&P_target[mstmp4.Source[j_target]])[1]
    endfor
    M_target2[i_target,?] = Toreal(mstmp4.CommonHit)
    add tmpProfile mstmp4
    s_mat = s_mat+ ",["+Sum(Tostring(mstmp4.CommonHit) ",")+"]"
    delete mstmp4
  endfor
  group table mstmp2 append header M_target2
 if (Nof(mstmp2)>=200) then
  delete tmpProfile l_warn=no
 else
  s_mat = "["+s_mat[2:$]+"]"
  write string s_mat "TargetChord2.json" delete
  group table mstmp4 mstmp2.Target "name" mstmp2.count "hit" mstmp2.Target+": "+mstmp2.count+" hits: "+mstmp2.fullname "label" mstmp2.cl "group"
  write table separator="\t" header mstmp4 "TargetChord1.tsv" delete; delete mstmp4 l_warn=no
  read string s_icmhome+"/models/Chord.html" name="s_tmp"
  write string s_tmp "TargetChord.html" delete
  tmpProfile.TANIdist = Toreal(Tointeger(tmpProfile.TANIdist*100))/100.
  add column tmpProfile Rarray(Nof(tmpProfile), -1.) name="Log_CommonHit"
  tmpProfile.Log_CommonHit [Index(tmpProfile.CommonHit !=0)]=Log(Toreal(tmpProfile.CommonHit[Index(tmpProfile.CommonHit != 0)]) 10)
  tmpProfile.Log_CommonHit = tmpProfile.Log_CommonHit+1 ; tmpProfile.Log_CommonHit = tmpProfile.Log_CommonHit / Max(tmpProfile.Log_CommonHit)
  write table tmpProfile separator="\t" header "TargetHeatMap.tsv" delete
  delete tmpProfile l_warn=no
  read string s_icmhome+"/models/HeatMap.html" name="s_heatmap"
  S_heatmap = Split(s_heatmap "\n")
  S_heatmap[Index(Index(S_heatmap ".*?var margin" regexp) 1)] = " var margin = { top: "+String(Max(Length(mstmp2.Target))*10)+", right: 10, bottom: 50, left: "+String(Max(Length(mstmp2.Target+": "+Tostring(mstmp2.count)+" hits: "+mstmp2.fullname))*10)+" },"
  S_heatmap[Index(Index(S_heatmap ".*?col_number=" regexp) 1)] = "  col_number="+String(Nof(mstmp2))+";"
  S_heatmap[Index(Index(S_heatmap ".*?row_number=" regexp) 1)] = "  row_number="+String(Nof(mstmp2))+";"
  sort mstmp2.ord
  S_heatmap[Index(Index(S_heatmap ".*?hcrow = " regexp) 1)] = " hcrow = ["+Sum(Tostring(mstmp2.origord) ",")+"],"
  S_heatmap[Index(Index(S_heatmap ".*?hccol = " regexp) 1)] = " hccol = ["+Sum(Tostring(mstmp2.origord) ",")+"],"
  sort mstmp2.origord
  if (Nof(mstmp2)<=100) then
    S_heatmap[Index(Index(S_heatmap ".*?rowLabel = " regexp) 1)] = "  rowLabel = ['"+Sum(mstmp2.Target+": "+Tostring(mstmp2.count)+" hits: "+mstmp2.fullname "','")+"'],"
  else
    S_heatmap[Index(Index(S_heatmap ".*?rowLabel = " regexp) 1)] = "  rowLabel = ['"+Sum(mstmp2.Target+": "+Tostring(mstmp2.count)+" hits" "','")+"'],"
  endif
  S_heatmap[Index(Index(S_heatmap ".*?colLabel = " regexp) 1)] = "  colLabel = ['"+Sum(mstmp2.Target "','")+"'];"
  S_heatmap[Index(Index(S_heatmap ".*?group = " regexp) 1)] = " group = ["+Sum(Tostring(mstmp2.cl) ",")+"],"
  write string Sum(S_heatmap "\n") "TargetHeatMap.html" delete
 endif

  make network mstmp2 distance=mstmp2.M_target limit=0.65 name="nk"
  group table append nk header mstmp2.M_target
  group table append nk header mstmp2.M_target2
  r_power = 2./Log(Toreal(Max(nk.count)))
  delete nk.ord nk.cl l_warn=no
  make tree nk full "UPGMA" split="cl" label="%Target,%count" distance="M_target"
  split nk.cluster 0.7
  add column nk  Power(Toreal(nk.count) r_power ) name="size" index=4
  minimize network global nk mncalls=1000 weight=128.
  r_power = 3./Log(Toreal(Max(nk.count)))
  add column nk  Power(Toreal(nk.count) r_power ) name="size" index=4
  for i_bond = 1, Nof(nk.nk["bonds"])
    i_source = nk.nk["bonds",i_bond,"source"]
    i_target = nk.nk["bonds",i_bond,"target"]
    nk.nk["bonds",i_bond,"width"]=Max(0. Power(nk.M_target2[i_source i_target] r_power*1.)-2.)
    nk.nk["bonds",i_bond,"color"]=Color(Matrix(1 Color(nk.M_target[i_source i_target] "red/orange/yellow/white" 0. 0.8)))[1]
#      nk.nk["bonds",i_bond,"color"]=Color(Matrix(1 Color(nk.M_msdist[i_source i_target] "red/orange/yellow/white" 0. 0.4)))[1]
  endfor
  make plot nk "x=x;y=y;color=cl;size=size;shape=Circle;label=Target;labelStyle=;tooltip=Target;depth=5.;;grid=no;"

  sort nk.ord
  delete Target_network l_warn=no; rename nk "Target_network"
  keep Target_network

  make network mstmp2.cluster name="nk" split=Max(mstmp2.cl)
#    add column nk Power(Toreal(nk.NOF_LIG) 0.2 ) name="size" index=4
  minimize network nk global mncalls=1000 weight=1.
  make plot nk "x=x;y=y;color=cl;size=size;shape=Circle;label=Target;labelStyle=;tooltip=Target;depth=5.;;grid=no;"
  r_power = 3./Log(Toreal(Max(nk.count)))
  add column nk Power(Toreal(nk.count) r_power*0.8 )*8 name="size" index=4
  delete Target_tree l_warn=no; rename nk "Target_tree"
  keep Target_tree

if (!l_targetonly) then
  group table "tmpProfile" Iarray(0) "Source" Iarray(0) "Target" Rarray(0) "TANIdist" Iarray(0) "CommonHit"
  s_mat = ""
  M_cmpd2 = Matrix(Nof(mstmp3) Nof(mstmp3))
  for i_cmpd = 1, Nof(mstmp3)
    group table "mstmp4" Count(Nof(M_cmpd)) "Source" Iarray(Nof(M_cmpd) i_cmpd) "Target" M_cmpd[i_cmpd] "TANIdist" Iarray(Nof(M_cmpd) 0) "CommonHit"
    for j_cmpd = 1, Nof(mstmp4)
      mstmp4.CommonHit[j_cmpd] = Sum(P_cmpd[i_cmpd]&P_cmpd[mstmp4.Source[j_cmpd]])[1]
    endfor
    M_cmpd2[i_cmpd,?] = Toreal(mstmp4.CommonHit)
    add tmpProfile mstmp4
    s_mat = s_mat+ ",["+Sum(Tostring(mstmp4.CommonHit) ",")+"]"
    delete mstmp4
  endfor
  group table mstmp3 append header M_cmpd2

  make network mstmp3 distance=mstmp3.M_cmpd limit=0.65 name="nk"
  group table append nk header mstmp3.M_cmpd
  group table append nk header mstmp3.M_cmpd2
  r_power = 2./Log(Toreal(Max(nk.count)))
  delete nk.ord nk.cl l_warn=no
  make tree nk full "UPGMA" split="cl" label="%CompoundID,%count" distance="M_cmpd"
  split nk.cluster 0.7
  add column nk  Power(Toreal(nk.count) r_power ) name="size" index=4
  minimize network global nk mncalls=1000 weight=128.
  r_power = 3./Log(Toreal(Max(nk.count)))
  add column nk  Power(Toreal(nk.count) r_power ) name="size" index=4
  for i_bond = 1, Nof(nk.nk["bonds"])
    i_source = nk.nk["bonds",i_bond,"source"]
    i_target = nk.nk["bonds",i_bond,"target"]
    nk.nk["bonds",i_bond,"width"]=Max(0. Power(nk.M_cmpd2[i_source i_target] r_power*1.)-3.)
    nk.nk["bonds",i_bond,"color"]=Color(Matrix(1 Color(nk.M_cmpd[i_source i_target] "red/orange/yellow/white" 0. 0.8)))[1]
#      nk.nk["bonds",i_bond,"color"]=Color(Matrix(1 Color(nk.M_msdist[i_source i_target] "red/orange/yellow/white" 0. 0.4)))[1]
  endfor
  make plot nk "x=x;y=y;color=cl;size=size;shape=Circle;label=CompoundID;labelStyle=;tooltip=CompoundID;depth=5.;;grid=no;"

  sort nk.ord
  delete Compound_network l_warn=no; rename nk "Compound_network"
  keep Compound_network

  make network mstmp3.cluster name="nk" split=Max(mstmp3.cl)
#    add column nk Power(Toreal(nk.NOF_LIG) 0.2 ) name="size" index=4
  minimize network nk global mncalls=1000 weight=0.5
  make plot nk "x=x;y=y;color=cl;size=size;shape=Circle;label=CompoundID;labelStyle=;tooltip=CompoundID;depth=5.;;grid=no;"
  r_power = 3./Log(Toreal(Max(nk.count)))
  add column nk Power(Toreal(nk.count) r_power*0.8 )*8 name="size" index=4
  delete Compound_tree l_warn=no; rename nk "Compound_tree"
  keep Compound_tree

 if (Nof(mstmp3)>=200) then
  delete tmpProfile l_warn=no
 else
  s_mat = "["+s_mat[2:$]+"]"
  write string s_mat "CmpdChord2.json" delete
  group table mstmp4 mstmp3.CompoundID "name" mstmp3.count "hit" mstmp3.CompoundID+": "+mstmp3.count+" hits" "label" mstmp3.cl "group"
  write table separator="\t" header mstmp4 "CmpdChord1.tsv" delete; delete mstmp4 l_warn=no
  read string s_icmhome+"/models/Chord.html" name="s_tmp"
  s_tmp = Replace(s_tmp "TargetChord" "CmpdChord")
  write string s_tmp "CmpdChord.html" delete
  tmpProfile.TANIdist = Toreal(Tointeger(tmpProfile.TANIdist*100))/100.
  add column tmpProfile Rarray(Nof(tmpProfile), -1.) name="Log_CommonHit"
  tmpProfile.Log_CommonHit [Index(tmpProfile.CommonHit !=0)]=Log(Toreal(tmpProfile.CommonHit[Index(tmpProfile.CommonHit != 0)]) 10)
  tmpProfile.Log_CommonHit = tmpProfile.Log_CommonHit+1 ; tmpProfile.Log_CommonHit = tmpProfile.Log_CommonHit / Max(tmpProfile.Log_CommonHit)
  write table tmpProfile separator="\t" header "CmpdHeatMap.tsv" delete
  delete tmpProfile l_warn=no
  read string s_icmhome+"/models/HeatMap.html" name="s_heatmap"
  S_heatmap = Split(s_heatmap "\n")
  S_heatmap[Index(Index(S_heatmap ".*?var margin" regexp) 1)] = " var margin = { top: "+String(Max(Length(mstmp3.CompoundID))*10)+", right: 10, bottom: 50, left: "+String(Max(Length(mstmp3.CompoundID+": "+Tostring(mstmp3.count)+" hits"))*10)+" },"
  S_heatmap[Index(Index(S_heatmap ".*?col_number=" regexp) 1)] = "  col_number="+String(Nof(mstmp3))+";"
  S_heatmap[Index(Index(S_heatmap ".*?row_number=" regexp) 1)] = "  row_number="+String(Nof(mstmp3))+";"
  sort mstmp3.ord
  S_heatmap[Index(Index(S_heatmap ".*?hcrow = " regexp) 1)] = " hcrow = ["+Sum(Tostring(mstmp3.origord) ",")+"],"
  S_heatmap[Index(Index(S_heatmap ".*?hccol = " regexp) 1)] = " hccol = ["+Sum(Tostring(mstmp3.origord) ",")+"],"
  sort mstmp3.origord
  S_heatmap[Index(Index(S_heatmap ".*?rowLabel = " regexp) 1)] = "  rowLabel = ['"+Sum(mstmp3.CompoundID+": "+Tostring(mstmp3.count)+" hits" "','")+"'],"
  S_heatmap[Index(Index(S_heatmap ".*?colLabel = " regexp) 1)] = "  colLabel = ['"+Sum(mstmp3.CompoundID "','")+"'];"
  S_heatmap[Index(Index(S_heatmap ".*?group = " regexp) 1)] = " group = ["+Sum(Tostring(mstmp3.cl) ",")+"],"
  S_heatmap[Index(Index(S_heatmap ".*?TargetHeatMap.tsv" regexp) 1)] = Replace(S_heatmap[Index(Index(S_heatmap ".*?TargetHeatMap.tsv" regexp) 1)] "TargetHeatMap" "CmpdHeatMap")
  write string Sum(S_heatmap "\n") "CmpdHeatMap.html" delete
 endif

endif

  group table "TargetNode" Count(Nof(mstmp2)) "ID" mstmp2.Target "Uniprot" mstmp2.count "Hit" mstmp2.fullname "fullname"
  group table "TargetEdge" Iarray(0) "Source" Iarray(0) "Target" Rarray(0) "TANIdist" Iarray(0) "CommonHit"
  for i_target = 1, Nof(TargetNode)
    group table "mstmp4" Iarray(Nof(M_target) i_target) "Source" Count(Nof(M_target)) "Target" M_target[i_target] "TANIdist" Iarray(Nof(M_target) 0) "CommonHit"
    mstmp4 = mstmp4.Target!=i_target
    mstmp4 = mstmp4.TANIdist < r_targetdistcutoff
    mstmp4 = mstmp4.Target > i_target
    for j_target = 1, Nof(mstmp4)
      mstmp4.CommonHit[j_target] = Sum(P_target[i_target]&P_target[mstmp4.Target[j_target]])[1]
    endfor
    add TargetEdge mstmp4
    delete mstmp4
  endfor
  TargetEdge = TargetEdge.CommonHit > 0
#  TargetNode = TargetNode.ID == TargetEdge.Source | TargetNode.ID == TargetEdge.Target
  add column TargetNode Count(0 Nof(TargetNode)-1) name="newID"
  join left TargetEdge.Source TargetNode.ID name="T_join"
  add column TargetEdge T_join.Uniprot name="SourceName" index=1
  TargetEdge.Source = T_join.newID
  join left TargetEdge.Target TargetNode.ID name="T_join"
  add column TargetEdge T_join.Uniprot name="TargetName" index=2
  TargetEdge.Target = T_join.newID
  TargetNode.ID = TargetNode.newID; delete TargetNode.newID
  delete T_join
  move TargetNode.Uniprot 1
  add column TargetEdge Power(Exp(-Log(r_distmult)/0.1*TargetEdge.TANIdist)*Toreal(TargetEdge.CommonHit) 2.) name="weight"
  TargetEdge.TANIdist = Toreal(Tointeger(TargetEdge.TANIdist*100))/100.
#  write table separator="," header TargetNode delete
#  write table separator="," header TargetEdge delete
  s_graphml = """
<?xml version="1.0" encoding="UTF-8"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://graphml.graphdrawing.org/mlns
  http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">
<graph id="TargetForce" edgedefault="undirected">
"""
  S_targetml = Sarray(1 s_graphml)
  S_targetml //= "<key id=\"node1\" for=\"node\" attr.name=\"Hit\" attr.type=\"int\"/>"
  S_targetml //= "<key id=\"edge1\" for=\"edge\" attr.name=\"TANIdist\" attr.type=\"float\"/>"
  S_targetml //= "<key id=\"edge2\" for=\"edge\" attr.name=\"CommonHit\" attr.type=\"int\"/>"
  S_targetml //= "<key id=\"edge3\" for=\"edge\" attr.name=\"weight\" attr.type=\"float\"/>"
  for i_node = 1, Nof(TargetNode)
    S_targetml //= "<node id=\""+TargetNode.Uniprot[i_node]+"\">"
    S_targetml //= " <data key=\"node1\">"+ Tostring(TargetNode.Hit [i_node] )+"</data>"
    S_targetml //= "</node>"
  endfor
  for i_edge = 1, Nof(TargetEdge)
    S_targetml //= "<edge source=\""+TargetEdge.SourceName[i_edge]+"\" target=\""+TargetEdge.TargetName[i_edge]+"\">"
    S_targetml //= " <data key=\"edge1\">"+Tostring(TargetEdge.TANIdist[i_edge])+"</data>"
    S_targetml //= " <data key=\"edge2\">"+Tostring(TargetEdge.CommonHit[i_edge])+"</data>"
    S_targetml //= " <data key=\"edge3\">"+Tostring(TargetEdge.weight[i_edge])+"</data>"
    S_targetml //= "</edge>"
  endfor
  S_targetml //= "</graph>"
  S_targetml //= "</graphml>"
  write string Sum(S_targetml "\n") "TargetForce.graphml" delete

 if (!l_targetonly) then
  group table "CmpdNode" Count(Nof(mstmp3)) "ID" mstmp3.CompoundID "CompoundID" mstmp3.count "Hit"
  group table "CmpdEdge" Iarray(0) "Source" Iarray(0) "Target" Rarray(0) "TANIdist" Iarray(0) "CommonHit"
  for i_cmpd = 1, Nof(CmpdNode)
    group table "mstmp4" Iarray(Nof(M_cmpd) i_cmpd) "Source" Count(Nof(M_cmpd)) "Target" M_cmpd[i_cmpd] "TANIdist" Iarray(Nof(M_cmpd) 0) "CommonHit"
    mstmp4 = mstmp4.Target!=i_cmpd
    mstmp4 = mstmp4.TANIdist < r_cmpddistcutoff
    mstmp4 = mstmp4.Target > i_cmpd
    for j_cmpd = 1, Nof(mstmp4)
      mstmp4.CommonHit[j_cmpd] = Sum(P_cmpd[i_cmpd]&P_cmpd[mstmp4.Target[j_cmpd]])[1]
    endfor
    add CmpdEdge mstmp4
    delete mstmp4
  endfor
  CmpdEdge = CmpdEdge.CommonHit > 0
#  CmpdNode = CmpdNode.ID == CmpdEdge.Source | CmpdNode.ID == CmpdEdge.Target
  add column CmpdNode Count(0 Nof(CmpdNode)-1) name="newID"
  join left CmpdEdge.Source CmpdNode.ID name="T_join"
  add column CmpdEdge T_join.CompoundID name="SourceName" index=1
  CmpdEdge.Source = T_join.newID
  join left CmpdEdge.Target CmpdNode.ID name="T_join"
  add column CmpdEdge T_join.CompoundID name="TargetName" index=2
  CmpdEdge.Target = T_join.newID
  CmpdNode.ID = CmpdNode.newID; delete CmpdNode.newID
  delete T_join
  move CmpdNode.CompoundID 1
  add column CmpdEdge Power(Toreal(CmpdEdge.CommonHit) 2.) name="weight"
  add column CmpdEdge Power(Exp(-Log(r_distmult)/0.1*CmpdEdge.TANIdist)*Toreal(CmpdEdge.CommonHit) 2.) name="weight"
  CmpdEdge.TANIdist = Toreal(Tointeger(CmpdEdge.TANIdist*100))/100.
#  write table separator="," header CmpdNode delete
#  write table separator="," header CmpdEdge delete
  S_cmpdml = Sarray(1 s_graphml)
  S_cmpdml //= "<key id=\"node1\" for=\"node\" attr.name=\"Hit\" attr.type=\"int\"/>"
  S_cmpdml //= "<key id=\"edge1\" for=\"edge\" attr.name=\"TANIdist\" attr.type=\"float\"/>"
  S_cmpdml //= "<key id=\"edge2\" for=\"edge\" attr.name=\"CommonHit\" attr.type=\"int\"/>"
  S_cmpdml //= "<key id=\"edge3\" for=\"edge\" attr.name=\"weight\" attr.type=\"float\"/>"
  for i_node = 1, Nof(CmpdNode)
    S_cmpdml //= "<node id=\""+CmpdNode.CompoundID[i_node]+"\">"
    S_cmpdml //= " <data key=\"node1\">"+ Tostring(CmpdNode.Hit [i_node] )+"</data>"
    S_cmpdml //= "</node>"
  endfor
  for i_edge = 1, Nof(CmpdEdge)
    S_cmpdml //= "<edge source=\""+CmpdEdge.SourceName[i_edge]+"\" target=\""+CmpdEdge.TargetName[i_edge]+"\">"
    S_cmpdml //= " <data key=\"edge1\">"+Tostring(CmpdEdge.TANIdist[i_edge])+"</data>"
    S_cmpdml //= " <data key=\"edge2\">"+Tostring(CmpdEdge.CommonHit[i_edge])+"</data>"
    S_cmpdml //= " <data key=\"edge3\">"+Tostring(CmpdEdge.weight[i_edge])+"</data>"
    S_cmpdml //= "</edge>"
  endfor
  S_cmpdml //= "</graph>"
  S_cmpdml //= "</graphml>"
  write string Sum(S_cmpdml "\n") "CmpdForce.graphml" delete
 endif

  group table mstmp4 TargetNode.Uniprot "name" TargetNode.ID "ID" TargetNode.Hit "value"
  join left mstmp4.name mstmp2.Target name="T_join"
  add column mstmp4 T_join.cl name="group"; delete T_join
  join left mstmp4.name mstmp.Target name="T_join"
  if (Type(T_join.Target_Name)!="unknown") then
    add column mstmp4 mstmp4.name+": "+Tostring(mstmp4.value)+" hits: "+T_join.Target_Name name="label"; delete T_join
  else
    add column mstmp4 mstmp4.name+": "+Tostring(mstmp4.value)+" hits" name="label"; delete T_join
  endif
  group table mstmp5 TargetEdge.Source "source" TargetEdge.Target "target" TargetEdge.CommonHit "value" TargetEdge.TANIdist "dist"
  add column mstmp5 mstmp4.name[mstmp5.source+1]+"-"+mstmp4.name[mstmp5.target+1]+Sarray(Nof(mstmp5) " CommonHit: ")+Tostring(mstmp5.value)+": Tanimoto dist: "+Tostring(Tointeger(mstmp5.dist*1000.)/1000.) name="label"
  nodes = Array()
  for i_nodes = 1, Nof(mstmp4)
    nodes//=  Collection("name" mstmp4.name[i_nodes] "group" mstmp4.group[i_nodes] "value" mstmp4.value[i_nodes] "label" mstmp4.label[i_nodes])
  endfor
  links = Array()
  for i_links = 1, Nof(mstmp5)
    links//= Collection("source" mstmp5.source[i_links] "target" mstmp5.target[i_links] "value" mstmp5.value[i_links] "dist" mstmp5.dist[i_links] "label" mstmp5.label[i_links])
  endfor
  c = Collection("nodes" nodes "links" links)
  write c "TargetForce.json" delete

 if (!l_targetonly) then
  group table mstmp4 CmpdNode.CompoundID "name" CmpdNode.ID "ID" CmpdNode.Hit "value"
  join left mstmp4.name mstmp3.CompoundID name="T_join"
  add column mstmp4 T_join.cl name="group"; delete T_join
  add column mstmp4 mstmp4.name+": "+Tostring(mstmp4.value)+" hits" name="label"
  group table mstmp5 CmpdEdge.Source "source" CmpdEdge.Target "target" CmpdEdge.CommonHit "value" CmpdEdge.TANIdist "dist"
  add column mstmp5 mstmp4.name[mstmp5.source+1]+"-"+mstmp4.name[mstmp5.target+1]+Sarray(Nof(mstmp5) " CommonHit: ")+Tostring(mstmp5.value)+": Tanimoto dist: "+Tostring(Tointeger(mstmp5.dist*1000.)/1000.) name="label"
  nodes = Array()
  for i_nodes = 1, Nof(mstmp4)
    nodes//=  Collection("name" mstmp4.name[i_nodes] "group" mstmp4.group[i_nodes] "value" mstmp4.value[i_nodes] "label" mstmp4.label[i_nodes])
  endfor
  links = Array()
  for i_links = 1, Nof(mstmp5)
    links//= Collection("source" mstmp5.source[i_links] "target" mstmp5.target[i_links] "value" mstmp5.value[i_links] "dist" mstmp5.dist[i_links] "label" mstmp5.label[i_links])
  endfor
  c = Collection("nodes" nodes "links" links)
  write c "CmpdForce.json" delete
 endif

  read string s_icmhome+"/models/Force.html" name="s_tmp"
  write string s_tmp "TargetForce.html" delete
  if (!l_targetonly) write string  Replace(s_tmp "TargetForce.json" "CmpdForce.json" ) "CmpdForce.html" delete

  if (Type(TargetProfile)!="unknown") delete TargetProfile l_warn=no
  rename mstmp2 "TargetProfile"
  add header TargetProfile "" name="toolsPanel" append
  TargetProfile.toolsPanel ="""
if (Nof(Index(%@ selection))==2) profilepair Name(variable %@)
"""
  keep TargetProfile TargetNode TargetEdge

 if (!l_targetonly) then
  if (Type(CmpdProfile)!="unknown") delete CmpdProfile l_warn=no
  rename mstmp3 "CmpdProfile"
  add header CmpdProfile "" name="toolsPanel" append
CmpdProfile.toolsPanel = """
if (Nof(Index(%@ selection))==2) profilepair Name(variable %@)
"""
  keep CmpdProfile CmpdNode CmpdEdge
 endif
endmacro
#
macro msPanelCluster s_tab ("") l_calcmissing (no) I_selectedrows (Iarray(0)) s_plottype ("all") auto
HELP = """
  Use the models precalculated distance to cluster models, if Nof(I_selectedrows) > 1, it will select those entries and group it into new panel, cluster and generate d3 plots
    <s_tab>             : Name of the Panel
    <l_calcmissing>     : This macro use the precalculated distance in models/msNode.icb, if a match cannot be found, the distance has to be calculated explicitly by reading each model pairs.  It will take a long time for a large panel. So, l_calcmissing is set to no to disable this calculation by default.
    <I_selectedrows>    : If it is an empty iarray, all entries from the panel will be used, l_calcmissing will be set to off. Only clustering will be performed.
                        : If it is an iarray with more than 1 elements, the selected row will be group into a new panel, clustering will be performed, l_calcmissing will be set to yes to calculate all missing distance, d3 plots will be generated
    <s_plottype>        : Only used with I_selectedrows is specified. Different types of d3 plot: all, Chord, HeatMap, Force, Tree

  Example:
    msPanelCluster 'AllTargets'            # Take the panel AllTargets and cluster it using precalculated distance
    msPanelCluster 'AllTargets' Count(72)  # Take the panel first 72 entries of AllTargets, group it into new Panel, calculate missing distance, cluster it, and generate all 4 types of d3 plot
"""
  l_info=no; l_commands=no; l_warn=no
  s_tab = Trim(s_tab all)
  if (s_tab=="") return "Please specify panel name"
  if (Type($s_tab)!="table") return "Panel specified not found"
  if (Type(T_tmppanel)!="unknown") delete T_tmppanel l_warn=no
  T_tmppanel = $s_tab
  if (Nof(I_selectedrows)==0) then
    T_tmppanel = $s_tab
  elseif (Nof(I_selectedrows)==1) then
    return "Only 1 row selected, please select more than 1 row"
  elseif  (Nof(I_selectedrows)>1) then
    T_tmppanel = $s_tab[I_selectedrows]
    s_tab = Name(s_tab unique)
    l_calcmissing = yes
  endif
  delete T_tmppanel.origid T_tmppanel.UniprotPref T_tmppanel.ord T_tmppanel.cl l_warn=no
  delete T_tmppanel.cluster
  add column T_tmppanel Count(Nof(T_tmppanel)) name="origid"
  if (!Exist(s_icmhome+"/models/msNode.icb")) return "msNode table not found in models directory"
  read binary s_icmhome+"models/msNode.icb"
  add column T_tmppanel Replace(Replace(Replace(Replace(T_tmppanel.model "^kcc" "") "^dfa" "") "^dpc" "") "^dfz" "") name="UniprotPref"
  M_msdist = Matrix(Nof(T_tmppanel) Nof(T_tmppanel), 1.)
  M_msnoflig = Matrix(Nof(T_tmppanel) Nof(T_tmppanel))
  N = Nof(T_tmppanel)
  sprintf " Info> Calculating %d rows ",N
  print bar s_out N l_info=yes
  join left T_tmppanel.UniprotPref msNode.UniprotID name="T_tmpjoin"
  for i_node = 1, Nof(T_tmppanel)
    if (T_tmppanel.UniprotPref[i_node][1:3]=="mcp") then
      M_msdist[i_node,?] = Rarray(Nof(M_msdist) 1.)
      M_msdist[?,i_node] = Rarray(Nof(M_msdist) 1.)
      M_msdist[i_node,i_node] = 0.
      M_msnoflig[i_node,i_node] = T_tmppanel.NOF_LIG[i_node]
      continue
    endif
    if (T_tmpjoin.msNode_origid[i_node]==0) then        # Custom model
      if (!l_calcmissing) continue
      if (Type(T_tmp1)!="unknown") delete T_tmp1 l_warn=no
      s_mod1 = T_tmpjoin.model[i_node]
      l_loadedi = no
      if (Type($s_mod1)!="unknown") then
        l_loadedi = yes
      elseif (Type(T_tmppanel.location)=="sarray") then
        read binary T_tmppanel.location[i_node]
      elseif (Exist(Name(s_mod1)+".icb")) then
        read binary Name(s_mod1)+".icb"
      elseif (Exist(s_icmhome+"models/"+Name(s_mod1)+".icb")) then
        read binary s_icmhome+"models/"+Name(s_mod1)+".icb"
      else
        S_modelsDir = Split(TOOLS.modelsDir ";")
        for i_modelsDir = 1, Nof(S_modelsDir)
          if (Exist(S_modelsDir[i_modelsDir]+Name(s_mod1)+".icb")) then
            read binary S_modelsDir[i_modelsDir]+Name(s_mod1)+".icb"
            break
          endif
        endfor
      endif

      if (Type($s_mod1)!="parray") return "Cannot find" s_mod1
      if  Exist($s_mod1 "MOL") then
        group table T_tmp1 $s_mod1["MOL"] "mol" Toreal($s_mod1["PKD"]) "pkd"
      else
        group table T_tmp1 Chemical($s_mod1["SMILES"]) "mol" Toreal($s_mod1["PKD"]) "pkd"
      endif
      T_tmp1 = T_tmp1.pkd >= 5.5
      if (Nof(T_tmp1)==0) then
        if (!l_loadedi) delete $s_mod1
        delete T_tmp1 l_warn=no
        continue
      endif
      for j_node = 1, Nof(T_tmppanel)
        if (Type(T_tmp2)!="unknown") delete T_tmp2 l_warn=no
        s_mod2 = T_tmpjoin.model[j_node]
        if (s_mod2[1:3] == "mcp") continue
        if (i_node == j_node) then
          M_msdist[i_node, j_node] = 0.
          M_msnoflig[i_node, j_node] = T_tmpjoin.NOF_LIG[i_node]
        else

          s_mod2 = T_tmpjoin.model[j_node]
          l_loadedj = no
          if (Type($s_mod2)!="unknown") then
            l_loadedj = yes
          elseif (Type(T_tmppanel.location)=="sarray") then
            read binary T_tmppanel.location[j_node]
          elseif (Exist(Name(s_mod2)+".icb")) then
            read binary Name(s_mod2)+".icb"
          elseif (Exist(s_icmhome+"models/"+Name(s_mod2)+".icb")) then
            read binary s_icmhome+"models/"+Name(s_mod2)+".icb"
          else
            S_modelsDir = Split(TOOLS.modelsDir ";")
            for i_modelsDir = 1, Nof(S_modelsDir)
              if (Exist(S_modelsDir[i_modelsDir]+Name(s_mod2)+".icb")) then
                read binary S_modelsDir[i_modelsDir]+Name(s_mod2)+".icb"
                break
              endif
            endfor
          endif
          if (Type($s_mod2)!="parray") return "Cannot find" s_mod2
          if  Exist($s_mod2 "MOL") then
            group table T_tmp2 $s_mod2["MOL"] "mol" Toreal($s_mod2["PKD"]) "pkd"
          else
            group table T_tmp2 Chemical($s_mod2["SMILES"]) "mol" Toreal($s_mod2["PKD"]) "pkd"
          endif
          T_tmp2 = T_tmp2.pkd >= 5.5
          if (Nof(T_tmp2)!=0) then
            M_msdist[i_node, j_node] = Distance(T_tmp1.mol T_tmp2.mol T_tmp1.pkd T_tmp2.pkd 0.6 6. set)
            M_msdist[j_node, i_node] = M_msdist[i_node, j_node]
            M_msnoflig[i_node, j_node] = Nof(T_tmp1.mol==T_tmp2.mol)
            M_msnoflig[j_node, i_node] = M_msnoflig[i_node, j_node]
          endif
          delete T_tmp2 l_warn=no
          if (!l_loadedj) delete $s_mod2
        endif
      endfor
      if (!l_loadedi) delete $s_mod1
      delete T_tmp1 l_warn=no
      continue
    endif
    i_tmp = T_tmpjoin.msNode_origid[i_node]
#    add column T_tmpjoin Rarray(Nof(T_tmpjoin) 999.) name="tmpdist"
#    add column T_tmpjoin Iarray(Nof(T_tmpjoin), -1) name="tmpnoflig"
    group table "tmpmat" msNode.M_dist[i_tmp] "dist" msNode.M_noflig[i_tmp] "noflig"
    add column tmpmat Count(Nof(tmpmat)) name="origid"
    join left T_tmpjoin.msNode_origid tmpmat.origid name="T_tmpjoin2"
    for j_node = 1, Nof(T_tmppanel)
      if (T_tmpjoin2.dist[j_node]==Toreal("ND")) continue
      M_msdist[i_node, j_node] = T_tmpjoin2.dist[j_node]
      M_msnoflig[i_node, j_node] = T_tmpjoin2.tmpmat_noflig[j_node]
    endfor
    delete tmpmat T_tmpjoin2 l_warn=no
    print bar N l_info=yes
  endfor
  delete T_tmpjoin l_warn=no
  if (Type(T_tmppanel.M_msdist)!="unknown") delete T_tmppanel.M_msdist
  if (Type(T_tmppanel.M_msnoflig)!="unknown") delete T_tmppanel.M_msnoflig
  group table append T_tmppanel header M_msdist
  group table append T_tmppanel header M_msnoflig
  if (Nof(I_selectedrows) > 1) then
    if (Type(T_tmppanel2)!="unknown") delete T_tmppanel2 l_warn=no
    T_tmppanel2 = T_tmppanel
    delete T_tmppanel2.M_msdist T_tmppanel2.M_msnoflig l_warn=no
    group T_tmppanel2.UniprotPref all "first"  header  name="T_tmppanel2"
    M_msdist = Matrix(Nof(T_tmppanel2) Nof(T_tmppanel2))
    M_msnoflig = Matrix(Nof(T_tmppanel2) Nof(T_tmppanel2))
    for i_tmp = 1, Nof(T_tmppanel2)
      for j_tmp = 1, Nof(T_tmppanel2)
        i_tmp2 = T_tmppanel2.origid[i_tmp]
        j_tmp2 = T_tmppanel2.origid[j_tmp]
        M_msdist[i_tmp, j_tmp] = T_tmppanel.M_msdist[i_tmp2, j_tmp2]
        M_msnoflig[i_tmp, j_tmp] = T_tmppanel.M_msnoflig[i_tmp2, j_tmp2]
      endfor
    endfor
    group table append T_tmppanel2 header M_msdist
    group table append T_tmppanel2 header M_msnoflig
    makeHtmlfromNode "T_tmppanel2" "NAME" "M_msdist" "M_msnoflig" Sarray(1 s_plottype)
    delete T_tmppanel2 l_warn=no
  endif
  make tree T_tmppanel full "UPGMA" split="cl" label="%model,%NOF_LIG" distance="M_msdist"
  sort T_tmppanel.origid

  l_matrixnetwork = yes
  if (l_matrixnetwork) then
    make network T_tmppanel distance=T_tmppanel.M_msdist limit=0.65 name="nk"
    group table append nk header T_tmppanel.M_msdist
    group table append nk header T_tmppanel.M_msnoflig
    r_power = 2./Log(Toreal(Max(nk.NOF_LIG)))
    delete nk.ord nk.cl l_warn=no
    make tree nk full "UPGMA" split="cl" label="%model,%NOF_LIG" distance="M_msdist"
    split nk.cluster 0.7
    split nk.cluster 0.75
    add column nk  Power(Toreal(nk.NOF_LIG) r_power ) name="size" index=4
    minimize network global nk mncalls=1000 weight=8.
    r_power = 3./Log(Toreal(Max(nk.NOF_LIG)))
    add column nk  Power(Toreal(nk.NOF_LIG) r_power ) name="size" index=4
    for i_bond = 1, Nof(nk.nk["bonds"])
      i_source = nk.nk["bonds",i_bond,"source"]
      i_target = nk.nk["bonds",i_bond,"target"]
      nk.nk["bonds",i_bond,"width"]=Max(0. Power(nk.M_msnoflig[i_source i_target] r_power*1.)-3.)
      nk.nk["bonds",i_bond,"color"]=Color(Matrix(1 Color(nk.M_msdist[i_source i_target] "red/orange/yellow/white" 0. 0.8)))[1]
#      nk.nk["bonds",i_bond,"color"]=Color(Matrix(1 Color(nk.M_msdist[i_source i_target] "red/orange/yellow/white" 0. 0.4)))[1]
    endfor
    make plot nk "x=x;y=y;color=cl;size=size;shape=Circle;label=model;labelStyle=;tooltip=model;depth=5.;;grid=no;"

    sort nk.ord
    add header nk String("") name="toolsPanel" append
    nk.toolsPanel = $s_tab.toolsPanel
    s_tabnet = s_tab+"_network"
    delete $s_tabnet l_warn=no; rename nk s_tabnet
    keep $s_tabnet

    split T_tmppanel.cluster 0.7
    make network T_tmppanel.cluster name="nk" split=Max(T_tmppanel.cl)
#    add column nk Power(Toreal(nk.NOF_LIG) 0.2 ) name="size" index=4
    minimize network nk global mncalls=1000 weight=0.5
    make plot nk "x=x;y=y;color=cl;size=size;shape=Circle;label=model;labelStyle=;tooltip=model;depth=5.;;grid=no;"
    r_power = 4./Log(Toreal(Max(nk.NOF_LIG)))
    add column nk Power(Toreal(nk.NOF_LIG) r_power ) name="size" index=4
    sort nk.ord
    add header nk String("") name="toolsPanel" append
    nk.toolsPanel = $s_tab.toolsPanel
    s_tabtree = s_tab+"_tree"
    delete $s_tabtree l_warn=no; rename nk s_tabtree
    keep $s_tabtree
  endif

  sort T_tmppanel.ord
  delete $s_tab l_warn=no
  delete T_tmppanel.UniprotPref
  rename T_tmppanel s_tab
  print bar "done\n"  l_info=yes
  keep $s_tab
endmacro
#
macro calctrainprofile S_models
HELP = """
  Use the models' training set compounds to calculate target/compound profile
    <S_models> : string array with model names or model file names,
      if the model directory location is different from $ICMHOME/models/
      append the path to the model array, e.g. {'andr','estro','/home/don/mod/'}

  Example:
    calctrainprofile "dfaESR1"//"dfaESR2"
    calctrainprofile "dfaANDR"//"dfaESR1"//"/home/don/mymodels/"
    calctrainprofile "/home/jon/tmp/a.icb"//"./b.icb"//"./c.icb"
"""
 l_info = l_commands = no
 s_moddir = s_icmhome+"models/"
 N = Nof( S_models ); if(N==0) return " Warning>  no models specified"
 if( N>1 & Exist( S_models[$] directory) ) then
   s_moddir = S_models[$]
   S_models = S_models[1:$-1]
 endif
 if (Type(msmacro)!="unknown") delete msmacro l_warn=no
 N = Nof(S_models)
 sprintf " Info> reading %d models",N
 print bar s_out  N l_info=yes
 for i = 1, Nof(S_models)
   s_mod = S_models[i]
   s_mod1=Name(s_mod)
   l_loaded = no
   if (Type($s_mod1)!="unknown") then
     l_loaded = yes
   elseif (Exist(s_mod)) then
     read binary s_mod
   elseif (Exist(s_moddir+Name(s_mod)+".icb")) then
     read binary s_moddir+Name(s_mod)+".icb"
   elseif (Exist(Name(s_mod)+".icb")) then
     read binary Name(s_mod)+".icb"
   elseif (Exist(s_icmhome+"models/"+Name(s_mod)+".icb")) then
     read binary s_icmhome+"models/"+Name(s_mod)+".icb"
   else
     S_modelsDir = Split(TOOLS.modelsDir ";")
     for i_modelsDir = 1, Nof(S_modelsDir)
       if (Exist(S_modelsDir[i_modelsDir]+Name(s_mod)+".icb")) then
         read binary S_modelsDir[i_modelsDir]+Name(s_mod)+".icb"
         break
       endif
     endfor
   endif
   s_mod = Name(s_mod)
   if (Type($s_mod)=="unknown") then
     print " Warning> cannot find file " + s_mod
     continue
   endif
   s_mod = Name(s_mod)
   if (!Exist($s_mod "PKD")) then
     print " Warning> Model " + s_mod + "does not contain pKd value"
     if (!l_loaded) delete $s_mod l_warn=no
     continue
   endif
   group table "mstmp" Toreal($s_mod["PKD"]) "MolpKd" $s_mod["SMILES"] "smiles"
   mstmp = mstmp.MolpKd >=5.5
   add column mstmp Sarray(Nof(mstmp) s_mod[4:$]) name="Target" index=1
   add column mstmp Sarray(Nof(mstmp) $s_mod["NAME"]) name="Target_Name"
   if (Type(msmacro)=="unknown") then
     rename mstmp "msmacro"
   else
     add msmacro mstmp; delete mstmp
   endif
   if (!l_loaded) delete $s_mod
   print bar N  l_info=yes
 endfor
 print bar "Processing files\n"  l_info=yes
 add column msmacro msmacro.Target+"_"+msmacro.smiles name="uniqueid"
 group msmacro.uniqueid msmacro.MolpKd "max,"  all "first"  header  name="msmacro"
 rename msmacro.max_MolpKd "MolpKd"
 calcmsprofile "msmacro" "smiles"
 keep TargetProfile
endmacro
#
macro profilepair s_tab
  l_info=no; l_commands=no; l_warn=no
  s_tab = Trim(s_tab)
  if (s_tab=="") return "Please specify table name"
  if (Type($s_tab)=="unknown") return "Table not found"
  if (Nof(Index($s_tab selection))!=2) return "Select two and only two entries"
  if (Type($s_tab.M_target)=="matrix") then
    s_type = "Target"
    s_m1 = s_tab+".M_target"
  elseif (Type($s_tab.M_cmpd)=="matrix") then
    s_type = "Cmpd"
    s_m1 = s_tab+".M_cmpd"
  else
    return "No suitable matrix found"
  endif
  I_select = ($s_tab.origord)[Index($s_tab.ord==Sort(($s_tab.ord)[Index($s_tab selection)]))]
  print " Info>"
  if (s_type == "Target") then
    print "Tanimoto Distance is" Tostring(Tointeger($s_m1[I_select[1] I_select[2]]*100)/100.) "between" ($s_tab.fullname)[I_select[1]] "and" ($s_tab.fullname)[I_select[1]]
    if (Type($s_tab.M_target2)=="matrix") then
      s_m2 = s_tab+".M_target2"
      print  ($s_tab.fullname)[I_select[1]] "has" Tostring(Tointeger($s_m2[I_select[1] I_select[1]])) "hits"
      print  ($s_tab.fullname)[I_select[2]] "has" Tostring(Tointeger($s_m2[I_select[2] I_select[2]])) "hits"
      print "Nubmer of Common hit is" Tostring(Tointeger($s_m2[I_select[1] I_select[2]])) "between" ($s_tab.fullname)[I_select[1]] "and" ($s_tab.fullname)[I_select[1]]
    endif
  else
    print "Tanimoto Distance is" Tostring(Tointeger($s_m1[I_select[1] I_select[2]]*100)/100.) "between" ($s_tab.CompoundID)[I_select[1]] "and" ($s_tab.CompoundID)[I_select[1]]
    if (Type($s_tab.M_cmpd2)=="matrix") then
      s_m2 = s_tab+".M_cmpd2"
      print  ($s_tab.CompoundID)[I_select[1]] "has" Tostring(Tointeger($s_m2[I_select[1] I_select[1]])) "hits"
      print  ($s_tab.CompoundID)[I_select[2]] "has" Tostring(Tointeger($s_m2[I_select[2] I_select[2]])) "hits"
      print "Nubmer of Common hit is" Tostring(Tointeger($s_m2[I_select[1] I_select[2]])) "between" ($s_tab.CompoundID)[I_select[1]] "and" ($s_tab.CompoundID)[I_select[1]]
    endif
  endif
endmacro
#
macro makeHtmlfromNode s_tab ("") s_col ("") s_distmat ("") s_propertymat ("") S_d3type ({"all"}) auto
HELP = """
  This is a macro to use a node table with associated column name and matrix as input for d3 rendering
  Usage:
    makeHtmlfromNode <s_tab> <s_col> <s_distmat> <s_propertymat>
  <s_tab> name of the table
  <s_col> name of the column that contains the node name

  if neither <s_distmat> nor <s_propertymat> is provided, it will look for the first appended matrix in the table and use it as distance matrix
  if only one of <s_distmat> or <s_propertymat> is specified, the other will be calculated accordingly

  <s_distmat> name of a square matrix, can be either a distance matrix with all diagonals == 0, or a similarity matrix with all diagonals == 1
  <s_propertymat> can be either name of:
  1. a square matrix indicating overlap of common property, diagonal will be the property of the node, off diagonal will be the overlap between node i and j, for example, the number of common compounds between different targets (node), sequence identity, etc
  2. a matrix of properties/descriptors, the number of row has to match the number of nodes, each matrix column will represent one property/descriptor.  Properties will be normalized first before combining to calculate the distance matrix.  The resultant property matrix is then Max(M_dist)-M_dist

  Example:
    makeHtmlfromNode 'T_nodetable' 'nodename'                        # The first appended matrix in the table header used as distance matrix
    makeHtmlfromNode 'T_nodetable' 'nodename' 'M_dist' 'M_property'  # Explicitly specify the name of the matrix, the matrix can either be appended in table header or in ICM session
    makeHtmlfromNode 'T_nodetable' 'nodename' 'M_dist.mat'           # Read the matrix from current folder
"""
  l_commands=no; l_warn=no; l_info=no
  if (Type(d3nodeinput)!="unknown") delete d3nodeinput l_warn=no
  s_tab = Trim(s_tab all)
  if (s_tab == "") return "Please specify table name"
  if (Type($s_tab)!="table") return "Table not found"
  s_col = Trim(s_col all)
  if (s_col == "") return "Please specify column name for the nodes"
  s_tabcol = s_tab +"." +s_col
  if (Type($s_tabcol)!="iarray"&Type($s_tabcol)!="sarray") return "Please specify column of iarray or sarray as name for nodes"
#  if (s_colorcol != "") then
#    s_tabcolorcol = s_tab+"."+s_colorcol
#    if (Type($s_tabcolorcol)!="sarray") return "Color column specified not correct"
#  endif
  s_distmat = Trim(s_distmat all); s_propertymat = Trim(s_propertymat all)
  if ((s_distmat=="")&(s_propertymat=="")) then
    S_tabheader =  Name($s_tab header)
    for i_tmp = 1, Nof(S_tabheader)
      s_tabheader = S_tabheader[i_tmp]
      if (Type($s_tabheader)=="matrix") then
        s_distmat = Field(s_tabheader 2 ".")
        break
      endif
    endfor
  endif
  if ((s_distmat=="")&(s_propertymat=="")) return "Please specify the name of distance matrix and/or property matrix"

  if (s_distmat!="") then
    if (Extension(s_distmat)==".mat") then
      if (!Exist(s_distmat)) return "Distance matrix specified not found"
      read matrix s_distmat name=Name(s_distmat)
      s_distmat = Name(s_distmat)
    endif
    s_tabdistmat = s_tab+"."+s_distmat
    if (Type($s_tabdistmat)=="matrix") then
      M_d3distmat = $s_tabdistmat
    elseif (Type($s_distmat)=="matrix") then
      M_d3distmat = $s_distmat
    else
      return "Distance matrix specified not found"
    endif
    if ((Nof(M_d3distmat)!=Nof($s_tab))|(Nof(M_d3distmat[1])!=Nof($s_tab))) return "A square matrix is expected for distance matrix"
    i_counter = 0
    for i_tmp = 1, Nof(M_d3distmat)
      if ((M_d3distmat[i_tmp, i_tmp] == 0.)&( Min(M_d3distmat[i_tmp])==0.)) then
        i_counter -= 1
      elseif ((M_d3distmat[i_tmp, i_tmp] == 1.)&(Max(M_d3distmat[i_tmp])==1.)) then
        i_counter += 1
      endif
    endfor
    if (i_counter==-Nof($s_tab)) then
      M_d3propertymat =  Max(Max(Max(M_d3distmat)) 1.) - M_d3distmat
    elseif (i_counter==Nof($s_tab)) then
      M_d3propertymat = M_d3distmat
      M_d3distmat = 1.-M_d3distmat
    else
      return "The distance matrix should either be a distance matrix with all diagonals == 0, or a similarity matrix with all diagonals == 1"
    endif
    i_property = 1
  endif

  if (s_propertymat!="") then
    if (Extension(s_propertymat)==".mat") then
      if (!Exist(s_propertymat)) return "Property matrix specified not found"
      read matrix s_propertymat name=Replace(s_propertymat ".mat" "")
      s_propertymat = Replace(s_propertymat ".mat" "")
    endif
    s_tabpropertymat = s_tab+"."+s_propertymat
    if (Type($s_tabpropertymat)=="matrix") then
      M_d3propertymat = $s_tabpropertymat
    elseif (Type($s_propertymat)=="matrix") then
      M_d3propertymat = $s_propertymat
    else
      return "Property matrix specified not found"
    endif
    i_counter = 0
    if (Nof(M_d3propertymat)!=Nof($s_tab)) return "Property matrix should have the same number of row as the node table"
    if (Nof(M_d3propertymat)==Nof(M_d3propertymat[1])) then
      for i_tmp = 1, Nof(M_d3propertymat)
        if (M_d3propertymat[i_tmp, i_tmp] == Min(M_d3propertymat[i_tmp])) then
          i_counter -= 1
        elseif (M_d3propertymat[i_tmp, i_tmp] == Max(M_d3propertymat[i_tmp])) then
          i_counter += 1
        endif
      endfor
    endif
    if (i_counter == Nof($s_tab)) then
      i_property = 1
    elseif (i_counter == -Nof($s_tab)) then
      i_property = -1
    else
      M_d3propertytmp = M_d3propertymat
      for i_tmp = 1, Nof(M_d3propertytmp[1])
        M_d3propertytmp[?, i_tmp] = (M_d3propertytmp[?, i_tmp]-Mean( M_d3propertytmp[?, i_tmp]))/Max(Rmsd(M_d3propertytmp[?, i_tmp]) 0.0000001)
      endfor
      if (Type(M_d3distmat)=="unknown") then
        M_d3distmat = Distance(M_d3propertytmp)
        M_d3propertymat =  Max(Max(Max(M_d3distmat)) 1.) - M_d3distmat
      else
        M_d3distmattmp = Distance(M_d3propertytmp)
        M_d3propertymat =  Max(Max(Max(M_d3distmattmp)) 1.) - M_d3distmattmp
      endif
      i_property = 1
    endif
    if (Type(M_d3distmat)=="unknown") then
      M_d3distmat = Matrix(Nof($s_tab ) Nof($s_tab))
      for i_tmp = 1, Nof($s_tab)
        for j_tmp = 1, Nof($s_tab)
          if (i_tmp == j_tmp) continue
          M_d3distmat[i_tmp, j_tmp] = 1.-M_d3propertymat[i_tmp, j_tmp]/(M_d3propertymat[i_tmp, i_tmp]+ M_d3propertymat[j_tmp, j_tmp] - M_d3propertymat[i_tmp, j_tmp])
        endfor
      endfor
    endif
  endif

  if (Type(M_d3distmat)=="unknown") return "Cannot calculate Distance matrix"
  if (Type(M_d3propertymat)=="unknown") return "Cannot calculate Common Property matrix"

  group table "d3nodeinput" Tostring($s_tabcol) "name"
  add column d3nodeinput Rarray(Nof($s_tab) 0.) name="value"
#  if (s_colorcol!="") add column d3nodeinput $s_tabcolorcol name="color"
  group table d3nodeinput header append M_d3distmat
  group table d3nodeinput header append M_d3propertymat
  for i_tmp = 1, Nof(d3nodeinput)
    d3nodeinput.value[i_tmp] = d3nodeinput.M_d3propertymat[i_tmp, i_tmp]
  endfor
  add column d3nodeinput Count(Nof(d3nodeinput)) name="origord"
  make tree d3nodeinput full "UPGMA" split="cl" label="%name" distance="M_d3distmat"
  for i_dist = 1, 18
    r_dist = 0.05*i_dist
    d3nodeinput.cl = Cluster(d3nodeinput.M_d3distmat r_dist)
    if (Toreal(Nof(d3nodeinput.cl!=0 ))/Nof(d3nodeinput)>0.9) break
  endfor
  split d3nodeinput.cluster r_dist
  d3nodeinput.cl = Cluster(d3nodeinput.M_d3distmat r_dist)

  d3output S_d3type i_property
endmacro
#
macro makeHtmlfromEdge s_tab ("") s_col1 ("") s_col2 ("") s_propertycol ("") s_distcol ("") S_nodesname (Sarray(0)) R_nodesproperty (Rarray(0)) S_d3type ({"all"}) auto
  HELP = """
  This is a macro to use a edge table with associated column name as input for d3 rendering
  Usage:
    makeHtmlfromEdge <s_tab> <s_col1> <s_col2> <s_propertycol> <s_distcol> <S_nodesname> <R_nodesproperty>
  <s_tab>: name of the table
  <s_col1>: name of the column that contains the source node
  <s_col2>: name of the column that contains the target node
  if s_col1 and s_col2 are both integer, then the optional S_nodesname and R_nodesproperty can be used to provide the name and property of the nodes

  Either specify <s_propertycol> or <s_distcol>, or both
  <s_propertycol>: name of the column that contains the common property between nodes (or property of the edges)
  if <s_propertycol> is specified, then all the nodes' property should be provided too, either from within the edge table (i.e. entries where source==target), or provided with <R_nodesproperty>

  <s_distcol>: name of the column that contain the distance between nodes (or edge distance).  The self distance should be all 0. (distance matrix) or all 1. (similarity matrix)

  <S_nodesname>: Optional, if s_col1 and s_col2 are both integer, then the name specified in S_nodesname can be used
  <R_nodesproperty>: Required if the nodes property are not provided in the edge table

  Example:
    makeHtmlfromEdge 'T_edgetable' 'sourcename' 'targetname' 'CommonHit' 'dist'
    makeHtmlfromEdge 'T_edgetable' 'sourceid' 'targetid' '' 'dist' S_nodesname R_nodesproperty

"""
  l_commands=no; l_info=no; l_warn=no
  if (Type(d3nodeinput)!="unknown") delete d3nodeinput l_warn=no
  s_tab = Trim(s_tab all); s_col1 = Trim(s_col1 all); s_col2 = Trim(s_col2 all)
  if (s_tab == "") return "Please specify table name"
  if (Type($s_tab)!="table") return "Table not found"
  if (s_col1 =="") return "Please specify name of first column"
  if (s_col2 =="") return "Please specify name of second column"
  s_tabcol1 = s_tab+"."+s_col1; s_tabcol2 = s_tab+"."+s_col2
  if ((Type($s_tabcol1)!="iarray")& (Type($s_tabcol1)!="sarray")) return "Column 1 need to be either iarray or sarray"
  if ((Type($s_tabcol2)!="iarray")& (Type($s_tabcol2)!="sarray")) return "Column 2 need to be either iarray or sarray"
  s_propertycol=Trim(s_propertycol all); s_distcol=Trim(s_distcol all)
  if ((s_propertycol=="") & (s_distcol=="")) return "Please specify name of the property column and/or distance column"
  if (s_propertycol!="") then
    s_tabproperty = s_tab+"."+s_propertycol
    if ((Type($s_tabproperty)!="iarray") & (Type($s_tabproperty)!="rarray")) return "Property column need to be iarray or rarray"
  endif
  if (s_distcol!="") then
    s_tabdist = s_tab+"."+s_distcol
    if ((Type($s_tabdist)!="rarray")) return "Distance column need to be rarray"
  endif
  group table d3edgeinput $s_tabcol1 "source" $s_tabcol2 "target"
  S_nodes = Tostring(S_nodesname)
  R_nodes = Toreal(R_nodesproperty)
  if (S_nodes != Sarray(0)) then
    if ((Type(d3edgeinput.source)!="iarray")|(Type(d3edgeinput.target)!="iarray")) return "For separate nodes name to work, col1 and col2 need to be iarray"
    if ((Min(d3edgeinput.source)==0)|(Min(d3edgeinput.target)==0)) then
      d3edgeinput.source = d3edgeinput.source + 1
      d3edgeinput.target = d3edgeinput.target + 1
    endif
    I_tmp =  Unique(Sort(d3edgeinput.source // d3edgeinput.target))
    if (Nof(I_tmp)>Nof(S_nodes)) return "Not enough nodes name to match the edges"
    if (Max(I_tmp)>Nof(S_nodes)) return "Edge number exceeds the number of nodes name"
    S_nodestmp = S_nodes
    group table d3nodetmp S_nodestmp "name" Count(Nof(S_nodestmp)) "i"
    join left d3edgeinput.source d3nodetmp.i name="T_join"
    delete d3edgeinput.source; add column d3edgeinput T_join.name name="source"
    join left d3edgeinput.target d3nodetmp.i name="T_join"
    delete d3edgeinput.target; add column d3edgeinput T_join.name name="target"
    delete d3nodetmp T_join l_warn=no
  endif
  if (Type(d3edgeinput.source)=="iarray") add column d3edgeinput Tostring(d3edgeinput.source,"") index=1 name="source" delete
  if (Type(d3edgeinput.target)=="iarray") add column d3edgeinput Tostring(d3edgeinput.target,"") index=2 name="target" delete
  if (s_propertycol!="") then
    add column d3edgeinput Toreal($s_tabproperty) name="value"
  endif
  if (s_distcol!="") then
    add column d3edgeinput Toreal($s_tabdist) name="dist"
  endif

  if (Type(d3nodeinput)!="unknown") delete d3nodeinput l_warn=no
  if ((S_nodes != Sarray(0)) & (Nof(R_nodes)==Nof(S_nodes))) then
    group table d3nodeinput S_nodes "name" R_nodes "value"
  else
    S_tmpname = Unique(Sort(d3edgeinput.source // d3edgeinput.target ))
    group table d3nodeinput S_tmpname "name" Toreal(Sarray(Nof(S_tmpname) "ND")) "value"
    if (s_propertycol!="") then
      for i_tmp = 1, Nof(d3nodeinput)
        if (Nof(d3edgeinput.source==d3nodeinput.name[i_tmp] & d3edgeinput.target==d3nodeinput.name[i_tmp])==0) continue
        d3nodeinput.value[i_tmp] = d3edgeinput.value[Index(d3edgeinput.source==d3nodeinput.name[i_tmp] & d3edgeinput.target==d3nodeinput.name[i_tmp])[1]]
      endfor
      if (Nof(d3nodeinput.value == Toreal("ND"))!=0) return "Either specify S_nodesname+R_nodesproperty, or include Nodes property (source=target) in edge table"
    endif
    sort reverse d3nodeinput.value
  endif

  if (Type(d3edgeinput.dist)!="unknown") then
    M_d3distmat = Matrix(Nof(d3nodeinput) Nof(d3nodeinput) Max(Max(d3edgeinput.dist) 1.))
    R_tmp = Rarray(0)
    for i_tmp = 1, Nof(d3edgeinput)
      j_tmp = Index(d3nodeinput.name==d3edgeinput.source[i_tmp])[1]
      k_tmp = Index(d3nodeinput.name==d3edgeinput.target[i_tmp])[1]
      if (j_tmp == k_tmp) R_tmp//= d3edgeinput.dist[i_tmp]
      M_d3distmat[j_tmp, k_tmp] = d3edgeinput.dist[i_tmp]
    endfor
    if ((Nof(R_tmp)==0)|((Max(R_tmp)==0.)&(Min(R_tmp)==0.))) then
      for i_tmp = 1, Nof(M_d3distmat)
        M_d3distmat[i_tmp, i_tmp] = 0.
      endfor
    elseif ((Max(R_tmp)==1.)&(Min(R_tmp)==1.)) then
      M_d3distmat = 1.-M_distmat
    else
      return "Distance matrix looks off, diagonal entries should be all 0. (distance) or 1. (similarity)"
    endif
  endif

  if (Type(d3edgeinput.value)!="unknown") then
    M_d3propertymat = Matrix(Nof(d3nodeinput))
    for i_tmp = 1, Nof(M_d3propertymat)
      if (d3nodeinput.value[i_tmp]!=Toreal("ND")) M_d3propertymat[i_tmp, i_tmp] = d3nodeinput.value[i_tmp]
    endfor
    for i_tmp = 1, Nof(d3edgeinput)
      j_tmp = Index(d3nodeinput.name==d3edgeinput.source[i_tmp])[1]
      k_tmp = Index(d3nodeinput.name==d3edgeinput.target[i_tmp])[1]
      M_d3propertymat[j_tmp, k_tmp] = d3edgeinput.value[i_tmp]
    endfor
  endif

  if (Type(d3edgeinput.value)=="unknown") then
    M_d3propertymat = Max(Max(Max(M_d3distmat)) 1.) - M_d3distmat
  endif

  if (Type(d3edgeinput.dist)=="unknown") then
    M_d3distmat = Matrix(Nof(d3nodeinput) Nof(d3nodeinput))
    for i_tmp = 1, Nof(d3nodeinput)
      for j_tmp = 1, Nof(d3nodeinput)
        if (i_tmp == j_tmp) continue
        M_d3distmat[i_tmp, j_tmp] = 1.-M_d3propertymat[i_tmp, j_tmp]/(M_d3propertymat[i_tmp, i_tmp]+ M_d3propertymat[j_tmp, j_tmp] - M_d3propertymat[i_tmp, j_tmp])
      endfor
    endfor
  endif

  if (Type(M_d3distmat)=="unknown") return "Cannot calculate Distance matrix"
  if (Type(M_d3propertymat)=="unknown") return "Cannot calculate Common Property matrix"

  i_counter = 0
  for i_tmp = 1, Nof(M_d3propertymat)
    if (M_d3propertymat[i_tmp, i_tmp] == Min(M_d3propertymat[i_tmp])) then
      i_counter -= 1
    elseif (M_d3propertymat[i_tmp, i_tmp] == Max(M_d3propertymat[i_tmp])) then
      i_counter += 1
    endif
  endfor
  if (i_counter == Nof(M_d3propertymat)) then
    i_property = 1
  elseif (i_counter == -Nof(M_d3propertymat)) then
    i_property = -1
  else
    return "The nodes property should either be the max or min of the edge"
  endif

  group table d3nodeinput header append M_d3distmat
  group table d3nodeinput header append M_d3propertymat
  for i_tmp = 1, Nof(d3nodeinput)
    d3nodeinput.value[i_tmp] = d3nodeinput.M_d3propertymat[i_tmp, i_tmp]
  endfor
  add column d3nodeinput Count(Nof(d3nodeinput)) name="origord"
  make tree d3nodeinput full "UPGMA" split="cl" label="%name" distance="M_d3distmat"
  for i_dist = 1, 18
    r_dist = 0.05*i_dist
    d3nodeinput.cl = Cluster(d3nodeinput.M_d3distmat r_dist)
    if (Toreal(Nof(d3nodeinput.cl!=0 ))/Nof(d3nodeinput)>0.9) break
  endfor
  split d3nodeinput.cluster r_dist
  d3nodeinput.cl = Cluster(d3nodeinput.M_d3distmat r_dist)

  d3output S_d3type i_property
endmacro
#
macro d3output S_output ({"HeatMap","Chord","Tree","Force","Neato"}) i_property (1) auto
HELP = """
  Used by makeHtmlfromNode and makeHtmlfromEdge to output d3 html script
"""
  l_info=no; l_commands=no; l_warn=no
  if (Type(d3nodeinput)!="table") return "Table specified not found"
  if (Type(d3nodeinput.M_d3distmat)!="matrix") return "Distance matrix not found in the table"
  if (Type(d3nodeinput.M_d3propertymat)!="matrix") return "Property matrix not found in the table"

  M_tmp1 = d3nodeinput.M_d3distmat
  M_tmp2 = d3nodeinput.M_d3propertymat
  if (S_output == Sarray(1 "all")) S_output = {"HeatMap","Chord","Tree","Force","Neato"}
  if (Index(S_output "Neato")!=0) then
   read sys whereis neato
   if (Field(Split(s_out "\n")[1] 2 ":") == "") then
    print "Graphviz Neato installation cannot be found, will not make Graphviz SVG"
   else
    mstmp2 = d3nodeinput
    rename mstmp2.value "count"
    if (Type(T_tmppanel2)=="table") then
      join left mstmp2.name T_tmppanel2.NAME name="T_tmpjoin"
      mstmp2.name = Replace(Replace(Replace(Replace(Replace(T_tmpjoin.model "dfa" "") "kcc" "") "dpc" "") "dfz" "") "mcp" "")
    endif
    rename mstmp2.name "Target"
    I_fontsizes={14}//Tointeger(Sqrt(mstmp2.count[1]))
    R_3th={0.8}//Distance(mstmp2.cluster split)//Distance(mstmp2.cluster split)-0.1
    R_sizescale = {1.0, 0.4}
    R_sizescale[2] = Log(5.*12.)/Log(mstmp2.count[1])
    r_minlen = 12.
    s_headfm = """
graph G {
graph [overlap=false; splines=false; model=mds; outputorder=nodesfirst, nodesep=10, size=40!];
node [shape=doublecircle; style=filled; fillcolor=white; fontsize=%d];
edge [fontsize=%d];
"""
    s_nodefm = '"%s"[label="%s" fillcolor="%s" fontsize="%s"'
    s_edgefm = '"%s" -- "%s" [len=%.2f, weight=%.1f, penwidth=%.3f, color="%s"'
    ddot=R_3th[1]; dvis=R_3th[2]; dlab=R_3th[3]
#    dvis = r_targetdistcutoff
    curdir = Path()
    nodefontsize=I_fontsizes[1]; edgefontsize=I_fontsizes[2]
    sprintf s_headfm nodefontsize, edgefontsize
    sd = s_out
    S_color = {"#c7c7c7","#9edae5","#1f77b4","#aec7e8","#ff7f0e","#ffbb78","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5","#8c564b","#c49c94","#e377c2","#f7b6d2","#7f7f7f","#bcbd22","#dbdb8d","#17becf"}
    for i_tmp2=1,Nof(mstmp2)
      s_color = S_color[Mod(mstmp2.cl[i_tmp2] 20)+1]
#      sprintf s_nodefm mstmp2.Target[i_tmp2], mstmp2.Target[i_tmp2], s_color, Tostring(14+Power(mstmp2.count[i_tmp2] 0.9))
      sprintf s_nodefm mstmp2.Target[i_tmp2], mstmp2.Target[i_tmp2], s_color, Tostring(R_sizescale[1]*(12+Power(mstmp2.count[i_tmp2] R_sizescale[2])))
      sd += (s_out+"]\n")
    endfor
    seidmi = 100; seidmx = 0; dmi = 0.; dmx = 1.; wlim=1.
    print bar " Generating nodes ", Nof(mstmp2) l_info=yes
    for i_tmp2=1,Nof(mstmp2)-1
      for j_tmp2=i_tmp2+1,Nof(mstmp2)
        d = mstmp2.M_d3distmat[i_tmp2,j_tmp2]; seid = Integer(100*(1-d))
        if(seid>seidmx)seidmx=seid; if(seid<seidmi)seidmi=seid
#        if(d < r_targetdistcutoff ) then
        if(d < ddot ) then
#          dd = Distance(d evolution); w = 0.1/(d*d*d*d+0.01)
          dd = Distance(d evolution); w = 0.001/(Power(d 2)+0.0001)
          dd = Distance(d evolution); w = 0.01/(Power(d 2)+0.001)
#          commonhit = Sum(P_target [i_tmp2]&P_target[j_tmp2])[1]
          commonhit = mstmp2.M_d3propertymat[i_tmp2,j_tmp2]
          penwid = R_sizescale[1]*2*Toreal(Power(commonhit R_sizescale[2]))
          sprintf s_edgefm mstmp2.Target[i_tmp2], mstmp2.Target[j_tmp2], (0.1+d)*0.8*(r_minlen+Power(mstmp2.count[1] R_sizescale[2])), w, penwid, Color(Matrix(Color(d,"#0000ff/#33ff66/#ffffaa/#ffffff",0.,ddot-0.1)))[1]
          sd += s_out
          if(d > dvis) sd += " style=invis "
          if ((d < dlab) & (commonhit>=10)) sd += (' label="'+ commonhit +' cmpds" fontsize="'+Tostring(R_sizescale[1]*(20+Power(commonhit R_sizescale[2])))+'"' )
          sd += "]\n"
        endif
      endfor
      print bar Nof(mstmp2) l_info=yes
    endfor

    sd+= "\n}\n"
    write sd s_tempDir + "sgraph.dot" delete
    set directory s_tempDir
    print bar "done. Running neato\n"  l_info=yes
    sprintf "neato sgraph.dot -T%s -osgraph.%s\n", "svg", "svg"
    unix $s_out

#    printf " Params: {%d,%d} {%.2f,%.2f,%.2f} => sgraph.dot -> '%s/sgraph.%s'\n",nodefontsize,edgefontsize, ddot, dvis, dlab,s_tempDir,"svg"
    printf " SVG is written in '%s/sgraph.svg'\n", s_tempDir
    read string s_tempDir+"sgraph.svg" name="svg"
    tsvg = Table(svg, plot)
    sort tsvg.width; sort tsvg.ty
    write Sum(tsvg.tx) s_tempDir + "sgraph.svg" delete
    set directory curdir
    delete mstmp2 l_warn=no
   endif
  endif

  print "Please place the following files in the same folder before opening the html:"
  if (Index(S_output "HeatMap")!=0) then
   if (Nof(d3nodeinput)>200) then
    print "Heat Map can only handle at most 200 entries"
   else
    group table d3HeatMap Iarray(0) "Source" Iarray(0) "Target" Rarray(0) "dist" Rarray(0) "value"
    for i_node = 1, Nof(d3nodeinput)
      group table "mstmp4" Count(Nof(d3nodeinput)) "Source" Iarray(Nof(d3nodeinput) i_node) "Target" Toreal(Tointeger(M_tmp1[i_node]*100))/100. "dist" Toreal(M_tmp2[i_node]) "value"
      add d3HeatMap mstmp4; delete mstmp4
    endfor
    if (Max(d3HeatMap.value)<=1. & Min(d3HeatMap.value)>=0.) then
      add column d3HeatMap d3HeatMap.value name="colorvalue"
    else
      add column d3HeatMap Rarray(Nof(d3HeatMap), -1.) name="colorvalue"
      d3HeatMap.colorvalue [Index(d3HeatMap.value !=0)]=Log(Toreal(d3HeatMap.value[Index(d3HeatMap.value != 0)])*i_property 10)
      d3HeatMap.colorvalue = d3HeatMap.colorvalue+1 ; d3HeatMap.colorvalue = d3HeatMap.colorvalue / Max(d3HeatMap.colorvalue)
    endif
    write table d3HeatMap separator="\t" header "d3HeatMap.tsv" delete
    read string s_icmhome+"/d3HeatMap.html" name="s_heatmap"
    S_heatmap = Split(s_heatmap "\n")
    S_heatmap[Index(Index(S_heatmap ".*?var margin" regexp) 1)] = " var margin = { top: "+String(Max(Length(d3nodeinput.name))*8+10)+", right: 10, bottom: 50, left: "+String(Max(Length(d3nodeinput.name+": "+Tostring(d3nodeinput.value)))*8+10)+" },"
    S_heatmap[Index(Index(S_heatmap ".*?col_number=" regexp) 1)] = "  col_number="+String(Nof(d3nodeinput))+";"
    S_heatmap[Index(Index(S_heatmap ".*?row_number=" regexp) 1)] = "  row_number="+String(Nof(d3nodeinput))+";"
    sort d3nodeinput.ord
    S_heatmap[Index(Index(S_heatmap ".*?hcrow = " regexp) 1)] = " hcrow = ["+Sum(Tostring(d3nodeinput.origord) ",")+"],"
    S_heatmap[Index(Index(S_heatmap ".*?hccol = " regexp) 1)] = " hccol = ["+Sum(Tostring(d3nodeinput.origord) ",")+"],"
    sort d3nodeinput.origord
    S_heatmap[Index(Index(S_heatmap ".*?rowLabel = " regexp) 1)] = "  rowLabel = ['"+Sum(d3nodeinput.name+": "+Tostring(d3nodeinput.value) "','")+"'],"
    S_heatmap[Index(Index(S_heatmap ".*?colLabel = " regexp) 1)] = "  colLabel = ['"+Sum(d3nodeinput.name "','")+"'];"
    S_heatmap[Index(Index(S_heatmap ".*?group = " regexp) 1)] = " group = ["+Sum(Tostring(d3nodeinput.cl) ",")+"],"
    print "d3HeatMap.html, d3HeatMap.tsv"
    write string Sum(S_heatmap "\n") "d3HeatMap.html" delete
    delete d3HeatMap
   endif
  endif

  if (Index(S_output "Chord")!=0) then
   if (Nof(d3nodeinput)>200) then
    print "Chord Diagram can only handle at most 200 entries"
   else
    s_mat = ""
    for i_node = 1, Nof(d3nodeinput)
      s_mat = s_mat+ ",["+Sum(Tostring(Tointeger(M_tmp2[i_node])) ",")+"]"
    endfor
    s_mat = "["+s_mat[2:$]+"]"
    write string s_mat "d3Chord2.json" delete
    group table mstmp4 d3nodeinput.name "name" d3nodeinput.value "hit" d3nodeinput.name+": "+Tostring(Tointeger(d3nodeinput.value)) "label" d3nodeinput.cl "group"
    write table separator="\t" header mstmp4 "d3Chord1.tsv" delete; delete mstmp4 l_warn=no
    read string s_icmhome+"/d3Chord.html" name="s_tmp"
    print "d3Chord.html, d3Chord1.tsv, and d3Chord2.json"
    write string s_tmp "d3Chord.html" delete
   endif
  endif

  if (Index(S_output "Force")!=0) then
    group table "d3Node" Count(Nof(d3nodeinput)) "ID" d3nodeinput.name "name" d3nodeinput.value "value"
    group table "d3Edge" Iarray(0) "Source" Iarray(0) "Target" Rarray(0) "dist" Rarray(0) "value"
    r_targetdistcutoff = Distance(d3nodeinput.cluster  split)
    for i_node = 1, Nof(d3Node)
      group table "mstmp4" Iarray(Nof(d3Node) i_node) "Source" Count(Nof(d3Node)) "Target" d3nodeinput.M_d3distmat[i_node] "dist" Rarray(Nof(d3Node) 0) "value"
      mstmp4 = mstmp4.Target!=i_node
      mstmp4 = mstmp4.dist < r_targetdistcutoff
      mstmp4 = mstmp4.Target > i_node
      for j_node = 1, Nof(mstmp4)
        mstmp4.value[j_node] = d3nodeinput.M_d3propertymat[mstmp4.Source[j_node] mstmp4.Target[j_node] ]
      endfor
      add d3Edge mstmp4
      delete mstmp4
    endfor
    d3Edge = d3Edge.value != 0.
    add column d3Node Count(0 Nof(d3Node)-1) name="newID"
    join left d3Edge.Source d3Node.ID name="T_join"
    add column d3Edge T_join.name name="SourceName" index=1
    d3Edge.Source = T_join.newID
    join left d3Edge.Target d3Node.ID name="T_join"
    add column d3Edge T_join.name name="TargetName" index=2
    d3Edge.Target = T_join.newID
    d3Node.ID = d3Node.newID; delete d3Node.newID
    delete T_join
    move d3Node.name 1
    d3Edge.dist = Toreal(Tointeger(d3Edge.dist*100))/100.

    group table mstmp4 d3Node.name "name" d3Node.ID "ID" d3Node.value "value"
    join left mstmp4.name d3nodeinput.name name="T_join"
    add column mstmp4 T_join.cl name="group"; delete T_join
    add column mstmp4 mstmp4.name+": "+Tostring(mstmp4.value) name="label"
    group table mstmp5 d3Edge.Source "source" d3Edge.Target "target" d3Edge.value "value" d3Edge.dist "dist"
    add column mstmp5 mstmp4.name[mstmp5.source+1]+"-"+mstmp4.name[mstmp5.target+1]+Sarray(Nof(mstmp5) " Value: ")+Tostring(mstmp5.value)+": dist: "+Tostring(Tointeger(mstmp5.dist*1000.)/1000.) name="label"
    nodes = Array()
    for i_nodes = 1, Nof(mstmp4)
      nodes//=  Collection("name" mstmp4.name[i_nodes] "group" mstmp4.group[i_nodes] "value" mstmp4.value[i_nodes] "label" mstmp4.label[i_nodes])
    endfor
    links = Array()
    for i_links = 1, Nof(mstmp5)
      links//= Collection("source" mstmp5.source[i_links] "target" mstmp5.target[i_links] "value" mstmp5.value[i_links] "dist" mstmp5.dist[i_links] "label" mstmp5.label[i_links])
    endfor
    c = Collection("nodes" nodes "links" links)
    write c "d3Force.json" delete

    read string s_icmhome+"/d3Force.html" name="s_tmp"
    print "d3Force.html, d3Force.json"
    write string s_tmp "d3Force.html" delete
  endif

  if (Index(S_output "Tree")!=0) then
   if (Nof(d3nodeinput)>2000) then
    print "Cluster Tree can only handle at most 2000 entries"
   else
    d3nodeinput.name = d3nodeinput.name+" "+Tostring(d3nodeinput.value)
#    d3nodeinput.name = Replace(d3nodeinput.name "[;,]" " ")
    sort d3nodeinput.ord
    add column d3nodeinput d3nodeinput.ord-1 name="ord2"
    group table colortmp Count(20)-1 "cl" {"#9edae5","#1f77b4","#aec7e8","#ff7f0e","#ffbb78","#2ca02c","#98df8a","#d62728","#ff9896","#9467bd","#c5b0d5","#8c564b","#c49c94","#e377c2","#f7b6d2","#7f7f7f","#c7c7c7","#bcbd22","#dbdb8d","#17becf"} "color"
    add column d3nodeinput Mod(d3nodeinput.cl 20) name="mod"
    join left d3nodeinput.mod colortmp.cl name="T_join"
    add column d3nodeinput T_join.color name="color"
    write table d3nodeinput separator="\t" header "d3Tree2.tsv" delete
    d3nodeinput.name = Tostring(d3nodeinput.ord2)
    write string Replace( String(d3nodeinput.cluster ) "'" "") "d3Tree1.tre" delete

    read string s_icmhome+"/d3Tree.html" name="s_tmp"
    S_tmp = Split(s_tmp "\n")
    S_tmp[Index(Index(S_tmp ".*?\.domain" regexp) 1 )] =  "    .domain([\""+Sum(d3nodeinput.name "\",\"")+"\"])"
    S_tmp[Index(Index(S_tmp ".*?\.range" regexp) 1 )] =  "    .range([\""+Sum(d3nodeinput.color "\",\"")+"\"]);"
    S_tmp[Index(Index(S_tmp ".*?var outerRadius" regexp) 1 )] =  "var outerRadius = "+String(1200+3*Nof(d3nodeinput))+" / 2,"
    print "d3Tree.html, d3Tree1.tre, and d3Tree2.tsv"
    write string Sum(S_tmp "\n") "d3Tree.html" delete
   endif
  endif

endmacro
#
macro predictModelsCompact s_tab ("") S_modelkey ({"kcc"}) S_combinecol ({"MolScore","MolpKd"})
  l_info = no; l_commands=no; l_warn=no
  if (s_tab == "") return "Table name not specified"
  if (Nof(S_modelkey)==0) return "Model keyword not specified"
  if (Nof(S_combinecol)==0) return "Combined column not specified"
  s_tab = Trim(s_tab all)
  if (Type($s_tab)!="table") return "Table not found"
  read binary s_icmhome+"models/catkcc.icb"; S_modlist = catkcc.model; delete catkcc
  read binary s_icmhome+"models/catdfa.icb"; S_modlist //= catdfa.model; delete catdfa
  read binary s_icmhome+"models/catdfz.icb"; S_modlist //= catdfz.model; delete catdfz
  read binary s_icmhome+"models/catdpc.icb"; S_modlist //= catdpc.model; delete catdpc
  read binary s_icmhome+"models/catmcp.icb"; S_modlist //= catmcp.model; delete catmcp
  I_keep = Iarray()
  for i_modelkey = 1, Nof(S_modelkey)
    I_keep //= Index(S_modlist S_modelkey[i_modelkey] regexp all)
  endfor
  if (Nof(I_keep)==0) return "No model specified by model keyword"
  S_modlist = S_modlist[Unique(Sort(I_keep))]
  T_tabtmp = $s_tab
  if (Type(msLigandModel)!="unknown") delete msLigandModel
  if (Type(msLigandTarget)!="unknown") delete msLigandTarget
  for i_mod = 1, Nof(S_modlist)
    s_mod = S_modlist[i_mod]
    if ((Type($s_mod)=="unknown")&!Exist(s_icmhome+"models/"+s_mod+".icb")) then
      S_modelsDir = Split(TOOLS.modelsDir ";")
      l_continue = yes
      for i_modelsDir = 1, Nof(S_modelsDir)
        if Exist(S_modelsDir[i_modelsDir]+s_mod+".icb") l_continue = no
      endfor
      if (l_continue) continue
    endif
    print "Predicting model:" i_mod "out of:" Nof(S_modlist) "models, name:" s_mod
    T_predicttmp = T_tabtmp
    predictModels "T_predicttmp" Sarray(1 s_mod)
    if (Nof(msLigandModel)==Nof(T_tabtmp)) then
      S_cpdtmp = msLigandModel.Target+Sarray(Nof(msLigandModel) "_"+s_mod[1:3])
      for i_combinecol = 1, Nof(S_combinecol)
        s_combinecol = S_combinecol[i_combinecol]
        if (Type(msLigandModel.$s_combinecol)=="unknown") return "combined column not found"
        S_cpdtmp = S_cpdtmp + Sarray(Nof(S_cpdtmp) ": "+s_combinecol+": ")+Tostring(Tointeger(msLigandModel.$s_combinecol*100.)/100.)
      endfor
    endif
    delete msLigandModel msLigandTarget l_warn=no
    if (Type(T_tabtmp.MolSummary)=="unknown") then
      add column T_tabtmp S_cpdtmp name="MolSummary"
    else
      T_tabtmp.MolSummary = T_tabtmp.MolSummary + Sarray(Nof(T_tabtmp) "\n") + S_cpdtmp
    endif
  endfor
  delete T_predicttmp
  for i_cpd = 1, Nof(T_tabtmp)
    S_tmpsummary = Split(T_tabtmp.MolSummary[i_cpd] "\n")
    group table T_predicttmp S_tmpsummary "A"
    add column T_predicttmp Toreal(Field(T_predicttmp.A 3 ":")) name="B"
    sort reverse T_predicttmp.B
    T_predicttmp = T_predicttmp.B != 0.
    T_tabtmp.MolSummary[i_cpd] = Sum(T_predicttmp.A "\n")
    delete T_predicttmp
  endfor
  T_tabtmp.doubleClick = """
if (Type(expandMolSummary)!="unknown") expandMolSummary Name(variable %@) String(%^) %#
"""
  delete $s_tab
  rename T_tabtmp s_tab
  keep $s_tab
endmacro
#
macro foldMolSummary s_tab ("") s_Pairwisetab ("msLigandModel") s_uniquecolumn ("") S_combinecol ({"MolScore","MolpKd","pPvalue","MolClass","MolSim"}) s_fileloc ("") l_keepall (yes) auto
  l_info = no;l_commands=no
  if (s_tab == "") return "Table not specified"
  if (Type($s_tab)!="table") return "Table not found"
  if (s_Pairwisetab =="") then
    if (s_fileloc == "") return "Pairwise table not specified"
  elseif (s_Pairwisetab !="") then
    if (Type($s_Pairwisetab)!="table") return "Pairwise table not found"
  endif
  if (s_uniquecolumn=="") return "Unique column not specified"
  if (Type($s_tab.$s_uniquecolumn)=="unknown") return "unique column not found"
  if (s_Pairwisetab!="") then
    if (Type($s_Pairwisetab.$s_uniquecolumn)=="unknown") return "unique column not found"
  endif
  if (Nof(S_combinecol)==0) return "No combine column specified"
  i_noffile = 1
  if (s_fileloc != "") then
    if ((Extension(s_fileloc)!=".icb")&(Extension(s_fileloc)!=".csv")) return "Please specify either .csv or .icb file location"
    if Exist(s_fileloc) then
      S_fileloc = Sarray(1 s_fileloc)
    else
      if (Version()~"*WIN*") then
        S_fileloc = Sarray(s_fileloc directory)
      else
        if (Type(S_fileloc)!="unknown") delete S_fileloc
        S_fileloc = Unique(Sort(Sarray(s_fileloc directory)))
#        read sarray "S_fileloc" sys $s_sysLs $s_fileloc

      endif
    endif
    if (Nof(S_fileloc)==0) return "Cannot find file in file location specified"
    i_noffile = Nof(S_fileloc)
  endif
  if (s_Pairwisetab!="") then
    for i_col = 1, Nof(S_combinecol)
      s_combinecol=S_combinecol[i_col]
      if (Type($s_Pairwisetab.$s_combinecol)=="unknown") return "Combine column not found"
    endfor
  endif
  T_tmpmacro = $s_tab
 N = i_noffile
 sprintf " Info> Folding %d files into table '%s' ",N,s_tab
 print bar s_out  N l_info=yes
 for i_file = 1, i_noffile
  if (Type(S_fileloc)!="unknown") then
    s_fileloc = S_fileloc[i_file]
    if (Extension(s_fileloc)==".icb") read binary s_fileloc
    if (Extension(s_fileloc)==".csv") then
      s_filelocname = Name(s_fileloc); delete $s_filelocname l_warn=no
      read csv header s_fileloc
    endif
    s_Pairwisetab = Name(s_fileloc)
    if (Type($s_Pairwisetab)!="table") return "Pairwise table not found"
  else
    T_Pairwiseold = $s_Pairwisetab
    delete $s_Pairwisetab
    $s_Pairwisetab = T_Pairwiseold
    delete T_Pairwiseold
    keep $s_Pairwisetab
  endif
  $s_Pairwisetab = $s_Pairwisetab.$s_uniquecolumn == T_tmpmacro.$s_uniquecolumn
  I_keep = Iarray(0)
  S_convertcol = {"MolScore","MolZScore","MolpKd","pPvalue","MolClass"}
  for i_convertcol = 1, Nof(S_convertcol)
    s_convertcol = s_Pairwisetab+"."+S_convertcol[i_convertcol]
    if (Type($s_convertcol)=="sarray") then
      R_tmp = Toreal($s_convertcol)
      delete $s_convertcol l_warn=no
      add column $s_Pairwisetab R_tmp name=S_convertcol[i_convertcol]
    endif
  endfor
  if (Type($s_Pairwisetab.MolScore)=="rarray") I_keep = Index($s_Pairwisetab.MolScore>=3.)
  if (Type($s_Pairwisetab.MolZScore)=="rarray") I_keep //= Index($s_Pairwisetab.MolZScore>=2.)
  if (Type($s_Pairwisetab.MolpKd)=="rarray") I_keep //= Index($s_Pairwisetab.MolpKd>=5.)
  if (Nof(I_keep)==0) then
    if (Type($s_Pairwisetab.pPvalue)=="rarray") I_keep //= Index($s_Pairwisetab.pPvalue>=2.)
    if (Type($s_Pairwisetab.MolClass)=="rarray") I_keep //= Index($s_Pairwisetab.MolClass>=0.1)
  endif
  I_keep = Unique(Sort(I_keep))
  if (l_keepall) then
    T_Pairwisetab = $s_Pairwisetab
  else
    T_Pairwisetab = $s_Pairwisetab[I_keep]
  endif
  if (Nof(T_Pairwisetab)==0) continue
  if (Type(T_tmpmacro.MolSummary)=="unknown") then
    add column T_tmpmacro Sarray(Nof(T_tmpmacro) "") name="MolSummary"
    add column T_tmpmacro Sarray(Nof(T_tmpmacro) "") name="MolSummaryloc"
    add column T_tmpmacro Sarray(Nof(T_tmpmacro) "") name="MolSummarysmi"
    add column T_tmpmacro Sarray(Nof(T_tmpmacro) "") name="MolSummarytargetname"
  endif
  S_unique = Unique(Sort(T_Pairwisetab.$s_uniquecolumn))
  if (Nof(S_unique)==0) return "Unique column has nothing"
  for i_unique = 1, Nof(S_unique)
    s_unique = S_unique[i_unique]
    if (Nof(T_tmpmacro.$s_uniquecolumn==s_unique)!=1) return "Unique column is not unique"
    i_cpd = Index(T_tmpmacro.$s_uniquecolumn==s_unique)[1]
    I_entries = Index(T_Pairwisetab.$s_uniquecolumn s_unique all)
    if (Nof(I_entries)==0) continue
    group table T_tabtmp (T_Pairwisetab.Target)[I_entries]+Sarray(Nof(I_entries) "_")+(T_Pairwisetab.predictType)[I_entries] "Target"
    if (Extension(s_fileloc)==".icb") then
      add column T_tabtmp Sarray(Nof(T_tabtmp) s_fileloc) name="fileloc"
      add column T_tabtmp  Smiles((T_Pairwisetab).mol[I_entries] unique cistrans) name="smi"
      add column T_tabtmp  (T_Pairwisetab).Target_Name[I_entries] name="targetname"
    else
      add column T_tabtmp Sarray(Nof(T_tabtmp) "") name="fileloc"
      add column T_tabtmp  Sarray(Nof(T_tabtmp) "") name="smi"
      if (Type( (T_Pairwisetab).Target_Name[I_entries]) == "sarray" ) then
        add column T_tabtmp  (T_Pairwisetab).Target_Name[I_entries] name="targetname"
      else
        add column T_tabtmp  Sarray(Nof(T_tabtmp) "") name="targetname"
      endif
    endif
    for i_col = 1, Nof(S_combinecol)
      s_combinecol=S_combinecol[i_col]
      add column T_tabtmp (T_Pairwisetab.$s_combinecol)[I_entries] name=s_combinecol
    endfor
    if (T_tmpmacro.MolSummary[i_cpd]!="") then
      S_tmpmacro = Split(T_tmpmacro.MolSummary[i_cpd] "\n")
      S_tmpmacro2 =  Split(T_tmpmacro.MolSummaryloc[i_cpd] "\n")
      S_tmpmacro3 =  Split(T_tmpmacro.MolSummarysmi[i_cpd] "\n")
      S_tmpmacro4 =  Split(T_tmpmacro.MolSummarytargetname[i_cpd] "\n")
      for i_row = 1, Nof(S_tmpmacro)
        add T_tabtmp
        T_tabtmp.Target[Nof(T_tabtmp)] =  Field(S_tmpmacro[i_row] 1 ":")
        i_noffield = (Nof(Split(S_tmpmacro[i_row] ":"))-1)/2
        for i_field = 1, i_noffield
          s_fieldname =  Trim(Split(S_tmpmacro[i_row] ":")[i_field*2] all)
          if (Type(T_tabtmp.$s_fieldname)=="unknown") then
            add column T_tabtmp Toreal(Sarray(Nof(T_tabtmp) "ND")) name=s_fieldname
          endif
          T_tabtmp.$s_fieldname[Nof(T_tabtmp)] = Toreal(Split(S_tmpmacro[i_row] ":")[i_field*2+1])
        endfor
        if (Nof(S_tmpmacro2)>=i_row) T_tabtmp.fileloc[Nof(T_tabtmp)] = S_tmpmacro2[i_row]
        if (Nof(S_tmpmacro2)>=i_row) T_tabtmp.smi[Nof(T_tabtmp)] = S_tmpmacro3[i_row]
        if (Nof(S_tmpmacro2)>=i_row) T_tabtmp.targetname[Nof(T_tabtmp)] = S_tmpmacro4[i_row]
      endfor
    endif
    move T_tabtmp.fileloc Nof(Name(T_tabtmp))
    move T_tabtmp.smi Nof(Name(T_tabtmp))
    move T_tabtmp.targetname Nof(Name(T_tabtmp))
    S_field = Name(T_tabtmp)
    for i_field = 1, Nof(S_field)-1
      s_field = S_field[Nof(S_field)-i_field+1]
      sort reverse $s_field
      if (s_field=="T_tabtmp.MolRecNNScore") sort $s_field
      if (s_field=="T_tabtmp.MolRecScore") sort $s_field
    endfor
    group T_tabtmp.Target all "first"  name="T_tabtmp_1"
    delete T_tabtmp; rename T_tabtmp_1 "T_tabtmp"
    S_tmpmacro = T_tabtmp.Target
    for i_field = 2, Nof(Name(T_tabtmp))-3
      s_field =  Name(T_tabtmp)[i_field]
      if (Type($s_field )=="rarray") then
        if (Nof($s_field==Toreal("ND")) == Nof(T_tabtmp)) continue
      endif
      S_tmpmacro = S_tmpmacro + Sarray(Nof(S_tmpmacro) ": "+Field(Name(T_tabtmp)[i_field] 2 ".")+": ")
      S_tmpmacro = S_tmpmacro + Tostring(Tointeger($s_field*100.)/100.)
    endfor
    T_tmpmacro.MolSummary[i_cpd] = Sum(S_tmpmacro "\n")
    T_tmpmacro.MolSummaryloc[i_cpd] = Sum(T_tabtmp.fileloc "\n")
    T_tmpmacro.MolSummarysmi[i_cpd] = Sum(T_tabtmp.smi "\n")
    T_tmpmacro.MolSummarytargetname[i_cpd] = Sum(T_tabtmp.targetname "\n")
    delete T_tabtmp
  endfor
  print bar N  l_info=yes
 endfor
 print bar "done\n"  l_info=yes
  set format T_tmpmacro.MolSummaryloc show off
  set format T_tmpmacro.MolSummarysmi show off
  set format T_tmpmacro.MolSummarytargetname show off
  add header T_tmpmacro name="toolsPanel" ""
  T_tmpmacro.toolsPanel = """
# s_Target_Keyword/regex ()
# l_Append_Column_for_Matrix_View (yes)
# S_Append_Columns ({"MolScore","MolpKd"})
# b_Extract_Compound_Target_Pair (expandMolSummaryTarget Name(variable %@) \"MolSummary\" \"$1\" $2 $3)
# txt_hint (Might take a while depending on number of records)
# X_This_Table (*) [RDONLY]
# C_Unique_Compound_ID_Column () [IARRAY,SARRAY,TABLE:6]
# b_Generate_Html_Report (msReport Name(variable %@) Field(Name(variable $7) 2 "."))
# b_Add/Update_GO_Terms (msaddGO Name(variable %@)) [ONCHANGE:REFRESH]
# i_Display_Only:GOonly (1@All|2@GO_Cellular|3@GO_Process|4@GO_Function) [RDONLY]
# s_GO_Cellular:gocellular ($%@.S_GOCellular) [VISIBLE:$GOonly==2]
# s_GO_Process:goprocess ($%@.S_GOProcess) [VISIBLE:$GOonly==3]
# s_GO_Function:gofunction ($%@.S_GOFunction) [VISIBLE:$GOonly==4]
# b_Display_All_Rows (msfilterGO Name(variable %@)) [VISIBLE:$GOonly==1]
# b_Filter_by_GO_Cellular (msfilterGO Name(variable %@) "GO_Cellular" Field($gocellular 1 ";")) [VISIBLE:$GOonly==2]
# b_Filter_by_GO_Process (msfilterGO Name(variable %@) "GO_Process" Field($goprocess 1 ";")) [VISIBLE:$GOonly==3]
# b_Filter_by_GO_Function (msfilterGO Name(variable %@) "GO_Function" Field($gofunction 1 ";")) [VISIBLE:$GOonly==4]
"""

  add header T_tmpmacro name="doubleClick" ""
  T_tmpmacro.doubleClick = """
if (Type(expandMolSummary)!="unknown") expandMolSummary Name(variable %@) String(%^) %#
"""
  delete $s_tab
  rename T_tmpmacro s_tab
  keep $s_tab
endmacro
#
macro expandMolSummary s_tab ("") s_MolSummarycol ("MolSummary") i_row (0)
  l_info = no; l_commands =no
  s_tab = Trim(s_tab all)
  if (s_tab == "") return "Table not specified"
  if (Type($s_tab)!="table") return "Table not found"
  if (s_MolSummarycol =="") return "Table column not specified"
  s_MolSummarycol = Trim(s_MolSummarycol all)
  if (Type($s_tab.$s_MolSummarycol)=="unknown") return "Table column not found"
  if (Type($s_tab.$s_MolSummarycol)!="sarray") return "Table column not sarray"
  if ((i_row<1)|(i_row>Nof($s_tab))) return "Row number specified outside of table range"
  if (Type(MolSummaryTab)!="unknown") delete MolSummaryTab
  S_tmpmacro = Split(($s_tab.$s_MolSummarycol)[i_row] "\n")
  group table MolSummaryTab Chemical(0) "mol" Sarray(0) "Target"
  S_fieldname = Sarray()
  s_Probcomment = "-Log(probability) relative to approved drugs decoy, capped at 10\n1: Top 10 percent\n2: Top 1 percent\n3: Top 0.1 percent"
  s_Scorecomment = "MolpKd adjusted by MolSim, \nScore of 3 or above indicates binder"
  s_Classcomment = "Classification Score:\nfor kcc models:\nProbability of being a positive, assume 0.5% hitrate\nfor others:\n1: Median value of actives\n0: Median value of inactives"
  s_Zscorecomment = "Z-Score\n>3. indicates 3 standard deviation above approved drugs decoy"
  s_pKdcomment = "Prediction of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND indicates disimilarity to known binders"
  s_DockNNScorecomment = "ICM Convolutional Neural Network docking score, \nScore < -32. are in general significant, \nbut may vary from structure to structure"
  s_DockScorecomment = "ICM docking score, \nScore < -32. are in general significant, \nbut may vary from structure to structure"
  s_MolTmplScorecomment = "ICM docking pose reliability, \ndpc model with MolTmplScore < 0.6 are likely mis-docked"
  for i_cpd = 1, Nof(S_tmpmacro)
    add MolSummaryTab
    MolSummaryTab.mol[i_cpd] = ($s_tab.mol)[i_row]
    MolSummaryTab.Target[i_cpd] = Field(S_tmpmacro[i_cpd] 1 ":")
    i_noffield = (Nof(Split(S_tmpmacro[i_cpd] ":"))-1)/2
    for i_field = 1, i_noffield
      s_fieldname =  Trim(Split(S_tmpmacro[i_cpd] ":")[i_field*2] all)
      if (Type(MolSummaryTab.$s_fieldname)=="unknown") then
        add column MolSummaryTab Toreal(Sarray(Nof(MolSummaryTab) "ND")) name=s_fieldname
        if (s_fieldname=="pPvalue") set format MolSummaryTab.pPvalue "%.2f" name="" color="rainbow='#FFFFFF/#FFFF00/#FF0000,1.:3.,pinwheel'" comment=s_Probcomment
        if (s_fieldname=="MolScore") set format MolSummaryTab.MolScore "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,3.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_Scorecomment
        if (s_fieldname=="MolpKd") set format MolSummaryTab.MolpKd "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_pKdcomment
        if (s_fieldname=="MolZScore") set format MolSummaryTab.MolZScore "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,1.:3.,pinwheel'" comment=s_Zscorecomment
        if (s_fieldname=="MolClass") set format MolSummaryTab.MolClass "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'" comment=s_Classcomment
        if (s_fieldname=="MolRecNNScore") set format MolSummaryTab.MolRecNNScore "%.1f" name="" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,-32.:-20.,pinwheel'" comment=s_DockNNScorecomment
        if (s_fieldname=="MolRecScore") set format MolSummaryTab.MolRecScore "%.1f" name="" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,-32.:-20.,pinwheel'" comment=s_DockScorecomment
        if (s_fieldname=="MolTmplScore") set format MolSummaryTab.MolTmplScore "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,0.6:0.9.,pinwheel'" comment=s_MolTmplScorecomment
        if (s_fieldname=="pKd") set format MolSummaryTab.pKd "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="-Log of Kd"
        S_fieldname //= s_fieldname
      endif
      MolSummaryTab.$s_fieldname[i_cpd] = Toreal(Split(S_tmpmacro[i_cpd] ":")[i_field*2+1])
    endfor
  endfor
  add column MolSummaryTab Sarray(Nof(MolSummaryTab)) name="fileloc"
  add column MolSummaryTab Sarray(Nof(MolSummaryTab)) name="smi"
  add column MolSummaryTab Sarray(Nof(MolSummaryTab)) name="Target_Name"
  if (s_MolSummarycol == "MolSummary") then
    S_tmpmacro =  Split(($s_tab.MolSummaryloc)[i_row] "\n")
    if (Nof(MolSummaryTab)==Nof(S_tmpmacro)) MolSummaryTab.fileloc = S_tmpmacro
    S_tmpmacro =  Split(($s_tab.MolSummarysmi)[i_row] "\n")
    if (Nof(MolSummaryTab)==Nof(S_tmpmacro)) MolSummaryTab.smi = S_tmpmacro
    S_tmpmacro =  Split(($s_tab.MolSummarytargetname)[i_row] "\n")
    if (Nof(MolSummaryTab)==Nof(S_tmpmacro)) MolSummaryTab.Target_Name = S_tmpmacro
  endif
  set format MolSummaryTab.fileloc show off
  set format MolSummaryTab.smi show off
  if (Type(T_join)!="unknown") delete T_join
  join left MolSummaryTab.mol $s_tab.mol
  S_col = Name(T_join)
  for i_col = Index(Name(T_join) "T_join.smi")+1,  Index(Name(T_join) "T_join.MolSummary")-1
    s_col = S_col[i_col]
    add column MolSummaryTab $s_col name=Replace(s_col "T_join." "")
  endfor
  delete T_join
  if (Nof(S_fieldname)==1)  make plot MolSummaryTab "x={"+S_fieldname[1]+"}"
  if (Nof(S_fieldname)>2) then
    make plot MolSummaryTab "x="+S_fieldname[1]+";y="+S_fieldname[2]+";color="+S_fieldname[3]+";label=Target;labelSize=10.;"
  elseif (Nof(S_fieldname)>1) then
    make plot MolSummaryTab "x="+S_fieldname[1]+";y="+S_fieldname[2]+";label=Target;labelSize=10.;"
  endif
  R_normscore = Rarray(Nof(MolSummaryTab))
  if (Exist(MolSummaryTab.MolpKd)) R_normscore = R_normscore -Normalize(MolSummaryTab.MolpKd "rmsd" 0.)
  if (Exist(MolSummaryTab.MolRecNNScore)) R_normscore = R_normscore +Normalize(MolSummaryTab.MolRecNNScore "rmsd" 0.)
  if (Exist(MolSummaryTab.MolRecScore)) R_normscore = R_normscore +Normalize(MolSummaryTab.MolRecScore "rmsd" 0.)
  if (R_normscore !=  Rarray(Nof(MolSummaryTab))) then
    add column MolSummaryTab R_normscore name="NormScore" index=3
    sort MolSummaryTab.NormScore
    set format MolSummaryTab.NormScore comment="Normalized score, negative->more significant"
  endif
  add header MolSummaryTab name="doubleClick" ""
  MolSummaryTab.doubleClick = """
if (Type(displayMolSummaryPose)!="unknown") displayMolSummaryPose Name(variable %@) %#
"""
  keep MolSummaryTab
  set foreground MolSummaryTab
endmacro
#
macro expandMolSummaryTarget s_tab ("") s_MolSummarycol ("MolSummary") s_targetkey ("") l_appendcol (yes) S_appendcol ({"MolScore","MolpKd"}) auto
  l_info = no; l_commands =no
  if (s_tab == "") return "Table not specified"
  s_tab = Trim(s_tab all)
  if (Type($s_tab)!="table") return "Table not found"
  if (s_MolSummarycol =="") return "Table column not specified"
  s_MolSummarycol = Trim(s_MolSummarycol all)
  if (Type($s_tab.$s_MolSummarycol)=="unknown") return "Table column not found"
  if (Type($s_tab.$s_MolSummarycol)!="sarray") return "Table column not sarray"
  if (s_targetkey=="") return "Please specify keyword for target"
  if (Type(MolSummaryTab)!="unknown") delete MolSummaryTab
  group table MolSummaryTab Chemical(0) "mol" Sarray(0) "Target"
  add column MolSummaryTab Sarray(Nof(MolSummaryTab)) name="fileloc"
  add column MolSummaryTab Sarray(Nof(MolSummaryTab)) name="smi"
  add column MolSummaryTab Sarray(Nof(MolSummaryTab)) name="Target_Name"
  S_fieldname = Sarray()
  s_tmpcol = s_tab+"."+s_MolSummarycol
  s_tmpcol2 = s_tab+".MolSummaryloc"
  s_tmpcol3 = s_tab+".MolSummarysmi"
  s_tmpcol4 = s_tab+".MolSummarytargetname"
  N = Nof($s_tab)
  sprintf " Info> Extracting target data from %d chemicals in table '%s' ",N,s_tab
  print bar s_out  N l_info=yes
  s_Probcomment = "-Log(probability) relative to approved drugs decoy, capped at 10.\n1: Top 10 percent\n2: Top 1 percent\n3: Top 0.1 percent"
  s_Scorecomment = "MolpKd adjusted by MolSim, \nScore of 3 or above indicates binder"
  s_Classcomment = "Classification Score:\nfor kcc models:\nProbability of being a positive, assume 0.5% hitrate\nfor others:\n1: Median value of actives\n0: Median value of inactives"
  s_Zscorecomment = "Z-Score\n>3. indicates 3 standard deviation above approved drugs decoy"
  s_pKdcomment = "Prediction of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND indicates disimilarity to known binders"
  s_DockScorecomment = "ICM docking score, \nScore < -32. are in general significant, \nbut may vary from structure to structure"
  s_MolTmplScorecomment = "ICM docking pose reliability, \ndpc model with MolTmplScore < 0.6 are likely mis-docked"
  for i_row = 1, Nof($s_tab)
    if ($s_tmpcol[i_row]=="") continue
    if (Index($s_tmpcol[i_row] s_targetkey regexp)==0) continue
    S_tmpmacro = Split($s_tmpcol[i_row] "\n")
    S_target = Field(S_tmpmacro 1 ":")
    if (Nof(S_target)==0) continue
    I_subrow = Index(Index(S_target s_targetkey regexp) 1 all)
    if (Nof(I_subrow) == 0) continue
    if (s_MolSummarycol == "MolSummary") then
      S_tmpmacro2 = Split($s_tmpcol2[i_row] "\n")
      S_tmpmacro3 = Split($s_tmpcol3[i_row] "\n")
      S_tmpmacro4 = Split($s_tmpcol4[i_row] "\n")
      if (Nof(S_tmpmacro2)!=Nof(S_tmpmacro)) delete S_tmpmacro2
      if (Nof(S_tmpmacro3)!=Nof(S_tmpmacro)) delete S_tmpmacro3
      if (Nof(S_tmpmacro4)!=Nof(S_tmpmacro)) delete S_tmpmacro4
    endif
    for i_subrow = 1, Nof(I_subrow)
      j_subrow = I_subrow[i_subrow]
      add MolSummaryTab
      MolSummaryTab.mol[Nof(MolSummaryTab)] = ($s_tab).mol[i_row]
      MolSummaryTab.Target[Nof(MolSummaryTab)] = S_target[j_subrow]
      if (Type(S_tmpmacro2)!="unknown") MolSummaryTab.fileloc[Nof(MolSummaryTab)] = S_tmpmacro2[j_subrow]
      if (Type(S_tmpmacro3)!="unknown") MolSummaryTab.smi[Nof(MolSummaryTab)] = S_tmpmacro3[j_subrow]
      if (Type(S_tmpmacro4)!="unknown") MolSummaryTab.Target_Name[Nof(MolSummaryTab)] = S_tmpmacro4[j_subrow]
      i_noffield = (Nof(Split(S_tmpmacro[j_subrow] ":"))-1)/2
      for i_field = 1, i_noffield
        s_fieldname =  Trim(Split(S_tmpmacro[j_subrow] ":")[i_field*2] all)
        if (Type(MolSummaryTab.$s_fieldname)=="unknown") then
          add column MolSummaryTab Toreal(Sarray(Nof(MolSummaryTab) "ND")) name=s_fieldname
          if (s_fieldname=="pPvalue") set format MolSummaryTab.pPvalue "%.2f" name="" color="rainbow='#FFFFFF/#FFFF00/#FF0000,1.:3.,pinwheel'" comment=s_Probcomment
          if (s_fieldname=="MolScore") set format MolSummaryTab.MolScore "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,3.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_Scorecomment
          if (s_fieldname=="MolpKd") set format MolSummaryTab.MolpKd "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_pKdcomment
          if (s_fieldname=="MolZScore") set format MolSummaryTab.MolZScore "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,1.:3.,pinwheel'" comment=s_Zscorecomment
          if (s_fieldname=="MolClass") set format MolSummaryTab.MolClass "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'" comment=s_Classcomment
          if (s_fieldname=="MolRecScore") set format MolSummaryTab.MolRecScore "%.1f" name="" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,-32.:-20.,pinwheel'" comment=s_DockScorecomment
          if (s_fieldname=="MolTmplScore") set format MolSummaryTab.MolTmplScore "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,0.6:0.9.,pinwheel'" comment=s_MolTmplScorecomment
          if (s_fieldname=="pKd") set format MolSummaryTab.pKd "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="-Log of Kd"
          S_fieldname //= s_fieldname
        endif
        MolSummaryTab.$s_fieldname[Nof(MolSummaryTab)] = Toreal(Split(S_tmpmacro[j_subrow] ":")[i_field*2+1])
      endfor
    endfor
    print bar N  l_info=yes
  endfor
  print bar "done\n"  l_info=yes
  if (Nof(MolSummaryTab)==0) return "No entries with the target keyword found, try other keyword"
  move MolSummaryTab.fileloc Nof(Name(MolSummaryTab))
  move MolSummaryTab.smi Nof(Name(MolSummaryTab))
  move MolSummaryTab.Target_Name Nof(Name(MolSummaryTab))
  set format MolSummaryTab.fileloc show off
  set format MolSummaryTab.smi show off
  if ((l_appendcol)&(Nof(S_appendcol)!=0)) then
    S_targets = Unique(Sort(MolSummaryTab.Target))
    for i_target = 1, Nof(S_targets)
      s_target = S_targets[i_target]
      T_tmptarget = MolSummaryTab.Target == s_target
      for i_col = 1, Nof(S_appendcol)
        s_appendcol = s_target+"_"+S_appendcol[i_col]
        if (Type($s_tab.$s_appendcol)!="unknown") continue
        s_tabappendcol = "T_tmptarget."+S_appendcol[i_col]
        rename $s_tabappendcol s_appendcol
        if (Type(T_join)!="unknown") delete T_join
        join left $s_tab.mol T_tmptarget.mol
        add column $s_tab T_join.$s_appendcol name=s_appendcol
        delete T_join l_warn=no
      endfor
      delete T_tmptarget l_warn=no
    endfor
    delete T_tmptarget l_warn=no
  endif
  if (Type(T_join)!="unknown") delete T_join
  join left MolSummaryTab.mol $s_tab.mol
  S_col = Name(T_join)
  for i_col = Index(Name(T_join) "T_join.smi")+1,  Index(Name(T_join) "T_join.MolSummary")-1
    s_col = S_col[i_col]
    add column MolSummaryTab $s_col name=Replace(s_col "T_join." "")
  endfor
  delete T_join
  for i_field = 1, Nof(S_fieldname)
    j_field = Nof(S_fieldname)-i_field+1
    s_fieldname="MolSummaryTab."+S_fieldname[j_field]
    sort reverse $s_fieldname
  endfor
  if (Nof(S_fieldname)==1)  make plot MolSummaryTab "x={"+S_fieldname[1]+"}"
  if (Nof(S_fieldname)>1)  make plot MolSummaryTab "x="+S_fieldname[1]+";y="+S_fieldname[2]+";"
  add header MolSummaryTab name="doubleClick" ""
  MolSummaryTab.doubleClick = """
if (Type(displayMolSummaryPose)!="unknown") displayMolSummaryPose Name(variable %@) %#
"""
  keep MolSummaryTab
  set foreground MolSummaryTab
endmacro
#
macro displayMolSummaryPose s_tab ("MolSummaryTab") i_row (0)
  l_info=no;l_commands=no
  if (s_tab == "") return "No table specified"
  s_tab = Trim(s_tab all)
  if (Type($s_tab)=="unknown") return "Table not found"
  if ((i_row < 1)|(i_row > Nof($s_tab))) return "Row number outside of the range of table rows"
  if (Type($s_tab.Target)=="unknown") return
  if (Type($s_tab.fileloc)=="unknown") return
  if (($s_tab).fileloc[i_row]=="") return
  if (Type($s_tab.smi)=="unknown") return
  if (($s_tab).smi[i_row]=="") return
  if (Index(($s_tab).Target[i_row] "_")==0) then
    s_type=($s_tab).predictType[i_row]
    if (s_type[1]=="m") return
    s_target = ($s_tab).Target[i_row]
  else
    s_type = Split(($s_tab).Target[i_row] "_")[Nof( Split(($s_tab).Target[i_row] "_"))]
    if (s_type[1]=="m") return
    s_target = Replace(($s_tab).Target[i_row] "_"+s_type "")
  endif
  s_smi = ($s_tab).smi[i_row]
  s_filename = Name(($s_tab).fileloc[i_row])
  if ((Type($s_filename)=="unknown")&(!Exist(($s_tab).fileloc[i_row]))) return
  if (Type($s_filename)!="unknown") then
    I_tmp = Index($s_filename.Target==s_target & $s_filename.predictType==s_type)
    if (Nof(I_tmp)>0) then
      I_tmp2 = Index(($s_filename).mol[I_tmp] s_smi)
      if (Nof(I_tmp2)>0) then
        if (s_type[1]=="d") displayModelPose s_filename I_tmp[I_tmp2[1]]
         if (Exist(($s_tab).fileloc[i_row])) then
           T_tmppairwise = $s_filename[I_tmp[I_tmp2[1]]]
           delete $s_filename; rename T_tmppairwise s_filename
         endif
#        print "Entry in table:" s_filename ", row number:" I_tmp[I_tmp2[1]]
        keep $s_filename
        set foreground $s_tab
        return
      endif
    endif
  endif
  if (!Exist(($s_tab).fileloc[i_row])) return
  read binary ($s_tab).fileloc[i_row] l_info=no
  I_tmp = Index($s_filename.Target==s_target & $s_filename.predictType==s_type)
  if (Nof(I_tmp)>0) then
    I_tmp2 = Index(($s_filename).mol[I_tmp] s_smi)
    if (Nof(I_tmp2)>0) then
      if (s_type[1]=="d") displayModelPose s_filename I_tmp[I_tmp2[1]]
       if (Exist(($s_tab).fileloc[i_row])) then
         T_tmppairwise = $s_filename[I_tmp[I_tmp2[1]]]
         delete $s_filename; rename T_tmppairwise s_filename
       endif
#      print "Entry in table:" s_filename ", row number:" I_tmp[I_tmp2[1]]
      keep $s_filename
      set foreground $s_tab
      return
    endif
  endif
endmacro
#
macro msReport s_tab ("") s_cpdnamecol ("") auto
  l_info = l_commands = l_warn = no
  s_tab = Trim(s_tab all)
  if (s_tab=="") return "Please specify table name"
  if (Type($s_tab)!="table") return "Table specified not found"
  s_cpdnamecol = Trim(s_cpdnamecol all)
  if (s_cpdnamecol!="") then
    if (Type($s_tab.$s_cpdnamecol)=="unknown") return "Compound name column not found"
  else
    if (Type($s_tab.NAME)!="unknown") then
      s_cpdnamecol = "NAME"
    elseif (Type($s_tab.name)!="unknown") then
      s_cpdnamecol = "name"
    elseif (Type($s_tab.idxtmp)!="unknown") then
      s_cpdnamecol = "idxtmp"
    endif
  endif
  if (s_cpdnamecol != "") then
    S_cpdname = Tostring($s_tab.$s_cpdnamecol)
  else
    S_cpdname = Tostring(Count(Nof($s_tab)))
  endif
  if (Type($s_tab.MolSummary)=="sarray") then
    i_mode = 1
  elseif (Type($s_tab.MolScore)=="rarray") then
    i_mode = 2
    S_cpdname = Unique(Sort(S_cpdname))
    if (Type($s_tab.MolScore)=="unknown") return "MolScore column need to be in the table"
  elseif (Type($s_tab.MolToxSummary)=="sarray") then
    i_mode = 1
  else
    return "Table input is neither a MolResult nor a msLigandHit pairwise table, table format not supported yet"
  endif
  s_tmp = "<h1>MolScreen Report for Chemical Table: "+s_tab+"</h1>\n"
  s_tmp//= """
<p></p>
"""

  if (Type(MolSummaryTab)!="unknown") then
    MolSummaryTabold = MolSummaryTab; delete MolSummaryTab
  endif
  for i_cpd = 1, Nof(S_cpdname)
    if (i_mode==1) then
      if (Type($s_tab.MolSummary)=="sarray") then
        if (($s_tab).MolSummary[i_cpd]=="") continue
        expandMolSummary s_tab String(MolSummary) i_cpd
        if (Type(MolSummaryTab.MolScore)=="unknown") return "MolScore column need to be embedded in MolSummary Column"
      elseif (Type($s_tab.MolToxSummary)=="sarray") then
        if (($s_tab).MolToxSummary[i_cpd]=="") continue
        MolSummaryTab = $s_tab[i_cpd]
      endif
    elseif (i_mode==2) then
      if (S_cpdname[i_cpd] == "") continue
      if (Type($s_tab.$s_cpdnamecol) == "sarray") then
        MolSummaryTab = $s_tab.$s_cpdnamecol == S_cpdname[i_cpd]
      else
        MolSummaryTab = $s_tab[i_cpd]
      endif
    endif
      if (Type(MolSummaryTab.MolToxSummary)!="sarray") then
        if (Nof(MolSummaryTab.MolScore>=3.)==0) continue
      elseif (Type(MolSummaryTab.MolScore)!="rarray") then
        if (MolSummaryTab.MolToxSummary[1]=="") continue
      elseif ((Nof(MolSummaryTab.MolScore>=3.)==0) & (MolSummaryTab.MolToxSummary[1]=="")) then
        continue
      endif
      s_tmp1 = "<p></p>\n<br><h2>Compound: "+S_cpdname[i_cpd]+"</h2>\n<p></p>"
      if (Type(MolSummaryTab.MolToxSummary)=="sarray") then
        if (MolSummaryTab.MolToxSummary[1]!="") then
          s_tmp1 = s_tmp1+"\n<h3><font color=\"#FFA500\">Toxicity Screen Results</font></h3>\n<p></p>"
          S_tmp1 = Split(MolSummaryTab.MolToxSummary[1] "\n")
          S_tmp2 = Split(MolSummaryTab.MolToxSummarytargetname[1] "\n")
          for i_tmp1 = 1, Nof(S_tmp1)
            s_tmp1 = s_tmp1+"\n<p>"
            s_tmp1 = s_tmp1+"<b>"+Field(S_tmp2[i_tmp1] 1 ":")+"</b>: "+Field(S_tmp1[i_tmp1] 2 ":")+"</p>"
          endfor
        endif
      endif
     if (Type(MolSummaryTab.MolScore)=="rarray") then
      I_target = Index(MolSummaryTab.MolScore>=7.)
      if (Nof(I_target)!=0) then
        s_tmp1 = s_tmp1+"\n<h3><font color=\"#FF0000\">Very likely Target</font></h3>\n<p></p>"
        for i_target = 1, Nof(I_target)
          j_target = I_target[i_target]
          s_tmp1 = s_tmp1+"\n<p>"
          if (Type(MolSummaryTab.Target_Name)=="sarray") then
            s_tmp1 = s_tmp1+"<b>"+MolSummaryTab.Target_Name[j_target]+"</b>"
          else
            s_tmp1 = s_tmp1+"<b>"+MolSummaryTab.Target[j_target]+"</b>"
          endif
          if (Type(MolSummaryTab.MolScore)!="unknown") s_tmp1 = s_tmp1+"; MolScore: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolScore[j_target])*10))
          if (Type(MolSummaryTab.MolpKd)!="unknown") s_tmp1 = s_tmp1+"; MolpKd: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolpKd[j_target])*10))
          if (Type(MolSummaryTab.MolZScore)!="unknown") then
            if (MolSummaryTab.MolZScore[j_target]!=Toreal("ND")) s_tmp1=s_tmp1+"; MolZScore: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolZScore[j_target])*10))
          endif
          if (Type(MolSummaryTab.MolSim)!="unknown") s_tmp1 = s_tmp1+"; MolSim: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolSim[j_target])*10))
          s_tmp1 = s_tmp1+"</p>"
        endfor
      endif

      I_target = Index(MolSummaryTab.MolScore>=5. & MolSummaryTab.MolScore<7.)
      if (Nof(I_target)!=0) then
        s_tmp1 = s_tmp1+"\n<h3><font color=\"#FFA500\">Likely Target</font></h3>\n<p></p>"
        for i_target = 1, Nof(I_target)
          j_target = I_target[i_target]
          s_tmp1 = s_tmp1+"\n<p>"
          if (Type(MolSummaryTab.Target_Name)=="sarray") then
            s_tmp1 = s_tmp1+"<b>"+MolSummaryTab.Target_Name[j_target]+"</b>"
          else
            s_tmp1 = s_tmp1+"<b>"+MolSummaryTab.Target[j_target]+"</b>"
          endif
          if (Type(MolSummaryTab.MolScore)!="unknown") s_tmp1 = s_tmp1+"; MolScore: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolScore[j_target])*10))
          if (Type(MolSummaryTab.MolpKd)!="unknown") s_tmp1 = s_tmp1+"; MolpKd: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolpKd[j_target])*10))
          if (Type(MolSummaryTab.MolZScore)!="unknown") then
            if (MolSummaryTab.MolZScore[j_target]!=Toreal("ND")) s_tmp1=s_tmp1+"; MolZScore: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolZScore[j_target])*10))
          endif
          if (Type(MolSummaryTab.MolSim)!="unknown") s_tmp1 = s_tmp1+"; MolSim: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolSim[j_target])*10))
          s_tmp1 = s_tmp1+"</p>"
        endfor
      endif

      I_target = Index(MolSummaryTab.MolScore>=3. & MolSummaryTab.MolScore<5.)
      if (Nof(I_target)!=0) then
        s_tmp1 = s_tmp1+"\n<h3><font color=\"#008000\">Possible Target</font></h3>\n<p></p>"
        for i_target = 1, Nof(I_target)
          j_target = I_target[i_target]
          s_tmp1 = s_tmp1+"\n<p>"
          if (Type(MolSummaryTab.Target_Name)=="sarray") then
            s_tmp1 = s_tmp1+"<b>"+MolSummaryTab.Target_Name[j_target]+"</b>"
          else
            s_tmp1 = s_tmp1+"<b>"+MolSummaryTab.Target[j_target]+"</b>"
          endif
          if (Type(MolSummaryTab.MolScore)!="unknown") s_tmp1 = s_tmp1+"; MolScore: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolScore[j_target])*10))
          if (Type(MolSummaryTab.MolpKd)!="unknown") s_tmp1 = s_tmp1+"; MolpKd: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolpKd[j_target])*10))
          if (Type(MolSummaryTab.MolZScore)!="unknown") then
            if (MolSummaryTab.MolZScore[j_target]!=Toreal("ND")) s_tmp1=s_tmp1+"; MolZScore: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolZScore[j_target])*10))
          endif
          if (Type(MolSummaryTab.MolSim)!="unknown") s_tmp1 = s_tmp1+"; MolSim: "+Tostring(0.1*Tointeger(Toreal(MolSummaryTab.MolSim[j_target])*10))
          s_tmp1 = s_tmp1+"</p>"
        endfor
      endif
     endif
      s_tmp = s_tmp+"\n"+s_tmp1
  endfor
  if (Type(MolSummaryTabold)!="unknown") then
    MolSummaryTab = MolSummaryTabold; delete MolSummaryTabold
  endif
  s_tmp = s_tmp +"\n<br><h2>Remarks</h2>"
  s_tmp = s_tmp +"\n<p>Class: Classification score of 0.5-1 indicates Cmpd predicted to be active</p>"
  s_tmp = s_tmp +"\n<p>MolScore: MolpKd prediction adjusted by MolSim, takes into account prediction with lower similarity to training set Cmpd has lower confidence</p>"
  s_tmp = s_tmp +"\n<p>MolpKd: pKd(Ki/IC50/EC50) prediction, 6 is uM; 9 is nM</p>"
  s_tmp = s_tmp +"\n<p>MolZScore: Z-Score prediction, ZScore of 2 is 2 standard deviation above mean score of decoy</p>"
  s_tmp = s_tmp +"\n<p>MolSim: 0-1, Similarity to known binders, either Tanimoto for 2D fingerprint or APF for 3D poses</p>"

  s_htmlname = "msReport_"+s_tab
  if (Type($s_htmlname)!="unknown") delete $s_htmlname
  makeNewHtml s_htmlname yes s_tmp
  keep $s_htmlname
endmacro
#
macro msReportCpd s_tab ("") s_UniqIDCol ("") s_UniqID ("") i_entry (0) auto
  l_info = l_warn = l_commands = no
  s_tab = Trim(s_tab all)
  if (s_tab=="") return " Info> Please specify table name"
  if (Type(s_tab)=="unknown") return " Info> Please specify valid table name"
  s_UniqIDCol = Trim(s_UniqIDCol all)
  if (s_UniqIDCol == "") return " Info> Please specify column name of unique ID"
  if ((Type($s_tab.$s_UniqIDCol )!="sarray") & (Type($s_tab.$s_UniqIDCol )!="iarray")) return " Info> Please specify either a sarray or iarray column as unique ID column"
  s_UniqID = Trim(s_UniqID all)
  if ((s_UniqID == "") & (i_entry == 0)) return " Info> Please either specify a unique ID from the unique ID column, or specify a row number from the table"
  S_paircol = {"Target","MolScore","pPvalue","MolpKd","MolpKd_Error","predictType","MolZScore","MolClass","MolRecNNScore","MolRecScore","MolSim","modelnearestCpd","TmplCl","modelAUC","modelpKdAUC","modelClassAUC","modelRMSE","modelQ2"}
  S_paircol //= {"modelR2pkd","Target_Name","MolTmplScore","ATOM_CONTRIB"}
  if (s_UniqID != "") then
    T_tmpmacro = $s_tab.$s_UniqIDCol == s_UniqID
  elseif (i_entry != 0) then
    s_UniqID = ($s_tab.$s_UniqIDCol)[i_entry]
    T_tmpmacro = $s_tab.$s_UniqIDCol == s_UniqID
  endif
  S_header = Name(T_tmpmacro header)
  delete $S_header l_warn=no
  if (Type(T_tmpmacro.MolZScore)=="rarray") sort reverse T_tmpmacro.MolZScore
  if (Type(T_tmpmacro.MolRecNNScore)=="rarray") sort T_tmpmacro.MolRecNNScore
  if (Type(T_tmpmacro.MolRecScore)=="rarray") sort T_tmpmacro.MolRecScore
  if (Type(T_tmpmacro.MolClass)=="rarray") sort reverse T_tmpmacro.MolClass
  if (Type(T_tmpmacro.MolpKd)=="rarray") sort reverse T_tmpmacro.MolpKd
  if (Type(T_tmpmacro.pPvalue)=="rarray") sort reverse T_tmpmacro.pPvalue
  if (Type(T_tmpmacro.MolScore)=="rarray") sort reverse T_tmpmacro.MolScore
  if (Type(T_tmpmacro.Target_Name)=="sarray")  move T_tmpmacro.Target_Name 2
  if (Type(T_tmpmacro.chk)=="iarray") delete T_tmpmacro.chk
  if (Type(T_tmpmacro.predictType)=="sarray") move T_tmpmacro.predictType 4

  T_tmpmacro2 = T_tmpmacro[1]
  for i_col = 1, Nof(S_paircol)
    s_col = "T_tmpmacro2."+S_paircol[i_col]
    delete $s_col l_warn=no
  endfor
  S_column = Name(T_tmpmacro2 column)
  s_smi = Smiles( T_tmpmacro.mol [1] cartesian )[1]
  s_html = "<h1>Compound: "+s_UniqID+"</h1>\n"
  s_html = s_html + '<object type="icm/chemview" smi=":SMI" width="50%" height="40%"></object>\n<br/>'
  s_html = Replace( s_html, ":SMI", s_smi )
  s_html = s_html +'\n<br><table cellpadding="0" cellspacing="0" border="1" width="100%" style=" border-color:#ffffff;  background-color:#ffffff">'
  s_html = s_html +'<tbody>'
  S_column = Name(T_tmpmacro2 column)

  for i_col = 1, Nof(S_column)
    s_col = S_column[i_col]
    if ((Type($s_col)!="sarray")&(Type($s_col)!="iarray")&(Type($s_col)!="rarray")) continue
    s_colorig = "T_tmpmacro."+Field(s_col 2 ".")
    delete $s_colorig l_warn=no
    add header T_tmpmacro $s_col[1] name=Field(s_col 2 ".")
    if (Collection($s_col format)["mask"]==10240) continue
    s_comment = ""
    s_color = "#ffffff"
    if (Color(T_tmpmacro2 Field(s_col 2 "." ) )[1]!="") s_color = Tolower(Color(T_tmpmacro2 Field(s_col 2 "." ) )[1])
    if (Type(Collection($s_col format )["comment"])!="real") s_comment = Collection($s_col format )["comment"]
    if (Type($s_col)=="sarray") then
      s_html = s_html+'\n<tr title="'+s_comment+'"><td><b>'+Field(s_col 2 ".")+'</b></td><td style="background-color:'+s_color+'">'
      s_html = s_html+Replace($s_col[1] "\n" "<br/>")+"</td></tr>"
    elseif (Type($s_col)=="rarray") then
      s_html = s_html+'\n<tr title="'+s_comment+'"><td><b>'+Field(s_col 2 ".")+'</b></td><td style="background-color:'+s_color+'">'
      s_html = s_html+Real($s_col[1] 2)+"</td></tr>"
    else
      s_html = s_html+'\n<tr title="'+s_comment+'"><td><b>'+Field(s_col 2 ".")+'</b></td><td style="background-color:'+s_color+'">'
      s_html = s_html+$s_col[1]+"</td></tr>"
    endif
  endfor
  s_html = s_html + '</tbody></table><div>'

  T_tmpmacro["_COMMENT_"] = s_html
  T_tmpmacro["_CURTOOLSTAB_"] = 2
  delete T_tmpmacro.mol T_tmpmacro.modelnearestCpd l_warn=no
  set property header T_tmpmacro
  set label T_tmpmacro 0 size=20
  if (i_entry != 0)  then
    s_fintab = Name("msCpdReport_"+Tostring(i_entry) unique)
  else
    s_fintab = Name("msCpdReport" unique)
  endif
  set property T_tmpmacro header
  rename T_tmpmacro s_fintab
  keep $s_fintab
endmacro
#
macro msTransposeCpd s_tab ("")  i_entry (0) auto
  l_info = l_commands = l_warn=no
  s_tab = Trim(s_tab all)
  if (s_tab=="") return " Info> Please specify table name"
  if (Type(s_tab)=="unknown") return " Info> Please specify valid table name"
  if (i_entry == 0) return " Info> Please specify table row number"

  tt_cell = $s_tab [ Field( Name( $s_tab  ) 2 '.' )!="mol" ][i_entry]
  S_column = Name(tt_cell column)
  for i_col = 1, Nof(S_column)
    s_col = S_column[i_col]
    if (Collection($s_col format)["mask"]==10240) then
      delete $s_col l_warn=no; continue
    endif
    if (Type($s_col)!="rarray") continue
    $s_col[1] = Real($s_col[1] 2)
  endfor
  tt_cell = Transpose( tt_cell )
  S_column = Name($s_tab column)
  for i_col = 1, Nof(S_column)
    s_col = S_column[i_col]
    if (Field(s_col 2 ".")!~"[A,B]") add header tt_cell $s_col[i_entry] name=Field(s_col 2 ".")
  endfor
  set label tt_cell 0 size=20
  s_smi = Smiles( $s_tab.mol [i_entry] cartesian )[1]

  if (Name($s_tab column) ~s_tab+".[Nn][Aa][Mm][Ee]*"!=Sarray(0)) then
    s_col =  (Name($s_tab column) ~s_tab+".[Nn][Aa][Mm][Ee]*")[1]
    s_html = "<h1>"+s_tab+" Compound: "+Tostring($s_col[i_entry])+"</h1>\n"
  else
    s_html = "<h1>"+s_tab+" Compound: "+Tostring(i_entry)+"</h1>\n"
  endif
  s_html = s_html + '<object type="icm/chemview" smi=":SMI" width="100%" height="80%"></object>\n<br/>'
  s_html = Replace( s_html, ":SMI", s_smi )

  tt_cell["_COMMENT_"] = s_html
  tt_cell["_CURTOOLSTAB_"] = 2
  set property header tt_cell
  s_fintab = Name("msCpd_"+Tostring(i_entry) unique)
  rename tt_cell s_fintab
  keep global $s_fintab
endmacro
#
macro calcpPvalue R_score R_sortednoisescore l_probabilityscore (no) auto
  l_info = l_commands = no
# Calculate -Log(probability) of R_score, using top 1-10 percentile score of noise sorted from most significant to least
  if (Type(R_score) == "unknown") return "R_score not specified"
  if (Type(R_sortednoisescore) == "unknown") return "R_sortednoisescore not specified"
  group table T_noisetmpmacro R_sortednoisescore "sortednoisescore"
  add column T_noisetmpmacro Toreal(Count(Nof(T_noisetmpmacro)))/Nof(T_noisetmpmacro) name="noisep"
  if (!l_probabilityscore) then
    T_noisetmpmacro = T_noisetmpmacro.noisep>=0.01 &  T_noisetmpmacro.noisep<=0.1 & T_noisetmpmacro.sortednoisescore != Toreal("ND")
#  if (Nof(T_noisetmpmacro) <=1) return "Not enough sortednoisescore to calculate Linearfit"
    if (Nof(T_noisetmpmacro) <=1) return
    add column T_noisetmpmacro Sqrt(-Log(T_noisetmpmacro.noisep 10)) name="Sqrtp_noisep"
    R_fit = LinearFit(T_noisetmpmacro.sortednoisescore T_noisetmpmacro.Sqrtp_noisep )
    R_out = Power(Max(R_score*R_fit[1]+R_fit[2] Rarray(Nof(R_score) 0.)) 2)
    R_out = Trim(R_out 0. 5.)
  else
    T_noisetmpmacro = T_noisetmpmacro.sortednoisescore < 0.1
    add column T_noisetmpmacro Exp(-Log(T_noisetmpmacro.noisep)) name="tmp"
    if (Nof(T_noisetmpmacro) <=1) return
    R_fit = LinearFit(T_noisetmpmacro.sortednoisescore T_noisetmpmacro.tmp )
    R_out = -Log(Exp(-Log(Max(R_score*R_fit[1]+R_fit[2] Rarray(Nof(R_score) 0.1)))) 10)
    R_out = Trim(R_out 0. 5.)
  endif
  keep R_out
endmacro
#
macro compresstoTargetPair s_tabname ("")
  l_commands = l_info = no
  if (s_tabname=="") return "Table name not found"
  if (Type($s_tabname)=="unknown") return "Table not found"
  if (Type(msLigandTarget)!="unknown") delete msLigandTarget
  if (Nof(Name($s_tabname))>2000) return "Too many embedded objects, please remove them, split the table into smaller one, and re-embed the object again"
  msLigandTarget = $s_tabname
  msLigandTarget.toolsPanel = """
# txt_ (Display pose by double clicking on any row<br>Double clicking on the same row again to keep the object)
# d_Models_Folder ($TOOLS.modelsDir)
# b_Check_Against_Embedded_Data (TOOLS.modelsDir=\"$2\";if (Nof(Index(%@ selection))==1) then;checkembeddata \"\" Index(%@ selection)[1];else;print "Please select one table row only";endif)[BEGINFRAME:Check data embedded in model]
# txt_ (Select one table row by clicking on its header<br>Open tools panel of T_embedded table for additional comment)[ENDFRAME]
# b_Embed_Objects_to_Table (TOOLS.modelsDir = \"$2\"; predictModelPoseEmbed Name(variable %@))
# b_Extract_Checked_Rows_to_New_Table (T_tmpselect=%@.chk==1;rename T_tmpselect Name(Name(variable %@) unique))
# X_Chemical_Table_with_Unique_ID_Column (*) [BEGINFRAME:Generate Reports in original table, new table, or html,RESIZE,LMINWIDTH:110,RDONLY]
# C_Unique_Chemical_ID_Column () [TABLE:7,IARRAY,SARRAY]
# S_Combine_Columns ({"MolScore","MolpKd","MolSim"})
# f_Pairwise_File_Location|*.icb ("")
# b_Generate_Activity_Summary_in_Original_Table (foldMolSummary \"$7\" Name(variable %@) Field( Name( variable $8 ) 2 "." ) $9 \"$10\")
# txt_ (Group activity by chemical and append back to original table<br>To process a series of files,|use expression,<br> e.g. folder/*/msLigandTarget.icb)
# b_Generate_Html_Report (msReport Name(variable %@) Field(Name(variable $8) 2 "."))
# b_Generate_Report_for_Checked_Compound (if (Nof(Index(%@.chk==1))==1) msReportCpd Name(variable %@) Field(Name(variable $8) 2 ".") "" Index(%@.chk==1)[1])
# txt_hint (Make sure the Unique_Chemical ID Column is set correctly)[ENDFRAME]
# b_Add/Update_GO_Terms (msaddGO Name(variable %@)) [ONCHANGE:REFRESH]
# i_Display_Only:GOonly (1@All|2@GO_Cellular|3@GO_Process|4@GO_Function) [RDONLY]
# s_GO_Cellular:gocellular ($%@.S_GOCellular) [VISIBLE:$GOonly==2]
# s_GO_Process:goprocess ($%@.S_GOProcess) [VISIBLE:$GOonly==3]
# s_GO_Function:gofunction ($%@.S_GOFunction) [VISIBLE:$GOonly==4]
# b_Display_All_Rows (msfilterGO Name(variable %@)) [VISIBLE:$GOonly==1]
# b_Filter_by_GO_Cellular (msfilterGO Name(variable %@) "GO_Cellular" Field($gocellular 1 ";")) [VISIBLE:$GOonly==2]
# b_Filter_by_GO_Process (msfilterGO Name(variable %@) "GO_Process" Field($goprocess 1 ";")) [VISIBLE:$GOonly==3]
# b_Filter_by_GO_Function (msfilterGO Name(variable %@) "GO_Function" Field($gofunction 1 ";")) [VISIBLE:$GOonly==4]
"""
  msLigandTarget.doubleClick = """
if ((%@.predictType[%#])[1]=="d") displayModelPose Name(variable %@) %#
"""
  sort msLigandTarget.predictType; sort msLigandTarget.MolScore reverse
  group table T_shadow msLigandTarget.mol "mol"
  modify T_shadow.mol delete salt
  modify T_shadow.mol delete salt simple
  delete hydrogen T_shadow.mol
  modify T_shadow.mol auto
  add column msLigandTarget Smiles(T_shadow.mol unique cistrans) name="smilestmpmacro" index=2; delete T_shadow
  S_Molcol = Name(msLigandTarget)[Index(Index(Name(msLigandTarget) "msLigandTarget.Mol*" regexp) 1 all)]
  S_Molcol = S_Molcol != "msLigandTarget.MolpKd"; S_Molcol = S_Molcol != "msLigandTarget.MolZScore"; S_Molcol = S_Molcol != "msLigandTarget.MolClass"
  S_Molcol = S_Molcol != "msLigandTarget.MolpKd_Error"; S_Molcol = S_Molcol != "msLigandTarget.MolRecScore"
  for i_cpdmacro = 1, Nof(msLigandTarget)
    if (i_cpdmacro >= Nof(msLigandTarget)) break
    I_tmpmacro = Index(msLigandTarget.smilestmpmacro==msLigandTarget.smilestmpmacro[i_cpdmacro] & msLigandTarget.Target==msLigandTarget.Target[i_cpdmacro])
    if (Nof(I_tmpmacro)<=1) continue
    if (Max(index msLigandTarget.MolpKd[I_tmpmacro])!=0) msLigandTarget.MolpKd_Error[i_cpdmacro] =  msLigandTarget.MolpKd_Error[Max(index msLigandTarget.MolpKd[I_tmpmacro])]
    msLigandTarget.MolpKd[i_cpdmacro] =  Max(msLigandTarget.MolpKd[I_tmpmacro])
    msLigandTarget.MolZScore[i_cpdmacro] =  Max(msLigandTarget.MolZScore[I_tmpmacro])
    msLigandTarget.MolClass[i_cpdmacro] =  Max(msLigandTarget.MolClass[I_tmpmacro])
    msLigandTarget.MolRecScore[i_cpdmacro] =  Min(msLigandTarget.MolRecScore[I_tmpmacro])
    if (Max(index msLigandTarget.MolSim[I_tmpmacro]) > 1) then
      msLigandTarget.modelnearestCpd[i_cpdmacro] = msLigandTarget.modelnearestCpd[I_tmpmacro[Max(index msLigandTarget.MolSim[I_tmpmacro])]]
      msLigandTarget.MolSim[i_cpdmacro] = Max(msLigandTarget.MolSim[I_tmpmacro])
    endif
    for i_molcol = 1, Nof(S_Molcol)
      s_Molcol = S_Molcol[i_molcol]
      if (Type($s_Molcol)!="rarray") continue
      $s_Molcol[i_cpdmacro] = Max($s_Molcol[I_tmpmacro])
    endfor
    I_tmpmacro = I_tmpmacro[2:Nof(I_tmpmacro)]
    delete msLigandTarget[I_tmpmacro]
  endfor
  delete msLigandTarget.smilestmpmacro
  keep msLigandTarget global
endmacro
#
macro compressModelcsv s_tab ("msLigandModel") s_uniquecol ("id") s_finaltab ("msLigandTarget") auto
  l_info=no; l_commands=no
  s_tab = Trim(s_tab all)
  s_tab = Name(s_tab)
  if (s_tab=="") return "Please specify table name"
  if (s_uniquecol=="") return "Please specify unique column name for grouping compounds"
  if (s_finaltab=="") return "Please specify final table name after compression"
  if (Type($s_tab) != "table") then
    if (Exist(s_tab+".csv")) then
      read csv header s_tab+".csv"
    else
      return "CSV table not found"
    endif
  endif
  if (Type(T_tmpmacro)!="unknown") delete T_tmpmacro l_warn=no
  T_tmpmacro = $s_tab
#  delete $s_tab
  if (Type(T_tmpmacro.$s_uniquecol)=="unknown") return "Unique column specified not found in table"
  if (s_uniquecol=="chk") s_uniquecol="idxtmp"
  sort T_tmpmacro.Target; sort T_tmpmacro.$s_uniquecol
  sort T_tmpmacro.MolpKd reverse
  sort T_tmpmacro.MolScore reverse
  add column T_tmpmacro Tostring(T_tmpmacro.$s_uniquecol)+Sarray(Nof(T_tmpmacro) "_")+T_tmpmacro.Target name="tmpmacroid"
  if ((Type(T_tmpmacro.MolClass)!="unknown")&(Type(T_tmpmacro.MolRecScore)!="unknown")) then
    group T_tmpmacro.tmpmacroid T_tmpmacro.MolScore "max," T_tmpmacro.pPvalue "max," T_tmpmacro.MolpKd "max," T_tmpmacro.MolZScore "max," T_tmpmacro.MolClass "max," T_tmpmacro.MolRecScore "min," all "first" header name="T_tmpmacro2"
    rename T_tmpmacro2.max_MolClass "MolClass"; set format T_tmpmacro2.MolClass Collection(T_tmpmacro.MolClass format)
    rename T_tmpmacro2.min_MolRecScore "MolRecScore"; set format T_tmpmacro2.MolRecScore Collection(T_tmpmacro.MolRecScore format)
  else
    group T_tmpmacro.tmpmacroid T_tmpmacro.MolScore "max," T_tmpmacro.pPvalue "max," T_tmpmacro.MolpKd "max," T_tmpmacro.MolZScore "max," all "first" header name="T_tmpmacro2"
  endif
  rename T_tmpmacro2.max_pPvalue "pPvalue"; set format T_tmpmacro2.pPvalue Collection(T_tmpmacro.pPvalue format)
  rename T_tmpmacro2.max_MolScore "MolScore"; set format T_tmpmacro2.MolScore Collection(T_tmpmacro.MolScore format)
  rename T_tmpmacro2.max_MolpKd "MolpKd"; set format T_tmpmacro2.MolpKd Collection(T_tmpmacro.MolpKd format)
  rename T_tmpmacro2.max_MolZScore "MolZScore"; set format T_tmpmacro2.MolZScore Collection(T_tmpmacro.MolZScore format)

  sort T_tmpmacro2.tmpmacroid; sort T_tmpmacro2.MolpKd reverse ; sort T_tmpmacro2.MolScore reverse
  S_colname = Name(T_tmpmacro2)
  for i_col = 3, Nof( S_colname )
    s_colname = S_colname[i_col]
    if (s_colname == "T_tmpmacro2.modelnearestCpd") then
    elseif (Type($s_colname)=="rarray") then
      set format $s_colname show Nof( $s_colname ND ) != Nof( $s_colname ) ? : off
    elseif (Type($s_colname)=="sarray") then
      set format $s_colname show Nof( $s_colname "" ) != Nof( $s_colname ) ? : off
    endif
  endfor
  delete T_tmpmacro2.tmpmacroid; rename T_tmpmacro2 s_finaltab
#  if Exist(s_finaltab+".csv") then
#    l_overwrite = Ask(s_finaltab+".csv exists, do you want to overwrite it?" no)
#  else
#    l_overwrite = yes
#  endif
#  print bar "writting...\n"  l_info=yes
#  if (l_overwrite) write table separator="," $s_finaltab s_finaltab+".csv" header delete
  keep $s_finaltab
endmacro
#
macro predictModelPose s_tab ("") s_mod ("") l_keepOrigCol (yes) l_removeinactives (no)
  if (s_tab=="") return "Table not specified"
  if (s_mod=="") return "Model name not specified"
  if (Type($s_tab)!="table") return "Table not found"
  if (Type($s_mod)!="parray") return "Model not found"
  s_predcol = Replace(s_mod s_mod[1:3] "")+"_"+s_mod[1:3]
  s_posecol = s_predcol+"_pose"
  s_clcol = s_predcol+"_cl"
  s_simcol = s_predcol+"_TANIsim"
  s_kcacol = Replace(s_predcol "kcc" "kca")
  s_dfccol = Replace(s_predcol "dfa" "dfc")
  s_dpacol = Replace(s_predcol "dpc" "dpa")
  s_nearestcol = s_predcol+"_nearest"
  s_dockScorecol = Replace(s_predcol "dpc" "dockScore")
  s_dockNNScorecol = Replace(s_predcol "dpc" "dockNNScore")
  if (!l_keepOrigCol) then
    group table modelposetmp $s_tab.mol "mol"
    if (Type($s_tab.$s_posecol)!="unknown") modelposetmp.mol = $s_tab.$s_posecol
  else
    modelposetmp = $s_tab
    if (Type($s_tab.$s_posecol)!="unknown") modelposetmp.mol = $s_tab.$s_posecol
    if ((s_mod[1:3]=="ncc")|(s_mod[1:3]=="mcp"& $s_mod["modeltype"]=="ncc")) then
      S_deletecol = Name(modelposetmp column)[Index(Name(modelposetmp column) "modelposetmp."+s_predcol):$]
      for i_deletecol = 1, Nof(S_deletecol)
        s_deletecol = S_deletecol[i_deletecol]
        delete $s_deletecol l_warn=no
      endfor
    endif
    delete modelposetmp.$s_predcol modelposetmp.$s_mod modelposetmp.$s_posecol modelposetmp.$s_clcol modelposetmp.$s_simcol  modelposetmp.$s_kcacol  modelposetmp.$s_dfccol modelposetmp.$s_dpacol modelposetmp.$s_nearestcol modelposetmp.$s_dockScorecol modelposetmp.$s_dockNNScorecol modelposetmp.ATOM_CONTRIB l_info=no l_warn=no
    delete modelposetmp.MolSim l_warn=no
    delete modelposetmp.Molnn l_warn=no
    delete modelposetmp.MolTmplScore l_warn=no
  endif
  if ((s_mod[1:3]=="ncc")|(s_mod[1:3]=="mcp"& $s_mod["modeltype"]=="ncc")) then
    add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="MolSim"
    if (Type($s_tab.$s_simcol)!="unknown") modelposetmp.MolSim = $s_tab.$s_simcol
    if (Type($s_tab.MolSim)!="unknown") modelposetmp.MolSim = $s_tab.MolSim
    add column modelposetmp Chemical(Sarray(Nof(modelposetmp) "")) name="modelnearestCpd"
    if (Type($s_tab.$s_nearestcol)!="unknown") modelposetmp.modelnearestCpd = $s_tab.$s_nearestcol
    if (Type($s_tab.Molnn)!="unknown") modelposetmp.modelnearestCpd = $s_tab.Molnn
    if (s_mod[1:3]=="ncc") then
      modelposetmp2 = modelposetmp
      $s_mod["l_probabilityscore"] = no
      $s_mod["l_pose"] = no
      predict modelposetmp2 $s_mod
      $s_mod["l_probabilityscore"] = yes
    endif
  endif
  add header modelposetmp Collection( ) name="recobj"
  add column modelposetmp Sarray(Nof(modelposetmp) Replace(s_mod s_mod[1:3] "")) name="Target" index=2
#  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="pPvalue" index=3
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="MolScore" index=3
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="pPvalue" index=4
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="MolpKd" index=5
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="MolpKd_Error" index=6
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="MolZScore" index=7
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="MolClass" index=8
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="MolRecNNScore" index=9
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="MolRecScore" index=10
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="MolTmplScore" index=11
  add column modelposetmp Parray(rarray Nof(modelposetmp)) name="ATOM_CONTRIB" index=12
  s_Probcomment = "-Log(probability) relative to approved drugs decoy, capped at 10\n1: Top 10 percent\n2: Top 1 percent\n3: Top 0.1 percent\nND or empty cell indicates inactive or disimilarity to known binders"
  s_Classcomment = "Classification Score:\nfor kcc/ncc models:\nProbability of being a positive, assume 0.5% hitrate for random compounds\nfor others:\n1: Median value of actives\n0: Median value of inactives"
  s_Zscorecomment = "Z-Score\n>3. indicates 3 standard deviation above approved drugs decoy"
  s_Scorecomment = "MolpKd adjusted by MolSim, \nScore of 3. or above indicates binder\nND or empty cell indicates inactive or disimilarity to known binders"
  s_pKdcomment = "Prediction of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND or empty cell indicates inactive or disimilarity to known binders"
  s_pKderrorcomment = "Estimated total uncertainty/error for pKd prediction, including experimental error of ~1. pKd unit\nND or empty cell indicates inactive or disimilarity to known binders"
  s_DockNNScorecomment = "ICM Convolutional Neural Network docking score, \nScore < -32. are in general significant, \nbut may vary from structure to structure"
  s_DockScorecomment = "ICM docking score, \nScore < -32. are in general significant, \nbut may vary from structure to structure"
  s_MolTmplScorecomment = "ICM docking pose reliability, \ndpc model with MolTmplScore < 0.6 are likely mis-docked"
  set format modelposetmp.pPvalue "%.2f" name="" color="rainbow='#FFFFFF/#FFFF00/#FF0000,1.:3.,pinwheel'" comment=s_Probcomment
  set format modelposetmp.MolScore "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,3.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_Scorecomment
  set format modelposetmp.MolpKd "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_pKdcomment
  set format modelposetmp.MolpKd_Error "%.1f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,1.5:2.5,pinwheel'" comment=s_pKderrorcomment
  set format modelposetmp.MolZScore "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,1.:3.,pinwheel'" comment=s_Zscorecomment
  set format modelposetmp.MolClass "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'" comment=s_Classcomment
  set format modelposetmp.MolRecNNScore "%.1f" name="" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,-32.:-20.,pinwheel'" comment=s_DockNNScorecomment
  set format modelposetmp.MolRecScore "%.1f" name="" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,-32.:-20.,pinwheel'" comment=s_DockScorecomment
  set format modelposetmp.MolTmplScore "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,0.6:0.9.,pinwheel'" comment=s_MolTmplScorecomment
  if (s_mod[1:3]=="mcp") then
    s_Molcol = "Mol"+Replace(s_predcol "_mcp" "")
    add column modelposetmp $s_tab.$s_predcol name=s_Molcol index=9
    s_predictValue = "modelposetmp."+s_Molcol
    set format modelposetmp.$s_Molcol "%.2f" name="" color=$s_mod["COLOR"] comment=$s_mod["NAME"]+"\n"+$s_mod["COMMENT"]
    if (Type(msLigandModel)!="unknown") then
      join left modelposetmp.mol msLigandModel.mol name="T_join"
      S_tmpmacro = Name(T_join)[Index(Index(Name(T_join) "T_join.Mol" regexp) 1 all)]
      if (Nof(S_tmpmacro)>4) then
        S_tmpmacro = S_tmpmacro[5:Nof(S_tmpmacro)]
        for i_tmpmacro = 1, Nof(S_tmpmacro)
          s_tmpmacro = S_tmpmacro[i_tmpmacro]
          add column modelposetmp $s_tmpmacro name=Field(s_tmpmacro 2 "." )
        endfor
      endif
      delete T_join
    endif
  else
    if (s_mod[1:3]=="ncc") s_predictValue = "modelposetmp.MolClass"
    if (s_mod[1:3]=="kcc") s_predictValue = "modelposetmp.MolClass"
    if (s_mod[1:3]=="dfz") s_predictValue = "modelposetmp.MolZScore"
    if (s_mod[1:3]=="dfa") s_predictValue = "modelposetmp.MolpKd"
    if (s_mod[1:3]=="dpc") s_predictValue = "modelposetmp.MolClass"
    if (s_mod[1:3]=="rca") s_predictValue = "modelposetmp.MolpKd"
    if (s_mod[1:3]=="eca") s_predictValue = "modelposetmp.MolpKd"
    if (Type($s_tab.$s_predcol)!="unknown") then
      $s_predictValue = ($s_tab).$s_predcol
    elseif  (Type($s_tab.$s_mod)!="unknown") then
      $s_predictValue = ($s_tab).$s_mod
    endif
    if (Type($s_tab.ATOM_CONTRIB)=="parray") modelposetmp.ATOM_CONTRIB = $s_tab.ATOM_CONTRIB
  endif
  if (s_mod[1:3]=="ncc") then
    if (Type(modelposetmp2.$s_predcol)!="unknown") then
      modelposetmp.pPvalue = modelposetmp2.$s_predcol
    elseif  (Type(modelposetmp2.$s_mod)!="unknown") then
      modelposetmp.pPvalue = modelposetmp2.$s_mod
    endif
    S_targetlist = $s_mod["S_targetlist"][Index(Tointeger($s_mod["I_used"]) 1 all)]
    modelposetmp3 = modelposetmp
    if (l_removeinactives) modelposetmp = modelposetmp.pPvalue >=2. | modelposetmp.MolClass >= 20.*Toreal($s_mod["r_posprior"]) | modelposetmp.MolpKd >= 5.
    for i_target = 1, Nof(S_targetlist)
      s_targetcol = S_targetlist[i_target]+"_"+s_mod
      if ((Type($s_tab.$s_targetcol)=="unknown") | (Type(modelposetmp2.$s_targetcol)=="unknown")) continue
      modelposetmp4 = modelposetmp3
      modelposetmp4.Target = Sarray(Nof(modelposetmp4) S_targetlist[i_target])
      modelposetmp4.MolClass = ($s_tab).$s_targetcol
      modelposetmp4.pPvalue = modelposetmp2.$s_targetcol
      s_targetcol2 =  S_targetlist[i_target]+"_"+Replace(s_mod "ncc" "nca")
      if (Type($s_tab.$s_targetcol2)!="unknown") then
        modelposetmp4.MolpKd = ($s_tab).$s_targetcol2
        modelposetmp4.MolpKd [Index(modelposetmp4.MolpKd==0.)] = Toreal("ND")
      endif
      if (l_removeinactives) modelposetmp4 = modelposetmp4.pPvalue >=2. | modelposetmp4.MolClass >= 20.* Toreal($s_mod["r_posprior"]) | modelposetmp4.MolpKd >= 5.
      if (Nof(modelposetmp4)>0) add modelposetmp modelposetmp4 ; delete modelposetmp4 l_warn=no
    endfor
  endif
  if ((s_mod[1:3]=="rca")|(s_mod[1:3]=="eca")) then
   modelposetmp.MolpKd[Index(modelposetmp.MolpKd==0.)] = Toreal("ND")
   if (Exist($s_mod "r_pPvalueA")&Exist($s_mod "r_pPvalueB")&Exist($s_mod "r_pPvalueC")) then
      I_tmppPvalue = Index(modelposetmp.MolpKd != Toreal("ND"))
      if (Nof(I_tmppPvalue)>0) then
        R_tmppPvalue =  $s_mod["r_pPvalueC"]+(100.-$s_mod["r_pPvalueC"])/(1.+Exp(-$s_mod["r_pPvalueA"]*(modelposetmp.MolpKd[I_tmppPvalue]-$s_mod["r_pPvalueB"])))
        modelposetmp.pPvalue[I_tmppPvalue] = -Log((100.-Trim(R_tmppPvalue 0. 99.99999999))/100. 10.)
      endif
    endif
  endif
  if (s_mod[1:3]=="kcc") then
    modelposetmp.MolpKd = ($s_tab).$s_kcacol
    modelposetmp.MolpKd[Index(modelposetmp.MolpKd==0.)] = Toreal("ND")
    if (Exist($s_mod "r_pPvalueA")&Exist($s_mod "r_pPvalueB")&Exist($s_mod "r_pPvalueC")) then
      I_tmppPvalue = Index(modelposetmp.MolpKd != Toreal("ND"))
      if (Nof(I_tmppPvalue)>0) then
        R_tmppPvalue =  $s_mod["r_pPvalueC"]+(100.-$s_mod["r_pPvalueC"])/(1.+Exp(-$s_mod["r_pPvalueA"]*(modelposetmp.MolpKd[I_tmppPvalue]-$s_mod["r_pPvalueB"])))
        modelposetmp.pPvalue[I_tmppPvalue] = -Log((100.-Trim(R_tmppPvalue 0. 99.99999999))/100. 10.)
      endif
    endif
#    if (Exist($s_mod["PREDext"]) & Exist($s_mod["PKDext"])) then
#      group table T_noisetmp Toreal($s_mod["PREDext"]) "PREDext" Toreal($s_mod["PKDext"]) "PKDext"
#      delete T_noisetmp[Index(T_noisetmp.PKDext > 5.)]
#      if (Nof(T_noisetmp)!=0) then
#        sort reverse T_noisetmp.PREDext
#        if (Exist($s_mod["version"]) & $s_mod["version"]>=1.1) then
#          calcpPvalue modelposetmp.MolClass T_noisetmp.PREDext yes
#        else
#          calcpPvalue modelposetmp.MolClass T_noisetmp.PREDext no
#        endif
#        modelposetmp.pPvalue = R_out
#      endif
#      delete T_noisetmp
#    endif
#     R_out = Power(Max(modelposetmp.MolpKd*0.29384-0.643836 Rarray(Nof(modelposetmp.MolpKd) 0.)) 2)
#     R_out = Trim(R_out 0. 10.)
#     modelposetmp.pPvalue = Max(R_out modelposetmp.pPvalue)
  endif
  if ((s_mod[1:3]=="dfz")|(s_mod[1:3]=="dfa")|(s_mod[1:3]=="dpc")) then
    if ((s_mod[1:3]=="dfa"|s_mod[1:3]=="dpc")& Exist($s_mod["PRED"]) & Exist($s_mod["PKD"]) &  Exist($s_mod["PKDext"])) then	#new model type and embedded data for dfa
      if (s_mod[1:3]=="dfa") then
        modelposetmp.MolClass = ($s_tab).$s_dfccol
      elseif (s_mod[1:3]=="dpc") then
        modelposetmp.MolpKd = ($s_tab).$s_dpacol
        s_tabdockNNScorecol = s_tab+"."+s_dockNNScorecol
        s_tabdockScorecol = s_tab+"."+s_dockScorecol
        s_tabMolTmplScorecol = s_tab+".MolTmplScore"
        if (Type($s_tabdockScorecol)!="unknown") then
          if (Type($s_tabdockNNScorecol)!="unknown") modelposetmp.MolRecNNScore = $s_tabdockNNScorecol
          modelposetmp.MolRecScore = $s_tabdockScorecol
        else
          modelposetmp.MolRecScore = (modelposetmp.MolClass -$s_mod["B"])/$s_mod["A"]
        endif
        if (Type($s_tabMolTmplScorecol)!="unknown") then
          modelposetmp.MolTmplScore = $s_tabMolTmplScorecol
        endif
      endif
      modelposetmp.MolpKd[Index(modelposetmp.MolpKd==0.)] = Toreal("ND")
      if (Exist($s_mod "r_pPvalueA")&Exist($s_mod "r_pPvalueB")&Exist($s_mod "r_pPvalueC")) then
        I_tmppPvalue = Index(modelposetmp.MolpKd != Toreal("ND"))
        if (Nof(I_tmppPvalue)>0) then
          R_tmppPvalue =  $s_mod["r_pPvalueC"]+(100.-$s_mod["r_pPvalueC"])/(1.+Exp(-$s_mod["r_pPvalueA"]*(modelposetmp.MolpKd[I_tmppPvalue]-$s_mod["r_pPvalueB"])))
          modelposetmp.pPvalue[I_tmppPvalue] = -Log((100.-Trim(R_tmppPvalue 0. 99.99999999))/100. 10.)
        endif
      endif
#        R_out = Power(Max(modelposetmp.MolpKd*0.29384-0.643836 Rarray(Nof(modelposetmp.MolpKd) 0.)) 2)
#        R_out = Trim(R_out 0. 10.)
#        modelposetmp.pPvalue = R_out
#      if (s_mod[1:3]=="dfa" & Exist($s_mod["ClassPREDext"]) & Exist($s_mod["PKDext"])) then
#        group table T_noisetmp Toreal($s_mod["ClassPREDext"]) "ClassPREDext" Toreal($s_mod["PKDext"]) "PKDext"
#        delete T_noisetmp[Index(T_noisetmp.PKDext > 5.)]
#        if (Nof(T_noisetmp)!=0) then
#          sort reverse T_noisetmp.ClassPREDext
#          if (Exist($s_mod["version"]) & $s_mod["version"]>=15.) then
#            calcpPvalue modelposetmp.MolClass T_noisetmp.ClassPREDext yes
#          else
#            calcpPvalue modelposetmp.MolClass T_noisetmp.ClassPREDext no
#          endif
#          modelposetmp.pPvalue = Max(R_out modelposetmp.pPvalue)
#        endif
#        delete T_noisetmp
#      endif
#      if (s_mod[1:3]=="dpc" & Exist($s_mod["PREDext"]) & Exist($s_mod["PKDext"])) then
#        group table T_noisetmp Toreal($s_mod["PREDext"]) "PREDext" Toreal($s_mod["PKDext"]) "PKDext"
#        delete T_noisetmp[Index(T_noisetmp.PKDext > 5.)]
#        if (Nof(T_noisetmp)!=0) then
#          sort reverse T_noisetmp.PREDext
#          if (Exist($s_mod["version"]) & $s_mod["version"]>=15.) then
#            calcpPvalue modelposetmp.MolClass T_noisetmp.PREDext yes
#          else
#            calcpPvalue modelposetmp.MolClass T_noisetmp.PREDext no
#          endif
#          modelposetmp.pPvalue = Max(R_out modelposetmp.pPvalue)
#        endif
#        delete T_noisetmp
#      endif
    elseif (s_mod[1:3]=="dpc") then
      if ($s_mod["l_qsar"] == no) then
        if ($s_mod["l_ZScore"]==yes) then
          modelposetmp.MolZScore = modelposetmp.MolClass
          modelposetmp.MolRecScore = (modelposetmp.MolClass - $s_mod["B"])/$s_mod["A"]
          modelposetmp.MolClass = Rarray(Sarray(Nof(modelposetmp) "0."))
        else
          modelposetmp.MolRecScore = modelposetmp.MolClass
          modelposetmp.MolClass = Rarray(Sarray(Nof(modelposetmp) "0."))
        endif
      endif
    endif
#    if (Exist($s_mod["PRED"]) & Exist($s_mod["PKD"]) & Exist($s_mod["TRAIN"])) then
#      group table T_noisetmp Toreal($s_mod["PRED"]) "PRED" Toreal($s_mod["PKD"]) "PKD" Tointeger($s_mod["TRAIN"]) "TRAIN"
#      T_noisetmp = T_noisetmp.TRAIN == 0
#      delete  T_noisetmp[Index(T_noisetmp.PKD > 5.)]
#      if (Nof(T_noisetmp)!=0) then
#        sort reverse T_noisetmp.PRED
#        if (s_mod[1:3]=="dfz") then
#          calcpPvalue modelposetmp.MolZScore T_noisetmp.PRED
#        elseif (s_mod[1:3]=="dfa") then
#          R_out = Power(Max(modelposetmp.MolpKd*0.29384-0.643836 Rarray(Nof(modelposetmp.MolpKd) 0.)) 2)
#          R_out = Trim(R_out 0. 10.)
#        endif
#        if (s_mod[1:3]!="dfz") modelposetmp.pPvalue = R_out
#      endif
#      delete T_noisetmp
#    endif
  endif
  i_add = 0;if (s_mod[1:3]=="mcp") i_add=1
  i_colnum = 11
  add column modelposetmp Sarray(Nof(modelposetmp) s_mod[1:3]) name="predictType" index=i_colnum+i_add
  add column modelposetmp Iarray(Nof(modelposetmp) 0) name="TmplCl" index=i_colnum+i_add
  if (Type($s_tab.$s_clcol)!="unknown") modelposetmp.TmplCl = $s_tab.$s_clcol
  if (s_mod[1:3]!="ncc") then
    add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="MolSim" index=i_colnum+i_add
    if (Type($s_tab.$s_simcol)!="unknown") modelposetmp.MolSim = $s_tab.$s_simcol
    if (Type($s_tab.MolSim)!="unknown") modelposetmp.MolSim = $s_tab.MolSim
  else
    if (Type(modelposetmp.MolSim)!="unknown") move modelposetmp.MolSim i_colnum+i_add
  endif
  set format modelposetmp.MolSim "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'" comment="Tanimoto Similarity for nearest 2D molecule or APF Similarity for nearest 3D pose"
#  r_y0 = 1./(1.+Exp(6.*0.8))
#  r_y1 = 1./(1.+Exp(-6.*0.2))
#  modelposetmp.MolScore = modelposetmp.MolpKd * ((1./(1.+Exp(-6.*(modelposetmp.MolSim-0.8))))-r_y0)/(r_y1-r_y0)
  if (s_mod[1:3] == "kcc") then
    r_y0 = 1./(1.+Exp(-96.*(0.-0.75)))
    r_y1 = 1./(1.+Exp(-96.*(1.-0.75)))
    modelposetmp.MolScore = modelposetmp.MolpKd * ((1./(1.+Exp(-96.*(modelposetmp.MolSim-0.75))))-r_y0)/(r_y1-r_y0)
  else
    r_y0 = 1./(1.+Exp(-6.*(0.-0.85)))
    r_y1 = 1./(1.+Exp(-6.*(1.-0.85)))
    modelposetmp.MolScore = modelposetmp.MolpKd * ((1./(1.+Exp(-6.*(modelposetmp.MolSim-0.85))))-r_y0)/(r_y1-r_y0)
  endif
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="modelAUC" index=i_colnum+2+i_add
  set format modelposetmp.modelAUC "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,50.:90.,pinwheel'"
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="modelpKdAUC" index=i_colnum+3+i_add
  set format modelposetmp.modelpKdAUC "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,50.:90.,pinwheel'"
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="modelClassAUC" index=i_colnum+4+i_add
  set format modelposetmp.modelClassAUC "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,50.:90.,pinwheel'"
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="modelRMSE" index=i_colnum+5+i_add
  set format modelposetmp.modelRMSE "%.1f" name="" color="rainbow='#DCFFDC/#FFFFDC/#FFDCDC,1.:2.,pinwheel'"
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="modelQ2" index=i_colnum+6+i_add
  set format modelposetmp.modelQ2 "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,0.1:0.6,pinwheel'"
  add column modelposetmp Toreal(Sarray(Nof(modelposetmp) "ND")) name="modelR2pkd" index=i_colnum+7+i_add
  set format modelposetmp.modelR2pkd "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,0.1:0.6,pinwheel'"
  add column modelposetmp Sarray(Nof(modelposetmp) $s_mod["NAME"]) name="Target_Name" index=i_colnum+8+i_add
  if Exist($s_mod["AUC"]) modelposetmp.modelAUC = Rarray(Nof(modelposetmp) $s_mod["AUC"])
  if Exist($s_mod["pKdAUC"]) modelposetmp.modelpKdAUC = Rarray(Nof(modelposetmp) $s_mod["pKdAUC"])
  if Exist($s_mod["ClassAUC"]) modelposetmp.modelClassAUC = Rarray(Nof(modelposetmp) $s_mod["ClassAUC"])
  if Exist($s_mod["RMSE"]) modelposetmp.modelRMSE = Rarray(Nof(modelposetmp) $s_mod["RMSE"])
  if Exist($s_mod["Q2"]) modelposetmp.modelQ2 = Rarray(Nof(modelposetmp) $s_mod["Q2"])
  if (($s_mod["R2pkd"]!=0.)&($s_mod["R2pkd"]!=Toreal("ND"))) modelposetmp.modelR2pkd = Rarray(Nof(modelposetmp) $s_mod["R2pkd"])
  if (s_mod[1:3]=="ncc") then
    if Exist($s_mod["R_AUC"]) then
      group table tauc1 modelposetmp.Target "Target"
      group table tauc2 $s_mod["S_targetlist"] "Target" $s_mod["R_AUC"] "AUC" $s_mod["S_Fullname"] "Target_Name"
      join left tauc1.Target tauc2.Target name="tauc3"
      modelposetmp.modelAUC = tauc3.AUC
      modelposetmp.Target_Name[Index(tauc3.Target_Name!="")] = tauc3.Target_Name[Index(tauc3.Target_Name!="")]
      delete tauc1 tauc2 tauc3 l_warn=no
    endif
    if Exist($s_mod["R_Q2"]) then
      group table tauc1 modelposetmp.Target "Target"
      group table tauc2 $s_mod["S_targetlist"] "Target" $s_mod["R_Q2"] "Q2" $s_mod["S_Fullname"] "Target_Name"
      join left tauc1.Target tauc2.Target name="tauc3"
      modelposetmp.modelQ2 = tauc3.Q2
      modelposetmp.Target_Name[Index(tauc3.Target_Name!="")] = tauc3.Target_Name[Index(tauc3.Target_Name!="")]
      delete tauc1 tauc2 tauc3 l_warn=no
    endif
  endif
  if (s_mod[1:3]!="ncc") then
    add column modelposetmp Chemical(Sarray(Nof(modelposetmp) "")) name="modelnearestCpd" index=i_colnum+i_add+1
    if (Type($s_tab.$s_nearestcol)!="unknown") modelposetmp.modelnearestCpd = $s_tab.$s_nearestcol
    if (Type($s_tab.Molnn)!="unknown") modelposetmp.modelnearestCpd = $s_tab.Molnn
  else
    if (Type(modelposetmp.modelnearestCpd)!="unknown") move modelposetmp.modelnearestCpd i_colnum+i_add+1
  endif
  if (l_removeinactives) then
    if ((s_mod[1:3]=="rca")|(s_mod[1:3]=="eca")|(s_mod[1:3]=="kcc")|(s_mod[1:3]=="dfa")|(s_mod[1:3]=="dpc")) then
#      modelposetmp = modelposetmp.MolpKd != Toreal("ND")
#      modelposetmp = modelposetmp.MolpKd >= 5.5
      modelposetmp = modelposetmp.MolScore >= 3. | modelposetmp.MolpKd >= 5. | modelposetmp.MolZScore > 2.
    elseif (s_mod[1:3]=="dfz") then
      modelposetmp = modelposetmp.MolZScore > 2.
    endif
    if (Nof(modelposetmp)==0) then
      delete modelposetmp
      return "No entry after removing inactives..."
    endif
    if (s_mod[1:3]!="ncc") predictModelPoseEmbed "modelposetmp"
  endif
  if ((s_mod[1:3]=="rca")|(s_mod[1:3]=="eca")|(s_mod[1:3]=="kcc")|(s_mod[1:3]=="dfa")|(s_mod[1:3]=="dpc")|(s_mod[1:3]=="ncc")) then
    if (Exist($s_mod "MolScorecutoff")) modelposetmp = modelposetmp.MolScore >= Toreal($s_mod["MolScorecutoff"])
    if (Exist($s_mod "MolpKdcutoff")) modelposetmp = modelposetmp.MolpKd >= Toreal($s_mod["MolpKdcutoff"])
    if (Exist($s_mod "MolSimcutoff")) modelposetmp = modelposetmp.MolSim >= Toreal($s_mod["MolSimcutoff"])
  endif
  if ((s_mod[1:3]=="dfz") & (Exist($s_mod "MolZScorecutoff"))) modelposetmp = modelposetmp.MolZScore >= Toreal($s_mod["MolZScorecutoff"])
  if (Nof(modelposetmp)==0) then
    delete modelposetmp
    return "No entry after removing inactives..."
  endif
  if (s_mod[1:3]=="dfa") then
    modelposetmp = $s_predictValue != Toreal("ND") | modelposetmp.MolClass != Toreal("ND")
  elseif (s_mod[1:3]=="dpc"|s_mod[1:3]=="kcc") then
    modelposetmp = $s_predictValue != Toreal("ND") | modelposetmp.MolpKd != Toreal("ND")
  else
    modelposetmp = $s_predictValue != Toreal("ND")
  endif
  if (Exist($s_mod["RMSE"])) then
    if (Nof(modelposetmp.MolSim == Toreal("ND" ) ) != Nof(modelposetmp)) then
      modelposetmp.MolpKd_Error = Sqrt(1.+Power($s_mod["RMSE"]+Max((1.-modelposetmp.MolSim)*3.37287-0.703663, Rarray(Nof(modelposetmp),-0.3405)) 2))
    else
      modelposetmp.MolpKd_Error = Rarray(Nof(modelposetmp) Sqrt(1.+Power($s_mod["RMSE"] 2)))
    endif
    modelposetmp.MolpKd_Error[Index(modelposetmp.MolpKd==Toreal("ND"))] = Toreal("ND")
  else
    if (Exist($s_mod["Q2"])) then
      if (Nof(modelposetmp.MolSim == Toreal("ND" ) ) != Nof(modelposetmp)) then
        modelposetmp.MolpKd_Error = Sqrt(1.+Power(Trim($s_mod["Q2"]*-0.6918+1.175+5.*(0.9-modelposetmp.MolSim) 0. 10.) 2))
      else
        modelposetmp.MolpKd_Error = Rarray(Nof(modelposetmp) Sqrt(1.+Power(Trim($s_mod["Q2"]*-0.6918+1.175 0. 10.) 2)))
      endif
      modelposetmp.MolpKd_Error[Index(modelposetmp.MolpKd==Toreal("ND"))] = Toreal("ND")
    endif
  endif
  s_return = "All prediction value ND for model: "+s_mod
  if (Nof(modelposetmp)==0) return s_return
  add header modelposetmp name="toolsPanel" ""
  modelposetmp.toolsPanel = """
# txt_ (Display pose by double clicking on any row<br>Double clicking on the same row again to keep the object)
# d_Models_Folder ($TOOLS.modelsDir)
# b_Check_Against_Embedded_Data (TOOLS.modelsDir=\"$2\";if (Nof(Index(%@ selection cursor))==1) then;checkembeddata \"\" Index(%@ selection cursor)[1];else;print "Please select one table row only";endif)[BEGINFRAME:Check data embedded in model]
# txt_ (Select one table row by clicking on its header<br>Open tools panel of T_embedded table for additional comment)[ENDFRAME]
# b_Embed_Objects_to_Table (TOOLS.modelsDir = \"$2\"; predictModelPoseEmbed Name(variable %@))
# b_Group_Models_for_Ligand_Target_Pairs (compresstoTargetPair Name(variable %@))
# b_Extract_Checked_Rows_to_New_Table (T_tmpselect=%@.chk==1;rename T_tmpselect Name(Name(variable %@) unique))
# X_Chemical_Table_with_ID_Column (*) [BEGINFRAME:Generate Reports in original table, new table, or html,RESIZE,LMINWIDTH:110,RDONLY]
# C_Unique_Chemical_ID_Column () [TABLE:8,IARRAY,SARRAY]
# S_Combine_Columns ({"MolScore","MolpKd","MolSim"})
# f_Pairwise_File_Location|*.icb ("")
# b_Generate_Activity_Summary_in_Original_Table (foldMolSummary \"$8\" Name(variable %@) Field( Name( variable $9 ) 2 "." ) $10 \"$11\")
# txt_ (Group activity by chemical and append back to original table<br>To process a series of files,|use expression,<br> e.g. folder/*/msLigandModel.icb)
# b_Generate_Html_Report (msReport Name(variable %@) Field(Name(variable $9) 2 "."))
# b_Generate_Report_for_Checked_Compound (if (Nof(Index(%@.chk==1))==1) msReportCpd Name(variable %@) Field(Name(variable $9) 2 ".") "" Index(%@.chk==1)[1])
# txt_hint (Make sure the Unique_Chemical ID Column is set correctly)[ENDFRAME]
# b_Add/Update_GO_Terms (msaddGO Name(variable %@)) [ONCHANGE:REFRESH]
# i_Display_Only:GOonly (1@All|2@GO_Cellular|3@GO_Process|4@GO_Function) [RDONLY]
# s_GO_Cellular:gocellular ($%@.S_GOCellular) [VISIBLE:$GOonly==2]
# s_GO_Process:goprocess ($%@.S_GOProcess) [VISIBLE:$GOonly==3]
# s_GO_Function:gofunction ($%@.S_GOFunction) [VISIBLE:$GOonly==4]
# b_Display_All_Rows (msfilterGO Name(variable %@)) [VISIBLE:$GOonly==1]
# b_Filter_by_GO_Cellular (msfilterGO Name(variable %@) "GO_Cellular" Field($gocellular 1 ";")) [VISIBLE:$GOonly==2]
# b_Filter_by_GO_Process (msfilterGO Name(variable %@) "GO_Process" Field($goprocess 1 ";")) [VISIBLE:$GOonly==3]
# b_Filter_by_GO_Function (msfilterGO Name(variable %@) "GO_Function" Field($gofunction 1 ";")) [VISIBLE:$GOonly==4]
"""
  add header modelposetmp String("") name="doubleClick" #append
  modelposetmp.doubleClick = """
if ((%@.predictType[%#])[1]=="d") displayModelPose Name(variable %@) %#
"""
#  group table append modelposetmp header "if ((%@.predictType[%#])!=\"kcc\") displayModelPose Name(variable %@) %#" "cursor"

 if (Nof(Name(modelposetmp))<=2000) then
  if (s_mod[1:3]=="dfz" | s_mod[1:3]=="dfa") then
    if (Nof(a_predictModelTmpl.)!=0) delete a_predictModelTmpl.
    S_objlist = Tostring(Unique(Sort(modelposetmp.TmplCl)))
    for i_objlist = 1, Nof(S_objlist)
      i_previousObj = Nof(a_*. )
      if (Type($s_mod["ob"+S_objlist[i_objlist]]) == "parray") then
        s_ob = "ob"+S_objlist[i_objlist]
        load object $s_mod[s_ob]
#    elseif ((S_objlist[i_objlist]=="1")&(Type($s_mod["ob"]) == "parray")) then
      else
        s_ob = "ob"
        if ((S_objlist[i_objlist]=="1")&(Type($s_mod[s_ob]) == "parray")) then
          load object $s_mod[s_ob]
        else
          return "Error loading object from model" s_mod
        endif
      endif
      i_currentObj = i_previousObj+1
      if (Nof(a_*.)>i_currentObj) then;s_objlist=String(i_currentObj+1)+":"+String(Nof(a_*.));move a_$s_objlist. a_$i_currentObj. ;endif
      s_objname = s_mod+"_cl"+S_objlist[i_objlist]
      rename a_$i_currentObj. "predictModelTmpl"
      modelposetmp.recobj[s_objname] = Parray(object a_$i_currentObj.)
#      group table append modelposetmp header Parray(object a_$i_currentObj.) s_objname
      delete a_$i_currentObj.
    endfor
  elseif (s_mod[1:3]=="dpc") then
    if (Nof(a_predictModelRec.)!=0) delete a_predictModelRec.
    i_objnum = Index(Index(Name($s_mod ["OBJS"]) ".*_rec" regexp) 1)
    if (i_objnum != 0) then
      s_objname = s_mod
      load object $s_mod["OBJS",Name($s_mod["OBJS"])[i_objnum]] name="predictModelRec"
      modelposetmp.recobj[s_objname] = Parray(object a_predictModelRec.)
#      group table append modelposetmp header Parray(object a_predictModelRec.) s_objname
      delete a_predictModelRec.
    endif
    if (Nof(a_predictModelTmpl.)!=0) delete a_predictModelTmpl.
    i_objnum = Index(Index(Name($s_mod ["OBJS"]) ".*_tmpl" regexp) 1)
    if (i_objnum != 0) then
      s_objname = s_mod+"_tmpl"
      load object $s_mod["OBJS",Name($s_mod["OBJS"])[i_objnum]] name="predictModelTmpl"
      modelposetmp.recobj[s_objname] = Parray(object a_predictModelTmpl.)
#      group table append modelposetmp header Parray(object a_predictModelRec.) s_objname
      delete a_predictModelTmpl.
    endif
  endif
 endif
  add column modelposetmp Iarray(Nof(modelposetmp) 0) name="chk" index=2
  set property modelposetmp.chk logical
  set property modelposetmp field off
  move modelposetmp.predictType Index(Name(modelposetmp) "modelposetmp.MolpKd_Error")+1
  if (Type(msLigandModel) != "unknown") then
    if (s_mod[1:3]=="mcp") then
      if (Type(msLigandModel.$s_Molcol)=="unknown") then
        join left msLigandModel.mol modelposetmp.mol name="T_join"
        add column msLigandModel T_join.$s_Molcol name=s_Molcol index=9; delete T_join
      endif
    endif
    add msLigandModel modelposetmp
#    S_header = Name(modelposetmp header)
#    for i_header = 1, Nof(S_header)
#      s_header = S_header[i_header]
#      if (Type($s_header)=="parray") group table append msLigandModel header $s_header Field(s_header 2 ".")
#    endfor
    msLigandModel.recobj = msLigandModel.recobj+modelposetmp.recobj
    delete modelposetmp
  else
    rename modelposetmp "msLigandModel"
    set property msLigandModel header
    keep global msLigandModel
  endif
  S_colname = Name(msLigandModel)
  for i_col = 3, Index(Name(msLigandModel) "msLigandModel.Target_Name")
    s_colname = S_colname[i_col]
    if (s_colname == "msLigandModel.modelnearestCpd") then
      if ( Nof($s_colname==Chemical(""))==Nof(msLigandModel)) then
        set format $s_colname show off
      else
        set format $s_colname show
      endif
    elseif (Type($s_colname)=="sarray") then
      if (Nof($s_colname=="")==Nof(msLigandModel)) then
        set format $s_colname show off
      else
        set format $s_colname show
      endif
    elseif (Type($s_colname)=="rarray") then
      if (Nof($s_colname==Toreal("ND"))==Nof(msLigandModel)) then
        set format $s_colname show off
      else
        set format $s_colname show
      endif
    elseif (Type($s_colname)=="iarray") then
      if (Nof($s_colname==0)==Nof(msLigandModel)) then
        set format $s_colname show off
      else
        set format $s_colname show
      endif
    endif
  endfor
  if (Type(msLigandModel.ATOM_CONTRIB)=="parray") set format msLigandModel.ATOM_CONTRIB show off
  if (Nof(Name(msLigandModel))<=2000) then
#    compresstoTargetPair "msLigandModel"
#    keep global msLigandTarget
  endif
endmacro
#
macro msnewMolScore s_tab ("") auto
HELP = """
  recalculate MolScore using the new formula in 2016/8
  Syntax:
    msnewMolScore <s_tab>
"""
  s_tab = Trim(s_tab all)
  if (s_tab == "") return "Please specify table name or location"
  if (Type($s_tab)!="table") return "Table specified not found"
  if (Type($s_tab.MolpKd)=="unknown") return "Column MolpKd not found"
  if (Type($s_tab.MolSim)=="unknown") return "Column MolSim not found"
  if (Type($s_tab.predictType)!="sarray") return "Sarray Column predictType not found"
  if (Type(T_tmpmacro)!="unknown") delete T_tmpmacro l_warn=no
  T_tmpmacro = $s_tab; delete $s_tab l_warn=no
  if (Type(T_tmpmacro.MolClass)!="rarray") add column T_tmpmacro Toreal(T_tmpmacro.MolClass) name="MolClass" delete
  if (Type(T_tmpmacro.MolpKd)!="rarray") add column T_tmpmacro Toreal(T_tmpmacro.MolpKd) name="MolpKd" delete
  if (Type(T_tmpmacro.MolScore)!="rarray") add column T_tmpmacro Toreal(T_tmpmacro.MolpKd) name="MolScore" delete
  r_y0 = 1./(1.+Exp(-6.*(0.-0.85)))
  r_y1 = 1./(1.+Exp(-6.*(1.-0.85)))
#  if (Type(T_tmpmacro.MolScore)!="unknown") delete T_tmpmacro.MolScore
  add column T_tmpmacro T_tmpmacro.MolpKd * ((1./(1.+Exp(-6.*(T_tmpmacro.MolSim-0.85))))-r_y0)/(r_y1-r_y0) name="MolScore" index=2
  I_kcc = Index(T_tmpmacro.predictType=="kcc")
  if (Nof(I_kcc)>0) then
    r_y0 = 1./(1.+Exp(-96.*(0.-0.75)))
    r_y1 = 1./(1.+Exp(-96.*(1.-0.75)))
    T_tmpmacro.MolScore[I_kcc] =  T_tmpmacro.MolpKd[I_kcc] * ((1./(1.+Exp(-96.*(T_tmpmacro.MolSim[I_kcc]-0.75))))-r_y0)/(r_y1-r_y0)
  endif
  rename T_tmpmacro s_tab
  keep $s_tab
endmacro
#
macro predictModelPoseEmbed s_posetab ("msLigandModel")
  l_info = no; l_commands = no
  T_posetab = $s_posetab
  I_entries = Index(Index(T_posetab.predictType "d" regexp) 1 all)
  if (Nof(I_entries)==0) return
  S_objlist = Unique(Sort((T_posetab.predictType +T_posetab.Target+Sarray(Nof(T_posetab) "_cl")+T_posetab.TmplCl)[I_entries]))
  I_dpc = Index(Index(S_objlist "dpc" regexp) 1 all)
  if (Nof(I_dpc)!=0) then
    S_objlist[I_dpc] = Field(S_objlist [I_dpc] 1 "_")
    S_objlist = Unique(Sort(S_objlist))
  endif
  if (Nof(S_objlist)>2000) return "Too many embeded object, please split the table into smaller ones and re-embed again"
  S_notfound = Sarray()
  if (Type( T_posetab.recobj)!="collection") then
    if (Type( T_posetab.recobj)!="unknown") delete T_posetab.recobj
    add header T_posetab Collection( ) name="recobj"
  endif
  for i_objlist = 1, Nof(S_objlist)
    s_objlist = S_objlist[i_objlist]
    if (Type(T_posetab.recobj[s_objlist])=="parray") continue
#    if (Type(T_posetab.$s_objlist)=="parray") continue
    if (Type(T_posetab.recobj[s_objlist])!="unknown") delete T_posetab.recobj[s_objlist]
#    if (Type(T_posetab.$s_objlist)!="unknown") delete T_posetab.$s_objlist
    s_modname = Field(s_objlist 1 "_")
    l_loaded = no
    if (Type($s_modname)!="unknown") then
      l_loaded = yes
    elseif (Exist(s_icmhome+"models/"+s_modname+".icb")) then
      read binary s_icmhome+"models/"+s_modname+".icb"
    else
      S_modelsDir = Split(TOOLS.modelsDir ";")
      l_continue = yes
      for i_modelsDir = 1, Nof(S_modelsDir)
        if (Exist(S_modelsDir[i_modelsDir]+s_modname+".icb")) then
          read binary S_modelsDir[i_modelsDir]+s_modname+".icb"
          l_continue = no
          break
        endif
      endfor
      if (l_continue) then
        S_notfound //= s_modname
        continue
      endif
    endif
    if (s_modname[1:3]=="dfz" | s_modname[1:3]=="dfa") then
      if (Nof(a_predictModelTmpl.)!=0) delete a_predictModelTmpl.
      i_previousObj = Nof(a_*. )
      s_ob = "ob"+Replace(Field(S_objlist[i_objlist] 2 "_") "cl" "")
      if (Type($s_modname[s_ob]) == "parray") then
        load object $s_modname[s_ob]
      else
        s_ob = "ob"
        if ((Replace(Field(S_objlist[i_objlist] 2 "_") "cl" "")=="1")&(Type($s_modname[s_ob]) == "parray")) then
          load object $s_modname[s_ob]
        else
          S_notfound //= s_modname
          continue
        endif
      endif
      i_currentObj = i_previousObj+1
      if (Nof(a_*.)>i_currentObj) then;s_objlist=String(i_currentObj+1)+":"+String(Nof(a_*.));move a_$s_objlist. a_$i_currentObj. ;endif
      s_objname =  S_objlist[i_objlist]
      rename a_$i_currentObj. "predictModelTmpl"
      T_posetab.recobj[s_objname] = Parray(object a_predictModelTmpl.)
#      group table append T_posetab header Parray(object a_$i_currentObj.) s_objname
      delete a_$i_currentObj.
    elseif (s_modname[1:3]=="dpc") then
      if (Nof(a_predictModelRec.)!=0) delete a_predictModelRec.
      i_objnum = Index(Index(Name($s_modname ["OBJS"]) ".*_rec" regexp) 1)
      if (i_objnum != 0) then
        s_objname = s_modname
        load object $s_modname["OBJS",Name($s_modname["OBJS"])[i_objnum]] name="predictModelRec"
        T_posetab.recobj[s_objname] = Parray(object a_predictModelRec.)
#        group table append T_posetab header Parray(object a_predictModelRec.) s_objname
        delete a_predictModelRec.
      endif
      if (Nof(a_predictModelTmpl.)!=0) delete a_predictModelTmpl.
      i_objnum = Index(Index(Name($s_modname ["OBJS"]) ".*_tmpl" regexp) 1)
      if (i_objnum != 0) then
        s_objname = s_modname+"_tmpl"
        load object $s_modname["OBJS",Name($s_modname["OBJS"])[i_objnum]] name="predictModelTmpl"
        T_posetab.recobj[s_objname] = Parray(object a_predictModelTmpl.)
        delete a_predictModelTmpl.
      endif
    endif
    if (!l_loaded) delete $s_modname
  endfor
  if (Nof(S_notfound)!=0) print " Warning> could not embed docking poses into result table. Hint: specify correct location in TOOLS.modelsDir:\n"+Sum(S_notfound ",")
  S_embeddedlist = Name(T_posetab.recobj )
  for i_obj = 1, Nof(S_embeddedlist)
    s_objname = S_embeddedlist[i_obj]
    if (Index(S_objlist s_objname)!=0) continue
    if (s_objname[1:3] == "dfa") then
      if (Index(S_objlist s_objname)==0) delete T_posetab.recobj [s_objname]
    elseif (s_objname[1:3] == "dpc") then
      if (Index(S_objlist Field(s_objname 1 "_"))==0) delete T_posetab.recobj [s_objname]
    endif
  endfor
  delete $s_posetab
  rename T_posetab s_posetab
  keep $s_posetab
endmacro
#
macro displayModelPose s_posetab i_row
  l_warn=l_info=no
  l_saveobj = no
  if ((Type(s_posetablast)!="unknown") & (Type(i_rowlast)!="unknown")) then
    if ((s_posetablast == s_posetab)&(i_rowlast==i_row)) l_saveobj = yes
  endif
  if (Nof(a_predictModelRec.)!=0) delete a_predictModelRec.
  if (Nof(a_predictModelTmpl.)!=0) delete a_predictModelTmpl.
  if (Nof(a_predictModelLig.)!=0) delete a_predictModelLig.
  if (Type(hbondpairs )!="unknown") delete hbondpairs
  if (Nof(a_*.)>0) then; I_delete = Index(Index(Name(a_*.) ".*_MolTmpl$" regexp) 1 all);if (Nof(I_delete)!=0) delete (a_*.)[I_delete];endif
  if (Nof(a_*.)>0) then; I_delete = Index(Index(Name(a_*.) ".*_MolLig$" regexp) 1 all);if (Nof(I_delete)!=0) delete (a_*.)[I_delete];endif
  if (Nof(a_*.)>0) then; I_delete = Index(Index(Name(a_*.) ".*_MolRec$" regexp) 1 all);if (Nof(I_delete)!=0) delete (a_*.)[I_delete];endif
  s_recobjname = s_posetab+".recobj"
  if (Type($s_recobjname)!="collection")  return "Receptor object not embedded in table, please use embed object button in Tools panel to embed object"
  if (($s_posetab).predictType[i_row]=="dpc") then
#    s_recname = s_posetab+"."+($s_posetab).predictType[i_row]+($s_posetab).Target[i_row]
    s_recname = ($s_posetab).predictType[i_row]+($s_posetab).Target[i_row]
    if (Type(($s_recobjname)[s_recname])!="parray") then
      return "Receptor object not embedded in table, please use embed object button in Tools panel to embed object"
    endif
    load object ($s_recobjname)[s_recname] name="predictModelRec"; display ribbon only a_predictModelRec.; color ribbon Res(a_*.//DD) ribbonColorStyle="NtoC"
    if (Nof(a_ stack)!=0) load conf a_ ($s_posetab).TmplCl[i_row]
    read mol ($s_posetab).mol[i_row] name="predictModelLig"; display xstick a_predictModelLig.
    if (Type($s_posetab.ATOM_CONTRIB)=="parray") then
      as_predictModelRecH = (a_predictModelLig.H)[$]
      if (Nof(($s_posetab.ATOM_CONTRIB)[i_row]) == Nof(a_predictModelLig.H//!h*,vt* & as_predictModelRecH)) then
        set field name="ATOM_CONTRIB" a_predictModelLig.H//!h*,vt* & as_predictModelRecH ($s_posetab.ATOM_CONTRIB)[i_row]
        GRAPHICS.NtoCRainbow = "blue/white/red"
        GRAPHICS.rainbowBarStyle = "left"
        GRAPHICS.rainbowBarLabels = "pKd_low/pKd_high"
      endif
    else
#      GRAPHICS.rainbowBarStyle = 4
    endif
    convert3Dto3D a_predictModelLig. yes yes yes
    s_tmplname = ($s_posetab).predictType[i_row]+($s_posetab).Target[i_row]+"_tmpl"
    if (Type(($s_recobjname)[s_tmplname])=="parray") then
      load object ($s_recobjname)[s_tmplname] name="predictModelTmpl"
      if(Nof(pmf)==0)read pmf s_icmhome+"APF"
      R_tmpl = Rarray(Nof(a_predictModelTmpl.H) 0.)
      for i_tmpl = 1, Nof(a_predictModelTmpl.H)
        R_tmpl[i_tmpl] = Score(a_predictModelLig.H (a_predictModelTmpl.H)[i_tmpl] field)
      endfor
      delete a_predictModelTmpl.H &! ((a_predictModelTmpl.H)[Min(index R_tmpl)])
      s_tmplobj = ($s_posetab).Target[i_row]+"_MolTmpl"
      display wire a_predictModelTmpl.; color wire a_predictModelTmpl. & a_*.//c* rgb={0,255,0}
      rename a_predictModelTmpl. s_tmplobj
      if (l_saveobj) rename a_$s_tmplobj. Name(s_tmplobj object unique)
    endif
    move a_predictModelLig. a_predictModelRec.
    dsLigandComplex2 a_predictModelRec.H
    color a_predictModelRec.A white
    if (Type($s_posetab.ATOM_CONTRIB)=="parray") then
      as_predictModelRecH = (a_predictModelRec.H)[$]
      if (Nof(($s_posetab.ATOM_CONTRIB)[i_row]) == Nof(a_predictModelRec.H//!h*,vt* & as_predictModelRecH)) then
#        set field name="ATOM_CONTRIB" a_predictModelRec.H//!h*,vt* & as_predictModelRecH ($s_posetab.ATOM_CONTRIB)[i_row]
        display cpk as_predictModelRecH; color cpk a_predictModelRec.H//!h*,vt* & as_predictModelRecH Field(a_predictModelRec.H//!h*,vt* & as_predictModelRecH "ATOM_CONTRIB")//-1//1.
        set atom label a_predictModelRec.H//!h*,vt* & as_predictModelRecH  Tostring(Toreal(Tointeger(Field(a_predictModelRec.H//!h*,vt* & as_predictModelRecH "ATOM_CONTRIB")*100.))/100.)
        display atom label a_predictModelRec.H//!h*,vt* & as_predictModelRecH
        color atom label a_predictModelRec.H//!h*,vt* & as_predictModelRecH Field(a_predictModelRec.H//!h*,vt* & as_predictModelRecH "ATOM_CONTRIB")//-1//1.
      endif
    endif
    center static as_predictModelRecH margin=8.
    s_recobj = ($s_posetab).Target[i_row]+"_MolRec"
    rename a_predictModelRec. s_recobj
    if (l_saveobj) rename a_$s_recobj. Name(s_recobj object unique)
  else
#    s_tmplname=s_posetab+"."+($s_posetab).predictType[i_row]+($s_posetab).Target[i_row]+"_cl"+String(($s_posetab).TmplCl[i_row])
    s_tmplname=($s_posetab).predictType[i_row]+($s_posetab).Target[i_row]+"_cl"+String(($s_posetab).TmplCl[i_row])
    if (Type(($s_recobjname)[s_tmplname])!="parray") then
      return "APF Template not embedded in table, please use embed object button in Tools panel to embed object"
    endif
    load object  ($s_recobjname)[s_tmplname]  name="predictModelTmpl"; lineWidth=1.; display wire only a_predictModelTmpl.;  color wire Res(a_*.//DD) & a_*.//c* rgb={0,255,0}
    s_tmplobj = ($s_posetab).Target[i_row]+"_MolTmpl"
    rename a_predictModelTmpl. s_tmplobj
    if (l_saveobj) rename a_$s_tmplobj. Name(s_tmplobj object unique)
    read mol ($s_posetab).mol[i_row] name="predictModelLig"; display xstick a_predictModelLig.
    if (Type($s_posetab.ATOM_CONTRIB)=="parray") then
      if (Nof(($s_posetab.ATOM_CONTRIB)[i_row]) == Nof(a_predictModelLig.H//!h*,vt*)) then
        set field name="ATOM_CONTRIB" a_predictModelLig.H//!h*,vt* ($s_posetab.ATOM_CONTRIB)[i_row]
        display cpk a_predictModelLig.; color cpk a_predictModelLig.H//!h*,vt* Field(a_predictModelLig.H//!h*,vt* "ATOM_CONTRIB")//1.//-1.
        set atom label a_predictModelLig.H//!h*,vt* Tostring(Toreal(Tointeger(Field(a_predictModelLig.H//!h*,vt* "ATOM_CONTRIB")*100.))/100.)
        display atom label a_predictModelLig.H//!h*,vt*; color atom label a_predictModelLig.H//!h*,vt* Field(a_predictModelLig.H//!h*,vt* "ATOM_CONTRIB")//-1//1.
        GRAPHICS.NtoCRainbow = "blue/white/red"
        GRAPHICS.rainbowBarStyle = "left"
        GRAPHICS.rainbowBarLabels = "pKd_low/pKd_high"
      endif
    else
      GRAPHICS.rainbowBarStyle = 4
    endif
    center static a_predictModelLig. margin=2.
    s_ligobj = ($s_posetab).Target[i_row]+"_MolLig"
    rename a_predictModelLig. s_ligobj
    if (l_saveobj) rename a_$s_ligobj. Name(s_ligobj object unique)
  endif
  s_posetablast = s_posetab
  i_rowlast = i_row
  keep s_posetablast i_rowlast
endmacro
#
macro msnnscore s_tab ("") auto
  l_info = l_warn = l_commands = no
  s_tab = Trim(s_tab all)
  if ((s_tab == "") & (Nof(Obj(as_graph))!=1)) return "Please specify either a molscreen output table or object selection as_graph"
  if (s_tab!="") then
    if (Type($s_tab)!="table") return "Please specify a valid table name"
    if (Type($s_tab.mol)!="parray") return "Please specify a valid chemical table name"
    i_mode = 0
    if ((Type($s_tab.MolRecScore)=="rarray") & (Type($s_tab.predictType)=="sarray")) then
      i_mode = 1
    elseif (Type($s_tab.Score)=="rarray") then
      i_mode = 2
    else
      return "Please specify a valid molscreen pairwise output table or a standalone hitlist table"
    endif
    if (i_mode == 1) then
      if (Type($s_tab.MolRecNNScore)!="rarray") add column $s_tab Toreal(Sarray(Nof($s_tab) "ND")) name="MolRecNNScore" format="%.1f" index= Index(Field(Name($s_tab column) 2 ".") "MolRecScore") \
      comment="ICM Docking Neural Network Score,\nScore < -32 are in general significant,\nbut will vary from structure to structure" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,-32.:-20.,pinwheel'"
      s_recobjname = s_tab+".recobj"
      s_tabMolRecNNScore = s_tab+".MolRecNNScore"
    elseif (i_mode == 2) then
      if (Type($s_tab.NNScore)!="rarray") add column $s_tab Toreal(Sarray(Nof($s_tab) "ND")) name="NNScore" format="%.1f" index= Index(Field(Name($s_tab column) 2 ".") "Score") \
      comment="ICM Docking Neural Network Score,\nScore < -32 are in general significant,\nbut will vary from structure to structure" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,-32.:-20.,pinwheel'"
      s_recobjname = s_tab+".RECEPTOR"
      s_tabMolRecNNScore = s_tab+".NNScore"
    endif
    N = Nof($s_tab)
    print bar "Calculating ICM NN Docking score" N l_info = yes
    delete a_tmprecobj. a_tmpligobj. l_warn=no
    for i_row = 1, Nof($s_tab)
      print bar N
      if (i_mode == 1) then
        if (($s_tab).predictType[i_row]!="dpc") continue
        if (($s_tab).MolRecNNScore[i_row]!=0.) continue
        s_recname = ($s_tab).predictType[i_row]+($s_tab).Target[i_row]
        if (Type(($s_recobjname)[s_recname])!="parray") then
          return "Receptor object not embedded in table, please use embed object button in Tools panel to embed object"
        endif
        if ((Nof(Unique(Sort(($s_tab).Target))) > 1)| (Nof(a_tmprecobj.)==0)) then
          delete a_tmprecobj. l_warn=no
          load object ($s_recobjname)[s_recname] name="tmprecobj"
        endif
        if (Nof(a_tmprecobj. stack)>1) load conf a_tmprecobj. ($s_tab).TmplCl[i_row]
      elseif (i_mode == 2) then
        if (($s_tab).NNScore[i_row]!=0.) continue
#        delete a_tmprecobj. l_warn=no
        if (Nof(a_tmprecobj.)==0) load object ($s_recobjname)[1] name="tmprecobj"
        if (Nof(a_tmprecobj. stack )>1) load conf a_tmprecobj. ($s_tab).RecConf[i_row]
      endif
      delete a_tmpligobj. l_warn=no
      read mol ($s_tab).mol[i_row] name="tmpligobj"
      convert3Dto3D a_tmpligobj. yes no yes
      show area surface mute a_tmprecobj.//!C1,C3,C4,C5,vt* a_tmprecobj.//!C1,C3,C4,C5,vt*
      show area surface mute a_tmprecobj.//!h*,vt*  a_tmprecobj.//!h*,vt*
      set field a_tmprecobj.//!C1,C3,C4,C5,vt* name="sac" 0.1*Area( a_tmprecobj.//!C1,C3,C4,C5,vt* )
      set energy nnInterMod a_tmprecobj.
      show area surface mute a_tmpligobj.//!C1,C3,C4,C5,vt* a_tmpligobj.//!C1,C3,C4,C5,vt*
      show area surface mute a_tmpligobj.//!h*,vt*  a_tmpligobj.//!h*,vt*
      set field a_tmpligobj.//!C1,C3,C4,C5,vt* name="sac" 0.1*Area( a_tmpligobj.//!C1,C3,C4,C5,vt* )
      show energy mute "nn"
      $s_tabMolRecNNScore[i_row] = Energy("nn")
      delete a_tmpligobj. l_warn=no
    endfor
    print bar "Ended\n" l_info=yes
    delete a_tmprecobj. l_warn=no
  else
    if (Nof(a_*.H & Obj(as_graph  )) == 0) return "Please specify an object selection with ligand in it"
    copy Obj(as_graph) "tmprecobj"
    moveMol Mol( a_tmprecobj.H//vt1 & ((a_tmprecobj.H)[$]) ) "tmpligobj"
    show area surface mute a_tmprecobj.//!C1,C3,C4,C5,vt* a_tmprecobj.//!C1,C3,C4,C5,vt*
    show area surface mute a_tmprecobj.//!h*,vt*  a_tmprecobj.//!h*,vt*
    set field a_tmprecobj.//!C1,C3,C4,C5,vt* name="sac" 0.1*Area( a_tmprecobj.//!C1,C3,C4,C5,vt* )
    set energy nnInterMod a_tmprecobj.
    show area surface mute a_tmpligobj.//!C1,C3,C4,C5,vt* a_tmpligobj.//!C1,C3,C4,C5,vt*
    show area surface mute a_tmpligobj.//!h*,vt*  a_tmpligobj.//!h*,vt*
    set field a_tmpligobj.//!C1,C3,C4,C5,vt* name="sac" 0.1*Area( a_tmpligobj.//!C1,C3,C4,C5,vt* )
    show energy mute "nn"
    r_out = Energy("nn")
    keep r_out
    print "ICM NN Docking Score: " r_out
    delete a_tmprecobj. a_tmpligobj. l_warn=no
  endif
endmacro
#
macro displayRECCONFlig as_lig (a_H) i_conf (1)
  l_info = l_warn = l_commands = no
  as_lig = a_*.H & Obj(as_lig )
  if (Nof(as_lig)==0) return "No ligand specified"
  if (Field(as_lig "_RECCONF_" ) == Sarray(Nof(as_lig) "")) then
    display wire as_lig
  endif
  undisplay wire as_lig
  display wire Select(as_lig "_RECCONF_~* "+i_conf+" *")
endmacro
#
macro checkPredictionModels S_models
HELP = """
  Check the performance of models using embedded training set data
    <S_models> : string array with model names or model file names,
      if the model directory location is different from $ICMHOME/models/
      append the path to the model array, e.g. {'andr','estro','/home/don/mod/'}

  Example:
    checkPredictionModels 'dfaESR1'//'dfaESR2'
    checkPredictionModels 'dfaANDR'//'dfaESR1'//'/home/don/mymodels/'
    checkPredictionModels '/home/jon/tmp/a.icb'//'./b.icb'//'./c.icb'
"""
 l_info = l_commands = no
 s_moddir = s_icmhome+"models/"
 N = Nof( S_models ); if(N==0) return " Warning>  no models specified"
 if( N>1 & Exist( S_models[$] directory) ) then
   s_moddir = S_models[$]
   S_models = S_models[1:$-1]
 endif
 S_kcccol1 = {"Class_Score","Actives","sens","spec","prec","accu","F1","matt"}
 S_kcccol2 = {"pKd_pred","Actives","sens","spec","prec","accu","F1","matt"}
 S_dpccol1 = {"Class_Score","Actives","sens","spec","prec","accu","F1","matt"}
 S_dpccol2 = {"pKd_pred","Actives","sens","spec","prec","accu","F1","matt"}
 S_dfzcol  = {"Z_Score","Actives","sens","spec","prec","accu","F1","matt"}
 S_dfacol1 = {"pKd_pred","Actives","sens","spec","prec","accu","F1","matt"}
 S_dfacol2 = {"Class_Score","Actives","sens","spec","prec","accu","F1","matt"}
 S_mcpcol  = {"","Actives","sens","spec","prec","accu","F1","matt"}
 for i = 1, Nof(S_models)
   s_mod = S_models[i]
   s_mod1=Trim(Name(s_mod) all)
   l_loaded = no
   if (Type($s_mod1)!="unknown") then
     l_loaded = yes
   elseif (Exist(s_mod)&(Extension(s_mod)==".icb")) then
     read binary s_mod
   elseif (Exist(s_moddir+s_mod1+".icb")) then
     read binary s_moddir+s_mod1+".icb"
   elseif (Exist(s_mod1+".icb")) then
     read binary s_mod1+".icb"
   elseif (Exist(s_icmhome+"models/"+s_mod1+".icb")) then
     read binary s_icmhome+"models/"+s_mod1+".icb"
   else
     S_modelsDir = Split(TOOLS.modelsDir ";")
     for i_modelsDir = 1, Nof(S_modelsDir)
       if (Exist(S_modelsDir[i_modelsDir]+s_mod1+".icb")) then
         read binary S_modelsDir[i_modelsDir]+s_mod1+".icb"
         break
       endif
     endfor
   endif
   s_mod = s_mod1
   if (Type($s_mod)=="unknown") then
     print " Warning> cannot find file " + s_mod
     continue
   endif
   if (s_mod[1:3]=="rca"|s_mod[1:3]=="eca"|s_mod[1:3]=="kcc"|s_mod[1:3]=="dpc") then
     if (Exist($s_mod["PKDext"])&Exist($s_mod["PREDext"])&Exist($s_mod["AUC"])) then
       group table T_tmpmacro Toreal($s_mod["PKDext"]) "pKd" Toreal($s_mod["PREDext"]) "Class_Score"
       add column T_tmpmacro Iarray(Nof(T_tmpmacro) 0) name="Actives"
       T_tmpmacro.Actives[Index(T_tmpmacro.pKd > 5.)] = 1
       if (Type(ROCs)!="unknown") delete ROCs
       calc3Rocs -T_tmpmacro.Class_Score T_tmpmacro.Actives yes "blue"
       add column ROCs -ROCs.Score name="Class_Score" index=1
       sort reverse ROCs.Class_Score
       rename ROCs.correct "Actives"
       s_EF = String(Integer(ROCs.rateTP[Min(index Abs(ROCs.rateFP -1.))]*10.)/10.)
       S_col = Name(ROCs)[1:Nof(Name(ROCs))-1]
       for i_col = 1, Nof(S_col)
         if (Index(S_kcccol1 Field(S_col[i_col] 2 "."))!=0) continue
         s_col = S_col[i_col]
         move $s_col 20
#         set format $s_col show off
       endfor
       delete variable ROCs.plot 3
       delete variable ROCs.plot 2
       s_auc =  String(Integer(Toreal($s_mod["AUC"]*10.))/10.)
       ROCs.plot[1] = "x=rateFP;y=rateTP;color=color;size=3.;shape=circle;series=series;style=connected;depth=5.;;element=polygon;xy=0,0,0,100,100,100;;title=Class Score ROC, AUC:"+s_auc+"%, EF at 1%FP:"+s_EF+";;"
       s_tabname1 = s_mod+"_ROCs"
       if (Type($s_tabname1)!="unknown") delete $s_tabname1
       rename ROCs s_tabname1
       delete T_tmpmacro
       keep $s_tabname1
     else
       if ((s_mod[1:3]!="rca")&(s_mod[1:3]!="eca")) print "Embedded data PKDext, PREDext, and AUC needed for performance check of" s_mod
     endif
     if (Exist($s_mod["PKDext"])&Exist($s_mod["pKdPREDext"])&Exist($s_mod["pKdAUC"])) then
       group table T_tmpmacro Toreal($s_mod["PKDext"]) "pKd" Toreal($s_mod["pKdPREDext"]) "pKd_pred"
       add column T_tmpmacro Iarray(Nof(T_tmpmacro) 0) name="Actives"
       T_tmpmacro.Actives[Index(T_tmpmacro.pKd > 5.)] = 1
       if (Type(ROCs)!="unknown") delete ROCs
       calc3Rocs -T_tmpmacro.pKd_pred T_tmpmacro.Actives yes "blue"
       add column ROCs -ROCs.Score name="pKd_pred" index=1
       sort reverse ROCs.pKd_pred
       rename ROCs.correct "Actives"
       s_EF = String(Integer(ROCs.rateTP[Min(index Abs(ROCs.rateFP -1.))]*10.)/10.)
       S_col = Name(ROCs)[1:Nof(Name(ROCs))-1]
       for i_col = 1, Nof(S_col)
         if (Index(S_kcccol2 Field(S_col[i_col] 2 "."))!=0) continue
         s_col = S_col[i_col]
         move $s_col 20
#         set format $s_col show off
       endfor
       delete variable ROCs.plot 3
       delete variable ROCs.plot 2
       s_auc =  String(Integer(Toreal($s_mod["pKdAUC"]*10.))/10.)
       ROCs.plot[1] = "x=rateFP;y=rateTP;color=color;size=3.;shape=circle;series=series;style=connected;depth=5.;;element=polygon;xy=0,0,0,100,100,100;;title=pKd pred ROC, AUC:"+s_auc+"%, EF at 1%FP:"+s_EF+";;"
       if (s_mod[1:3]=="kcc") then
         s_tabname2 = Replace(s_mod "kcc" "kca")+"_ROCs"
       elseif (s_mod[1:3]=="dpc") then
         s_tabname2 = Replace(s_mod "dpc" "dpa")+"_ROCs"
       elseif (s_mod[1:3]=="rca") then
         s_tabname2 = Replace(s_mod "rca" "rca")+"_ROCs"
       elseif (s_mod[1:3]=="eca") then
         s_tabname2 = Replace(s_mod "eca" "eca")+"_ROCs"
       endif
       if (Type($s_tabname2)!="unknown") delete $s_tabname2
       rename ROCs s_tabname2
       delete T_tmpmacro
       keep $s_tabname2
     else
       print "Embedded data PKDext, pKdPREDext, and pKdAUC needed for performance check of" s_mod
     endif
     if (Exist($s_mod["PKDext"])&Exist($s_mod["pKdPREDext"])&Exist($s_mod["Q2"])) then
       s_tabname3 = s_mod+"_Q2"
       if (Type($s_tabname3)!="unknown") delete $s_tabname3
       group table s_tabname3 Toreal($s_mod["PKDext"]) "pKd" Toreal($s_mod["pKdPREDext"]) "Prediction"
       if (Exist($s_mod["RMSE"])) then
         s_rmse = String(Integer(Toreal($s_mod["RMSE"])*100)/100.)
         make plot $s_tabname3 "x=pKd;y=Prediction;size=6.;regression=linear;depth=5.;;title=External Test Set pKd Prediction, RMSE:"+s_rmse+";;"
       else
         s_q2 = String(Integer(Toreal($s_mod["Q2"])*100)/100.)
         make plot $s_tabname3 "x=pKd;y=Prediction;size=6.;regression=linear;depth=5.;;title=External Test Set pKd Prediction, Q2:"+s_q2+";;"
       endif
       keep $s_tabname3
     else
       print "Embedded data PKDext, pKdPREDext, and Q2 needed for performance check of" s_mod
     endif
   endif
   if (s_mod[1:3]=="dfz") then
     if (Exist($s_mod["TRAIN"])&Exist($s_mod["PRED"])&Exist($s_mod["AUC"])) then
       group table T_tmpmacro Toreal($s_mod["PRED"]) "Z_Score" Tointeger($s_mod["TRAIN"]) "Actives"
       if (Type(ROCs)!="unknown") delete ROCs
       calc3Rocs -T_tmpmacro.Z_Score T_tmpmacro.Actives yes "blue"
       add column ROCs -ROCs.Score name="Z_Score" index=1
       sort reverse ROCs.Z_Score
       rename ROCs.correct "Actives"
       s_EF = String(Integer(ROCs.rateTP[Min(index Abs(ROCs.rateFP -1.))]*10.)/10.)
       for i_col = 1, Nof(Name(ROCs))-1
         if (Index(S_dfzcol Field(Name(ROCs)[i_col] 2 "."))!=0) continue
         s_col = Name(ROCs)[i_col]
         move $s_col 20
#         set format $s_col show off
       endfor
       delete variable ROCs.plot 3
       delete variable ROCs.plot 2
       s_auc = String(Integer(Toreal($s_mod["AUC"]*10.))/10.)
       ROCs.plot[1] = "x=rateFP;y=rateTP;color=color;size=3.;shape=circle;series=series;style=connected;depth=5.;;element=polygon;xy=0,0,0,100,100,100;;title=Z-Score ROC, AUC:"+s_auc+"%, EF at 1%FP:"+s_EF+";;"
       s_tabname = s_mod+"_ROCs"
       if (Type($s_tabname)!="unknown") delete $s_tabname
       rename ROCs s_tabname
       delete T_tmpmacro
       keep $s_tabname
     else
       print "Embedded data TRAIN, PRED, and AUC needed for performance check of" s_mod
     endif
   endif
   if (s_mod[1:3]=="dfa") then
    if (Exist($s_mod["PKDext"])) then
     if (Exist($s_mod["PKDext"])&Exist($s_mod["PREDext"])&Exist($s_mod["AUC"])) then
       group table T_tmpmacro Toreal($s_mod["PKDext"]) "pKd" Toreal($s_mod["PREDext"]) "pKd_pred"
       if Exist($s_mod["ACTIVESext"]) then
         add column T_tmpmacro Tointeger($s_mod["ACTIVESext"]) name="Actives"
       else
         add column T_tmpmacro Iarray(Nof(T_tmpmacro) 0) name="Actives"
         T_tmpmacro.Actives[Index(T_tmpmacro.pKd > 5.)] = 1
       endif
       if (Type(ROCs)!="unknown") delete ROCs
       calc3Rocs -T_tmpmacro.pKd_pred T_tmpmacro.Actives yes "blue"
       add column ROCs -ROCs.Score name="pKd_pred" index=1
       sort reverse ROCs.pKd_pred
       rename ROCs.correct "Actives"
       s_EF = String(Integer(ROCs.rateTP[Min(index Abs(ROCs.rateFP -1.))]*10.)/10.)
       S_col = Name(ROCs)[1:Nof(Name(ROCs))-1]
       for i_col = 1, Nof(S_col)
         if (Index(S_dfacol1 Field(S_col[i_col] 2 "."))!=0) continue
         s_col = S_col[i_col]
         move $s_col 20
#         set format $s_col show off
       endfor
       delete variable ROCs.plot 3
       delete variable ROCs.plot 2
       s_auc =  String(Integer(Toreal($s_mod["AUC"]*10.))/10.)
       ROCs.plot[1] = "x=rateFP;y=rateTP;color=color;size=3.;shape=circle;series=series;style=connected;depth=5.;;element=polygon;xy=0,0,0,100,100,100;;title=pKd pred ROC, AUC:"+s_auc+"%, EF at 1%FP:"+s_EF+";;"
       s_tabname1 = s_mod+"_ROCs"
       if (Type($s_tabname1)!="unknown") delete $s_tabname1
       rename ROCs s_tabname1
       delete T_tmpmacro
       keep $s_tabname1
     else
#       print "Embedded data PKDext, PREDext, and AUC needed for performance check of" s_mod
     endif
     if (Exist($s_mod["PKDext"])&Exist($s_mod["ClassPREDext"])&Exist($s_mod["ClassAUC"])) then
       group table T_tmpmacro Toreal($s_mod["PKDext"]) "pKd" Toreal($s_mod["ClassPREDext"]) "Class_Score"
       if Exist($s_mod["ACTIVESext"]) then
         add column T_tmpmacro Tointeger($s_mod["ACTIVESext"]) name="Actives"
       else
         add column T_tmpmacro Iarray(Nof(T_tmpmacro) 0) name="Actives"
         T_tmpmacro.Actives[Index(T_tmpmacro.pKd > 5.)] = 1
       endif
       if (Type(ROCs)!="unknown") delete ROCs
       calc3Rocs -T_tmpmacro.Class_Score T_tmpmacro.Actives yes "blue"
       add column ROCs -ROCs.Score name="Class_Score" index=1
       sort reverse ROCs.Class_Score
       rename ROCs.correct "Actives"
       s_EF = String(Integer(ROCs.rateTP[Min(index Abs(ROCs.rateFP -1.))]*10.)/10.)
       S_col = Name(ROCs)[1:Nof(Name(ROCs))-1]
       for i_col = 1, Nof(S_col)
         if (Index(S_dfacol2 Field(S_col[i_col] 2 "."))!=0) continue
         s_col = S_col[i_col]
         move $s_col 20
#         set format $s_col show off
       endfor
       delete variable ROCs.plot 3
       delete variable ROCs.plot 2
       s_auc =  String(Integer(Toreal($s_mod["ClassAUC"]*10.))/10.)
       ROCs.plot[1] = "x=rateFP;y=rateTP;color=color;size=3.;shape=circle;series=series;style=connected;depth=5.;;element=polygon;xy=0,0,0,100,100,100;;title=Class Score ROC, AUC:"+s_auc+"%, EF at 1%FP:"+s_EF+";;"
       s_tabname2 = Replace(s_mod "dfa" "dfc")+"_ROCs"
       if (Type($s_tabname2)!="unknown") delete $s_tabname2
       rename ROCs s_tabname2
       delete T_tmpmacro
       keep $s_tabname2
     else
#       print "Embedded data PKDext, ClassPREDext, and ClassAUC needed for performance check of" s_mod
     endif
     if (Exist($s_mod["PKDext"])&Exist($s_mod["PREDext"])&Exist($s_mod["Q2"])) then
       s_tabname3 = s_mod+"_Q2"
       if (Type($s_tabname3)!="unknown") delete $s_tabname3
       group table s_tabname3 Toreal($s_mod["PKDext"]) "pKd" Toreal($s_mod["PREDext"]) "Prediction"
       s_q2 = String(Integer(Toreal($s_mod["Q2"])*100)/100.)
       make plot $s_tabname3 "x=pKd;y=Prediction;size=6.;regression=linear;depth=5.;;title=External Test Set pKd Prediction, Q2:"+s_q2+";;"
       keep $s_tabname3
     else
#       print "Embedded data PKDext, PREDext, and Q2 needed for performance check of" s_mod
     endif
    endif
    if (Exist($s_mod["TRAIN"])&Exist($s_mod["PRED"])&Exist($s_mod["AUC"])&Exist($s_mod["PKD"])&Exist($s_mod["R2pkd"])) then
       s_tabname1 = s_mod+"_R2"
       if (Type($s_tabname1)!="unknown") delete $s_tabname1
       group table T_tmpmacro Toreal($s_mod["PKD"]) "pKd" Toreal($s_mod["PRED"]) "Prediction" Tointeger($s_mod["TRAIN"]) "TrainingSet"
       T_tmpmacro = T_tmpmacro.pKd != Toreal("ND")
       T_tmpmacro.Prediction[Index(T_tmpmacro.Prediction==3.)] = Toreal("ND")
       r_r2 = Toreal($s_mod["R2pkd"])
       s_r2 = String(Integer(r_r2*100)/100.)
       make plot T_tmpmacro "x=pKd;y=Prediction;size=6.;regression=linear;depth=5.;;title=Combined R2+Q2:"+s_r2+";;"
       rename T_tmpmacro s_tabname1
       keep $s_tabname1

       group table T_tmpmacro Toreal($s_mod["PKD"]) "pKd" Toreal($s_mod["PRED"]) "pKd_pred" Tointeger($s_mod["TRAIN"]) "TrainingSet"
       T_tmpmacro = T_tmpmacro.pKd >=7. | T_tmpmacro.TrainingSet ==0
       T_tmpmacro.pKd_pred[Index(T_tmpmacro.pKd_pred==3.)] = Toreal("ND")
       T_tmpmacro.TrainingSet[Index(T_tmpmacro.pKd>=7.)] = 1
       rename T_tmpmacro.TrainingSet "Actives"
       if (Type(ROCs)!="unknown") delete ROCs
       calc3Rocs -T_tmpmacro.pKd_pred T_tmpmacro.Actives yes "blue"
       add column ROCs -ROCs.Score name="pKd_pred" index=1
       sort reverse ROCs.pKd_pred
       rename ROCs.correct "Actives"
       s_EF = String(Integer(ROCs.rateTP[Min(index Abs(ROCs.rateFP -1.))]*10.)/10.)
       for i_col = 1, Nof(Name(ROCs))-1
         if (Index(S_dfacol1 Field(Name(ROCs)[i_col] 2 "."))!=0) continue
         s_col = Name(ROCs)[i_col]
         move $s_col 20
#         set format $s_col show off
       endfor
       delete variable ROCs.plot 3
       delete variable ROCs.plot 2
       s_auc = String(Integer(Toreal($s_mod["AUC"])))
       ROCs.plot[1] = "x=rateFP;y=rateTP;color=color;size=3.;shape=circle;series=series;style=connected;depth=5.;;element=polygon;xy=0,0,0,100,100,100;;title=pKd pred ROC, AUC:"+s_auc+"%, EF at 1%FP:"+s_EF+";;"
       s_tabname2 = s_mod+"_ROCs"
       if (Type($s_tabname2)!="unknown") delete $s_tabname2
       rename ROCs s_tabname2
       delete T_tmpmacro
       keep $s_tabname2
    else
#       print "Embedded data TRAIN, PKD, PRED, AUC, and R2pkd needed for performance check of" s_mod
    endif
   endif
   if ((s_mod[1:3]=="mcp")& (!Exist($s_mod "modeltype"))) then
     if ($s_mod["PREDCOL"]==Toreal("ND")) then
       print "Embedded data needed for performance check of" s_mod
       continue
     endif
     s_PREDCOL = $s_mod["PREDCOL"]
     s_PREDCOLext = s_PREDCOL+"ext"
     s_PREDCOLPREDext = s_PREDCOL+"PREDext"
    if (Exist($s_mod["AUC"])) then
     if (Exist($s_mod[s_PREDCOLext])&Exist($s_mod[s_PREDCOLPREDext])&Exist($s_mod["AUC"])) then
       group table T_tmpmacro Tointeger($s_mod[s_PREDCOLext]) s_PREDCOLext Toreal($s_mod[s_PREDCOLPREDext]) s_PREDCOLPREDext
       if (Type(ROCs)!="unknown") delete ROCs
       calc3Rocs -T_tmpmacro.$s_PREDCOLPREDext T_tmpmacro.$s_PREDCOLext yes "blue"
       add column ROCs -ROCs.Score name=s_PREDCOL index=1
       sort reverse ROCs.$s_PREDCOL
       rename ROCs.correct "Actives"
       s_EF = String(Integer(ROCs.rateTP[Min(index Abs(ROCs.rateFP -1.))]*10.)/10.)
       S_mcpcol[1] = s_PREDCOL
       S_col = Name(ROCs)[1:Nof(Name(ROCs))-1]
       for i_col = 1, Nof(S_col)
         if (Index(S_mcpcol Field(S_col[i_col] 2 "."))!=0) continue
         s_col = S_col[i_col]
         move $s_col 20
#         set format $s_col show off
       endfor
       delete variable ROCs.plot 3
       delete variable ROCs.plot 2
       s_auc =  String(Integer(Toreal($s_mod["AUC"]*10.))/10.)
       ROCs.plot[1] = "x=rateFP;y=rateTP;color=color;size=3.;shape=circle;series=series;style=connected;depth=5.;;element=polygon;xy=0,0,0,100,100,100;;title="+s_PREDCOL+" ROC, AUC:"+s_auc+"%, EF at 1%FP:"+s_EF+";;"
       s_tabname1 = s_mod+"_ROCs"
       if (Type($s_tabname1)!="unknown") delete $s_tabname1
       rename ROCs s_tabname1
       delete T_tmpmacro
       keep $s_tabname1
     else
       print "Embedded data PKDext, PREDext, and AUC needed for performance check of" s_mod
     endif
    endif
    if (Exist($s_mod["Q2"])) then
     if (Exist($s_mod[s_PREDCOLext])&Exist($s_mod[s_PREDCOLPREDext])&Exist($s_mod["Q2"])) then
       s_tabname3 = s_mod+"_Q2"
       if (Type($s_tabname3)!="unknown") delete $s_tabname3
       group table s_tabname3 Toreal($s_mod[s_PREDCOLext]) s_PREDCOL Toreal($s_mod[s_PREDCOLPREDext]) "Prediction"
       if (Exist($s_mod["RMSE"])) then
         s_rmse = String(Integer(Toreal($s_mod["RMSE"])*100)/100.)
         make plot $s_tabname3 "x="+s_PREDCOL+";y=Prediction;size=6.;regression=linear;depth=5.;;title=External Test Set "+s_PREDCOL+" Prediction, RMSE:"+s_rmse+";;"
       else
         s_q2 = String(Integer(Toreal($s_mod["Q2"])*100)/100.)
         make plot $s_tabname3 "x="+s_PREDCOL+";y=Prediction;size=6.;regression=linear;depth=5.;;title=External Test Set "+s_PREDCOL+" Prediction, Q2:"+s_q2+";;"
       endif
       keep $s_tabname3
     else
       print "Embedded data:"s_PREDCOLext+"," s_PREDCOLPREDext+", and Q2 needed for performance check of" s_mod
     endif
    endif
   endif
   if ((s_mod[1:3]=="ncc")|($s_mod["modeltype"]=="ncc")) then
     if (Type($s_mod ["TABLE"])=="collection") then
       T_tmpmacro = Table($s_mod["TABLE"])
       if (Type($s_mod ["TABLEformat"])=="collection") set format T_tmpmacro $s_mod ["TABLEformat"]
       if (Type($s_mod["TABLEorder"])=="sarray") then
         for i_col = 1, Nof($s_mod["TABLEorder"])
           s_col = "T_tmpmacro."+$s_mod["TABLEorder"][i_col]
           move $s_col Nof($s_mod["TABLEorder"])
         endfor
       endif
       if (Type(T_tmpmacro.Used)=="iarray") T_tmpmacro = T_tmpmacro.Used != 0
       s_tabname1 = s_mod+"_Targets"
       delete $s_tabname1 l_warn=no
       rename T_tmpmacro s_tabname1
       keep $s_tabname1
     else
       print "Embedded table: TABLE needed for performance check of" s_mod
     endif
   endif
   if ($s_mod["doc"] != Toreal("ND" )) then
     if (Type($s_mod["doc"])=="string") then
       s_htmlname = s_mod+"_doc"
       if (Type($s_htmlname)!="unknown") delete $s_htmlname
       makeNewHtml s_htmlname yes $s_mod["doc"]
       keep $s_htmlname
     endif
   elseif (s_mod[1:3]=="kcc") then
     s_htmlname = "kcc_doc"
   elseif (s_mod[1:3]=="dfa") then
     s_htmlname = "dfa_doc"
   elseif (s_mod[1:3]=="dfz") then
     s_htmlname = "dfz_doc"
   elseif (s_mod[1:3]=="dpc") then
     s_htmlname = "dpc_doc"
   elseif (s_mod[1:3]=="rca") then
     s_htmlname = "rca_doc"
   elseif (s_mod[1:3]=="eca") then
     s_htmlname = "eca_doc"
   endif
   if (Type($s_htmlname)=="unknown") then
     if (Exist(s_icmhome+"models/"+s_htmlname)) then
       read string s_icmhome+"models/"+s_htmlname name="s_tmp"
       makeNewHtml s_htmlname yes s_tmp
       keep $s_htmlname
     endif
   endif
   if (!l_loaded) delete $s_mod
 endfor
endmacro
#
macro msunpackModels S_models s_modelsDir ("") auto
HELP = """
  Generate a header table of models containing embedded training set/test set data/objects
    <S_models> : string array with model names or model file names,
      if the model directory location is different from $ICMHOME/models/
      append the path to the model array, e.g. {'andr','estro','/home/don/mod/'}

  Example:
    msunpackModels 'dfaESR1'//'dfaESR2'
    msunpackModels 'dfaANDR'//'dfaESR1'//'/home/don/mymodels/'
    msunpackModels '/home/jon/tmp/a.icb'//'./b.icb'//'./c.icb'
"""
  l_info = l_commands = l_warn = no
  s_moddir = s_modelsDir == "" ? s_icmhome+"models/" : s_modelsDir
  N = Nof( S_models ); if(N==0) return " Warning>  no models specified"
  if( N>1 & Exist( S_models[$] directory) ) then
    if (S_models[$][1:3] !~ "[dekmr][cfp][acpz]") then
      s_moddir = S_models[$]
      S_models = S_models[1:$-1]
    endif
  endif
  S_field = {"TYPE","Category","GO_Cellular","GO_Function","GO_Process","Species","Tissue","ADR","Disease","Drug_Mechanism","tag","ChEMBLversion","ICMversion","version"}
  for i_model = 1, Nof(S_models)
    s_mod = S_models[i_model]
    s_mod1= Trim(Name(s_mod) all)
    l_loaded = no
    if (Type($s_mod1)!="unknown") then
      l_loaded = yes
    elseif ((Exist(s_mod))&(Extension(s_mod)==".icb")) then
      read binary s_mod
    elseif (Exist(s_moddir+Name(s_mod)+".icb")) then
      read binary s_moddir+Name(s_mod)+".icb"
    elseif (Exist(Name(s_mod)+".icb")) then
      read binary Name(s_mod)+".icb"
    elseif (Exist(s_icmhome+"models/"+Name(s_mod)+".icb")) then
      read binary s_icmhome+"models/"+Name(s_mod)+".icb"
    else
      S_modelsDir = Split(TOOLS.modelsDir ";")
      for i_modelsDir = 1, Nof(S_modelsDir)
        if (Exist(S_modelsDir[i_modelsDir]+Name(s_mod)+".icb")) then
          read binary S_modelsDir[i_modelsDir]+Name(s_mod)+".icb"
          break
        endif
      endfor
    endif
    s_mod = s_mod1
    if (Type($s_mod)=="unknown") then
      print " Warning> cannot find file " + s_mod
      continue
    endif
    if (Type($s_mod )!="parray") then
      print " Warning> "+s_mod+" is not a model file"
      delete $s_mod
      continue
    endif
    if (s_mod[1:3]=="kcc"|s_mod[1:3]=="mcp") then
      if ($s_mod["version"]==Toreal("ND")) then
        print " Warning> "+s_mod+" is incompatible with the latest ICM, please download the latest model and/or remake model"
        delete $s_mod
        continue
      endif
    endif
    s_tab = s_mod+"_header"
  if ((s_mod[1:3] == "ncc")|($s_mod["modeltype"]=="ncc")) then
    if (Type($s_mod ["TABLE"])=="collection") then
      T_tabmacro = Table($s_mod["TABLE"])
      if (Type($s_mod ["TABLEformat"])=="collection") set format T_tabmacro $s_mod ["TABLEformat"]
      if (Type($s_mod["TABLEorder"])=="sarray") then
        for i_col = 1, Nof($s_mod["TABLEorder"])
          s_col = "T_tabmacro."+$s_mod["TABLEorder"][i_col]
          move $s_col Nof($s_mod["TABLEorder"])
        endfor
      endif
      T_tabmacro = T_tabmacro.Used != 0
      add header T_tabmacro $s_mod["model"] name="model"
      add header T_tabmacro $s_mod["S_targetlist"] name="S_targetlist"
      add header T_tabmacro $s_mod["S_Fullname"] name="S_Fullname"
      add header T_tabmacro $s_mod["I_used"] name="I_used"
      add header T_tabmacro $s_mod["SMILES"] name="SMILES"
      add header T_tabmacro $s_mod["SMILESext"] name="SMILESext"
      M_PREDext = $s_mod["M_PREDext"]
      if (Exist($s_mod "R_midpoint")) then
        add header T_tabmacro $s_mod["M_CLASSext"] name="M_CLASSext"
        R_midpoint = Toreal($s_mod["R_midpoint"])
        R_pPvalueA = Toreal($s_mod["R_pPvalueA"])
        R_pPvalueB = Toreal($s_mod["R_pPvalueB"])
        R_pPvalueC = Toreal($s_mod["R_pPvalueC"])
        R_posmean = Toreal($s_mod["R_posmean"])
        R_posrmsd = Toreal($s_mod["R_posrmsd"])
        R_negmean = Toreal($s_mod["R_negmean"])
        R_negrmsd = Toreal($s_mod["R_negrmsd"])
        R_NSA_train = Trim(Toreal($s_mod["R_NSA_train"])/100. 0.01 1.)
        r_posprior = Toreal($s_mod["r_posprior"])
      endif
      i_nofext = Nof($s_mod["SMILESext"])
      i_noftarget = Nof($s_mod["S_targetlist"])
      T_tabmacro = T_tabmacro.Used != 0

      if (Exist($s_mod "R_pPvalueA")) then
        M_pPvalueext = Matrix(i_nofext i_noftarget)
        for i_cpd = 1, i_nofext
          R_tmp = M_PREDext[i_cpd]/R_midpoint
          M_pPvalueext[i_cpd,?] = -Log((100.-Trim(R_pPvalueC+(100.-R_pPvalueC)*(1./(1.+Exp(-R_pPvalueA*( R_tmp - R_pPvalueB)))) 0. 99.99999999))/100. 10.)
        endfor

        M_Probext = Matrix(i_nofext i_noftarget)
        for i_cpd = 1, i_nofext
          R_postmp = (M_PREDext[i_cpd]-R_posmean )/R_posrmsd
          R_negtmp = (M_PREDext[i_cpd]-R_negmean )/R_negrmsd
          R_posabs = Max(Abs(R_postmp) Rarray(Nof(R_postmp) 0.000001))
          R_negabs = Max(Abs(R_negtmp) Rarray(Nof(R_negtmp) 0.000001))
          R_possign = Sign(R_postmp)
          R_negsign = Sign(R_negtmp)
          R_postmp = 0.5+0.5*R_possign-R_possign*((1.-Exp(-1.422*R_posabs))*Exp(-Power(R_posabs 2)/2.))/1.135/Sqrt(2.*Pi())/R_posabs
          R_negtmp = 0.5+0.5*R_negsign-R_negsign*((1.-Exp(-1.422*R_negabs))*Exp(-Power(R_negabs 2)/2.))/1.135/Sqrt(2.*Pi())/R_negabs
#        M_Probext[i_cpd,?] = (r_posprior * R_postmp)/((r_posprior * R_postmp)+(1.-r_posprior)*(1.-R_negtmp))
#        M_Probext[i_cpd,?] = (r_posprior*R_postmp*R_NSA_train)/((r_posprior*R_postmp*R_NSA_train)+(1.-r_posprior)*(1.-R_negtmp))

          R_postmp = 1.-R_postmp
          R_negtmp = 1.-R_negtmp
          R_postmp = Max(Abs(R_postmp) Rarray(Nof(R_postmp) 0.000001))
#        M_Probext[i_cpd,?] = (r_posprior*R_postmp*R_NSA_train)/((r_posprior*R_postmp*R_NSA_train)+(1.-r_posprior*R_NSA_train)*(1.-R_negtmp))
          M_Probext[i_cpd,?] = (r_posprior*R_postmp)/((r_posprior*R_postmp)+(1.-r_posprior)*(R_negtmp))

#        M_Probext[i_cpd,?] = (r_posprior*R_negtmp*R_NSA_train)/((r_posprior*R_negtmp*R_NSA_train)+(1.-r_posprior*R_NSA_train)*(1.-R_postmp))
        endfor

        add header T_tabmacro M_pPvalueext name="M_pPvalueext"
        add header T_tabmacro M_Probext name="M_Probext"
        if Exist($s_mod["M_PKDext"]) add header T_tabmacro $s_mod["M_PKDext"] name="M_PKDext"
        if Exist($s_mod["M_PKDPREDext"]) add header T_tabmacro $s_mod["M_PKDPREDext"] name="M_PKDPREDext"
      endif
      if Exist($s_mod "PREDCOL") then
        s_DATAext = "M_"+$s_mod["PREDCOL"]+"ext"
        add header T_tabmacro $s_mod[s_DATAext] name="M_DATAext"
        add header T_tabmacro $s_mod["M_PREDext"] name="M_PREDext"
        add header T_tabmacro $s_mod["PREDCOL"] name="PREDCOL"
        add header T_tabmacro $s_mod["COMMENT"] name="COMMENT"
        add header T_tabmacro $s_mod["COLOR"] name="COLOR"
      endif
      group table T_tabmacro2 T_tabmacro.SMILES "smiles"
      print " Info> You can right-click on the Training table smiles column -> view Smiles as 2D"
#      add column T_tabmacro2 Chemical(T_tabmacro2.smiles smiles) name="mol" index=1
      s_tab2 = s_mod+"_Train"
      delete $s_tab2 l_warn=no
      rename T_tabmacro2 s_tab2
      keep $s_tab2
      add header T_tabmacro String("") name="doubleClick" append
      if (Type(T_tabmacro.Target)!="unknown") then
        T_tabmacro.doubleClick = "s_currTab=Name(%@ table); msunpackModelsncc s_currTab ($s_currTab).Target[%#]"
      elseif (Type(T_tabmacro.Uniprot)!="unknown") then
        T_tabmacro.doubleClick = "s_currTab=Name(%@ table); msunpackModelsncc s_currTab ($s_currTab).Uniprot[%#]"
      endif
      add header T_tabmacro String("") name="toolsPanel" append
      T_tabmacro.toolsPanel = "# txt_Hint (Doubleclick on any row to load external test set)"
      set property T_tabmacro header
      print " Info> Please doubleclick on any row of header table to load the external test set of that target"
    else
      print " Info> Embedded table: TABLE needed for performance check of" s_mod
    endif
  else
    group table T_tabmacro {"Model Name", "NAME"} "Field" s_mod//$s_mod["NAME"] "Value"
    add column T_tabmacro Sarray(Nof(T_tabmacro ) "") name="Remarks"
    add column T_tabmacro Sarray(Nof(T_tabmacro ) "string") name="FieldType"
    add column T_tabmacro Sarray(Nof(T_tabmacro ) "") name="Action"
    add header T_tabmacro String("") name="doubleClick" append
    T_tabmacro.doubleClick = "s_currTab=Name(%@ table);call string ($s_currTab).Action[%#]"
    for i_field = 1, Nof(S_field)
      s_field = S_field[i_field]
      if Exist($s_mod s_field) then
        add T_tabmacro
        T_tabmacro.Field[$] = s_field
        T_tabmacro.Value[$] = Tostring($s_mod[s_field])
        T_tabmacro.FieldType[$] = Type($s_mod[s_field])
      endif
    endfor
    i_counter = 4
    if ((s_mod[1:3]=="mcp")&Exist($s_mod "PREDCOL")) then
      s_PREDCOL = $s_mod["PREDCOL"]
      s_PREDCOLPRED = s_PREDCOL+"PRED"
      s_PREDCOLext = s_PREDCOL+"ext"
      s_PREDCOLPREDext = s_PREDCOL+"PREDext"
      if Exist($s_mod "AUC") then
        add T_tabmacro
        T_tabmacro.Field[$] = "AUC External Test Set"
        T_tabmacro.Value[$] =  Tostring(Tointeger(Toreal($s_mod["AUC"])*100.)/100.)
        T_tabmacro.Remarks[$] = "Area under ROC curve using predicted "+$s_mod["PREDCOL"]+" to differentiate positives from negatives"
        T_tabmacro.FieldType[$] = "real"
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
      endif
      if Exist($s_mod "NSA") then
        add T_tabmacro
        T_tabmacro.Field[$] = "NSA External Test Set"
        T_tabmacro.Value[$] =  Tostring(Tointeger(Toreal($s_mod["NSA"])*100.)/100.)
        T_tabmacro.Remarks[$] = "Normalized Squareroot Area under ROC curve using predicted "+$s_mod["PREDCOL"]+" to differentiate positives from negatives"
        T_tabmacro.FieldType[$] = "real"
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
      endif
       if Exist($s_mod "RMSE") then
        add T_tabmacro
        T_tabmacro.Field[$] = "RMSE External Test Set"
        T_tabmacro.Value[$] =  Tostring(Tointeger(Toreal($s_mod["RMSE"])*100.)/100.)
        T_tabmacro.Remarks[$] = "RMSE of predicted "+ $s_mod["PREDCOL"] +" of external test set, better measurement of uncertainty than Q2"
        T_tabmacro.FieldType[$] = "real"
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
      endif
      if Exist($s_mod "Q2") then
        add T_tabmacro
        T_tabmacro.Field[$] = "Q2 External Test Set"
        T_tabmacro.Value[$] =  Tostring(Tointeger(Toreal($s_mod["Q2"])*100.)/100.)
        T_tabmacro.Remarks[$] = "Q2 of predicted "+ $s_mod["PREDCOL"] + " of external test set, unstable if only a few external test set compounds"
        T_tabmacro.FieldType[$] = "real"
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
      endif
      if Exist($s_mod s_PREDCOL) then
        if Exist($s_mod "MOL") then
          group table T_intmacro $s_mod["MOL"] "mol" Toreal($s_mod[s_PREDCOL]) s_PREDCOL
        elseif Exist($s_mod "SMILES") then
          group table T_intmacro Chemical($s_mod["SMILES"]) "mol" Toreal($s_mod[s_PREDCOL]) s_PREDCOL
        endif
        if Exist($s_mod s_PREDCOLPRED) add column T_intmacro Toreal($s_mod[s_PREDCOLPRED]) name=s_PREDCOLPRED
        if (Exist($s_mod "COLOR")&Exist($s_mod "COMMENT")) then
          if (Type(T_intmacro.$s_PREDCOL)!="unknown") set format T_intmacro.$s_PREDCOL "%.2f" name="" color=$s_mod["COLOR"] comment=$s_mod["COMMENT"]
          if (Type(T_intmacro.$s_PREDCOLPRED)!="unknown") set format T_intmacro.$s_PREDCOLPRED "%.2f" name="" color=$s_mod["COLOR"] comment=$s_mod["COMMENT"]
        endif
        add header T_tabmacro Collection(T_intmacro column ) name="T_intmacro"
        add header T_tabmacro Collection(T_intmacro format ) name="s_intmacro"
        add T_tabmacro
        T_tabmacro.Field[$] = "Training Set Compounds"
        T_tabmacro.Value[$] = Tostring($s_mod["NOF_LIG"])
        T_tabmacro.Remarks[$] = "DoubleClick: Load Training Set table"
        T_tabmacro.FieldType[$] = "Embedded Table"
        if Exist($s_mod "AUC") then
          T_tabmacro.Action[$] = "s_loadtab=\""+s_mod+"_train"+"\";$s_loadtab=Table(($s_currTab).T_intmacro);set format $s_loadtab ($s_currTab).s_intmacro;make plot $s_loadtab \"x={"+s_PREDCOLPRED+":"+s_PREDCOL+"};pinwheel=blue;depth=4.;;\""
        else
          T_tabmacro.Action[$] = "s_loadtab=\""+s_mod+"_train"+"\";$s_loadtab=Table(($s_currTab).T_intmacro);set format $s_loadtab ($s_currTab).s_intmacro;make plot $s_loadtab \"x="+s_PREDCOL+";y="+s_PREDCOLPRED+";size=6.;regression=linear;depth=5.;;\""
        endif
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
        delete T_intmacro
      endif
      if Exist($s_mod s_PREDCOLext) then
        if Exist($s_mod "MOLext") then
          group table T_extmacro $s_mod["MOLext"] "mol" Toreal($s_mod[s_PREDCOLext]) s_PREDCOLext
        elseif Exist($s_mod "SMILESext") then
          group table T_extmacro Chemical($s_mod["SMILESext"]) "mol" Toreal($s_mod[s_PREDCOLext]) s_PREDCOLext
        endif
        if Exist($s_mod s_PREDCOLPREDext) add column T_extmacro Toreal($s_mod[s_PREDCOLPREDext]) name=s_PREDCOLPREDext
        if (Exist($s_mod "COLOR")&Exist($s_mod "COMMENT")) then
          if (Type(T_extmacro.$s_PREDCOLext)!="unknown") set format T_extmacro.$s_PREDCOLext "%.2f" name="" color=$s_mod["COLOR"] comment=$s_mod["COMMENT"]
          if (Type(T_extmacro.$s_PREDCOLPREDext)!="unknown") set format T_extmacro.$s_PREDCOLPREDext "%.2f" name="" color=$s_mod["COLOR"] comment=$s_mod["COMMENT"]
        endif
        add header T_tabmacro Collection(T_extmacro column ) name="T_extmacro"
        add header T_tabmacro Collection(T_extmacro format ) name="s_extmacro"
        add T_tabmacro
        T_tabmacro.Field[$] = "External Test Set Compounds"
        T_tabmacro.Value[$] = Tostring(Nof(T_extmacro.$s_PREDCOLext!=Toreal("ND")))
        T_tabmacro.Remarks[$] = "DoubleClick: Load External Test Set table"
        T_tabmacro.FieldType[$] = "Embedded Table"
        if Exist($s_mod "AUC") then
          T_tabmacro.Action[$] = "s_loadtab=\""+s_mod+"_exttest"+"\";$s_loadtab=Table(($s_currTab).T_extmacro);set format $s_loadtab ($s_currTab).s_extmacro;make plot $s_loadtab \"x={"+s_PREDCOLPREDext+":"+s_PREDCOLext+"};pinwheel=blue;depth=4.;;\""
        else
          T_tabmacro.Action[$] = "s_loadtab=\""+s_mod+"_exttest"+"\";$s_loadtab=Table(($s_currTab).T_extmacro);set format $s_loadtab ($s_currTab).s_extmacro;make plot $s_loadtab \"x="+s_PREDCOLext+";y="+s_PREDCOLPREDext+";size=6.;regression=linear;depth=5.;;\""
        endif
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
        delete T_extmacro
      endif
    elseif (s_mod[1:3]=="dfa"|s_mod[1:3]=="dfz") then
      if Exist($s_mod "AUC") then
        add T_tabmacro
        if (s_mod[1:3]=="dfz") then
          T_tabmacro.Field[$] = "AUC Training Set"
        else
          T_tabmacro.Field[$] = "AUC External Test Set"
        endif
        T_tabmacro.Value[$] =  Tostring(Tointeger(Toreal($s_mod["AUC"])*100.)/100.)
        if (s_mod[1:3]=="dfz") then
          T_tabmacro.Remarks[$] = "Area under ROC curve using predicted ZScore to differentiate binders from approved drugs decoy"
        else
          T_tabmacro.Remarks[$] = "Area under ROC curve using predicted pKd to differentiate binders from approved drugs decoy"
        endif
        T_tabmacro.FieldType[$] = "real"
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
      endif
      if Exist($s_mod "NSA") then
        add T_tabmacro
        T_tabmacro.Field[$] = "NSA External Test Set"
        T_tabmacro.Value[$] =  Tostring(Tointeger(Toreal($s_mod["NSA"])*100.)/100.)
        T_tabmacro.Remarks[$] = "Normalized squareroot area under ROC curve using predicted pKd to differentiate binders from approved drugs decoy"
        T_tabmacro.FieldType[$] = "real"
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
      endif
    else
      if Exist($s_mod "pKdAUC") then
        add T_tabmacro
        T_tabmacro.Field[$] = "AUC External Test Set"
        T_tabmacro.Value[$] =  Tostring(Tointeger(Toreal($s_mod["pKdAUC"])*100.)/100.)
        T_tabmacro.Remarks[$] = "Area under ROC curve using predicted pKd to differentiate binders from approved drugs decoy"
        T_tabmacro.FieldType[$] = "real"
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
      endif
      if Exist($s_mod "pKdNSA") then
        add T_tabmacro
        T_tabmacro.Field[$] = "NSA External Test Set"
        T_tabmacro.Value[$] =  Tostring(Tointeger(Toreal($s_mod["pKdNSA"])*100.)/100.)
        T_tabmacro.Remarks[$] = "Normalized squareroot area under ROC curve using predicted pKd to differentiate binders from approved drugs decoy"
        T_tabmacro.FieldType[$] = "real"
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
      endif
    endif
   if (s_mod[1:3]!="mcp") then
    if Exist($s_mod "RMSE") then
      add T_tabmacro
      T_tabmacro.Field[$] = "RMSE External Test Set"
      T_tabmacro.Value[$] =  Tostring(Tointeger(Toreal($s_mod["RMSE"])*100.)/100.)
      T_tabmacro.Remarks[$] = "RMSE of predicted pKd of external test set, better measurement of uncertainty than Q2"
      T_tabmacro.FieldType[$] = "real"
      move T_tabmacro[$] i_counter; i_counter = i_counter+1
    endif
    if Exist($s_mod "Q2") then
      add T_tabmacro
      T_tabmacro.Field[$] = "Q2 External Test Set"
      T_tabmacro.Value[$] =  Tostring(Tointeger(Toreal($s_mod["Q2"])*100.)/100.)
      T_tabmacro.Remarks[$] = "Q2 of predicted pKd of external test set, unstable if only a few external test set compounds"
      T_tabmacro.FieldType[$] = "real"
      move T_tabmacro[$] i_counter; i_counter = i_counter+1
    endif
    if Exist($s_mod "PKD") then
      if Exist($s_mod "MOL") then
        group table T_intmacro $s_mod["MOL"] "mol" Toreal($s_mod["PKD"]) "pKd"
      elseif Exist($s_mod "SMILES") then
        group table T_intmacro Chemical($s_mod["SMILES"]) "mol" Toreal($s_mod["PKD"]) "pKd"
      endif
      set format T_intmacro.pKd "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value"
      if (s_mod[1:3] == "dfa") then
        if Exist($s_mod "ClassPRED") add column T_intmacro Toreal($s_mod["ClassPRED"]) name="ClassPRED"
        if Exist($s_mod "PRED") add column T_intmacro Toreal($s_mod["PRED"]) name="pKdPRED"
      elseif (s_mod[1:3] == "dfz") then
        if Exist($s_mod "PRED") add column T_intmacro Toreal($s_mod["PRED"]) name="ZScorePRED"
        if Exist($s_mod "TRAIN") add column T_intmacro Tointeger($s_mod["TRAIN"]) name="TrainingSet"
      else
        if Exist($s_mod "PRED") add column T_intmacro Toreal($s_mod["PRED"]) name="ClassPRED"
        if Exist($s_mod "pKdPRED") add column T_intmacro Toreal($s_mod["pKdPRED"]) name="pKdPRED"
        if Exist($s_mod "pKdPREX") add column T_intmacro Toreal($s_mod["pKdPRED"]) name="pKdPREX"
        if Exist($s_mod "dockScore") add column T_intmacro Toreal($s_mod["dockScore"]) name="DockScore"
      endif
      if (Type(T_intmacro.ClassPRED)!="unknown") set format T_intmacro.ClassPRED "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'" comment="Classification Score:\nProbability of being a positive, assume 0.5% hitrate"
      if (Type(T_intmacro.pKdPRED)!="unknown") set format T_intmacro.pKdPRED "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="Prediction of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value"
      if (Type(T_intmacro.pKdPREX)!="unknown") set format T_intmacro.pKdPREX "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="Internal Cross-validated Prediction of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value"
      if (Type(T_intmacro.ZScorePRED)!="unknown") set format T_intmacro.ZScorePRED "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,1.:3.,pinwheel'" comment="Z-Score\n>3. indicates 3 standard deviation above approved drugs decoy"
      if (Type(T_intmacro.DockScore)!="unknown") set format T_intmacro.DockScore "%.1f" name="" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,-32.:-20.,pinwheel'" comment="ICM docking score, \nScore < -32. are in general significant, \nbut may vary from structure to structure"
      if (Type(T_intmacro.TrainingSet)!="unknown") set format T_intmacro.TrainingSet "%.1f" name="" color="rainbow='#DCDCFF/#FFFFFF/#FFDCDC,0.:1.,pinwheel'" comment="1: Training Set\n0: Approved Drugs Decoy"
      add header T_tabmacro Collection(T_intmacro column ) name="T_intmacro"
      add header T_tabmacro Collection(T_intmacro format) name="s_intmacro"
      add T_tabmacro
      T_tabmacro.Field[$] = "Training Set Compounds"
      T_tabmacro.Value[$] = Tostring($s_mod["NOF_LIG"])
      if (s_mod[1:3]=="dfz") then
        T_tabmacro.Remarks[$] = "DoubleClick: Load Training Set/Decoy Set table"
      else
        T_tabmacro.Remarks[$] = "DoubleClick: Load Training Set table"
      endif
      T_tabmacro.FieldType[$] = "Embedded Table"
      if (s_mod[1:3]=="dfz") then
        T_tabmacro.Action[$] = "s_loadtab=\""+s_mod+"_train"+"\";$s_loadtab=Table(($s_currTab).T_intmacro);set format $s_loadtab ($s_currTab).s_intmacro;make plot $s_loadtab \"x={ZScorePRED:TrainingSet};pinwheel=blue;depth=4.;;\""
      else
        T_tabmacro.Action[$] = "s_loadtab=\""+s_mod+"_train"+"\";$s_loadtab=Table(($s_currTab).T_intmacro);set format $s_loadtab ($s_currTab).s_intmacro;make plot $s_loadtab \"x=pKd;y=pKdPRED;size=6.;regression=linear;depth=5.;;\""
      endif
      move T_tabmacro[$] i_counter; i_counter = i_counter+1
      delete T_intmacro
    endif
    if Exist($s_mod "PKDext") then
      if Exist($s_mod "MOLext") then
        group table T_extmacro $s_mod["MOLext"] "mol" Toreal($s_mod["PKDext"]) "pKd"
      elseif Exist($s_mod "SMILESext") then
        group table T_extmacro Chemical($s_mod["SMILESext"]) "mol" Toreal($s_mod["PKDext"]) "pKd"
      endif
      set format T_extmacro.pKd "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value"
      if (s_mod[1:3]=="dfa") then
        if Exist($s_mod "ClassPREDext") add column T_extmacro Toreal($s_mod["ClassPREDext"]) name="ClassPRED"
        if Exist($s_mod "PREDext") add column T_extmacro Toreal($s_mod["PREDext"]) name="pKdPRED"
      else
        if Exist($s_mod "PREDext") add column T_extmacro Toreal($s_mod["PREDext"]) name="ClassPRED"
        if Exist($s_mod "pKdPREDext") add column T_extmacro Toreal($s_mod["pKdPREDext"]) name="pKdPRED"
        if Exist($s_mod "dockScoreext") add column T_extmacro Toreal($s_mod["dockScoreext"]) name="DockScore"
      endif
      if (Type(T_extmacro.ClassPRED)!="unknown") set format T_extmacro.ClassPRED "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'" comment="Classification Score:\nProbability of being a positive, assume 0.5% hitrate"
      if (Type(T_extmacro.pKdPRED)!="unknown") set format T_extmacro.pKdPRED "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="Prediction of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value"
      if (Type(T_extmacro.pKdPREX)!="unknown") set format T_extmacro.pKdPREX "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="Internal Cross-validated Prediction of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value"
      if (Type(T_extmacro.ZScorePRED)!="unknown") set format T_extmacro.ZScorePRED "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,1.:3.,pinwheel'" comment="Z-Score\n>3. indicates 3 standard deviation above approved drugs decoy"
      if (Type(T_extmacro.DockScore)!="unknown") set format T_extmacro.DockScore "%.1f" name="" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,-32.:-20.,pinwheel'" comment="ICM docking score, \nScore < -32. are in general significant, \nbut may vary from structure to structure"
      add header T_tabmacro Collection(T_extmacro column ) name="T_extmacro"
      add header T_tabmacro Collection(T_extmacro format) name="s_extmacro"
      add T_tabmacro
      T_tabmacro.Field[$] = "External Test Set Compounds"
      T_tabmacro.Value[$] = Tostring(Nof(T_extmacro.pKd != Toreal("ND")))
      T_tabmacro.Remarks[$] = "DoubleClick: Load External Test Set table"
      T_tabmacro.FieldType[$] = "Embedded Table"
      T_tabmacro.Action[$] = "s_loadtab=\""+s_mod+"_exttest"+"\";$s_loadtab=Table(($s_currTab).T_extmacro);set format $s_loadtab ($s_currTab).s_extmacro;make plot $s_loadtab \"x=pKd;y=pKdPRED;size=6.;regression=linear;depth=5.;;\""
      move T_tabmacro[$] i_counter; i_counter = i_counter+1
      delete T_extmacro
    endif
    if (s_mod[1:3] == "dfa" | s_mod[1:3] == "dfz") then
      for i_tmpl = 1,  Tointeger($s_mod["NOF_TMPLCL"])
        s_obj = s_mod+"_tmpl"+Tostring(i_tmpl)
        i_nofobj = Nof(a_*.)
        load object $s_mod["ob"+Tostring(i_tmpl)]
        i_obst = i_nofobj+1
        i_obend = Nof(a_*.)
        move a_$i_obst:$i_obend. a_$i_obst.
        rename a_$i_obst. s_obj
        add header T_tabmacro Parray(a_$i_obst. object) name=s_obj
        add T_tabmacro
        T_tabmacro.Field[$] = "Ligand APF Template"
        T_tabmacro.Value[$] = s_obj
        T_tabmacro.Remarks[$] = "DoubleClick: Load APF Template"
        T_tabmacro.FieldType[$] = "Embedded Object"
        T_tabmacro.Action[$] = "delete a_"+s_obj+". l_warn=no;undisplay;load object ($s_currTab)."+s_obj+";cool a_; consensusPh4byAPF a_ { 0.75 , 0.75 , 0.75 , 0.5 , 0.5 } yes yes"
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
        delete a_$i_obst.
      endfor
    endif
    if (s_mod[1:3] == "dpc") then
      i_rec = Index(Index(Name($s_mod["OBJS"]) ".*_rec$" regexp) 1)
      if (i_rec!=0) then
        s_rec = s_mod+"_rec"
        s_obj = Name($s_mod["OBJS"])[i_rec]
        delete a_$s_rec. l_warn=no
        load object $s_mod["OBJS" s_obj]
        rename a_ s_rec
        add header T_tabmacro Parray(a_$s_rec. object) name=s_rec
        add T_tabmacro
        T_tabmacro.Field[$] = "Receptor Object"
        T_tabmacro.Value[$] = s_rec
        T_tabmacro.Remarks[$] = "DoubleClick: Load Receptor Object"
        T_tabmacro.FieldType[$] = "Embedded Object"
        T_tabmacro.Action[$] = "delete a_"+s_rec+". l_warn=no;undisplay;load object ($s_currTab)."+s_rec+";cool a_"
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
        delete a_$s_rec.
      endif
      i_tmpl = Index(Index(Name($s_mod["OBJS"]) ".*_tmplt.ob$" regexp) 1)
      if (i_tmpl!=0) then
        s_tmpl = s_mod+"_tmpl"
        s_obj = Name($s_mod["OBJS"])[i_tmpl]
        delete a_$s_tmpl. l_warn=no
        load object $s_mod["OBJS" s_obj]
        rename a_ s_tmpl
        add header T_tabmacro Parray(a_$s_tmpl. object) name=s_tmpl
        add T_tabmacro
        T_tabmacro.Field[$] = "Docking Ligand Template"
        T_tabmacro.Value[$] = s_tmpl
        T_tabmacro.Remarks[$] = "DoubleClick: Load Docking Ligand Template"
        T_tabmacro.FieldType[$] = "Embedded Object"
        T_tabmacro.Action[$] = "delete a_"+s_tmpl+". l_warn=no;load object ($s_currTab)."+s_tmpl+";display wire a_"
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
        delete a_$s_tmpl.
      endif
    endif
    if (s_mod[1:3] == "eca") then
      group table T_tabmacro2 $s_mod["MODELMOL"] "mol" Toreal($s_mod["MODELPKD"]) "pKd" Tointeger($s_mod["MODELiTARGET"]) "iTarget"
      group table T_tabmacro3 $s_mod["MODELTARGET"] "Target"
      add column T_tabmacro3 Count(Nof(T_tabmacro3)) name="iTarget"
      join left T_tabmacro2.iTarget T_tabmacro3.iTarget name="T_tabmacro4"
      T_tabmacro2 = T_tabmacro4; delete T_tabmacro3 T_tabmacro4 l_warn=no
      for i_tab = 1, Max(T_tabmacro2.iTarget )
        s_tab0 = "T_"+String(i_tab)
        T_tabmacro3 = T_tabmacro2.iTarget == i_tab
        if (Type($s_tab0)!="unknown") delete $s_tab0 l_warn=no
        set format T_tabmacro3.pKd "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="Experimental value of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value"
        rename T_tabmacro3 s_tab0
        add header T_tabmacro Collection($s_tab0 column ) name=s_tab0
        add header T_tabmacro Collection($s_tab0 format) name=Replace(s_tab0 "^T_" "s_")
        add T_tabmacro
        T_tabmacro.Field[$] = "Experimental data for single target"
        T_tabmacro.Value[$] = ($s_tab0).Target[1]
        T_tabmacro.Remarks[$] = "DoubleClick: Load Experimental Data table"
        T_tabmacro.FieldType[$] = "Embedded Table"
        T_tabmacro.Action[$] = "s_loadtab=\""+s_mod+"_"+($s_tab0).Target[1]+""+"\";$s_loadtab=Table(($s_currTab)."+s_tab0+");set format $s_loadtab ($s_currTab)."+Replace(s_tab0 "^T_" "s_")+";make plot $s_loadtab \"x={pKd};pinwheel=blue;depth=4.;;\""
        move T_tabmacro[$] i_counter; i_counter = i_counter+1
      endfor
      for i_tab = 1, Max(T_tabmacro2.iTarget ) - 1
        s_tab1 = "T_"+String(i_tab)
        for j_tab = i_tab+1, Max(T_tabmacro2.iTarget )
          s_tab0 = "T_"+String(i_tab)+"_"+String(j_tab)
          s_tab2 = "T_"+String(j_tab)
          T_tabmacro3 = $s_tab2
          rename T_tabmacro3.pKd "pKd2"
          rename T_tabmacro3.iTarget "iTarget2"
          rename T_tabmacro3.Target "Target2"
          join left $s_tab1.mol T_tabmacro3.mol name="T_tabmacro4"
          T_tabmacro4 = T_tabmacro4.pKd2 != Toreal("ND")
          if (Nof(T_tabmacro4)==0) then
            delete T_tabmacro3 T_tabmacro4 l_warn=no
            continue
          endif
          add column T_tabmacro4 T_tabmacro4.pKd-T_tabmacro4.pKd2 name="pKd_diff" index=2
          sort reverse T_tabmacro4.pKd_diff
          set format T_tabmacro4.pKd_diff "%.1f" name="" color="rainbow='#0000FF/#FFFFFF/#FF0000,-2.:2.,pinwheel'" comment="Difference in experimental value of pKd, pKi, pIC50, pEC50, etc for Target and Target2"
          rename T_tabmacro4 s_tab0
          add header T_tabmacro Collection($s_tab0 column ) name=s_tab0
          add header T_tabmacro Collection($s_tab0 format) name=Replace(s_tab0 "^T_" "s_")
          add T_tabmacro
          T_tabmacro.Field[$] = "Selectivity and Experimental data for two targets"
          T_tabmacro.Value[$] = ($s_tab0).Target[1]+" vs "+($s_tab0).Target2[1]
          T_tabmacro.Remarks[$] = "DoubleClick: Load Selectivity and Experimental Data table"
          T_tabmacro.FieldType[$] = "Embedded Table"
          T_tabmacro.Action[$] = "s_loadtab=\""+s_mod+"_"+($s_tab0).Target[1]+"vs"+($s_tab0).Target2[1]+"\";$s_loadtab=Table(($s_currTab)."+s_tab0+");set format $s_loadtab ($s_currTab)."+Replace(s_tab0 "^T_" "s_")+";make plot $s_loadtab \"x={pKd_diff};pinwheel=blue;depth=4.;;\";make plot $s_loadtab \"x=pKd2;y=pKd;size=6.;regression=xy;depth=5.;;\""
          move T_tabmacro[$] i_counter; i_counter = i_counter+1
          delete T_tabmacro3 l_warn=no
          delete $s_tab0 l_warn=no
        endfor
        delete $s_tab1 l_warn=no
      endfor
    endif
   endif
  endif
    if (Type(T_tabmacro.FieldType)!="unknown") set format T_tabmacro.FieldType show off
    if (Type(T_tabmacro.Action)!="unknown") set format T_tabmacro.Action show off
    if (Type($s_tab)!="unknown") delete $s_tab
    rename T_tabmacro s_tab
    keep $s_tab
    if (!l_loaded) delete $s_mod l_warn=no
    set foreground $s_tab
  endfor
endmacro
#
macro msunpackModelsncc s_tab ("") s_target ("") auto
  l_info=l_warn=l_commands=no
  s_tab = Trim(s_tab all)
  s_target = Trim(s_target all)
  if (s_tab == "") return "Please specify the ncc/mcp header table name"
  if (s_target == "") return "Please specify the target name/uniprot prefix"
  if (Type($s_tab)!="table") return "Header table specified not loaded in ICM"
  S_targetlist = $s_tab.S_targetlist
  i_idx = Index(S_targetlist s_target)
  if (i_idx == 0) return "Target/Uniprot prefix specified not found in header table"
  group table T_tabmacro $s_tab.SMILESext "smiles"
  if (Type($s_tab.M_CLASSext)=="matrix") then
    M_CLASSext = $s_tab.M_CLASSext
    add column T_tabmacro Tointeger(M_CLASSext[?,i_idx]) name="Actives"
    M_pPvalueext = $s_tab.M_pPvalueext
    add column T_tabmacro M_pPvalueext[?,i_idx] name="pPvalue"
    M_Probext = $s_tab.M_Probext
    add column T_tabmacro M_Probext[?,i_idx] name="Class_Score"
    s_Probcomment = "-Log(probability) relative to approved drugs decoy, capped at 10\n1: Top 10 percent\n2: Top 1 percent\n3: Top 0.1 percent"
    set format T_tabmacro.pPvalue "%.2f" name="" color="rainbow='#FFFFFF/#FFFF00/#FF0000,1.:3.,pinwheel'" comment=s_Probcomment
    s_Classcomment = "Classification Score:\nProbability of being a positive, assume 0.5% hitrate for random compounds"
    set format T_tabmacro.Class_Score "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'" comment=s_Classcomment
  endif
  if (Type($s_tab.PREDCOL)=="string") then
    s_PREDCOL = $s_tab.PREDCOL
    M_DATAext = $s_tab.M_DATAext
    M_PREDext = $s_tab.M_PREDext
    l_class = yes
    if (Max(Max(M_DATAext))==99999.) l_class = no
    if (l_class) then

    else
      add column T_tabmacro M_DATAext[?,i_idx] name=s_PREDCOL
      add column T_tabmacro M_PREDext[?,i_idx] name=s_PREDCOL+"Pred"
      T_tabmacro = T_tabmacro.$s_PREDCOL != 99999.
      s_PREDCOLPred = s_PREDCOL+"Pred"
      make plot T_tabmacro "x="+s_PREDCOL+";y="+s_PREDCOL+"Pred;size=6.;shapeBorder=no;regression=linear;labelZoom=1.;pointZoom=1.;depth=5.;;"
      set format T_tabmacro.$s_PREDCOL "%.2f" name="" color=$s_tab.COLOR comment = $s_tab.COMMENT
      set format T_tabmacro.$s_PREDCOLPred "%.2f" name="" color=$s_tab.COLOR comment = "Prediction of:\n"+$s_tab.COMMENT
    endif
  endif
  if (Type($s_tab.M_PKDext)!="unknown") then
    M_PKDext = $s_tab.M_PKDext
    add column T_tabmacro M_PKDext[?,i_idx] name="pKd"
    T_tabmacro.pKd [Index(T_tabmacro.pKd == 0.)] = Toreal("ND")
    s_pKdcomment = "Experimental value of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND indicates Not Determined Experimentally"
    set format T_tabmacro.pKd "%.2f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_pKdcomment
  endif
  if (Type($s_tab.M_PKDPREDext)!="unknown") then
    M_PKDPREDext = $s_tab.M_PKDPREDext
    add column T_tabmacro M_PKDPREDext[?,i_idx] name="pKdPred"
    T_tabmacro.pKdPred [Index(T_tabmacro.pKdPred == 0.)] = Toreal("ND")
    s_pKdPredcomment = "Predicted value of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND indicates disimilarity to known binders"
    set format T_tabmacro.pKdPred "%.2f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_pKdPredcomment
  endif

  s_tabname1 = Field(s_tab 1 "_")+"_"+s_target+"_ExtTest"
  if (Type(T_tabmacro.Actives)=="iarray") then
    T_tabmacro = T_tabmacro.Actives != -1
    delete ROCs l_warn=no
    calc3Rocs -T_tabmacro.Class_Score T_tabmacro.Actives yes "blue"
    add column ROCs -ROCs.Score name="Class_Score" index=1
    sort reverse ROCs.Class_Score
    rename ROCs.correct "Actives"
    s_EF = String(Integer(ROCs.rateTP[Min(index Abs(ROCs.rateFP -1.))]*10.)/10.)
    S_col = Name(ROCs)[1:Nof(Name(ROCs))-1]
    S_ncccol1 = {"Class_Score","Actives","sens","spec","prec","accu","F1","matt"}
    for i_col = 1, Nof(S_col)
      if (Index(S_ncccol1 Field(S_col[i_col] 2 "."))!=0) continue
      s_col = S_col[i_col]
      move $s_col 20
#    set format $s_col show off
    endfor
    delete variable ROCs.plot 3
    delete variable ROCs.plot 2
    s_auc =  String(Integer(Toreal(R_out[1]*10.))/10.)
    ROCs.plot[1] = "x=rateFP;y=rateTP;color=color;size=3.;shape=circle;series=series;style=connected;depth=5.;;element=polygon;xy=0,0,0,100,100,100;;title=Class Score ROC, AUC:"+s_auc+"%, EF at 1%FP:"+s_EF+";;"
    s_tabname2 = Field(s_tab 1 "_")+"_"+s_target+"_ROCs"
    if (Type($s_tabname2)!="unknown") delete $s_tabname2
    make plot T_tabmacro "x=pPvalue;y=Class_Score;"
  endif
  if (Type($s_tabname1)!="unknown") delete $s_tabname1
  add column T_tabmacro Chemical(T_tabmacro.smiles smiles) name="mol" index=1
  if (Type(T_tabmacro.pKd)=="rarray" &  Type(T_tabmacro.pKdPred)=="rarray") make plot T_tabmacro "x=pKdPred;y=pKd;size=6.;regression=linear"
  rename T_tabmacro s_tabname1
  keep $s_tabname1
  if (Type(s_tabname2)!="unknown") then
    rename ROCs s_tabname2
    keep $s_tabname2
  endif
endmacro
#
macro checkembeddata s_mod ("") i_row (0) auto
  l_info=no; l_warn=no
  s_tab = Name(foreground table)[1]
  s_mod = Trim(s_mod all)
  if ((s_mod=="")&(i_row==0)) return "Please specify model name or select table row"
  if (s_mod=="") then
    if ((Type($s_tab.Target)!="sarray")|(Type($s_tab.predictType)!="sarray")) return "Please specify model name or select table row"
    s_mod = ($s_tab.predictType)[i_row]+($s_tab.Target)[i_row]
  endif
  l_loaded = no
  if (Type($s_mod)!="unknown") then
    l_loaded = yes
  elseif Exist(s_icmhome+"/models/"+s_mod+".icb") then
    read binary s_icmhome+"/models/"+s_mod+".icb"
  elseif Exist(s_mod+".icb") then
    read binary s_mod+".icb"
  else
    l_continue = yes
    S_modelsDir = Split(TOOLS.modelsDir ";")
    for i_modelsDir = 1, Nof(S_modelsDir)
      if Exist(S_modelsDir[i_modelsDir]+s_mod+".icb") then
        read binary S_modelsDir[i_modelsDir]+s_mod+".icb"
        l_continue = no
        break
      endif
    endfor
    if (l_continue) return "Model not found, please specify model location"
  endif
  if (((!Exist($s_mod "SMILES"))&(!Exist($s_mod "MOL")))|(!Exist($s_mod "PKD"))) then
    delete $s_mod
    return "Model does not contain embedded data needed"
  else
    if (Type(T_embedded)!="unknown") delete T_embedded
    if Exist($s_mod "MOL") then
      group table T_embedded $s_mod["MOL"] "mol" Toreal($s_mod["PKD"]) "PKD"
    else
      group table T_embedded Chemical($s_mod["SMILES"]) "mol" Toreal($s_mod["PKD"]) "PKD"
    endif
    set format T_embedded.PKD "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="Experimental pKd value\n6. is uM\n9. is nM"
    if (Exist($s_mod "pKdPRED")) then
      if (Nof($s_mod["pKdPRED"]) == Nof(T_embedded)) then
        add column T_embedded Toreal($s_mod["pKdPRED"]) name="pKdPRED"
        set format T_embedded.pKdPRED "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="pKd Prediction\n6. is uM\n9. is nM"
      endif
#      make plot T_embedded "x=PKD;y=pKdPRED;size=6.;regression=linear;depth=5.;;"
    elseif (Exist($s_mod "PRED")) then
      if (Nof($s_mod["PRED"]) == Nof(T_embedded)) then
        add column T_embedded Toreal($s_mod["PRED"]) name="PRED"
        set format T_embedded.PRED "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment="pKd Prediction\n6. is uM\n9. is nM"
      endif
#      make plot T_embedded "x=PKD;y=PRED;size=6.;regression=linear;depth=5.;;"
    endif
  endif
  if (i_row!=0) then
    if ((Type(T_embedded.mol 2)=="3D")&( Type(($s_tab).mol[i_row] 2)=="3D")) then
      if(Nof(pmf)==0)read pmf s_icmhome+"APF"
      group table T_embeddedtmp ($s_tab).mol[i_row] "mol"
      add T_embeddedtmp T_embedded
      M_apf = Score(T_embeddedtmp.mol[1] T_embeddedtmp.mol[2:$] field)
      R_self = Rarray(Nof(T_embeddedtmp) 0.)
      for i_self = 1, Nof(R_self)
        R_self[i_self] = Score(T_embeddedtmp.mol[i_self] field)[1,1]
      endfor
      add column T_embedded Toreal(Sarray(Nof(T_embedded) "ND")) name="similarity"
      for i_embed = 1, Nof(T_embedded)
        T_embedded.similarity[i_embed] = 1.-(R_self[1]+R_self[i_embed+1]-2.*M_apf[1,i_embed])/(R_self[1]+R_self[i_embed+1])
      endfor
      delete T_embeddedtmp l_warn=no
      set format T_embedded.similarity "%.4g" name="" color="rainbow='#FFFFFF/#FFFF00/#FF0000,0.7:0.95,pinwheel'" comment="APF 3D Poses similarity, a value of 1 means the test and reference compounds have identical poses"
      set property display T_embedded
    else
      add column T_embedded  1.-Min(Distance(($s_tab).mol[i_row] T_embedded.mol)) name="similarity"
      set format T_embedded.similarity "%.4g" name="" color="rainbow='#FFFFFF/#FFFF00/#FF0000,0.7:0.95,pinwheel'" comment="Fingerprint TANIMOTO similarity, a value of 1 means the test and reference compounds have identical fingerprints"
    endif
    sort T_embedded.similarity reverse
    if (s_mod[1:3]=="mcp") then
    else
      s_comment = ($s_tab).Target_Name[i_row]+"<br>"
      if (s_mod[1:3]=="kcc") then
        s_comment=s_comment+"Kernel Chemical Classification/Activity (kcc) model<br><br>"
      elseif (s_mod[1:3]=="dfa") then
        s_comment=s_comment+"Docking to Ligand Field Activity (dfa) Model<br><br>"
      elseif (s_mod[1:3]=="dpc") then
        s_comment=s_comment+"Docking to Pocket Classification/Activity (dpc) model<br><br>"
      elseif (s_mod[1:3]=="dfz") then
        s_comment=s_comment+"Docking to Ligand Field Z-Score (dfz) Model<br><br>"
      endif
      s_comment = s_comment+"The selected compound is "
      if (T_embedded.similarity[1]>=0.9) then
        s_comment = s_comment+"very similar"
      elseif (T_embedded.similarity[1]>=0.8) then
        s_comment = s_comment+"similar"
      elseif (T_embedded.similarity[1]>=0.7) then
        s_comment = s_comment+"somewhat similar"
      elseif (T_embedded.similarity[1]>=0.6) then
        s_comment = s_comment+"borderline similar"
      else
        s_comment = s_comment+"not similar"
      endif
      s_comment = s_comment+" to the training set compounds<br>"
      if (($s_tab).MolpKd[i_row]!=Toreal("ND")&(s_mod[1:3]!="dfz")) then
        s_comment = s_comment+" MolpKd of "+String(($s_tab).MolpKd[i_row])[1:3]+" predicts it is a "
        if (($s_tab).MolpKd[i_row]>7.) then
          s_comment = s_comment+"high affinity binder<br>"
        elseif (($s_tab).MolpKd[i_row]>5.) then
          s_comment = s_comment+"binder<br>"
        else
          s_comment = s_comment+"non-binder<br>"
        endif
      endif
#      if (($s_tab).pPvalue[i_row]!=Toreal("ND")&(s_mod[1:3]!="dfz")) then
#        s_comment = s_comment+" pPvalue of "+String(($s_tab).pPvalue[i_row])[1:4]+" indicates the predicted activity is "
#        if (($s_tab).pPvalue[i_row]>4.) then
#          s_comment = s_comment+"highly significant "
#        elseif (($s_tab).pPvalue[i_row]>2.) then
#          s_comment = s_comment+"significant "
#        elseif (($s_tab).pPvalue[i_row]>1.) then
#          s_comment = s_comment+"somewhat significant "
#        else
#          s_comment = s_comment+"insignificant "
#        endif
#        s_comment = s_comment+" versus random noise<br>"
#      endif
      if ((($s_tab).MolZScore[i_row]!=Toreal("ND")&($s_tab).MolZScore[i_row]!=0.)|(s_mod[1:3]=="dfz")) then
        s_comment = s_comment+" MolZScore implies its activity is "
        if (($s_tab).MolZScore[i_row]>0.) then
          s_comment = s_comment+String(($s_tab).MolZScore[i_row])[1:4]+" standard deviation more significant than random noise<br>"
        else
          s_comment = s_comment+String(($s_tab).MolZScore[i_row])[1:4]+" standard deviation less significant than random noise<br>"
        endif
      endif
      if (s_mod[1:3]!="kcc") s_comment = s_comment +"Always check docking pose vs known compounds for confirmation<br>"
    endif
    add header T_embedded String("") name="toolsPanel" append
    T_embedded.toolsPanel = "# txt_Selected_Compound_Assessment ("+s_comment+")"
  endif
  if (!l_loaded) delete $s_mod
  if (Type(T_embedded.mol 2)=="3D") then
    rename T_embedded.similarity "APF_similarity"
  else
    rename T_embedded.similarity "TANI_similarity"
  endif
  set property T_embedded header
  set foreground T_embedded
  keep T_embedded
endmacro
#
macro msaddGO s_tab ("msLigandModel") auto
HELP = """
  Add GO_Cellular, GO_Process, and GO_Function to MolScreen Panel or Result table
  It will also add filter options in the Tools Panel of the table if not already present
  If the table is modified, one can update the list of GO terms by running this macro again
  Syntax:
  <s_tab> : Table name
  Example:
  msaddGO 'msLigandModel'
  msaddGO 'AllTargets'
"""
  l_info = l_commands = l_warn = no
  s_tab = Trim(s_tab all)
  if (s_tab == "") return "Please specify table name"
  if (Type($s_tab)!="table") return "Table specified not found"
  s_col = s_tab+".Target"
  i_mode = 1
  if (Type($s_col)!="sarray") then
    s_col = s_tab+".model"
    if (Type($s_col)!="sarray") return "Either Target column or model column is needed"
    i_mode = 2
  endif
  if (i_mode == 1) then
    I_actives = Iarray()
    if (Type($s_tab.MolScore)=="rarray") I_actives //= Index($s_tab.MolScore>=3.)
    if (Type($s_tab.MolpKd)=="rarray") I_actives //= Index($s_tab.MolpKd>=5.)
    if (Type($s_tab.MolZScore)=="rarray") I_actives //= Index($s_tab.MolZScore>=2.)
    if (Nof(I_actives)==0) return "No hit in the table specified, nothing to filter"
    I_actives = Unique(Sort(I_actives))
  elseif (i_mode == 2) then
    add column $s_tab Field(Replace(Replace(Replace(Replace(Replace(Replace($s_col "kcc" "") "eca" "") "dpc" "") "dfa" "") "dfz" "") "mcp" "") 1 "_") name="Target"
    I_actives = Count(Nof($s_tab))
  endif
  delete T_tmptab l_warn=no
  rename $s_tab "T_tmptab"
  if (Type(T_tmptab.GO_Cellular)!="unknown") delete T_tmptab.GO_Cellular l_warn=no
  if (Type(T_tmptab.GO_Process)!="unknown") delete T_tmptab.GO_Process l_warn=no
  if (Type(T_tmptab.GO_Function)!="unknown") delete T_tmptab.GO_Function l_warn=no
  add column T_tmptab Sarray(Nof(T_tmptab) "") name="GO_Cellular"
  add column T_tmptab Sarray(Nof(T_tmptab) "") name="GO_Process"
  add column T_tmptab Sarray(Nof(T_tmptab) "") name="GO_Function"
  if (Type(GOterm)!="table") then
    delete GOterm l_warn=no
    read binary s_icmhome+"models/GOterm.icb"
  endif
  S_target = Unique(Sort(T_tmptab.Target[I_actives ]))
  group table "TGO_Cellular" Sarray() "Target" Sarray() "GO_Cellular" Iarray() "Count"
  group table "TGO_Process" Sarray() "Target" Sarray() "GO_Process" Iarray() "Count"
  group table "TGO_Function" Sarray() "Target" Sarray() "GO_Function" Iarray() "Count"

  N=Nof(S_target)
  print bar "Processing GO terms" N l_info=yes
  for i_target = 1, Nof(S_target)
    s_target = S_target[i_target]
    if (Trim(s_target)=="") continue
    j_target = Index(GOterm.Uniprot s_target)
    if (j_target==0) continue
    i_count = Nof(T_tmptab.Target[I_actives] s_target)
    I_target =  Index(T_tmptab[I_actives] & T_tmptab.Target ==s_target)
    if (GOterm.GO_Cellular [j_target]!="") then
      group table TGOtmp Split(GOterm.GO_Cellular [j_target] "\n") "GO_Cellular"
      add column TGOtmp Sarray(Nof(TGOtmp) s_target) name="Target" index=1
      add column TGOtmp Iarray(Nof(TGOtmp) i_count) name="Count" index=3
      T_tmptab.GO_Cellular[I_target] = GOterm.GO_Cellular [j_target]
      add TGO_Cellular TGOtmp; delete TGOtmp l_warn=no
    endif
    if (GOterm.GO_Process [j_target]!="") then
      group table TGOtmp Split(GOterm.GO_Process [j_target] "\n") "GO_Process"
      add column TGOtmp Sarray(Nof(TGOtmp) s_target) name="Target" index=1
      add column TGOtmp Iarray(Nof(TGOtmp) i_count) name="Count" index=3
      T_tmptab.GO_Process[I_target] = GOterm.GO_Process [j_target]
      add TGO_Process TGOtmp; delete TGOtmp l_warn=no
    endif
    if (GOterm.GO_Function [j_target]!="") then
      group table TGOtmp Split(GOterm.GO_Function [j_target] "\n") "GO_Function"
      add column TGOtmp Sarray(Nof(TGOtmp) s_target) name="Target" index=1
      add column TGOtmp Iarray(Nof(TGOtmp) i_count) name="Count" index=3
      T_tmptab.GO_Function[I_target] = GOterm.GO_Function [j_target]
      add TGO_Function TGOtmp; delete TGOtmp l_warn=no
    endif
    print bar N l_info=yes
  endfor

  S_GOCellular = Sarray()
  S_GOProcess = Sarray()
  S_GOFunction = Sarray()
  if (Nof(TGO_Cellular)!=0) then
    sort TGO_Cellular.GO_Cellular
    group TGO_Cellular.GO_Cellular TGO_Cellular.Count "sum,"  all "first"  header  name="TGO_Cellular"
    rename TGO_Cellular.sum_Count "Count"
    sort reverse TGO_Cellular.Count
    S_GOCellular = TGO_Cellular.GO_Cellular + Sarray(Nof(TGO_Cellular) "; ") +Tostring(TGO_Cellular.Count  )
  endif
  if (Nof(TGO_Process)!=0) then
    sort TGO_Process.GO_Process
    group TGO_Process.GO_Process TGO_Process.Count "sum,"  all "first"  header  name="TGO_Process"
    rename TGO_Process.sum_Count "Count"
    sort reverse TGO_Process.Count
    S_GOProcess = TGO_Process.GO_Process + Sarray(Nof(TGO_Process) "; ") +Tostring(TGO_Process.Count  )
  endif
  if (Nof(TGO_Function)!=0) then
    sort TGO_Function.GO_Function
    group TGO_Function.GO_Function TGO_Function.Count "sum,"  all "first"  header  name="TGO_Function"
    rename TGO_Function.sum_Count "Count"
    sort reverse TGO_Function.Count
    S_GOFunction = TGO_Function.GO_Function + Sarray(Nof(TGO_Function) "; ") +Tostring(TGO_Function.Count  )
  endif

  delete T_tmptab.S_GOCellular l_warn=no; add header T_tmptab S_GOCellular name="S_GOCellular"
  delete T_tmptab.S_GOProcess l_warn=no; add header T_tmptab S_GOProcess name="S_GOProcess"
  delete T_tmptab.S_GOFunction l_warn=no; add header T_tmptab S_GOFunction name="S_GOFunction"

  if (Type(T_tmptab.toolsPanel) != "string") add header T_tmptab name="toolsPanel" ""
  S_cursor = Split(T_tmptab.toolsPanel "\n")
  l_updatecursor = no
  if (Nof(S_cursor)==0) then
    S_cursor //= "# b_Add/Update_GO_Terms (msaddGO Name(variable %@)) [ONCHANGE:REFRESH]"
    l_updatecursor=yes
  elseif (Index(Index(S_cursor ".*msaddGO.*" regexp) 1)==0) then
    S_cursor //= "# b_Add/Update_GO_Terms (msaddGO Name(variable %@)) [ONCHANGE:REFRESH]"
    l_updatecursor=yes
  endif
  if (Index(Index(S_cursor ".*msfilterGO.*" regexp) 1)==0) then
    S_cursor//="# i_Display_Only:GOonly (1@All|2@GO_Cellular|3@GO_Process|4@GO_Function) [RDONLY]"
    S_cursor//="# s_GO_Cellular:gocellular ($%@.S_GOCellular) [VISIBLE:$GOonly==2]"
    S_cursor//="# s_GO_Process:goprocess ($%@.S_GOProcess) [VISIBLE:$GOonly==3]"
    S_cursor//="# s_GO_Function:gofunction ($%@.S_GOFunction) [VISIBLE:$GOonly==4]"
    S_cursor//="# b_Display_All_Rows (msfilterGO Name(variable %@)) [VISIBLE:$GOonly==1]"
    S_cursor//="# b_Filter_by_GO_Cellular (msfilterGO Name(variable %@) \"GO_Cellular\" Field($gocellular 1 \";\")) [VISIBLE:$GOonly==2]"
    S_cursor//="# b_Filter_by_GO_Process (msfilterGO Name(variable %@) \"GO_Process\" Field($goprocess 1 \";\")) [VISIBLE:$GOonly==3]"
    S_cursor//="# b_Filter_by_GO_Function (msfilterGO Name(variable %@) \"GO_Function\" Field($gofunction 1 \";\")) [VISIBLE:$GOonly==4]"
#    S_cursor//="# txt_GO (After updating the GO terms, please right click on the workspace and refresh)"
    l_updatecursor=yes
  endif
  if (l_updatecursor) then
    T_tmptab.toolsPanel = Sum(S_cursor "\n")+"\n"
    print "Table tools panel is modified, if you do not see the new Display/filter by GO terms, please right click on the workspace and refresh"
  endif
  print bar "Done\n" l_info=yes
  if (i_mode==2) then
    delete T_tmptab.Target l_warn=no
    if (Type(T_tmptab.version)!="unknown") move T_tmptab.version Index(Name(T_tmptab) "T_tmptab.GO_Function")+1
  endif
  rename T_tmptab s_tab
  keep $s_tab
endmacro
#
macro msfilterGO s_tab ("msLigandModel") s_type ("") s_GOterm ("") auto
HELP = """
  Filter the table rows by GO term
  Require table column .GO_Cellular .GO_Process .GO_Function, which can be added to any MolScreen Panel or Result table by the macro msaddGO
  Arguments and Options:
    <s_tab>: Table name
    <s_type>: Column name, can be GO_Cellular, GO_Process, GO_Function that can be added by the macro msaddGO
              Alternatively, any string column with new line separated phrases can be used
    <s_GOterm>: GO term in the <s_type> column separated by new line, only exact match will be returned
    if both <s_type> and <s_GOterm> are empty string, it will unhide all the previously hidden row of the table
  Example:
    msfilterGO 'msLigandModel' '' '' # Unhide all previously hidden row
    msfilterGO 'msLigandModel' 'GO_Function' 'G-protein coupled serotonin receptor activity' # Only rows with the exact phrase in GO_Function is shown
"""
  l_info = l_commands = l_warn = no
  s_tab = Trim(s_tab all)
  if (s_tab == "") return "Please specify table name"
  if (Type($s_tab)!="table") return "Table specified not found"
  s_type = Trim(s_type all); s_GOterm = Trim(s_GOterm all)
  if ((s_type=="")|(s_GOterm=="")) then
    find table $s_tab index=Iarray(0) show off
  else
    if (Type(($s_tab).$s_type)!="sarray") then
      find table $s_tab index=Iarray(0) show off
    else
      s_tabtype = s_tab+"."+s_type
      I_select = Index($s_tabtype==s_GOterm | $s_tabtype~s_GOterm+"\n*" | $s_tabtype~"*\n"+s_GOterm | $s_tabtype ~"*\n"+s_GOterm+"\n*")
      find table $s_tab index=Index(I_select Nof($s_tab) inverse) show off
    endif
  endif
endmacro
#
macro msSelectPocket s_proj ("") s_sdf ("") l_optconf (no) l_ligpocket (yes) l_dock (no) l_RECCONF (yes) l_nocluster (yes) r_clustdist (1.0) i_maxsel (10) auto
HELP = """
  Select a representative set of PDBs from any pocketome entry for 4D docking with Ligand APF template. If you want to preserve all of pdb-objects, use macro mrcStack
  To proceed, it will delete all objects loaded in the current ICM session
  It will return:
    a_recobject.: an icm-converted Receptor object with a reduced stack of selected conformations.
    a_ligtemplate.: an icm-object with multiple ligands extracted from the input pdb-objects. It may be used later to make an APF template for docking
    T_pocket: Indicates which PDBs are used,
    dock_answers: 4D docking result of all the co-crystallized ligands, with Lig_Rmsd column
  Arguments and options:
    <s_proj>:      File name, it can be:
                   1: Pocketome entry name, can be a simplified form such as 'ESR1' if there is only one pocketome entry with that Uniprot ID
                   The Pocketome entry will be read from the Pocketome server
                   2: Object file name
    <l_optconf>:   If yes, then an additional step will be performed in which the incorrectly docked ligands will be docked to each unused pocket,
                   the best combination of pockets will be added to the representative, it will take much longer time
    <l_ligpocket>: If yes, cluster the co-crystallized ligands by APF, then add representative conformations to the selection
    <l_dock>:      If yes, an initial docking step will be attempted to check the performance of the intitial pocket selection
    as_graph:      If any loaded objects are selected, they will be added to pocketome/object files
  Example:
    msSelectPocket 'ESR1'
    msSelectPocket '/data/pocketome/2015dec/icb/ESR1_HUMAN_301_551.icb'
"""
  l_info = l_commands = l_warn = no
  if (Nof(a_*.)!=0) then
    print "Warning: all objects will be deleted"
    l_origobj = yes
  else
    l_origobj = no
  endif
  i_noforigobj = Nof(a_*.)
  s_proj = Trim(s_proj all)
  s_sdf = Trim(s_sdf all)
  l_resulttab = no
  if (s_proj != "") then
    if (Extension(s_proj) == ".ob") then
      if !Exist(s_proj) return "Object specified not found"
    elseif (Extension(s_proj) == ".dtb") then
      if !Exist(s_proj) return "Docking table specified not found"
      if !Exist(Replace(s_proj ".dtb" "_rec.ob")) return "Docking object specified not found"
    elseif (Extension(s_proj) == ".icb") then
      if !Exist(s_proj) return "Pocketome file specified not found"
    else
      if (Type($s_proj) == "table") then
        if ((Type($s_proj.recobj)!="collection") | (Type($s_proj.ligobj)!="collection")) return "Table specified does not contain rec and lig object"
        delete a_*. l_warn=no
        s_recname = Name($s_proj.recobj)[1]
        s_ligname = Name($s_proj.ligobj)[1]
        load object ($s_proj.recobj)[s_recname]
        load object ($s_proj.ligobj)[s_ligname]
        l_resulttab = yes
        if (Name(a_1.)!="recobject") rename a_1. "recobject"
        if (Name(a_2.)!="ligobject") rename a_2. "ligobject"
        s_tmpligobjpath = s_tempDir+"tmpligobj"+Iproc( )+".ob"
        write object a_2. s_tmpligobjpath delete
        if( Type(chem)!="unknown") delete chem l_warn=no
        extractLigand a_ligobject.1 "2D" no "" no
        if (Nof(a_ligobject.*) > 1) then
          for i_ligobject = 2, Nof(a_ligobject.*)
            extractLigand a_ligobject.$i_ligobject "2D" yes Name( chem table ) no
          endfor
        endif
        add column chem Count(Nof(chem)) name="IX"
        s_tmpligsdfpath = s_tempDir+"tmpligsdf"+Iproc( )+".sdf"
        write table mol chem s_tmpligsdfpath delete
        makeIndexChemDb s_tmpligsdfpath Replace(s_tmpligsdfpath ".sdf$" ".inx") "mol" { "ID" }
        i_noflig = Nof(chem)
        delete chem l_warn=no
        s_parentdir = Path()
        l_optconf = no
        l_dock = yes
      else
        findPocketome s_proj "proteinname"
        if (Nof(POCKETOME_HITS)==0) return "Pocketome entry not found"
      endif
    endif
  endif
 if (!l_resulttab) then
  if (s_sdf != "") then
    if (Extension(s_sdf)==".sdf") then
      if !Exist(s_sdf) return "sdf file specifed not found"
      read table mol s_sdf name="ligsdf"
    else
      if (Type($s_sdf)!="table") return "sdf table specified not found"
      if (s_sdf != "ligsdf") then
        delete ligsdf l_warn=no
        ligsdf = $s_sdf
      endif
    endif
    if (Type(ligsdf)!="table") return "sdf table specified not found"
    if (Type(ligsdf.mol 2)!="3D") return "sdf table specified need to be in 3D coordinates"
  endif
  if ((!l_origobj) & (s_proj=="")) return "No object and project specified, nothing to do"
  if (l_nocluster) l_optconf = no
  if (l_optconf) l_dock=yes
  s_tmpobjpath = s_tempDir+"tmpobj"+Iproc( )+".ob"
  if (Nof(a_*.)!=0) then
    write object a_*. s_tmpobjpath delete
    delete a_*. l_warn=no
  endif
  if (Extension(s_proj)==".icb") then
    read binary s_proj
    if Error() quit "Quitting, Error reading pocketome object file"
  elseif (Extension(s_proj)==".dtb") then
    read object Replace(s_proj ".dtb" "_rec.ob")
  elseif (Extension(s_proj)==".ob") then
    read object s_proj
  else
    if (Nof(POCKETOME_HITS)!=0) then
      s_proj = POCKETOME_HITS.Entry[1]
      read binary "http://pocketome.org/files/"+POCKETOME_HITS.Entry[1]
      if Error() quit "Quitting, Error reading pocketome object file"
    endif
  endif
  i_nofpocketome = Nof(a_*.)
  if (l_origobj) read object s_tmpobjpath
  if (s_sdf != "") then
    for i_lig = 1, Nof(ligsdf)
      if (Type(ligsdf.mol[i_lig] 2)=="3D") read mol ligsdf[i_lig] name=Name(Name(ligsdf.mol[i_lig])[1] object unique)
    endfor
  endif
  i_opt = 1
  i_maxconf = 1
  for i_obj = 1, Nof(a_*.)
    if (Type(a_$i_obj. 2)!="ICM") continue
    if (Nof(a_$i_obj. conf)<=i_maxconf) continue
    i_opt = i_obj
    i_maxconf = Nof(a_$i_obj. conf)
  endfor
  if (((Type(ST)=="table")|(Type(A1)=="table")) & (!l_origobj)) then
  elseif (((Type(ST)=="table")|(Type(AT)=="table")) & (i_opt==1)) then
    for i_obj = i_nofpocketome+1, Nof(a_*.)
      set object a_$i_obj.
      if (Nof(a_A)==0) continue
      if (Nof(a_1:$i_nofpocketome.H)>0) then
        superimpose a_1.//ca & Res(Sphere(a_1:$i_nofpocketome.H a_1.A 5.)) a_$i_obj.//ca minimize align
      elseif (Nof(a_$i_obj.H)>0) then
        superimpose a_1.//ca a_$i_obj.//ca & Res(Sphere(a_$i_obj.H a_$i_obj.A 5.)) minimize align
      else
        superimpose a_1.//ca a_$i_obj.//ca minimize align
      endif
    endfor
  else
    if (Nof(a_*.)>1) then
      for i_obj = 1, Nof(a_*.)
        set object a_$i_obj.
        if (Nof(a_A)==0) continue
        if (i_obj == i_opt) continue
        if ((Type(a_ 2)=="ICM") & (Nof(a_ conf)>1)) then
          for i_conf = 1, Nof(a_ conf)
            load conf a_ i_conf
            if (Nof(a_$i_opt.H)>0) then
              superimpose a_$i_opt.//ca & Res(Sphere(a_$i_opt.H a_$i_opt.A 5.)) a_$i_obj.//ca minimize align
            elseif (Nof(a_$i_obj.H)>0) then
              superimpose a_$i_opt.//ca a_$i_obj.//ca & Res(Sphere(a_$i_obj.H a_$i_obj.A 5.)) minimize align
            else
              superimpose a_$i_opt.//ca a_$i_obj.//ca minimize align
            endif
            store conf a_ atom i_conf
          endfor
          load conf a_ 1
        else
          if (Nof(a_$i_opt.H)>0) then
            superimpose a_$i_opt.//ca & Res(Sphere(a_$i_opt.H a_$i_opt.A 5.)) a_$i_obj.//ca minimize align
          elseif (Nof(a_$i_obj.H)>0) then
            superimpose a_$i_opt.//ca a_$i_obj.//ca & Res(Sphere(a_$i_obj.H a_$i_obj.A 5.)) minimize align
          else
            superimpose a_$i_opt.//ca a_$i_obj.//ca minimize align
          endif
        endif
      endfor
    endif
  endif
  set object a_1.
  S_cofactor={"hem","nap","fad","ndp","fmn","nad","adp","sf4","udp","gtp","gsh","oro","ma4","sam","anp","atp","coh","hea","bog","sfg"}
  as_H = a_!*.
  for i_mol = 1, Nof(a_*.H)
    if (Index(Name((a_*.H)[i_mol] field) "metal")!=0) continue
    if (Index(Name((a_*.H)[i_mol] field) "cofac")!=0) continue
    if (Index(Name((a_*.H)[i_mol] field) "lignm")!=0) then
      as_H = (a_*.H)[i_mol] | as_H
    endif
  endfor
  if (Nof(as_H)==0) then
    for i_mol = 1, Nof(a_*.H)
      if (Index(S_cofactor Name(Res((a_*.H)[i_mol]))[1])==0) as_H = (a_*.H)[i_mol] | as_H
    endfor
  else
    for i_mol = 1, Nof(a_*.H)
      if (Nof((a_*.H)[i_mol] & as_H)!=0) continue
      if (Index(Name((a_*.H)[i_mol] field) "metal")!=0) continue
      if (Index(Name((a_*.H)[i_mol] field) "cofac")!=0) continue
      if ((Index(S_cofactor Name(Res((a_*.H)[i_mol]))[1])==0) & (Nof(Sphere(as_H (a_*.H)[i_mol] 3.))!=0)) then
        as_H = (a_*.H)[i_mol] | as_H
      endif
    endfor
  endif
 if (Nof(as_H)!=0) then
  as_graph = a_*.* &! Mol(Sphere(as_H a_*.* 5. ))
  if (Nof(as_graph)!= 0) delete Mol(as_graph)
  if (Nof(a_*.)==0) return "No Protein chain near ligands, cannot proceed"
  write object a_*. s_tmpobjpath delete
  as_graph = a_1:$i_nofpocketome. &! Obj(as_H)
  if (Nof(as_graph)!= 0) delete Obj(as_graph)
  if (Nof(a_*.)!=0) then
    i_nofobj = Nof(a_*.)
    N = i_nofobj*3
    print bar "Processing Object..." N l_info=yes
    for i = 1, i_nofobj
      print bar N l_info=yes
      set object a_$i.
      S_tmp = Name(a_* & as_H)
      if (Nof(S_tmp)==0) continue
      if (Type(a_ 2)=="ICM") strip virtual a_
      as_H = a_$S_tmp | as_H
      delete (Res(a_A)&!Res(Sphere(a_H & as_H a_A 5.)))
      if (Nof(Sphere((a_H//!h* & as_H) (a_*//!h* &! as_H) 2.5))!=0) then
        as_cov1 = Sphere((a_*//!h* &! as_H) (a_H//!h* & as_H) 2.5)
        as_cov2 = Sphere((a_H//!h* & as_H) (a_*//!h* &! as_H) 2.5)
        for i_cov = 1, Nof(as_cov1)
          as_covi = as_cov1[i_cov]
          for j_cov = 1, Nof(as_cov2)
            as_covj = as_cov2[j_cov]
            if ((Nof(Next(as_covj bond)&as_covi)>0)|(Nof(Next(as_covi bond)&as_covj)>0)) delete bond as_covi as_covj
            delete as_covj
          endfor
          delete as_covi
        endfor
        delete as_cov1 as_cov2
      endif
      for i_mol = 1, Nof(a_H)
        as_cov1 = Sphere(a_* &! ((a_H)[i_mol]) (a_H)[i_mol] 2.5)
        as_cov2 = Sphere(as_cov1 a_* &! ((a_H)[i_mol]) 2.5)
        for i_cov = 1, Nof(as_cov1)
          as_covi = as_cov1[i_cov]
          for j_cov = 1, Nof(as_cov2)
            as_covj = as_cov2[j_cov]
            if ((Nof(Next(as_covj bond)&as_covi)>0)|(Nof(Next(as_covi bond)&as_covj)>0)) delete bond as_covi as_covj
            delete as_covj
          endfor
          delete as_covi
        endfor
        delete as_cov1 as_cov2
      endfor
      if (Nof(a_ stack)!=0) delete stack a_
      convertObject a_ yes yes no no yes no no
      as_H = a_$S_tmp | as_H
    endfor
    delete a_1:$i_nofobj.
    errorActionold = errorAction
    errorAction = "none"
    delete (a_*.* &! as_H)
    errorAction = errorActionold
    if (Nof(a_*.)==0) return "No ligand left in pocketome entry cannot proceed"
    for i_lig = 1, Nof(a_*.H)
      set field (a_*.H)[i_lig] name="pdb" Field(Name(Obj((a_*.H)[i_lig]))[1] 1 "_")[1:4]+"."+ Name((a_*.H)[i_lig])[1]
    endfor
    delete a_ligobject. l_warn=no
    rename a_1. "ligobject"
    if (Nof(a_*.)>1) move a_!ligobject. a_ligobject.
    l_flatoccup = no
    S_ligands = Name(a_*)
    if (l_flatoccup) then
      set occupancy a_// 8./Nof(a_*)
    else
      group table T_tmplig Chemical(a_*.H exact hydrogen) "mol" Name(a_*.H) "name"
      scanClusterHitList "T_tmplig"
      add column T_tmplig Rarray(Nof(T_tmplig) 0.) name="occup"
      for i_cl = 1, Max(T_tmplig.cl)
        T_tmplig.occup[Index(T_tmplig.cl==i_cl)] = 4./Max(T_tmplig.cl)/Nof(T_tmplig.cl==i_cl)
      endfor
      for i_tmplig = 1, Nof(T_tmplig)
#        set occupancy a_ligobject.$i_tmplig T_tmplig.occup[i_tmplig]
        set occupancy a_ligobject.$i_tmplig Sqrt(T_tmplig.occup[i_tmplig])
      endfor
      r_occupfac = 4./Sum(Occupancy(a_ligobject.*))
      for i_tmplig = 1, Nof(T_tmplig)
        set occupancy a_ligobject.$i_tmplig r_occupfac*Occupancy(a_ligobject.$i_tmplig)[1]
      endfor
      delete T_tmplig l_warn=no
    endif
    s_tmpligobjpath = s_tempDir+"tmpligobj"+Iproc( )+".ob"
    write object a_*. s_tmpligobjpath delete
    if( Type(chem)!="unknown") delete chem l_warn=no
    extractLigand a_ligobject.1 "2D" no "" no
    if (Nof(a_ligobject.*) > 1) then
      for i_ligobject = 2, Nof(a_ligobject.*)
        extractLigand a_ligobject.$i_ligobject "2D" yes Name( chem table ) no
      endfor
    endif
    add column chem Count(Nof(chem)) name="IX"
    s_tmpligsdfpath = s_tempDir+"tmpligsdf"+Iproc( )+".sdf"
    write table mol chem s_tmpligsdfpath delete
    makeIndexChemDb s_tmpligsdfpath Replace(s_tmpligsdfpath ".sdf$" ".inx") "mol" { "ID" }
    i_noflig = Nof(chem)
    delete chem l_warn=no
    delete a_*.
  else
    return "no a_H in pocketome entry, cannot determine the best pocket combinations"
  endif
  read object s_tmpobjpath
  as_H = a_!*.
  for i_mol = 1, Nof(a_*.H)
    if (Index(Name((a_*.H)[i_mol] field) "metal")!=0) continue
    if (Index(Name((a_*.H)[i_mol] field) "cofac")!=0) continue
    if (Index(Name((a_*.H)[i_mol] field) "lignm")!=0) then
      as_H = (a_*.H)[i_mol] | as_H
    endif
  endfor
  if (Nof(as_H)==0) then
    for i_mol = 1, Nof(a_*.H)
      if (Index(S_cofactor Name(Res((a_*.H)[i_mol]))[1])==0) as_H = (a_*.H)[i_mol] | as_H
    endfor
  else
    for i_mol = 1, Nof(a_*.H)
      if (Nof((a_*.H)[i_mol] & as_H)!=0) continue
      if (Index(Name((a_*.H)[i_mol] field) "metal")!=0) continue
      if (Index(Name((a_*.H)[i_mol] field) "cofac")!=0) continue
      if ((Index(S_cofactor Name(Res((a_*.H)[i_mol]))[1])==0) & (Nof(Sphere(as_H (a_*.H)[i_mol] 3.))!=0)) then
        as_H = (a_*.H)[i_mol] | as_H
      endif
    endfor
  endif
  as_graph = a_*.* &! Mol(Sphere(as_H a_*.* 5.))
  if (Nof(as_graph)!= 0) delete Mol(as_graph)
  delete a_*.W
 else
  for i_obj = 1, Nof(a_*.)
    if (Type(a_$i_obj. 2 )=="ICM") then
      set object a_$i_obj.
      icmPocketFinder a_A & a_*.!H,W 4.6 no no yes
      s_out=POCKETS.Type[1]
      as_graph=Sphere($s_out a_*.A 2.5)
      delete grob l_warn=no
      delete POCKETS l_warn=no
      delete map l_warn=no
      break
    endif
  endfor
  l_ligpocket = no
  l_optconf = no
  l_dock = no
 endif
  if (Type(T_pocket)!="unknown") delete T_pocket l_warn=no
  if (Type(T_pocket)=="unknown") then
    if (Nof(a_*.H)==0) return "No ligand, cannot continue"
    consensuspocket r_clustdist !l_nocluster
    if (l_ligpocket) consensusligpocket
    keep global T_pocket
    if (Type(T_pocket.cl)=="unknown") add column T_pocket Split(T_pocket.cluster r_clustdist) name="cl"
    add column T_pocket Iarray(Nof(T_pocket) 0) name="nof_cl"
    add column T_pocket Iarray(Nof(T_pocket) 0) name="used"
    add column T_pocket Iarray(Nof(T_pocket) 0) name="check"
    add column T_pocket Count(Nof(T_pocket)) name="objord"
  endif
  for i = 1, Max(T_pocket.cl)
    T_pocket.nof_cl[Index(T_pocket.cl==i)] = Nof(T_pocket.cl==i)
  endfor
  I_tmp = Iarray(0)
  for i_tmp = 1, Max(T_pocket.cl)
    I_tmp //= T_pocket.nof_cl[Index(T_pocket.cl==i_tmp)][1]
  endfor
  I_tmp = Sort(I_tmp reverse)
  i_minnofcl = I_tmp[Min(5 Nof(I_tmp))]
  if (Type(T_pocket.cluster)!="unknown") then
    T_pockettmp = T_pocket[Index(T_pocket.cluster center)]
  else
    T_pockettmp = T_pocket
  endif
  T_pockettmp = T_pockettmp.nof_cl >= i_minnofcl
  l_addpocket = no
  if (l_ligpocket) l_addpocket = yes
  if (!l_addpocket) T_pocket.used [Index(T_pocket.objord == T_pockettmp.objord)] = 1
  if (l_ligpocket) then
    if (!l_nocluster) then
      for i_cl = 1, Max(T_pocket.cl)
        if (Nof(T_pocket.cl==i_cl & T_pocket.pdb == T_ligpocket.pdb)==0) continue
        T_pocket.used[Index(T_pocket.cl==i_cl)] = 0
        T_pocket.used[Index(T_pocket.cl==i_cl & T_pocket.pdb == T_ligpocket.pdb)] = 1
      endfor
    endif
    delete T_ligpocket l_warn=no
    if (l_addpocket) then
      vwMethod = 2
      vwSoftMaxEnergy = 15.
      if (i_maxsel <1) i_maxsel=1
      for i_cl = 1, Max(T_pocket.cl)
        if ((l_nocluster) & (i_cl>1)) break
        if (Nof(Index(T_pocket.cl==i_cl & T_pocket.used==0))==0) continue
        read object s_tmpligobjpath
        I_pdb = Index(T_pocket.cl==i_cl & T_pocket.used==0)
        if (l_nocluster) I_pdb = Index(T_pocket.used==0)
        M_pdb = Matrix(Nof(I_pdb) Nof(a_ligobject.*))
        for i_pdb = 1, Nof(I_pdb)
          print bar N l_info=yes
          s_pdb = T_pocket.pdb[I_pdb[i_pdb]]
          set object a_$s_pdb.
          S_H = Name(a_* & as_H )
          if ((Type(a_ 2)=="ICM") & (T_pocket.conf[I_pdb[i_pdb]]>1)) load conf a_ T_pocket.conf[I_pdb[i_pdb]]
          copy a_ "tmpobj1"
          if ((Type(a_ 2)=="ICM") & (T_pocket.conf[I_pdb[i_pdb]]>1)) load conf a_ 1
          set object a_tmpobj1.
          if (Nof(S_H)!=0) delete a_$S_H
          if (Type(a_ 2)!="ICM") convertObject a_tmpobj1. 1==1 no yes no no yes no ""+( 1==2 ? "water=tight ":"" )+( no ? "tautomer ":"" )
          errorAction = 1
          for i_lig = 1, Nof(a_ligobject.*)
            S_H = Name(a_ligobject.$i_lig)
            copy a_ligobject.$i_lig "tmpobj2"
            move a_tmpobj2. a_tmpobj1.
            show energy a_!$S_H a_$S_H mute
            M_pdb[i_pdb i_lig] = Energy("vw,hb,el")
            delete a_$S_H
          endfor
          errorAction = 2
          delete a_tmpobj1. l_warn=no
        endfor
        M_pdb2 = Matrix(Nof(I_pdb) Nof(a_ligobject.*))
        for i_pdb = 1, Nof(I_pdb)
          M_pdb2[i_pdb ?] = Sort(M_pdb[i_pdb] reverse)
        endfor
        for i_lig = 1, Nof(a_ligobject.*)
          if (Min(M_pdb2[? i_lig])<0.) then
            T_pocket.used[I_pdb[Min(index M_pdb2[? i_lig])]] = 1
            break
          endif
        endfor
        if (Nof(T_pocket.used==1)==0) T_pocket.used[I_pdb[Min(index M_pdb2[? Nof(a_ligobject.*)])]] = 1
        delete a_ligobject. l_warn=no
      endfor
      l_addconf = yes
      if ((!(l_nocluster & Nof(T_pocket.used==1)>=i_maxsel)) & (l_addconf)) then
        read object s_tmpligobjpath
        I_pdb = Count(Nof(T_pocket))
        M_pdb = Matrix(Nof(I_pdb) Nof(a_ligobject.*))
        N = Nof(I_pdb)*3
        for i_pdb = 1, Nof(I_pdb)
          print bar N l_info=yes
          s_pdb = T_pocket.pdb[I_pdb[i_pdb]]
          set object a_$s_pdb.
          S_H = Name(a_* & as_H )
          if ((Type(a_ 2)=="ICM") & (T_pocket.conf[I_pdb[i_pdb]]>1)) load conf a_ T_pocket.conf[I_pdb[i_pdb]]
          copy a_ "tmpobj1"
          if ((Type(a_ 2)=="ICM") & (T_pocket.conf[I_pdb[i_pdb]]>1)) load conf a_ 1
          set object a_tmpobj1.
          if (Nof(S_H)!=0) delete a_$S_H
          if (Type(a_ 2)!="ICM") convertObject a_tmpobj1. 1==1 no yes no no yes no ""+( 1==2 ? "water=tight ":"" )+( no ? "tautomer ":"" )
          errorAction = 1
          for i_lig = 1, Nof(a_ligobject.*)
            S_H = Name(a_ligobject.$i_lig)
            copy a_ligobject.$i_lig "tmpobj2"
            move a_tmpobj2. a_tmpobj1.
            show energy a_!$S_H a_$S_H mute
            M_pdb[i_pdb i_lig] = Energy("vw,hb,el")
            delete a_$S_H
          endfor
          errorAction = 2
          delete a_tmpobj1. l_warn=no
        endfor
        i_maxadd = 10
        if (l_nocluster) i_maxadd = i_maxsel - Nof(T_pocket.used==1)
        add column T_pocket T_pocket.used name="order"
        for i_add = 1, i_maxadd
          M_pdb2 = M_pdb[Index(T_pocket.used==1)]
          if (Nof(T_pocket.used==0)==0) break
          M_pdb3 = M_pdb[Index(T_pocket.used==0)]
          I_lig = Iarray(0)
          for i_lig = 1, Nof(a_ligobject.*)
            if (Min(M_pdb2[? i_lig]) >= 0.) I_lig//=i_lig
          endfor
          if (Nof(I_lig)==0) break
          M_pdb4 = Transpose(Transpose(M_pdb3)[I_lig])
          for i_pdb = 1, Nof(M_pdb4)
            M_pdb4[i_pdb ?] = Sort(M_pdb4[i_pdb] reverse)
          endfor
          for i_lig = 1, Nof(I_lig)
            if (Min(M_pdb4[? i_lig])<0.) then
              i_tmp = Index(T_pocket.used==0)[Min(index M_pdb4[? i_lig])]
              T_pocket.used[i_tmp] = 1
              T_pocket.order[i_tmp] = 1+i_add
              break
            endif
          endfor
          if (i_lig > Nof(I_lig)) break
        endfor
        T_pocket.M_pdb = M_pdb
        add T_pocket header S_ligands append name="ligands"
        for i_lig = 1, Nof(M_pdb[1])
          s_col = "lig_"+i_lig
          add column T_pocket M_pdb[?, i_lig] name=s_col
        endfor
        delete a_ligobject. l_warn=no
      endif
    endif
  endif
  T_pockettmp = T_pocket.used == 1
  delete T_pockettmp.M_pdb l_warn=no
  I_keep = Iarray()
  for i = 1, Nof(T_pocket.used==1)
    j = Index(T_pocket.used==1)[i]
    I_keep //= Index(Name(a_*.) T_pocket.pdb[j])
  endfor
  I_keep = Unique(Sort(I_keep))
  delete a_*.&! ((a_*.)[I_keep])
  as_graph = as_H
  if (Nof(as_graph)!=0) delete Mol(as_graph)
  add column T_pockettmp Iarray(Nof(T_pockettmp) 0) name="ICM"
  add column T_pockettmp Iarray(Nof(T_pockettmp) 1) name="nof_conf"
  add column T_pockettmp Iarray(Nof(T_pockettmp) 0) name="nof_mol"
  add column T_pockettmp Sarray(Nof(T_pockettmp) "") name="name_mol"
  add column T_pockettmp Sarray(Nof(T_pockettmp) "") name="res_mol"
  add column T_pockettmp Iarray(Nof(T_pockettmp) 0) name="nof_Amino"
  add column T_pockettmp Iarray(Nof(T_pockettmp) 0) name="nof_metal"
  add column T_pockettmp Iarray(Nof(T_pockettmp) 0) name="nof_cofac"
  for i_pdb = 1, Nof(a_*.)
    set object a_$i_pdb.
    s_pdb = Name(a_$i_pdb.)[1]
    if (Type(a_ 2)=="ICM") T_pockettmp.ICM[Index(T_pockettmp.pdb==s_pdb)] = 1
    if (Nof(a_ stack)>1) T_pockettmp.nof_conf[Index(T_pockettmp.pdb==s_pdb)] = Nof(a_ stack)
    T_pockettmp.nof_mol[Index(T_pockettmp.pdb==s_pdb)] =  Nof(a_* &! as_H )
    T_pockettmp.name_mol[Index(T_pockettmp.pdb==s_pdb)] = Sum( Name(a_* &! as_H) ",")
    S_tmp = Sarray(0)
    for i_mol = 1, Nof(a_* &! as_H )
      if (Nof(Res((a_* &! as_H)[i_mol])) > 1) then
        S_tmp //= Type((a_* &! as_H)[i_mol] 2)
      else
        if (Name(Res((a_* &! as_H)[i_mol]))[1]=="res") then
          S_tmp //= Sum(Split(Name((a_* &! as_H)[i_mol])[1] "")[2:$] "")
        else
          S_tmp //= Name(Res((a_* &! as_H)[i_mol]))[1]
        endif
      endif
    endfor
    T_pockettmp.res_mol[Index(T_pockettmp.pdb==s_pdb)] = Sum( S_tmp ",")
    T_pockettmp.nof_Amino[Index(T_pockettmp.pdb==s_pdb)] = Nof(Index(Split(T_pockettmp.res_mol[Index(T_pockettmp.pdb==s_pdb)[1]] ",") "Amino" all))
    T_pockettmp.nof_metal[Index(T_pockettmp.pdb==s_pdb)] = Nof(a_M)
    T_pockettmp.nof_cofac[Index(T_pockettmp.pdb==s_pdb)] = Nof(Select(a_H "cofac"))
  endfor
  I_tmp = Index(T_pockettmp.ICM == Max(T_pockettmp.ICM))
  if (Max(T_pockettmp.ICM) == 1) then
    I_tmp = I_tmp[Index(T_pockettmp.nof_conf[I_tmp] Max(T_pockettmp.nof_conf[I_tmp]) all)]
  else
    I_tmp = I_tmp[Index(T_pockettmp.nof_conf[I_tmp] Min(T_pockettmp.nof_conf[I_tmp]) all)]
  endif
  I_tmp = I_tmp[Index(T_pockettmp.nof_Amino[I_tmp] Max(T_pockettmp.nof_Amino[I_tmp]) all)]
  I_tmp = I_tmp[Index(T_pockettmp.nof_cofac[I_tmp] Max(T_pockettmp.nof_cofac[I_tmp]) all)]
  I_tmp = I_tmp[Index(T_pockettmp.nof_metal[I_tmp] Max(T_pockettmp.nof_metal[I_tmp]) all)]
  I_tmp = I_tmp[Index(T_pockettmp.nof_mol[I_tmp] Max(T_pockettmp.nof_mol[I_tmp]) all)]
  i_opt = I_tmp[1]
  s_opt = T_pockettmp.pdb[i_opt]
  l_ICM = no
  set object a_$s_opt.
  if (Type(a_ 2)=="ICM") l_ICM = yes
 if (!l_ICM) then
  if (Max(T_pockettmp.nof_cofac)>0) then
    group table T_cofactmp Name(Res(Select(a_*.H "cofac" ))) "cofac"
    add column T_cofactmp Iarray(Nof(T_cofactmp) 0) name="nof_cofac"
    for i_cofac = 1, Nof(T_cofactmp)
      T_cofactmp.nof_cofac[i_cofac] = Nof(T_cofactmp.cofac==T_cofactmp.cofac[i_cofac])
    endfor
    S_cofac = Unique(Sort(T_cofactmp.cofac[Index(T_cofactmp.nof_cofac==Max(T_cofactmp.nof_cofac))]))
    delete T_cofactmp l_warn=no
    I_opt = Iarray(Nof(T_pockettmp))
    for i_obj = 1, Nof(T_pockettmp)
      s_obj = T_pockettmp.pdb[i_obj]
      S_cofacobj = Name(Res(Select(a_$s_obj.H "cofac" )))
      if (Nof(S_cofacobj)==0) continue
      for i_cofac = 1, Nof(S_cofac)
        s_cofac = S_cofac[i_cofac]
        if (Index(S_cofacobj s_cofac)!=0) I_opt[i_obj] = I_opt[i_obj]+1
      endfor
      I_opt[i_obj] = I_opt[i_obj]+T_pockettmp.nof_cofac[i_obj]
    endfor
    if (I_opt[i_opt]!=Max(I_opt)) then
      i_opt2 = Max(index I_opt)
      s_opt2 = T_pockettmp.pdb[i_opt2]
      if (Nof(Select(a_H "cofac"))!=0) delete Select(a_H "cofac")
      copy a_$s_opt2. "tmpobj"
      move Select(a_tmpobj.H "cofac") a_$s_opt.
      delete a_tmpobj.
      set object a_$s_opt.
      T_pockettmp.nof_mol[i_opt] =  Nof(a_* &! as_H )
      T_pockettmp.name_mol[i_opt] = Sum( Name(a_* &! as_H) ",")
      S_tmp = Sarray(0)
      for i_mol = 1, Nof(a_* &! as_H )
        if (Nof(Res((a_* &! as_H)[i_mol])) > 1) then
          S_tmp //= Type((a_* &! as_H)[i_mol] 2)
        else
          if (Name(Res((a_* &! as_H)[i_mol]))[1]=="res") then
            S_tmp //= Sum(Split(Name((a_* &! as_H)[i_mol])[1] "")[2:$] "")
          else
            S_tmp //= Name(Res((a_* &! as_H)[i_mol]))[1]
          endif
        endif
      endfor
      T_pockettmp.res_mol[i_opt] = Sum( S_tmp ",")
      T_pockettmp.nof_Amino[i_opt] = Nof(Index(Split(T_pockettmp.res_mol[i_opt] ",") "Amino" all))
      T_pockettmp.nof_metal[i_opt] = Nof(a_M)
      T_pockettmp.nof_cofac[i_opt] = Nof(Select(a_* "cofac"))
    endif
  endif
  if (T_pockettmp.nof_metal [i_opt] != Max(T_pockettmp.nof_metal)) then
    i_opt2 = Max(index T_pockettmp.nof_metal)
    s_opt2 = T_pockettmp.pdb[i_opt2]
    delete a_$s_opt.M
    copy a_$s_opt2. "tmpobj"
    move a_tmpobj.M a_$s_opt.
    delete a_tmpobj.
    set object a_$s_opt.
    T_pockettmp.nof_mol[i_opt] =  Nof(a_* &! as_H )
    T_pockettmp.name_mol[i_opt] = Sum( Name(a_* &! as_H) ",")
    S_tmp = Sarray(0)
    for i_mol = 1, Nof(a_* &! as_H )
      if (Nof(Res((a_* &! as_H)[i_mol])) > 1) then
        S_tmp //= Type((a_* &! as_H)[i_mol] 2)
      else
        if (Name(Res((a_* &! as_H)[i_mol]))[1]=="res") then
          S_tmp //= Sum(Split(Name((a_* &! as_H)[i_mol])[1] "")[2:$] "")
        else
          S_tmp //= Name(Res((a_* &! as_H)[i_mol]))[1]
        endif
      endif
    endfor
    T_pockettmp.res_mol[i_opt] = Sum( S_tmp ",")
    T_pockettmp.nof_Amino[i_opt] = Nof(Index(Split(T_pockettmp.res_mol[i_opt] ",") "Amino" all))
    T_pockettmp.nof_metal[i_opt] = Nof(a_M)
    T_pockettmp.nof_cofac[i_opt] = Nof(Select(a_H "cofac"))
  endif
  set object a_$s_opt.
  i_nofmol = Nof(a_*)
  i_nofA = Nof(a_A)
  i_counter = 0
  if (i_nofA!=0) then
    for i_mol = 1, i_nofmol
      if (i_counter == i_nofA) break
      if (Nof((a_*)[i_mol]&a_A)!=0) then
        i_counter = i_counter + 1
      else
        move (a_*)[i_mol] a_$i_nofmol
        i_mol = i_mol-1
      endif
    endfor
  endif
  i_nofH = Nof(a_H)
  i_counter = 0
  if (i_nofH!=0) then
    for i_mol = i_nofA+1, i_nofmol
      if (i_counter == i_nofH) break
      if (Nof((a_*)[i_mol]&a_H)!=0) then
        i_counter = i_counter + 1
      else
        move (a_*)[i_mol] a_$i_nofmol
        i_mol = i_mol-1
      endif
    endfor
  endif
  i_nofM = Nof(a_M)
  i_counter = 0
  if (i_nofM!=0) then
    for i_mol = i_nofA+i_nofH+1, i_nofmol
      if (i_counter == i_nofM) break
      if (Nof((a_*)[i_mol]&a_M)!=0) then
        i_counter = i_counter + 1
      else
        move (a_*)[i_mol] a_$i_nofmol
        i_mol = i_mol-1
      endif
    endfor
    for i_M = 1, i_nofM
      as_M = (a_M)[i_M]
      if (Nof(as_M & a_M/res)!=0) then
        s_type = Sum(Split(Name(as_M & a_M )[1] "")[2:$] "")
        rename as_M & a_M/ s_type type
      endif
      s_type = Name(as_M & a_M/ )[1]
      if (Type(as_M 2)=="Hetatm") rename as_M & a_M/ s_type type
      if (Name(as_M & a_M// )[1]!= Toupper(s_type 1)) rename as_M & a_M//  Toupper(s_type 1)
    endfor
  endif
  set object a_$s_opt.
 endif
  as_rec = a_* &! as_H
  if (Nof(a_* &! as_rec)!=0) delete a_* &! as_rec l_warn=no
  if (Type(a_ 2)!="ICM") then
    print 3
    convertObject a_ 1==1 yes yes no yes yes no ""+( 1==2 ? "water=tight ":"" )+( no ? "tautomer ":"" )
  else
    if (Nof(a_ stack)>1) then
      I_conf = Sort(T_pockettmp.conf[Index(T_pockettmp.pdb == s_opt)] reverse)
      delete stack
      load stack a_
      i_nofconf = Nof(a_ stack)
      for i_conf = 1, i_nofconf
        j_conf = i_nofconf-i_conf+1
        if (Index(I_conf j_conf)==0) delete conf j_conf
      endfor
      store stack a_
      load conf a_ 1
    endif
  endif
  if (Nof(a_ conf)==0) then
    store conf atom a_
    set comment a_ conf Nof(a_ conf) String(Name(Obj(a_)))
  else
    delete stack
    for i_conf = 1, Nof(a_ conf)
      load conf a_ i_conf
      store conf atom
    endfor
    store stack a_
    delete stack
    for i_conf = 1, Nof(a_ conf)
      load conf a_ i_conf
      set comment a_ conf i_conf String(Name(Obj(a_)))
    endfor
    load conf a_ 1
  endif
  if (Name(a_)[1] != "recobject") then
    delete a_recobject. l_warn=no
    rename a_ "recobject"
  endif
  for i_M = 1, Nof(a_M)
    as_M = (a_M)[i_M]
    if (Nof(as_M & a_M/res)!=0) then
      s_type = Sum(Split(Name(as_M & a_M )[1] "")[2:$] "")
      rename as_M & a_M/ s_type type
    endif
    s_type = Name(as_M & a_M/ )[1]
    if (Type(as_M 2)=="Hetatm") rename as_M & a_M/ s_type type
    if (Name(as_M & a_M//!vt* )[1]!= Toupper(s_type 1)) rename as_M & a_M//!vt*  Toupper(s_type 1)
  endfor
  if (Nof(a_*.)>1) then
    for i_pdb = 1, Nof(T_pockettmp)
      s_pdb = T_pockettmp.pdb[i_pdb]
      if (s_pdb == s_opt) continue
      set object a_$s_pdb.
     if (Nof(a_ stack)<2) then
      if (Nof(a_ & as_H)>0) delete a_ & as_H
      S_name = Split(T_pockettmp.name_mol[i_pdb] ",")
      S_res = Split(T_pockettmp.res_mol[i_pdb] ",")
      i_nofmol = Nof(a_*)
      i_nofA = Nof(a_A)
      i_counter = 0
      if (i_nofA!=0) then
        for i_mol = 1, i_nofmol
          if (i_counter == i_nofA) break
          if (Nof((a_*)[i_mol]&a_A)!=0) then
            i_counter = i_counter + 1
          else
            move (a_*)[i_mol] a_$i_nofmol
            i_mol = i_mol-1
          endif
        endfor
      endif
      i_nofH = Nof(a_H)
      i_counter = 0
      if (i_nofH!=0) then
        for i_mol = i_nofA+1, i_nofmol
          if (i_counter == i_nofH) break
          if (Nof((a_*)[i_mol]&a_H)!=0) then
            i_counter = i_counter + 1
          else
            move (a_*)[i_mol] a_$i_nofmol
            i_mol = i_mol-1
          endif
        endfor
      endif
      i_nofM = Nof(a_M)
      i_counter = 0
       if (i_nofM!=0) then
        for i_mol = i_nofA+i_nofH+1, i_nofmol
          if (i_counter == i_nofM) break
          if (Nof((a_*)[i_mol]&a_M)!=0) then
            i_counter = i_counter + 1
          else
            move (a_*)[i_mol] a_$i_nofmol
            i_mol = i_mol-1
          endif
        endfor
        for i_M = 1, i_nofM
          as_M = (a_M)[i_M]
          if (Nof(as_M & a_M/res)!=0) then
            s_type = Sum(Split(Name(as_M & a_M )[1] "")[2:$] "")
            rename as_M & a_M/ s_type type
          endif
          s_type = Name(as_M & a_M/ )[1]
          if (Type(as_M 2)=="Hetatm") rename as_M & a_M/ s_type type
          if (Name(as_M & a_M// )[1]!= Toupper(s_type 1)) rename as_M & a_M//  Toupper(s_type 1)
        endfor
      endif
     endif
    endfor
    as_source = a_recobject.
    as_sel = a_*. &! as_source
    set object a_recobject.
    errorActionold = errorAction
    errorAction = "none"
    set object a_recobject.
    for i_pdb = 1, Nof(T_pockettmp)
      s_pdb = T_pockettmp.pdb[i_pdb]
      if (s_pdb == s_opt) continue
      set object a_$s_pdb.
      if (T_pockettmp.conf[i_pdb]>1) load conf a_ T_pockettmp.conf[i_pdb]
      mrcStack as_source a_ no yes
    endfor
    errorAction = errorActionold
    set object as_source
    if (Nof(a_ conf )==0) store conf atom a_
    load conf a_ 1
    delete a_*. &! as_source
  else
    set object a_1.
    if (Nof(a_ conf)==0) then
      store conf atom a_
      set comment a_ conf i_conf String(Name(Obj(a_)))
    endif
  endif
  s_parentdir = Path()
  if (Type(s_tmpligobjpath)!="unknown") read object s_tmpligobjpath
  set object a_1.
 endif #l_resulttab
# if (!l_dock) then
# else
 if (!l_resulttab) then
  i_nofobj = Nof(a_1. conf)
  M=i_nofobj
  N=i_noflig
  l_oldopt = no
 if (l_oldopt) then
  as_recpatch = Res(Sphere(a_ligobject. a_1. 5.))
  delete a_ligobject.
  s_currdockobjpath = s_tempDir+"currdockobj"+Iproc( )+".ob"
  write object a_*. s_currdockobjpath delete
  s_tmpdockdir = s_tempDir +"tmpdock"+Iproc( )
  if Exist(s_tmpdockdir) then
    delete system Sarray( s_tmpdockdir + "/*" directory )
    delete directory s_tmpdockdir
  endif
  make directory s_tmpdockdir
  set directory s_tmpdockdir
  as_graph = as_recpatch
  mstmpdockrun s_tmpligsdfpath s_tmpligobjpath no
  if !Exist("tmpdock_answers1.ob") then
    set directory s_parentdir
    return "Initial 4D Docking failed, cannot proceed"
  else
    scanMakeHitList "tmpdock" "tmpdock_answers1" Name(Name( "tmpdock_answers1" ),simple) 1 ==2 yes 1 ==1 no ? 100 : 0
    add column tmpdock_answers1 Rarray(Nof(tmpdock_answers1) 999.) name="Lig_Rmsd" index=2
    for i_lig = 1, i_noflig
      read mol tmpdock_answers1.mol[i_lig] name="tmplig"
      R_tmplig = Rarray(0)
      for j_lig = 1, Nof(a_ligobject.*)
        if ((i_lig==j_lig) | Chemical(a_tmplig.H)==Chemical(a_ligobject.$j_lig)) R_tmplig//=Srmsd(a_tmplig.H//!h*,vt* a_ligobject.$j_lig chemical)
      endfor
      tmpdock_answers1.Lig_Rmsd[i_lig] = Max(Min(R_tmplig) 0.1)
      delete a_tmplig. l_warn=no
    endfor
  endif
  i_optimized = 0
  i_optimized = 1
  if ((Nof(tmpdock_answers1.Lig_Rmsd>2.)==0)|(i_nofobj==1)|(!l_optconf)) then
    i_optimized = 1
  endif
  I_usedbest = T_pockettmp.used
  R_srmsdbest = tmpdock_answers1.Lig_Rmsd
  i_correctbest = Nof(tmpdock_answers1.Lig_Rmsd<=2.)
  if (i_optimized != 1) then
    sprintf " Info> Optimizing %d Pockets vs %d ligands",M,N
    print bar s_out M l_info=yes
  else
    M = 2
    sprintf " Info> Docking %d ligands",N
    print bar s_out M l_info=yes
  endif
  for i_cycle = 1, i_nofobj-1
    if (i_optimized!=0) break
    I_correcttry = Iarray(i_nofobj  0)
    M_correcttry = Matrix(i_nofobj i_noflig)
    for i_try = 1, i_nofobj
      if (i_optimized!=0) break
      if (I_usedbest[i_try] == 0) continue
      I_usedtry = I_usedbest
      I_usedtry[i_try] = 0
      delete a_!1.
      set directory s_parentdir
      s_tmpdockdir = s_tempDir +"tmpdock"+Iproc( )
      if Exist(s_tmpdockdir) then
        delete system Sarray( s_tmpdockdir + "/*" directory )
        delete directory s_tmpdockdir
      endif
      make directory s_tmpdockdir
      set directory s_tmpdockdir
      as_graph = as_recpatch
      mstmpdockrun s_tmpligsdfpath s_tmpligobjpath Index(I_usedtry 1 all) no
      if !Exist("tmpdock_answers1.ob") then
        continue
      else
        scanMakeHitList "tmpdock" "tmpdock_answers1" Name(Name( "tmpdock_try1" ),simple) 1 ==2 yes 1 ==1 no ? 100 : 0
        add column tmpdock_try1 Rarray(Nof(tmpdock_try1) 999.) name="Lig_Rmsd" index=2
        for i_lig = 1, i_noflig
          read mol tmpdock_try1.mol[i_lig] name="tmplig"
          R_tmplig= Rarray(0)
          for j_lig = 1, Nof(a_ligobject.*)
            if ((i_lig==j_lig) | Chemical(a_tmplig.H)==Chemical(a_ligobject.$j_lig)) R_tmplig//=Srmsd(a_tmplig.H//!h*,vt* a_ligobject.$j_lig chemical)
          endfor
          tmpdock_try1.Lig_Rmsd[i_lig] = Max(Min(R_tmplig) 0.1)
          delete a_tmplig. l_warn=no
        endfor
      endif
      I_correcttry[i_try] = Nof(tmpdock_try1.Lig_Rmsd<=2.)
      M_correcttry[i_try,?] = tmpdock_try1.Lig_Rmsd
      delete tmpdock_try1 l_warn=no
    endfor
    if (Max(I_correcttry)>i_correctbest) then
      R_tmp = Rarray(Nof(Index(I_correcttry Max(I_correcttry ) all)) 0.)
      for i_tmp = 1, Nof(R_tmp)
        R_tmp[i_tmp] = Sum(Log(Max(M_correcttry [Index(I_correcttry Max(I_correcttry ) all)[i_tmp],?] Rarray(i_noflig 0.1))))
      endfor
      i_usedbest = Index(I_correcttry Max(I_correcttry ) all)[Min(index R_tmp)]
      T_pockettmp.used[i_usedbest] = 0
      I_usedbest = T_pockettmp.used
      R_srmsdbest = M_correcttry[i_usedbest]
      i_correctbest = Max(I_correcttry)
    elseif (Max(I_correcttry)==i_correctbest) then
      r_tmpbest = Sum(Log(Max(R_srmsdbest Rarray(i_noflig 0.1))))
      R_tmp = Rarray(Nof(Index(I_correcttry Max(I_correcttry ) all)) 0.)
      for i_tmp = 1, Nof(R_tmp)
        R_tmp[i_tmp] = Sum(Log(Max(M_correcttry [Index(I_correcttry Max(I_correcttry ) all)[i_tmp],?] Rarray(i_noflig 0.1))))
      endfor
      if (Min(R_tmp)<=r_tmpbest) then
        i_usedbest = Index(I_correcttry Max(I_correcttry ) all)[Min(index R_tmp)]
        T_pockettmp.used[i_usedbest] = 0
        I_usedbest = T_pockettmp.used
        R_srmsdbest = M_correcttry[i_usedbest]
        i_correctbest = Max(I_correcttry)
      else
        i_optimized = 1
      endif
    else
      i_optimized = 1
    endif
    print bar M l_info=yes
  endfor
  I_usedbest = T_pockettmp.used
  set directory s_parentdir
  delete a_!1.
  if (Nof(I_usedbest 1)!=Nof(T_pockettmp)) then
    delete a_copy. l_warn=no
    copy a_1. "copy" stack
    set object a_copy.
    I_conf = Sort(Index(I_usedbest 1 all) reverse)
    i_nofconf = Nof(a_copy. stack)
    delete stack
    load stack a_
    for i_conf = 1, i_nofconf
      j_conf = i_nofconf-i_conf+1
      if (Index(I_conf j_conf)==0) delete conf j_conf
    endfor
    store stack a_
    load conf a_ 1
    delete a_1.
    s_objname = T_pockettmp.pdb [Index(T_pockettmp.used==1)][1]
    rename a_ "recobject"
  else
  endif
  delete a_ligobject. l_warn=no
  read object s_tmpligobjpath
 endif
 if (l_RECCONF) then
  l_docklig = no
  if (!l_docklig) then
    if (Nof(a_ligobject.)==0) read object s_tmpligobjpath
    set object a_recobject.
    i_nofconf =  Max(1 Nof(a_ conf))
  else
    as_recpatch = Res(Sphere(a_ligobject. a_1. 5.))
    s_tmpdockdir = s_tempDir +"tmpdock"+Iproc( )
    if Exist(s_tmpdockdir) then
      delete system Sarray( s_tmpdockdir + "/*" directory )
      delete directory s_tmpdockdir
    endif
    make directory s_tmpdockdir
    set directory s_tmpdockdir
    as_graph = as_recpatch
    dock2SetupReceptor "tmpdock" a_1. as_graph no "none"
    s_out = currentDockProj.data[1] + "_rec"
    set object a_$s_out.
    i_nofconf = Max(1 Nof(a_ conf))
    if (Nof(a_ conf ) > 1) then
      write object delete
      dockTableValue currentDockProj.data[1] "s_grid4DFlex" "string" "embedded"
      currentDockProj.l_readyMaps=no
    endif
    dock5CalcMaps currentDockProj.data[1] 0.5 4.0 no
    currentDockProj.data[2:9] = { "dock3DbScanSetup" "no" "no"}//Replace(s_tmpligsdfpath ".sdf$" ".inx") //{"mol" "auto" "yes" "no"}
    currentDockProj.data[3] = "yes"
#    currentDockProj.data[4] = "yes"
    currentDockProj.data[9] = "yes"
    dock3DbScanSetup currentDockProj.data[1] no yes "default"
    dockUpdateGlobals currentDockProj.data[1] -2
    currentDockProj.data[8] = "yes"
    dockTableValue currentDockProj.data[1] "r_ScoreThreshold" "real" "999."
    dockTableValue currentDockProj.data[1] "r_mfScoreThreshold" "real" "999."
    dockTableValue currentDockProj.data[1] "i_minLigSize" "integer" "50"
    dockTableValue currentDockProj.data[1] "i_maxLigSize" "integer" "1000"
    dockTableValue currentDockProj.data[1] "i_maxHdonors" "integer" "10"
    dockTableValue currentDockProj.data[1] "i_maxNO" "integer" "20"
    dockTableValue currentDockProj.data[1] "i_maxTorsion" "integer" "20"
    dockTableValue currentDockProj.data[1] "l_samplePyramid" "logical" "yes"
    dockTableValue currentDockProj.data[1] "r_maxPk" "real" "20."
    dockTableValue currentDockProj.data[1] "r_minPk" "real" "-20"
    dockUpdateGlobals currentDockProj.data[1] -1
    currentDockProj.data[8] = "yes"
  endif
 if (!l_docklig) then
  M_pdb = Matrix(i_nofconf Nof(a_ligobject.*))
  vwMethod = 2
  vwSoftMaxEnergy = 15.
  for i_conf = 1, i_nofconf
    set object a_recobject.
    if (Nof(a_ conf)>1) load conf a_ i_conf
    delete a_tmpobj1. l_warn=no
    copy a_ "tmpobj1"
    for i_lig = 1, Nof(a_ligobject.*)
      delete a_tmpobj2. l_warn=no
      S_H = Name(a_ligobject.$i_lig)
      copy a_ligobject.$i_lig "tmpobj2"
      delete a_tmpobjcomb. l_warn=no
      copy a_tmpobj1. "tmpobjcomb"
      move a_tmpobj2. a_tmpobjcomb.
      set object a_tmpobjcomb.
      show energy mute a_!$S_H a_$S_H
      M_pdb[i_conf i_lig] =  Energy("vw,hb,el" )
      delete a_tmpobjcomb. a_tmpobj2. l_warn=no
    endfor
    delete a_tmpobj1. l_warn=no
  endfor
  for i_lig = 1, Nof(a_ligobject.*)
    I_conf = Iarray(0)
    for i_conf = 1, i_nofconf
      if (M_pdb[i_conf i_lig]<=0.) I_conf //= i_conf
    endfor
    if (I_conf!=Iarray(0)) then
      set field a_ligobject.$i_lig name="_RECCONF_" " "+Sum(Tostring(Unique(Sort(I_conf))) " ")+" "
    else
      if (!l_optconf) set field a_ligobject.$i_lig name="_RECCONF_" " "+Sum(Tostring(Count(Nof(a_recobject. conf))) " ")+" "
    endif
  endfor
 else
  for i_lig = 1, Nof(a_ligobject.*)
    if Exist("tmpdock_tmpligobj1.ob") delete system "tmpdock_tmpligobj1.ob"
    delete a_tmpligobj. l_warn=no
    copy a_ligobject.$i_lig "tmpligobj"
    set object a_tmpligobj.
    currentDockProj.data[8] = "yes"
    group table "tmpligobj" Chemical(a_tmpligobj.H exact hydrogen) "mol"
    write binary tmpligobj "tmpligobj" delete
    delete tmpligobj l_warn=no
    s_cmd= " effort="+ 10.*i_nofconf + " -n input=tmpligobj.icb name=" + "answers" + " -a " + "tmpdock"
    s_cmd= "-s " + s_cmd
    s_cmd= s_cmd + " -z "
    s_cmd= Path(origin, " " + " " + " \"" + s_icmhome + "/_dockScan\" " + s_cmd + " > " + "tmpdock" + "_all.ou" )
    currentDockProj.data[13]= "tmpdock" + "_" + "answers" + "1"
    currentDockProj.data[1] = "tmpdock"
    I_conf = Iarray(0)
    s_out = Unix(s_cmd)
    if Exist("tmpdock_tmpligobj1.ob") then
      read object "tmpdock_tmpligobj1.ob" name="tmpdocklig"
      set object a_tmpdocklig.
      load stack a_
      if (Nof(a_tmpdocklig. conf)!=0) then
        load conf a_tmpdocklig. 1
        I_conf //= grid4Dlayer
        r_minen = Energy(stack )[1]
        for i_conf = 2,  Nof(a_tmpdocklig. conf)/2+1
          if (Energy(stack )[i_conf]>0.) break
          load conf a_tmpdocklig. i_conf
          if (Srmsd(a_tmpdocklig.//!h*,vt* a_tmpligobj.//!h*,vt* chemical) > 1.) continue
          I_conf //= grid4Dlayer
        endfor
      endif
      delete a_tmpdocklig. l_warn=no
    endif
    delete a_tmpligobj. l_warn=no
    if (I_conf!=Iarray(0)) then
      set field a_ligobject.$i_lig name="_RECCONF_" " "+Sum(Tostring(Unique(Sort(I_conf))) " ")+" "
    else
      if (!l_optconf) set field a_ligobject.$i_lig name="_RECCONF_" " "+Sum(Tostring(Count(Nof(a_tmpdock_rec. conf))) " ")+" "
    endif
  endfor
 endif
  write object a_ligobject. s_tmpligobjpath delete
  if (l_optconf) then
    I_finalconf = Unique({1}//Tointeger(Sort(Split(Sum(Trim(Field(a_ligobject.* "_RECCONF_" ) all ) " ") " "))))
    if (Nof(I_finalconf)!=Nof(a_1. stack)) then
      delete T_pockettmp.M_pdb l_warn=no
      if (i_opt!=1) move T_pockettmp[i_opt] 1
      delete a_*. &! a_1. &! a_ligobject.
      T_pockettmp.used = Iarray(Nof(T_pockettmp) 0)
      T_pockettmp.used[I_finalconf] = 1
      set object a_recobject.
      I_removeconf = Sort(Index(T_pockettmp.used ==0) reverse)
      for i_remove = 1, Nof(I_removeconf)
        j_remove = I_removeconf[i_remove]
        delete conf a_recobject. j_remove
      endfor
      set object a_ligobject.
      add column T_pockettmp Iarray(Nof(T_pockettmp) 0) name="newused" index=7
      for i_finalconf = 1, Nof(I_finalconf)
        T_pockettmp.newused[I_finalconf[i_finalconf]] = i_finalconf
      endfor
      for i_lig = 1, Nof(a_ligobject.*)
        I_tmpRECCONF = Tointeger(Split(Trim(Field(a_ligobject.$i_lig "_RECCONF_"  )[1] all) " "))
        if (Nof(I_tmpRECCONF)!=0) set field a_ligobject.$i_lig name="_RECCONF_" " "+Sum(Tostring(T_pockettmp.newused[I_tmpRECCONF]) " ")+" "
      endfor
      write object a_ligobject. s_tmpligobjpath delete
    endif
  endif
 endif
 endif
 if (l_dock) then
  set directory s_parentdir
  as_recpatch = Res(Sphere(a_ligobject. a_1. 5.))
  delete a_!1.
  s_tmpdockdir = s_tempDir +"tmpdock"+Iproc( )
  if Exist(s_tmpdockdir) then
    delete system Sarray( s_tmpdockdir + "/*" directory )
    delete directory s_tmpdockdir
  endif
  make directory s_tmpdockdir
  set directory s_tmpdockdir
  as_graph = as_recpatch
  mstmpdockrun s_tmpligsdfpath s_tmpligobjpath no
  if (!l_resulttab) print bar M l_info=yes
  if !Exist("tmpdock_answers1.ob") then
    set directory s_parentdir
    return "Initial 4D Docking failed, cannot proceed"
  else
    delete tmpdock_answers1 l_warn=no
    scanMakeHitList "tmpdock" "tmpdock_answers1" Name(Name( "tmpdock_answers1" ),simple) 1 ==2 yes 1 ==1 no ? 100 : 0
    add column tmpdock_answers1 Rarray(Nof(tmpdock_answers1) 999.) name="Lig_Rmsd" index=2
    i_noflig = Nof(tmpdock_answers1)
    for i_lig = 1, i_noflig
      read mol tmpdock_answers1.mol[i_lig] name="tmplig"
      R_tmplig = Rarray(0)
      for j_lig = 1, Nof(a_ligobject.*)
        if ((i_lig==j_lig) | Chemical(a_tmplig.H)==Chemical(a_ligobject.$j_lig)) R_tmplig//=Srmsd(a_tmplig.H//!h*,vt* a_ligobject.$j_lig chemical)
      endfor
      tmpdock_answers1.Lig_Rmsd[i_lig] = Max(Min(R_tmplig) 0.1)
      delete a_tmplig. l_warn=no
    endfor
  endif
  delete dock_answers l_warn=no
  rename tmpdock_answers1 "dock_answers"
  keep dock_answers
  scanStandaloneHitList Name( dock_answers table)
  delete a_tmpdock_rec. l_warn=no
  if (!l_resulttab) then
    T_pocket.used = Iarray(Nof(T_pocket) 0)
    T_pocket.used[Index(T_pocket.pdb== T_pockettmp.pdb[Index(T_pockettmp.used==1)])] = 1
    delete T_pockettmp l_warn=no
    print bar "done\n"  l_info=yes
  endif
 endif
  delete a_ligtemplate. a_tmpdock_rec. l_warn=no
  rename a_ligobject. "ligtemplate"
  set object a_recobject.
  if (Nof(a_ conf)>1) load conf a_ 1
  if (!l_resulttab) then
    add header T_pocket Collection( ) name="recobj"
    add header T_pocket Collection() name="ligobj"
    T_pocket.recobj[s_proj] = Parray(object a_recobject.)
    T_pocket.ligobj[s_proj] = Parray(object a_ligtemplate.)
  endif
  set directory s_parentdir
endmacro
#
macro msSelectPocketBG s_proj ("") s_sdf ("") l_dock (yes) i_mode (1) i_maxconf (10) auto
HELP="""
  Start: several loaded PDB objects with the same protein by sequence.
  Output: a new ICM-object a_recobject. with a stack of conformations from those pdbs.
  Output: a new a_ligtemplate. object with multiple ligand-molecules from the pdbs.
  This macro submits background job for the msSelectPocket macro
  Options:
  <s_proj>: Name of the Pocketome entry, binary file for Pocketome entry, or object file
  <s_sdf> : Name of the optional sdf file, if specified, must be 3D coordinates of the correct poses
  <i_mode>: 1. No docking
            2. Single conformation only as representative
            3. Multi-conformations (up to 10) added by receptor-ligand compatibility
            4. Clustering of pocket residues, add compatible conformation from each cluster
"""
  l_info = no; l_commands=no; l_warn=no
  s_proj = Trim(s_proj all)
  s_sdf = Trim(s_sdf all)
  if ((s_proj == "") & (Nof(as_graph)==0)) return "No object or file name specified"
  s_currDir = Path()
  if (Nof(as_graph)!=0) then
    l_obj = yes
    as_obj = Obj(as_graph)
  else
    l_obj = no
  endif
  if (s_proj!="") then
    if (Extension(s_proj)!="") then
      if (Path(s_proj)=="") s_proj = s_currDir+s_proj
      if (!Exist(s_proj)) return "File specified does not exist"
    endif
  endif
  if (s_sdf!="") then
    if (Extension(s_proj)!="") then
      if (Path(s_proj)=="") s_proj = s_currDir+s_proj
      if (!Exist(s_proj)) return "SDF file specified does not exist"
    endif
  endif
  s_tmpDir = s_tempDir +"tmpDir"+Iproc( )
  if Exist(s_tmpDir) then
    delete system Sarray( s_tmpDir + "/*" directory )
    delete directory s_tmpDir
  endif
  make directory s_tmpDir
  set directory s_tmpDir
  if (l_obj) write object as_obj "tmpobj.ob" delete
  S_tmpscript={"call _startup"}
  S_tmpscript//="set directory \""+s_tmpDir+"/\""
  if (l_obj) S_tmpscript//="read object \"tmpobj.ob\""
  if (l_dock) then
    if (i_mode==1) then
      S_tmpscript//="msSelectPocket \""+s_proj+"\" \""+s_sdf+"\" no yes yes yes yes 2.0 1"
    elseif (i_mode==2) then
      S_tmpscript//="msSelectPocket \""+s_proj+"\" \""+s_sdf+"\" no yes yes yes yes 2.0 "+Tostring(i_maxconf)
    elseif (i_mode==3) then
      S_tmpscript//="msSelectPocket \""+s_proj+"\" \""+s_sdf+"\" yes yes yes yes no 2.0 1"
    endif
    S_tmpscript//="write binary a_*. T_pocket dock_answers \"tmpoutput.icb\" delete"
  else
    if (i_mode==1) then
      S_tmpscript//="msSelectPocket \""+s_proj+"\" \""+s_sdf+"\" no yes no yes yes 2.0 1"
    elseif (i_mode==2) then
      S_tmpscript//="msSelectPocket \""+s_proj+"\" \""+s_sdf+"\" no yes no yes yes 2.0 "+Tostring(i_maxconf)
    elseif (i_mode==3) then
      S_tmpscript//="msSelectPocket \""+s_proj+"\" \""+s_sdf+"\" yes yes no yes no 2.0 1"
    endif
    S_tmpscript//="write binary a_*. T_pocket \"tmpoutput.icb\" delete"
  endif
  S_tmpscript//="l_info=yes"
  S_tmpscript//="show version"
  S_tmpscript//="quit"
  S_tmpscript//="l_info=yes"
  write Sum(S_tmpscript "\n")+"\n" "_msSelectPocket" delete
  if (Field(Version( ) 2 "/")!~"Win*") sys chmod 755 _msSelectPocket
  s_cmd = Path( macro, "-P"+s_icmhome, s_tmpDir+"/_msSelectPocket")
  fname_out = s_tmpDir+"/tmpoutput.icb"
  sprintf "read binary %s\ndelete system Sarray(\"%s\" +\"/*\" directory)\ndelete directory \"%s\" ", String(fname_out string), s_tmpDir, s_tmpDir
  make background s_cmd command=s_out info="msSelectPocket finished. Press OK to load the result"
  print " Info> msSelectPocket started in background. You will be notified when the job is complete."
  printf " Info> bg_cmd:  %s\n", s_cmd
  printf " Info> output:  %s\n", fname_out
  l_info=yes
  if (!l_dock) print " Info> No docking"
  if (i_mode==1) print " Info> A single conformation is selected as a representative"
  if (i_mode==2) print " Info> Up to "+Tostring(i_maxconf)+" conformations will be selected by receptor-ligand compatibility to reduce the number of stack conformations"
  if (i_mode==3) print " Info> Clustering of pocket residues, compatible conformation from each cluster is added, will take a very long time..."
  l_info=no
  set directory s_currDir
endmacro
#
macro mstmpdockrun s_ligsdf ("") s_ligtmpl ("") I_conf (Iarray(0)) l_final (no) l_scare (no) r_effort (10.) auto
  s_ligsdf = Trim(s_ligsdf all)
  s_ligtmpl = Trim(s_ligtmpl all)
  if (Extension(s_ligsdf) != ".sdf") return "s_ligsdf has to be a .sdf path"
  if !Exist(s_ligsdf) return "s_ligsdf specified does not exist"
  if ((s_ligtmpl!="")&(Extension(s_ligtmpl) != ".ob")) return "s_ligtmpl has to be a .ob path"
  if ((s_ligtmpl!="")&!Exist(s_ligtmpl)) return "s_ligtmpl specified does not exist"
  if (Nof(Res(as_graph))==0) return "Please select residues of the pocket"
  currentDockProj.data[8] = "yes"
  if (I_conf == Iarray(0)) then
    tempsel = as_graph
    as_rec = a_*
  else
    delete a_copy. l_warn=no
    copy Obj(as_graph) "copy" stack
    set object a_copy.
    I_conf = Sort(I_conf reverse)
    i_nofconf = Nof(a_copy. stack)
    delete stack
    load stack a_
    for i_conf = 1, i_nofconf
      j_conf = i_nofconf-i_conf+1
      if (Index(I_conf j_conf)==0) delete conf j_conf
    endfor
    store stack a_
    load conf a_ 1
    tempsel = Res(Sphere(as_graph a_copy. 1.))
    as_rec = a_copy.
  endif
  dock2SetupReceptor "tmpdock" as_rec tempsel no "none"
  s_out = currentDockProj.data[1] + "_rec"
  set object a_$s_out.
  if (Nof(a_ conf ) > 1) then
    write object delete
    dockTableValue currentDockProj.data[1] "s_grid4DFlex" "string" "embedded"
    currentDockProj.l_readyMaps=no
  elseif (l_scare) then
    dock7stackSCARE currentDockProj.data[1]
    write object delete
    dockTableValue currentDockProj.data[1] "s_grid4DFlex" "string" "embedded"
    currentDockProj.l_readyMaps=no
  endif
  Error()
  dock5CalcMaps currentDockProj.data[1] 0.5 4.0 no
  if (Error()) return
  i_nofconf = Max(1 Nof(a_ conf ))
  if (s_ligtmpl!="") then
    read object s_ligtmpl
    dockUpdateGlobals currentDockProj.data[1] -2
    dockSetupTemplate currentDockProj.data[1] currentDockProj.data[1] + "_tmplt.ob" a_ ""
    dockTableValue currentDockProj.data[1] "s_templateMatch" "string" "APF"
  endif
  if (!Exist(Replace(s_ligsdf ".sdf" ".inx"))) makeIndexChemDb s_ligsdf Replace(s_ligsdf ".sdf" ".inx") "mol" { "ID" }
  currentDockProj.data[2:9] = { "dock3DbScanSetup" "no" "no"}//Replace(s_ligsdf ".sdf$" ".inx") //{"mol" "auto" "yes" "no"}
  currentDockProj.data[3] = "yes"
#  currentDockProj.data[4] = "yes"
  currentDockProj.data[9] = "yes"
  dock3DbScanSetup currentDockProj.data[1] no yes "default"
  dockUpdateGlobals currentDockProj.data[1] -2
  currentDockProj.data[8] = "yes"
  dockTableValue currentDockProj.data[1] "r_ScoreThreshold" "real" "999."
  dockTableValue currentDockProj.data[1] "r_mfScoreThreshold" "real" "999."
  dockTableValue currentDockProj.data[1] "i_minLigSize" "integer" "50"
  dockTableValue currentDockProj.data[1] "i_maxLigSize" "integer" "1000"
  dockTableValue currentDockProj.data[1] "i_maxHdonors" "integer" "10"
  dockTableValue currentDockProj.data[1] "i_maxNO" "integer" "20"
  dockTableValue currentDockProj.data[1] "i_maxTorsion" "integer" "20"
  dockTableValue currentDockProj.data[1] "l_samplePyramid" "logical" "yes"
  dockTableValue currentDockProj.data[1] "r_maxPk" "real" "20."
  dockTableValue currentDockProj.data[1] "r_minPk" "real" "-20"
  dockUpdateGlobals currentDockProj.data[1] -1
  currentDockProj.data[8] = "yes"
  if (!l_final) then
    s_cmd= " effort="+ Min(r_effort*i_nofconf 200.) + " name=" + "answers" + " -a " + "tmpdock -z"
    s_cmd= "-s " + s_cmd
  else
    s_cmd= " effort="+ Min(r_effort*i_nofconf 200.) + " name=" + "answers" + " -a " + "tmpdock -z"
    s_cmd ="-S " + s_cmd
  endif
  s_cmd= s_cmd + " -z "
  s_cmd= Path(origin, " " + " " + " \"" + s_icmhome + "/_dockScan\" " + s_cmd + " > " + "tmpdock" + "_all.ou" )
  currentDockProj.data[13]= "tmpdock" + "_" + "answers" + "1"
  currentDockProj.data[1] = "tmpdock"
  s_out = Unix(s_cmd)
endmacro
#
macro consensuspocket r_dist (1.0) l_cluster (no) auto
  s_skipMessages = "1599"
  errorActionold = errorAction
  errorAction = "none"
  if (Nof(as_graph)!=0) then
    as_ligand = as_graph
  elseif (Nof(Select(a_*.H/ "ligand" ))>0) then
    as_ligand = Select(a_*.H/ "ligand" )
  else
    as_ligand = a_*.H
  endif
  if (Nof(as_ligand)==0) return "No ligand, cannot do consensuspocket"
  as_obj = Obj(Sphere(as_ligand a_*.A 4.))
  S_obj = Name(as_obj)
  group table T_pocket S_obj "pdb"
  S_obj = Name(as_obj)
  add column T_pocket Iarray(Nof(T_pocket) 1) name="conf"
  for i_obj = 1, Nof(as_obj)
    s_obj = S_obj[i_obj]
    if ((Type(a_$s_obj. 2)=="ICM") & (Nof(a_$s_obj. stack )>1)) then
      for i_conf = 2, Nof(a_$s_obj. stack )
        i_row = Index(T_pocket.pdb==s_obj)[$]
        add T_pocket T_pocket[i_row] i_row+1
        T_pocket.conf[i_row+1] = i_conf
      endfor
    endif
  endfor
  M_pdb = Matrix(Nof(T_pocket) Nof(T_pocket))
  if (Nof(Select(a_*.A/ "psite" ))>0) then
    as_atom = a_*.//!h*,vt* & Res(Sphere(Select(a_*.A/ "psite" ) a_*.A 0.5))
  else
    as_atom = a_*.//!h*,vt* & Res(Sphere(as_ligand a_*.A 4.))
  endif
 if (l_cluster) then
  N = (Nof(T_pocket)-1)*3
#  print bar "Comparing Pocket" N l_info = yes
  for i = 1, Nof(T_pocket)-1
    print bar N l_info=yes
    s_i = T_pocket.pdb[i]
    set object a_$s_i.
    if (Max(T_pocket.conf[Index(T_pocket.pdb==s_i)])>1) load conf a_ T_pocket.conf[i]
    copy a_ "tmpobj1"
    as_atom = as_atom | Sphere(a_$s_i. & as_atom a_tmpobj1. 1.)
    as_moli = Mol(a_tmpobj1.A & as_atom)
    for j = i+1, Nof(T_pocket)
      s_j = T_pocket.pdb[j]
      set object a_$s_j.
      if (Max(T_pocket.conf[Index(T_pocket.pdb==s_j)])>1) load conf a_ T_pocket.conf[j]
      copy a_ "tmpobj2"
      as_atom = as_atom | Sphere(a_$s_j. & as_atom a_tmpobj2. 1.)
      as_molj = Mol(a_tmpobj2.A & as_atom)
      R_tmp = Rarray(1 6.)
      for k = 1, Nof(as_moli)
        for l = 1, Nof(as_molj)
          if  (Distance( Sequence(as_moli[k]) Sequence(as_molj[l])) > 0.2) continue
          if (Distance(Sequence(Res(as_moli[k] &as_atom)) Sequence(Res(as_molj[l] &as_atom)))>1.) continue
          if (Distance(Res(as_moli[k] &as_atom) Res(as_molj[l] &as_atom))>6.) continue
          r_tmp = Srmsd(as_moli[k] &as_atom as_molj[l] &as_atom align)
          if !Error() R_tmp //= r_tmp
        endfor
      endfor
      if (Nof(R_tmp)!=0) M_pdb[i j] = Min(R_tmp)
      M_pdb[j i] = M_pdb[i j]
      delete a_tmpobj2.
    endfor
    delete a_tmpobj1.
  endfor
  print bar "Done Comparing..." l_info=yes
  group table T_pocket append header M_pdb
  make tree T_pocket full "UPGMA" split="cl" distance = "M_pdb"
  split T_pocket.cluster r_dist
 else
  add column T_pocket Count(Nof(T_pocket)) name="cl"
 endif
  keep T_pocket
  errorAction = errorActionold
endmacro
#
macro consensusligpocket
  if (Nof(as_graph)==0) then
    if (Nof(Select(a_*.H/ "ligand" ))>0) then
      as_ligand = Select(a_*.H/ "ligand" )
    else
      as_ligand = a_*.H
    endif
    if (Nof(as_ligand)==0) return "No ligand, cannot do consensusligpocket"
    as_obj = Obj(Sphere(as_ligand a_*.A 4.))
  else
    as_obj = Obj(as_graph) & Obj(Sphere(a_*.H a_*.A 4.))
  endif
  S_obj = Name(as_obj)
  group table T_ligpocket S_obj "pdb"
  M_cpd = Matrix(Nof(T_ligpocket) Nof(T_ligpocket))
  if (Type(chem)!="unknown") delete chem l_warn=no
  as_ligand = a_*.H & as_obj &! Select(a_*.H "cofac" ) &! Select(a_*.H "metal" )
  if (Nof(as_ligand)==0) return "No ligand, cannot do consensusligpocket"
  extractLigand (as_ligand)[1] "3D" no "" no
  for i_cpd = 2, Nof(as_ligand)
    extractLigand (as_ligand)[i_cpd] "3D" yes Name( chem table ) no
  endfor
#  add column chem  Field(Field(chem.sel 2 "_" ) 1 ".") name="pdb"
  add column chem Replace(Field(chem.sel 1 ".") "^a_" "") name="pdb"
#  make tree chem full "UPGMA" split="cl" label="%name;" view="mol" name=""
  scanClusterHitList "chem"
  add column chem Iarray(Nof(chem) 0) name="nof_cl"
  for i = 1, Max(chem.cl)
    chem.nof_cl[Index(chem.cl==i)] = Nof(chem.cl==i)
  endfor
  I_tmp = Iarray(0)
  for i_tmp = 1, Max(chem.cl)
    I_tmp //= chem.nof_cl[Index(chem.cl==i_tmp)][1]
  endfor
  I_tmp = Sort(I_tmp reverse)
#  I_tmp = Unique(Sort(T_pocket.nof_cl reverse))
  i_minnofcl = I_tmp[Min(10 Nof(I_tmp))]
  chem2 = chem[Index(chem.cluster center)]
  chem2 = chem2.nof_cl >= i_minnofcl
  if (Nof(chem2)>10) then
    sort chem2.nof_cl reverse
    chem2 = chem2[1:10]
  endif
  T_ligpocket = T_ligpocket[Index(T_ligpocket.pdb==chem2.pdb)]
#  T_ligpocket = T_ligpocket[Index(T_ligpocket.pdb==Unique(Sort(chem.pdb[Index(chem.cluster center)]))) ]
  if (Type(chem)!="unknown") delete chem l_warn=no
  if (Type(chem2)!="unknown") delete chem2 l_warn=no
  keep T_ligpocket
endmacro
#
macro evalAPFdiversity os_in l_ds (no)
  os_in = Obj( os_in )
  mybox = Box( a_*. 5. )
  make map potential "gc" a_.//vt1 mybox
  n = Nof( os_in )
  apfmt = Matrix(Nof(Rarray(m_gc)),n*7)
  GRID.gpGaussianRadius = 1.0
  for i = 1,Nof( os_in )
    printf "Calculating APF for ligand %d out of %d\r" i n l_info=yes
    set object os_in [i]
    make map potential "gp" mybox
    apfmt[?,     i] = Rarray(m_g1)
    apfmt[?,n*1 +i] = Rarray(m_g2)
    apfmt[?,n*2 +i] = Rarray(m_g3)
    apfmt[?,n*3 +i] = Rarray(m_g4)
    apfmt[?,n*4 +i] = Rarray(m_g5)
    apfmt[?,n*5 +i] = Rarray(m_g6)
    apfmt[?,n*6 +i] = Rarray(m_g7)
  endfor
  R_rms = Rarray(Nof(Rarray(m_gc)))
  R_cons= Rarray(Nof(Rarray(m_gc)))
#
  for j = 1 Nof(R_rms)
    for i = 1,7
      r = Rmsd( apfmt[j,n*(i-1)+1:n*i] )
      R_rms[j] = R_rms[j] + r*r
      R_cons[j]= R_cons[j]+Abs(Mean(apfmt[j,n*(i-1)+1:n*i]))/(r+.5)
    endfor
  endfor
  R_rms = Sqrt(R_rms)
  n1= Nof(m_g1 1)
  n2= Nof(m_g1 2)
  n3= Nof(m_g1 3)
  for i1 = 1 n1
    for i2 = 1 n2
      for i3 = 1 n3
        m_gc[ i1 i2 i3 ] = R_cons[ i1 + (i2-1)*n1 + (i3-1)*n1*n2 ]
        m_gl[ i1 i2 i3 ] = R_rms [ i1 + (i2-1)*n1 + (i3-1)*n1*n2 ]
      endfor
    endfor
  endfor
  rename m_gc "m_apfCons"
  rename m_gl "m_apfRmsd"
  make grob m_apfCons header exact 4.
  make grob m_apfRmsd header exact  .5
  if(l_ds)then
    display g_apfCons g_apfRmsd
    color g_apfRmsd magenta
    color g_apfCons green
  endif
  keep m_apfCons g_apfCons m_apfRmsd g_apfRmsd
endmacro
#
macro calcAPFsim s_tab1 ("") s_tab2 ("") l_replaceoriginal (yes) l_keepmatrix (yes) auto
HELP = """
  Calculate APF similarity between two tables with 3D mol, or between a table and graphical selection
  It will return a column 'APFsim' and a Similarity Matrix 'M_APFsim' to table 1
  Syntax:
    calcAPFsim <s_tab1> <s_tab2> # Similarity to table 2 will be calculated
    calcAPFsim <s_tab1>          # Graphical selection as_graph will be used instead
"""
  l_info = l_commands = no
  s_tab1 = Trim(s_tab1 all)
  if (s_tab1 == "") return "Please specify table name"
  if (Type($s_tab1)!="table") "Table specified not found"
  s_tab2 = Trim(s_tab2 all)
  if ((s_tab2 =="") & (Nof(a_*.H & as_graph)==0)) return "Either specify a second table name or select ligand objects"
  if (s_tab2!="") then
    if (Type($s_tab2)!="table") return "Second table specified not found"
  endif
  T_tmpmacro1 = $s_tab1
  if (s_tab2!="") then
    T_tmpmacro2 = $s_tab2
  else
    group table T_tmpmacro2 Chemical(a_*.H & as_graph exact hydrogen) "mol"
  endif
  add column T_tmpmacro1 Rarray(Nof(T_tmpmacro1) 0.) name="APFsim"
  if(Nof(pmf)==0)read pmf s_icmhome+"APF"
  M_APFsim = Matrix(Nof(T_tmpmacro1) Nof(T_tmpmacro2))
  for i_1 = 1, Nof(T_tmpmacro1)
    for i_2 = 1, Nof(T_tmpmacro2)
      T_tmpmacro3 = T_tmpmacro1[i_1]
      add T_tmpmacro3 T_tmpmacro2[i_2]
      M_tmpmacro = Score(T_tmpmacro3.mol field)
      M_APFsim[i_1 i_2] = 1.-((M_tmpmacro[1,1]+M_tmpmacro[2,2]-2.*M_tmpmacro[1,2])/(M_tmpmacro[1,1]+M_tmpmacro[2,2]))
      delete T_tmpmacro3
    endfor
    T_tmpmacro1.APFsim[i_1] = Max(M_APFsim[i_1])
  endfor
  if (Type(T_tmpmacro1.M_APFsim)!="unknown") delete T_tmpmacro1.M_APFsim
  if (l_keepmatrix) group table T_tmpmacro1 append header M_APFsim
  if (l_replaceoriginal) then
    delete $s_tab1
    rename T_tmpmacro1 s_tab1
    keep $s_tab1
  else
    delete T_APFsim l_warn=no
    rename T_tmpmacro1 "T_APFsim"
    keep T_APFsim
  endif
endmacro
#
macro calcAPFscore s_hitlist ("") r_apfratio (1.) auto
  s_hitlist = Trim(s_hitlist all)
  if (s_hitlist == "") return "Please specify a table name"
  if (Type($s_hitlist)!="table") return "Table specified does not exist"
  if (Type($s_hitlist.Score )!="rarray") return "Column Score does not exist"
#  if (Type($s_hitlist.APFsim )!="rarray") return "APFsim column required, please use the macro calcAPFsim to calculate APF similarity to template first"
  if ((Type($s_hitlist.NNScore )!="rarray") & (Type($s_hitlist.RTCNNscore )=="rarray")) then
    add column $s_hitlist $s_hitlist.RTCNNscore name="NNScore" index=Index(Name($s_hitlist) s_hitlist+".Score")
    add column $s_hitlist Normalize($s_hitlist.NNScore "rmsd" 0.)+Normalize(Trim($s_hitlist.Score, -99.,0.) "rmsd" 0.) name="NormScore" index=Index(Name($s_hitlist) s_hitlist+".NNScore")
  endif
  if (Type($s_hitlist.APFsim )=="rarray") then
    add column $s_hitlist  (Normalize(Trim($s_hitlist.Score,  -99., 0. ) "rmsd" 0.)-Normalize($s_hitlist.APFsim "rmsd" 0.))* $s_hitlist.APFsim \
    name="ScoreAPFsim" index=Index(Name($s_hitlist) s_hitlist+".Score")
    if (Type($s_hitlist.NNScore )=="rarray") then
      add column $s_hitlist  (Normalize(Trim($s_hitlist.NNScore,  -99., 0. ) "rmsd" 0.)-Normalize($s_hitlist.APFsim "rmsd" 0.))* $s_hitlist.APFsim \
      name="NNScoreAPFsim" index=Index(Name($s_hitlist) s_hitlist+".NNScore")
      add column $s_hitlist  ($s_hitlist.NormScore-Normalize($s_hitlist.APFsim "rmsd" 0.))* $s_hitlist.APFsim \
      name="NormScoreAPFsim" index=Index(Name($s_hitlist) s_hitlist+".NormScore")
    endif
  endif
  keep $s_hitlist
endmacro
#
macro calcRMSD s_hitlist ("") auto
  l_info = l_commands = l_warn = no
  l_minRedraw = no
  s_hitlist = Trim(s_hitlist all)
  if (s_hitlist=="") return "Please specify name of the hitlist"
  if (Type($s_hitlist)!="table") return "Please specify a valid table as hitlist"
  if (Type($s_hitlist.mol 2)!="3D") return "Please specify a valid 3D table as hitlist"
  if (Nof(Mol(as_graph) )==0) return "Graphical selection as_graph needed"
  T_tmpmacro = $s_hitlist
  add column T_tmpmacro Rarray(Nof(T_tmpmacro) 999.) name="Lig_Rmsd" index=Index(Name(T_tmpmacro) "T_tmpmacro.NAME")+1
  N = Nof(T_tmpmacro)
  sprintf " Info> Calcluating Srmsd for %d ligands in table '%s' ",N,s_hitlist
  print bar s_out  N l_info=yes
  for i_lig = 1, Nof(T_tmpmacro)
    R_tmp = Rarray(1 999.)
    read mol T_tmpmacro.mol[i_lig] name="tmplig"
    for i_mol = 1, Nof(Mol(as_graph))
      if (Chemical(a_tmplig.H)==Chemical(Mol(as_graph)[i_mol])) R_tmp//=Srmsd(a_tmplig.H//!h*,vt* Mol(as_graph)[i_mol] chemical)
      if (Distance(Chemical(a_tmplig.H) Chemical(Mol(as_graph)[i_mol]))[1,1]==0) R_tmp//=Srmsd(a_tmplig.H//!h*,vt* Mol(as_graph)[i_mol] chemical)
    endfor
    s_name = Trim(T_tmpmacro.NAME[i_lig ] all)
    as_mol = Mol(as_graph & a_*.$s_name)
    if (Nof(as_mol)!=0) then
      for i_mol = 1, Nof(as_mol)
#        R_tmp //= Srmsd(T_tmpmacro.mol[i_lig] as_mol[i_mol])
        R_tmp //= Srmsd(a_tmplig.H//!h*,vt* as_mol[i_mol] chemical)
      endfor
    else
      if (Type(T_tmpmacro.name)=="sarray") then
        s_name = Trim(T_tmpmacro.name[i_lig ] all)
        as_mol = Mol(as_graph & a_*.$s_name)
        if (Nof(as_mol)!=0) then
          for i_mol = 1, Nof(as_mol)
            R_tmp //= Srmsd(a_tmplig.H//!h*,vt* as_mol[i_mol] chemical)
          endfor
        endif
      endif
    endif
    T_tmpmacro.Lig_Rmsd[i_lig] = Max(Min(R_tmp) 0.1)
    delete a_tmplig. l_warn=no
    print bar N  l_info=yes
  endfor
  delete $s_hitlist l_warn=no
  rename T_tmpmacro s_hitlist
  keep $s_hitlist
  print bar "done\n"  l_info=yes
endmacro
#
macro calcRMSE R_1 (Rarray(0)) R_2 (Rarray(0)) auto
  l_info = l_commands = no
  if (R_1 == Rarray(0)) return "Please specify the first and second rarray"
  if (R_2 == Rarray(0)) return "Please specify the first and second rarray"
  if (Nof(R_1)!=Nof(R_2)) return "First and second rarray have different number of elements"
  r_out = Sqrt(Sum(Power((R_1 - R_2) 2))/Nof(R_1))
  keep r_out
  print "RMSE between the two rarray is " r_out
endmacro
#
macro calctaub R_1 R_2 l_silence (no) auto
  l_info = l_commands = l_warn = no
  if (Nof(R_1)!=Nof(R_2)) return "Please specify two rarray with identical size"
#  if ((Nof(R_1 == Toreal("ND"))!=0) | (Nof(R_2 == Toreal("ND"))!=0)) return "Please specify two rarray with non ND values"
  r_p = 0.; r_q = 0.; r_x0 = 0.; r_y0 = 0.
  for i = 1, Nof(R_1)-1
    for j = i+1, Nof(R_1)
      if ((R_1[i]==R_1[j]) & (R_2[i]==R_2[j])) continue
      if (R_1[i]==R_1[j]) then
        r_x0 += 1
      elseif (R_2[i]==R_2[j]) then
        r_y0 += 1
      elseif (((R_1[i]-R_1[j])*(R_2[i]-R_2[j]))>0) then
        r_p += 1
      else
        r_q += 1
      endif
    endfor
  endfor
  if (Sqrt((r_p+r_q+r_x0)*(r_p+r_q+r_y0)) == 0) then
    r_out = 0.
    print "Cannot calculate Tau-b for array with identical values"
  else
    r_out = (r_p - r_q) / Sqrt((r_p+r_q+r_x0)*(r_p+r_q+r_y0))
  endif
  if (!l_silence) print "The Kendall Tau-b Correlation Coefficient is" r_out
  keep r_out
endmacro
#
macro calctaubM M_1 M_2
  l_info = l_commands = l_warn = no
  if (Nof(M_1)!=Nof(M_2)) return "Please specify two matrices with identical size"
  if (Nof(M_1[1])!=Nof(M_2[1])) return "Please specify two matrices with identical size"
  r_p = 0.; r_q = 0.; r_x0 = 0.; r_y0 = 0.
  for h = 1, Nof(M_1)
    R_1 = M_1[h]
    R_2 = M_2[h]
    for i = 1, Nof(R_1)-1
      for j = i+1, Nof(R_1)
        if ((R_1[i]==R_1[j]) & (R_2[i]==R_2[j])) continue
        if (R_1[i]==R_1[j]) then
          r_x0 += 1
        elseif (R_2[i]==R_2[j]) then
          r_y0 += 1
        elseif (((R_1[i]-R_1[j])*(R_2[i]-R_2[j]))>0) then
          r_p += 1
        else
          r_q += 1
        endif
      endfor
    endfor
  endfor
  r_out = (r_p - r_q) / Sqrt((r_p+r_q+r_x0)*(r_p+r_q+r_y0))
  print "The Kendall Tau-b Correlation Coefficient is" r_out
  keep r_out
endmacro
#
macro oniongroup s_tab ("") l_cluster (no) i_group (4) auto
HELP = """
  Add a column 'group' which can be used to separate the chemical table into training set and external test set
  Syntax:
    oniongroup <s_tab> l_cluster i_group
    <s_tab>: Chemical table name
    <l_cluster>: If yes, the table will be clustered by chemical fingerprint at 0.3 distance, the compounds in smallest cluster will be assigned the highest group number
                 If no, the compounds with the longest distance from anything else will be assigned the highest group number
    <i_group>: Maximum number of group, with default value of 4, the compounds with group==4 can be taken out as external test set
  Example:
    oniongroup 'LIG' yes 4 #Chemical table 'LIG' clustered and divided into 4 groups
"""
  l_info = l_commands = no
  s_tab = Trim(s_tab all)
  if (s_tab=="") return "No table specified"
  if (i_group <= 1) return "Group number should be greater than 1"
  T_tmpmacro = $s_tab
  add column T_tmpmacro Count(Nof(T_tmpmacro)) name="idxtmp"
  add column T_tmpmacro Iarray(Nof(T_tmpmacro) 1) name="group"
  if (l_cluster) then
    i_check = 0
    delete T_tmpmacro.cluster l_warn=no
    delete T_tmpmacro.cl T_tmpmacro.ord T_tmpmacro.size l_warn=no
    make tree T_tmpmacro full "UPGMA" split="cl"  view="mol" name=""
    i_check = 0
    for i_multi = 1,5
      if (i_check==1) break
      r_split = 0.4-(i_multi-1)*0.05
      split T_tmpmacro.cluster r_split
      add column T_tmpmacro Iarray(Nof(T_tmpmacro) 0) name="size"
      for i_macro = 1, Max(T_tmpmacro.cl)
        T_tmpmacro.size[Index(T_tmpmacro.cl==i_macro)] = Nof(T_tmpmacro.cl==i_macro)
      endfor
      sort T_tmpmacro.cl; sort T_tmpmacro.size reverse
      I_macro2 = Unique(T_tmpmacro.cl)
      group table T_tmpmacro2 I_macro2 "cl" Mod(Count(Nof(I_macro2)) i_group) "group"
      T_tmpmacro2.group[Index(T_tmpmacro2.group==0)] = i_group
      for i_tmpmacro2 = 1, Nof(T_tmpmacro2)
        T_tmpmacro.group[Index(T_tmpmacro.cl==T_tmpmacro2.cl[i_tmpmacro2])] = T_tmpmacro2.group[i_tmpmacro2]
      endfor
      delete T_tmpmacro2 l_warn=no
      sort T_tmpmacro.idxtmp
      if (Nof(T_tmpmacro.group==i_group)>=3) i_check=1
    endfor
    for i_multi = 2, 4
      break
      r_multi = Toreal(i_multi)
      if (i_check==1) break
      delete T_tmpmacro.cluster l_warn=no
      delete T_tmpmacro.cl T_tmpmacro.ord l_warn=no
      make tree T_tmpmacro full "UPGMA" split="cl"  view="mol" name=""
      split T_tmpmacro.cluster 0.6-0.1*r_multi
      split
#    T_tmpmacro.cl = Split(T_tmpmacro.cluster 0.3 )
      if (Max(T_tmpmacro.cl)<i_group) return "No of cluster smaller than group number, cannot proceed"
      add column T_tmpmacro Iarray(Nof(T_tmpmacro) 0) name="group"
      for i_trial = 1, 1000
        if (i_check==1) break
        group table T_tmpmacro2 Count(Max(T_tmpmacro.cl)) "cl"
        add column T_tmpmacro2 Random(1 i_group Nof(T_tmpmacro2)) name="group"
        for i_macro = 1, Max(T_tmpmacro.cl)
          T_tmpmacro.group[Index(T_tmpmacro.cl==i_macro)] = T_tmpmacro2.group[i_macro]
        endfor
        i_check = 1
        for j_group = 1, i_group
          if (Nof(T_tmpmacro.group==j_group)>r_multi*Nof(T_tmpmacro)/i_group) i_check = 0
          if (Nof(T_tmpmacro.group==j_group)<=1./r_multi*Nof(T_tmpmacro)/i_group) i_check = 0
          if (Type(T_tmpmacro.pkd)=="rarray") then
            if (Nof(T_tmpmacro.pkd>5. & T_tmpmacro.group==j_group) > r_multi*Nof(T_tmpmacro.pkd>5.)/i_group) i_check = 0
            if (Nof(T_tmpmacro.pkd>5. & T_tmpmacro.group==j_group) < 1./r_multi*Nof(T_tmpmacro.pkd>5.)/i_group) i_check = 0
          endif
        endfor
        delete T_tmpmacro2 l_warn=no
      endfor
    endfor
    if (i_check==0) return "Distribution of compounds not ideal, probably not enough ligands for external test set, cannot proceed..."
#    sort T_tmpmacro.cl ; sort T_tmpmacro.size
#    for i_g = 1, i_group-1
#      I_cl =  Unique(T_tmpmacro.cl[(i_g-1)*Nof(T_tmpmacro)/i_group+1:i_g*Nof(T_tmpmacro)/i_group])
#      T_tmpmacro.group[Index(T_tmpmacro.group<=i_g & T_tmpmacro.cl==I_cl)] = i_group-i_g+1
#    endfor
    sort T_tmpmacro.idxtmp
    I_tmpmacro = T_tmpmacro.group
    delete T_tmpmacro; T_tmpmacro = $s_tab
    add column T_tmpmacro I_tmpmacro name="group"
  else
    M_tmpmacro = Distance(T_tmpmacro.mol)
    for i_tmp = 1, Nof(M_tmpmacro)
      M_tmpmacro[i_tmp,i_tmp] = 1.
    endfor
    for i_groupno = 1, i_group-1
      I_tmpmacro = Index(T_tmpmacro.group ==1)
      add column T_tmpmacro Rarray(Nof(T_tmpmacro) 0.) name="mindisttmp"
      T_tmpmacro.mindisttmp[I_tmpmacro] = Min(M_tmpmacro[I_tmpmacro])
      sort T_tmpmacro.mindisttmp reverse
      T_tmpmacro.group[1:Integer(Nof(T_tmpmacro)/i_group)] = Iarray(Integer(Nof(T_tmpmacro)/i_group) i_group+1-i_groupno)
      sort T_tmpmacro.idxtmp
    endfor
    delete T_tmpmacro.idxtmp T_tmpmacro.mindisttmp
  endif
  delete $s_tab l_warn=no
  rename T_tmpmacro s_tab
  keep $s_tab
endmacro
#
macro calcPIP s_seq ("") S_seq (Sarray(0)) l_pH (no) r_pH (7.4) auto
HELP = """
  Calculation of Protein Isoelectric Point or Net Charge at a specific pH
  Syntax:
    calcPIP <s_seq> <S_seq> <r_pH>
    Either specify:
    <s_seq>: Name of sequence already loaded in ICM or its residue content e.g. MTTSTLLFVLA....
    <S_seq>: String array of the sequences name or their residue content
    <l_pH>: If no, calculate the isoelectric point; if yes, calculate the net charge at the pH specified
    <r_pH>: only used when l_pH == yes, calculate the net charge of protein at r_pH
"""
  l_commands = l_info = l_warn = no
  if ((s_seq=="") & (S_seq==Sarray(0))) return "Please specify either Name or Content of a single sequence or a list of sequences"
  if (s_seq != "") S_seq = Sarray(1 s_seq)
  R_protein = {7.284, 4.719, 8.729, 3.885, 4.766, 5.734, 11.31, 9.886, 9.248}
  R_protein2 = {0.3405, 0.3261, 0.737, 2.22, 1.434, 0.8082, 0.3792, 0.4076, 2.384}
  R_peptide = {9.517, 2.382, 8.298, 3.955, 4.404, 6.122, 10.53, 12.41, 10.07}
  R_peptide2 = {0.8034, 0.8716, 0.8343, 1.232, 0.9353, 0.8379, 1.14, 0.9233, 0.9194}
  R_oldprotein = {9.094,2.869,7.555,3.872,4.412,5.637,9.052,11.84,10.85}
  R_oldpeptide = {9.564,2.383,8.297,3.877,4.317,6.018,10.517,12.503,10.071}
  R_oldprotein2 = Rarray(9 1.)
  R_oldpeptide2 = Rarray(9 1.)
  R_sign = {1.,-1.,-1.,-1.,-1.,1.,1.,1.,-1.}
  S_res = {"C","D","E","H","K","R","Y"}
  R_result = Toreal(Sarray(Nof(S_seq) "ND"))
  I_length = Iarray(Nof(S_seq) 0)
  for i_seq = 1, Nof(S_seq)
    s_seq = S_seq[i_seq]
    s_seq = Trim(s_seq all)
    if (Index(Name(sequence) s_seq)!=0) then
      s_seq = String($s_seq)
    else
      s_seq = String(Sequence(Sum(Split(s_seq "\n" )!~">*" "\n")))
    endif
    if (Length(s_seq) < 50) then
      R_para = R_peptide
      R_para2 = R_peptide2
    else
      R_para = R_protein
      R_para2 = R_protein2
    endif
    R_res = Rarray(7 0.)
    for i_res = 1, Nof(R_res)
      R_res[i_res] = Toreal(Nof(s_seq S_res[i_res]))
    endfor
    R_res = 1.//1.//R_res
    if (!l_pH) then
      R_pH = {0., 7.4, 14.}
      R_charge = Toreal(Sarray(3 "ND"))
      i_maxcycle = 100
    else
      R_pH = {0.}//r_pH//{14.}
      R_charge = 999.//Toreal("ND")//-999.
      i_maxcycle = 1
    endif
    for i_cycle = 1, i_maxcycle
      for i_pH = 1, Nof(R_pH)
        if (R_charge[i_pH]!=Toreal("ND")) continue
        R_charge[i_pH] = 0.
        for i_para = 1, Nof(R_para)
          R_charge[i_pH] = R_charge[i_pH] + R_res[i_para]*R_sign[i_para]/(1.+Power(10. R_sign[i_para]*R_para2[i_para]*(R_pH[i_pH]-R_para[i_para])))
        endfor
      endfor
      if ((Max(R_pH)-Min(R_pH)<=0.001)|(i_cycle==i_maxcycle)) break
      if (Sign(R_charge[2])==0.) then
        break
      elseif (Sign(R_charge[2])==-1.) then
        R_pH[3] = R_pH[2]
        R_charge[3] = R_charge[2]
        R_pH[2] = (R_pH[1]+R_pH[2])/2.
        R_charge[2] = Toreal("ND")
      elseif (Sign(R_charge[2])==1.) then
        R_pH[1] = R_pH[2]
        R_charge[1] = R_charge[2]
        R_pH[2] = (R_pH[3]+R_pH[2])/2.
        R_charge[2] = Toreal("ND")
      endif
    endfor
    if (!l_pH) then
      R_result[i_seq] = R_pH[2]
    else
      R_result[i_seq] = R_charge[2]
    endif
    I_length[i_seq] = Length(s_seq)
  endfor
  R_out = R_result
  print "The length(s) of the Protein/Peptide:" Sum(Tostring(I_length) ",")
  if (!l_pH) then
    print "The Predicted Protein/Peptide Isoelectric Point(s):" Sum(Tostring(Integer(R_out*100.)/100.) ",")
  else
    print "The Predicted Net Protein Charge at pH:" r_pH ":" Sum(Tostring(Integer(R_out*10.)/10.) ",")
  endif
  print "The Predicted result is kept in R_out"
  keep R_out
endmacro
#
function PredictPIP S_seq l_pH r_pH
  R_protein = {7.284, 4.719, 8.729, 3.885, 4.766, 5.734, 11.31, 9.886, 9.248}
  R_protein2 = {0.3405, 0.3261, 0.737, 2.22, 1.434, 0.8082, 0.3792, 0.4076, 2.384}
  R_peptide = {9.517, 2.382, 8.298, 3.955, 4.404, 6.122, 10.53, 12.41, 10.07}
  R_peptide2 = {0.8034, 0.8716, 0.8343, 1.232, 0.9353, 0.8379, 1.14, 0.9233, 0.9194}
  R_oldprotein = {9.094,2.869,7.555,3.872,4.412,5.637,9.052,11.84,10.85}
  R_oldpeptide = {9.564,2.383,8.297,3.877,4.317,6.018,10.517,12.503,10.071}
  R_oldprotein2 = Rarray(9 1.)
  R_oldpeptide2 = Rarray(9 1.)
  R_sign = {1.,-1.,-1.,-1.,-1.,1.,1.,1.,-1.}
  S_res = {"C","D","E","H","K","R","Y"}
  R_result = Toreal(Sarray(Nof(S_seq) "ND"))
  I_length = Iarray(Nof(S_seq) 0)
  for i_seq = 1, Nof(S_seq)
    s_seq = S_seq[i_seq]
    s_seq = Trim(s_seq all)
    if (Index(Name(sequence) s_seq)!=0) then
      s_seq = String($s_seq)
    else
      s_seq = String(Sequence(Sum(Split(s_seq "\n" )!~">*" "\n")))
    endif
    if (Length(s_seq) < 50) then
      R_para = R_peptide
      R_para2 = R_peptide2
    else
      R_para = R_protein
      R_para2 = R_protein2
    endif
    R_res = Rarray(7 0.)
    for i_res = 1, Nof(R_res)
      R_res[i_res] = Toreal(Nof(s_seq S_res[i_res]))
    endfor
    R_res = 1.//1.//R_res
    if (!l_pH) then
      R_pH = {0., 7.4, 14.}
      R_charge = Toreal(Sarray(3 "ND"))
      i_maxcycle = 100
    else
      R_pH = {0.}//r_pH//{14.}
      R_charge = 999.//Toreal("ND")//-999.
      i_maxcycle = 1
    endif
    for i_cycle = 1, i_maxcycle
      for i_pH = 1, Nof(R_pH)
        if (R_charge[i_pH]!=Toreal("ND")) continue
        R_charge[i_pH] = 0.
        for i_para = 1, Nof(R_para)
          R_charge[i_pH] = R_charge[i_pH] + R_res[i_para]*R_sign[i_para]/(1.+Power(10. R_sign[i_para]*R_para2[i_para]*(R_pH[i_pH]-R_para[i_para])))
        endfor
      endfor
      if ((Max(R_pH)-Min(R_pH)<=0.001)|(i_cycle==i_maxcycle)) break
      if (Sign(R_charge[2])==0.) then
        break
      elseif (Sign(R_charge[2])==-1.) then
        R_pH[3] = R_pH[2]
        R_charge[3] = R_charge[2]
        R_pH[2] = (R_pH[1]+R_pH[2])/2.
        R_charge[2] = Toreal("ND")
      elseif (Sign(R_charge[2])==1.) then
        R_pH[1] = R_pH[2]
        R_charge[1] = R_charge[2]
        R_pH[2] = (R_pH[3]+R_pH[2])/2.
        R_charge[2] = Toreal("ND")
      endif
    endfor
    if (!l_pH) then
      R_result[i_seq] = R_pH[2]
    else
      R_result[i_seq] = R_charge[2]
    endif
    I_length[i_seq] = Length(s_seq)
  endfor
  R_out = R_result
  return R_out
endfunction
#
macro msAPFpredict s_predict ("") s_train ("") s_activitycol ("pkd") l_cluster (yes) l_dockterms (yes) i_mintrainset (50) i_maxtrainset (500) auto
  l_info = l_commands = l_warn = no
  s_predict = Trim(s_predict all)
  s_train = Trim(s_train all)
  s_predictcol = s_activitycol+"_APFpred"
  s_predictcol2 = s_activitycol+"_DockAPFpred"
  if (s_predict == "") return "Please specify the name of the table you want to predict"
  if (s_train == "") return "Please specify the name of the table you want to train"
  if (Extension(s_predict)=="") then
    if (Type($s_predict)!="table") return "Prediction table specified does not exist"
  else
    if (!Exist(s_predict)) return "Prediction table specified does not exist"
    if (Extension(s_predict)==".icb") read binary s_predict
    if (Extension(s_predict)==".sdf") read table mol s_predict
    s_predict = Name(s_predict)
    if (Type($s_predict)!="table") return "Prediction table specified does not exist"
  endif
  if (Extension(s_train)=="") then
    if (Type($s_train)!="table") return "Prediction table specified does not exist"
  else
    if (!Exist(s_train)) return "Prediction table specified does not exist"
    if (Extension(s_train)==".icb") read binary s_train
    if (Extension(s_train)==".sdf") read table mol s_train name=Name(s_train)
    s_train= Name(s_train)
    if (Type($s_train)!="table") return "Prediction table specified does not exist"
  endif
  if (Type($s_predict.mol 2)!="3D") return "3D column mol is required in the prediction table"
  if (Type($s_train.mol 2)!="3D") return "3D column mol is required in the training table"
  if (Type($s_train.$s_activitycol)!="rarray") return "An rarray activity column is required for the training table"
  T_macropredict = $s_predict
  T_macrotrain = $s_train
  if (l_cluster) then
    delete T_macropredict.cl T_macropredict.ord T_macropredict.CO T_macropredict.cluster T_macropredict.M_dist l_warn=no
    scanClusterHitList "T_macropredict"
    split T_macropredict.cluster 0.5
    T_macropredict.cl = Split(T_macropredict.cluster 0.5)
  endif
  delete T_macropredict.M_APFsim T_macropredict.MolApfQsar T_macrotrain.MolApfQsar T_macropredict.ATOM_CONTRIB T_macrotrain.ATOM_CONTRIB l_warn=no
  delete T_macropredict.tmprfmod T_macrotrain.tmprfmod l_warn=no
  delete T_macropredict.$s_predictcol T_macropredict.$s_predictcol2 l_warn=no
  S_traincol = {"Hbond","Hphob","VwInt","Eintl","Dsolv","SolEl","tmplAPF"}
  S_traincol2 = {"MolApfQsar"}
  for i_traincol = 1, Nof(S_traincol)
    s_traincol = S_traincol[i_traincol]
    if ((Type(T_macropredict.$s_traincol)=="rarray") & (Type(T_macropredict.$s_traincol)=="rarray")) S_traincol2 //= s_traincol
  endfor
  add column T_macropredict Toreal(Sarray(Nof(T_macropredict) "ND")) name=s_predictcol
  if (l_dockterms & Nof(S_traincol2)!=1) add column T_macropredict Toreal(Sarray(Nof(T_macropredict) "ND")) name=s_predictcol2
  add column T_macropredict Toreal(Sarray(Nof(T_macropredict) "ND")) name="TrainAPFSim"
  if (Type(T_macropredict.cl)=="iarray") then
    i_maxcl = Max(T_macropredict.cl)
  else
    i_maxcl = 1
  endif
  M = i_maxcl
  sprintf " Info> Training and predicting for %d group of compounds for table '%s' ",M,s_predict
  print bar s_out M l_info=yes

  for i_cl = 1, i_maxcl
    delete T_macropredict2 T_macrotrain2 l_warn=no
    if (i_maxcl == 1) then
      T_macropredict2 = T_macropredict
    else
      if (Nof(T_macropredict.cl==i_cl)==0) continue
      T_macropredict2 = T_macropredict.cl == i_cl
    endif
    calcAPFsim "T_macropredict2" "T_macrotrain"
    delete r_sim l_warn=no
    i_minset = Max(i_mintrainset*2 Nof(T_macropredict2))
    for i_incre = 1, 36			# 0.65 similarity
      I_keep = Iarray(0)
      for i_cpd = 1, Nof(T_macropredict2)
        group table t T_macropredict2.M_APFsim[i_cpd]
        I_keep //= Index(t.A >= 1.-0.01*(i_incre-1))
        delete t l_warn=no
      endfor
      if (Nof(Unique(Sort(I_keep ) ) )<i_minset) continue
      if ((Nof(Unique(Sort(I_keep ) ) )>i_maxtrainset) & (Type(r_sim)!="unknown")) break
      r_sim = 1.-0.01*(i_incre-1)
    endfor
    if (Type(r_sim)=="unknown") then
      for i_incre = 37, 51		# 0.5 similarity
        I_keep = Iarray(0)
        for i_cpd = 1, Nof(T_macropredict2)
          group table t T_macropredict2.M_APFsim[i_cpd]
          I_keep //= Index(t.A >= 1.-0.01*(i_incre-1))
          delete t l_warn=no
        endfor
        if (Nof(Unique(Sort(I_keep ) ) )<i_minset) continue
        if  ((Nof(Unique(Sort(I_keep ) ) )>i_maxtrainset) & (Type(r_sim)!="unknown")) break
        r_sim = 1.-0.01*(i_incre-1)
      endfor
    endif
    i_minset = Max(i_mintrainset Nof(T_macropredict2))
    if (Type(r_sim)=="unknown") then
      I_select = Iarray(0)
      R_sim = Rarray(0)
      for i_incre = 52, 71              # 0.3 similarity
        I_keep = Iarray(0)
        for i_cpd = 1, Nof(T_macropredict2)
          group table t T_macropredict2.M_APFsim[i_cpd]
          I_keep //= Index(t.A >= 1.-0.01*(i_incre-1))
          delete t l_warn=no
        endfor
        if (Nof(Unique(Sort(I_keep ) ) )<i_minset) continue
        if ((Nof(Unique(Sort(I_keep ) ) )>i_maxtrainset) & (Nof(R_sim)!=0)) break
        R_sim //= 1.-0.01*(i_incre-1)
        I_select //= Nof(Unique(Sort(I_keep ) ) )
      endfor
      if (Nof(R_sim)==0) continue
      r_sim  = R_sim[Nof(R_sim)/2+1]
    endif
    I_keep = Iarray(0)
    for i_cpd = 1, Nof(T_macropredict2)
      group table t T_macropredict2.M_APFsim[i_cpd]
      I_keep //= Index(t.A >= r_sim)
      delete t l_warn=no
    endfor
    T_macrotrain2 = T_macrotrain[Unique(Sort(I_keep))]
    fname_in  =  Name( system s_tempDir + "apf3DqsarXXXX.sdf" )
    fname_out = s_tempDir + Name( fname_in ) + "_out.icb"
    delete system fname_out
    write table mol T_macrotrain2 fname_in delete
#    if (l_dockterms & Nof(S_traincol2)!=1) then
#      s_cmd = Path( macro, s_icmhome + "_apf3Dqsar", "atomContrib=yes",  "train="+fname_in , "field="+s_activitycol , "extra="+Sum(S_traincol2[2:$] ",") , Sarray(1 "icb=" + fname_out) )
#    else
      s_cmd = Path( macro, s_icmhome + "_apf3Dqsar", "atomContrib=yes",  "train="+fname_in , "field="+s_activitycol , Sarray(1 "icb=" + fname_out) )
#    endif
    s_out = Unix(s_cmd)

    if (Exist(fname_out)) then
      delete MolApfQsar BASIS l_warn=no
      read binary fname_out
      predict MolApfQsar T_macropredict2
      predict MolApfQsar T_macrotrain2
      delete MolApfQsar BASIS l_warn=no
      delete tmprfmod l_warn=no
      if (l_dockterms & (Nof(S_traincol2)!=1)) then
        learn T_macrotrain2.$s_activitycol name="tmprfmod" type="rfRegression" column=S_traincol2
        predict tmprfmod T_macropredict2
        delete tmprfmod l_warn=no
      endif
    else
      delete T_macropredict2 T_macrotrain2 l_warn=no
      continue
      add column T_test Toreal(Sarray(Nof(T_test) "ND")) name="MolApfQsar"
      add column T_train Toreal(Sarray(Nof(T_train) "ND")) name="MolApfQsar"
      learn T_train.pkd name="pkdpredrf" type="randomForestRegression" column={"Hbond", "Hphob", "VwInt", "Eintl", "Dsolv", "SolEl", "tmplAPF"}
    endif
    add column T_macropredict2 Rarray(Nof(T_macropredict2) r_sim) name="TrainAPFSim"
    if (i_maxcl==1) then
      T_macropredict.$s_predictcol = T_macropredict2.MolApfQsar
      T_macropredict.TrainAPFSim = T_macropredict2.TrainAPFSim
      if (l_dockterms & (Nof(S_traincol2)!=1)) T_macropredict.$s_predictcol2 = T_macropredict2.tmprfmod
    else
      T_macropredict.$s_predictcol[Index(T_macropredict.cl == i_cl)] = T_macropredict2.MolApfQsar
      T_macropredict.TrainAPFSim[Index(T_macropredict.cl == i_cl)] = T_macropredict2.TrainAPFSim
      if (l_dockterms & (Nof(S_traincol2)!=1)) T_macropredict.$s_predictcol2[Index(T_macropredict.cl == i_cl)] = T_macropredict2.tmprfmod
    endif
    delete T_macropredict2 T_macrotrain2 l_warn=no
    print bar M  l_info=yes
  endfor
  delete $s_predict.$s_predictcol $s_predict.TrainAPFSim l_warn=no
  add column $s_predict T_macropredict.$s_predictcol name=s_predictcol
  if (l_dockterms & (Nof(S_traincol2)!=1)) then
    delete $s_predict.$s_predictcol2 l_warn=no
    add column $s_predict T_macropredict.$s_predictcol2 name=s_predictcol2
  endif
  add column $s_predict T_macropredict.TrainAPFSim name="TrainAPFSim"
  print bar "done\n" l_info=yes
endmacro
#
macro msAPFpredictresult s_predict ("") s_activitycol ("pkd") auto
  l_info = l_commands = l_warn = no
  s_dir = Path()
  s_predict = Trim(s_predict all)
  s_predictcol = s_activitycol+"_APFpred"
  s_predictcol2 = s_activitycol+"_DockAPFpred"
  if (s_predict == "") return "Please specify the name of the table you want to predict"
  if (Extension(s_predict)=="") then
    if (Type($s_predict)!="table") return "Prediction table specified does not exist"
  else
    if (!Exist(s_predict)) return "Prediction table specified does not exist"
    if (Extension(s_predict)==".icb") read binary s_predict
    if (Extension(s_predict)==".sdf") read table mol s_predict
    s_predict = Name(s_predict)
    if (Type($s_predict)!="table") return "Prediction table specified does not exist"
  endif
  if (Type($s_predict.idxtmp)=="unknown") add column $s_predict Count(Nof($s_predict)) name="idxtmp"
  if (Type($s_predict.$s_predictcol)=="unknown") then
    add column $s_predict Toreal(Sarray(Nof($s_predict) "ND")) name=s_predictcol
    if (Type($s_predict.$s_predictcol2)=="unknown") add column $s_predict Toreal(Sarray(Nof($s_predict) "ND")) name=s_predictcol2
  endif
  if (Type($s_predict.TrainAPFSim)=="unknown") add column $s_predict Toreal(Sarray(Nof(T_macropredict) "ND")) name="TrainAPFSim"
  S_files = Sarray("*/T_output.icb" directory)
  s_col = s_predict+"."+s_predictcol
  s_col2 = s_predict+"."+s_predictcol2
  s_TrainAPFSim = s_predict+".TrainAPFSim"
  for i_file = 1, Nof(S_files)
    read binary S_files[i_file]
    if (Type(T_output.idxtmp)=="unknown") continue
    if (Type(T_output.$s_predictcol)!="unknown") $s_col[T_output.idxtmp] = T_output.$s_predictcol
    if (Type(T_output.$s_predictcol2)!="unknown") $s_col2[T_output.idxtmp] = T_output.$s_predictcol2
    if (Type(T_output.TrainAPFSim)!="unknown") $s_TrainAPFSim[T_output.idxtmp] = T_output.TrainAPFSim
    delete T_output l_warn=no
  endfor
endmacro
#
macro msAPFpredictcluster s_predict ("") s_train ("") s_activitycol ("pkd") l_cluster (yes) l_dockterms (yes) i_mintrainset (50) i_maxtrainset (500) i_mode (3) s_sshcommand ("ssh vls.molsoft.com") s_qsubarg ("-q all.q") auto
  l_info = l_commands = l_warn = no
  s_dir = Path()
  s_predict = Trim(s_predict all)
  s_train = Trim(s_train all)
  s_predictcol = s_activitycol+"_APFpred"
  s_predictcol2 = s_activitycol+"_DockAPFpred"
  if (s_predict == "") return "Please specify the name of the table you want to predict"
  if (s_train == "") return "Please specify the name of the table you want to train"
  if (Extension(s_predict)=="") then
    if (Type($s_predict)!="table") return "Prediction table specified does not exist"
  else
    if (!Exist(s_predict)) return "Prediction table specified does not exist"
    if (Extension(s_predict)==".icb") read binary s_predict
    if (Extension(s_predict)==".sdf") read table mol s_predict
    s_predict = Name(s_predict)
    if (Type($s_predict)!="table") return "Prediction table specified does not exist"
  endif
  if (Extension(s_train)=="") then
    if (Type($s_train)!="table") return "Prediction table specified does not exist"
  else
    if (!Exist(s_train)) return "Prediction table specified does not exist"
    if (Extension(s_train)==".icb") read binary s_train
    if (Extension(s_train)==".sdf") read table mol s_train name=Name(s_train)
    s_train= Name(s_train)
    if (Type($s_train)!="table") return "Prediction table specified does not exist"
  endif
  if (Type($s_predict.mol 2)!="3D") return "3D column mol is required in the prediction table"
  if (Type($s_train.mol 2)!="3D") return "3D column mol is required in the training table"
  if (Type($s_train.$s_activitycol)!="rarray") return "An rarray activity column is required for the training table"

  T_macropredict = $s_predict
  T_macrotrain = $s_train
  if (l_cluster) then
    delete T_macropredict.cl T_macropredict.ord T_macropredict.CO T_macropredict.cluster T_macropredict.M_dist l_warn=no
    scanClusterHitList "T_macropredict"
    split T_macropredict.cluster 0.5
    T_macropredict.cl = Split(T_macropredict.cluster 0.5)
  endif
  delete T_macropredict.M_APFsim T_macropredict.MolApfQsar T_macrotrain.MolApfQsar T_macropredict.ATOM_CONTRIB T_macrotrain.ATOM_CONTRIB l_warn=no
  delete T_macropredict.tmprfmod T_macrotrain.tmprfmod l_warn=no
  delete T_macropredict.$s_predictcol T_macropredict.$s_predictcol2 l_warn=no
  add column T_macropredict Count(Nof(T_macropredict)) name="idxtmp"
  S_traincol = {"Hbond","Hphob","VwInt","Eintl","Dsolv","SolEl","tmplAPF"}
  S_traincol2 = {"MolApfQsar"}
  for i_traincol = 1, Nof(S_traincol)
    s_traincol = S_traincol[i_traincol]
    if ((Type(T_macropredict.$s_traincol)=="rarray") & (Type(T_macropredict.$s_traincol)=="rarray")) S_traincol2 //= s_traincol
  endfor
  add column T_macropredict Toreal(Sarray(Nof(T_macropredict) "ND")) name=s_predictcol
  if (l_dockterms & Nof(S_traincol2)!=1) add column T_macropredict Toreal(Sarray(Nof(T_macropredict) "ND")) name=s_predictcol2
  add column T_macropredict Toreal(Sarray(Nof(T_macropredict) "ND")) name="TrainAPFSim"
  if (Type(T_macropredict.cl)=="iarray") then
    i_maxcl = Max(T_macropredict.cl)
  else
    i_maxcl = 1
  endif
  M = i_maxcl
  s_predicttab = s_predict+"_APFpred"
  s_traintab = s_predict+"_APFtrain"
  delete $s_predicttab $s_traintab l_warn=no
  if (Type(T_macropredict.cursor) == "string") then
    T_macropredict.cursor = T_macropredict.cursor+"\n# b_Retrieve_Partial/Full_Results_from_APF_prediction (msAPFpredictresult Name(variable %@))"
  else
    if (Type(T_macropredict.toolsPanel) == "string") then
      T_macropredict.toolsPanel = T_macropredict.cursor+"\n# b_Retrieve_Partial/Full_Results+from_APF_prediction (msAPFpredictresult Name(variable %@))"
    else
      add header T_macropredict "" name="toolsPanel"
      T_macropredict.toolsPanel = """
# b_Retrieve_Partial/Full_Results_from_APF_prediction (msAPFpredictresult Name(variable %@))
"""
    endif
  endif
  rename T_macropredict s_predicttab
  rename T_macrotrain s_traintab
  write binary $s_predicttab delete
  write binary $s_traintab delete

  S_tmpscript={"call _startup"}
  S_tmpscript//="set directory \""+s_dir+"\""
  S_tmpscript//="i_runno=Getarg(\"run\",1,delete)"
  S_tmpscript//="read binary \""+s_traintab+".icb\""
  S_tmpscript//="read binary \""+s_predicttab+".icb\""
  S_tmpscript//="l_info=no; l_commands=no"
  S_tmpscript//="if (Type("+s_predicttab+".cl)==\"iarray\") then"
  S_tmpscript//="  i_maxcl = Max("+s_predicttab+".cl)"
  S_tmpscript//="else"
  S_tmpscript//="  i_maxcl = 1"
  S_tmpscript//="endif"
  S_tmpscript//="if (i_runno>i_maxcl) quit"
  S_tmpscript//="if (i_maxcl==1) then"
  S_tmpscript//="  T_output="+s_predicttab
  S_tmpscript//="else"
  S_tmpscript//="  T_output="+s_predicttab+".cl==i_runno"
  S_tmpscript//="  if (Nof(T_output)==0) quit"
  S_tmpscript//="endif"
  i_foldermax = Max(0 Max(Tointeger(Name(Sarray("*" directory )))))
  S_tmpscript//="i_foldermax = "+i_foldermax
  S_tmpscript//="if (!Exist(Tostring(i_foldermax+i_runno))) make directory Tostring(i_foldermax+i_runno)"
  S_tmpscript//="set directory Tostring(i_foldermax+i_runno)"
  S_tmpscript//="msAPFpredict \"T_output\" \""+s_traintab+"\" \""+s_activitycol+"\" no "
  if (l_dockterms) then
    S_tmpscript[$] = S_tmpscript[$]+"yes "+Tostring(i_mintrainset)+" "+Tostring(i_maxtrainset)
  else
    S_tmpscript[$] = S_tmpscript[$]+"no "+Tostring(i_mintrainset)+" "+Tostring(i_maxtrainset)
  endif
  S_tmpscript//="write binary T_output delete"
  S_tmpscript//="l_info = yes"
  S_tmpscript//="show version"
  S_tmpscript//="quit"
  S_tmpscript//="l_info = no"
  if (!Exist("_msAPFpredictCluster")) then
    write Sum(S_tmpscript "\n")+"\n" "_msAPFpredictCluster" delete
  else
    l_continue = Ask("Previous scripts exists, please do not submit new jobs until all previous jobs have started/finished, continue?(yes/no)",no)
    if (l_continue==yes) then
      write Sum(S_tmpscript "\n")+"\n" "_msAPFpredictCluster" delete
    else
      return "Job was not submitted, please wait until all previous jobs have started/finished"
    endif
  endif
  sys chmod 755 _msAPFpredictCluster

  if (i_mode<=1) then   #Local batch job, create subfolders
    S_tmpsh={"#!/bin/csh"}
    S_tmpsh//="setenv ICMHOME "+s_icmhome
    S_tmpsh//="cd "+s_dir
    S_tmpsh//="set i = 1"
    S_tmpsh//="while ( $i <= "+M+")"
    S_tmpsh//="  "+Path(macro )+" -p"+s_icmhome+" ./_msAPFpredictCluster run=$i"
    S_tmpsh//="  @ i++"
    S_tmpsh//="end"
    S_tmpsh//=" "
    write Sum(S_tmpsh "\n")+"\n" "shscript" delete
    sys chmod 755 shscript

    s_cmd = "./shscript"
    if (i_mode!=0) then
      sprintf "predictModelsHit \"%s\" yes ", s_dir
    else
      s_out = "print \"Testing directories created, no prediction submitted\""
    endif
    make background s_cmd command=s_out info="MolScreen Batch Job finished. Press OK to load the result"
    print " Info> MolScreen Batch Job started in background. You will be notified when the job is complete."

  else  #submit job to cluster
    S_tmpqsub={"#!/bin/csh"}
    S_tmpqsub//="#$ -l h_rt=2880000"
    S_tmpqsub//="#$ -j y"
    S_tmpqsub//="setenv ICMHOME "+s_icmhome
    S_tmpqsub//="cd "+s_dir
    S_tmpqsub//=Path(macro )+" -p"+s_icmhome+" ./_msAPFpredictCluster run=$SGE_TASK_ID"
    S_tmpqsub//=" "
    write Sum(S_tmpqsub "\n")+"\n" "qsubscript" delete
    sys chmod 755 qsubscript

    S_tmpssh={"#!/bin/csh"}
    S_tmpssh//="cd "+s_dir
    S_tmpssh//="qsub -t "+1+"-"+M+" "+s_qsubarg+" qsubscript"
    S_tmpssh//=" "
    write Sum(S_tmpssh "\n")+"\n" "sshscript" delete
    sys chmod 755 sshscript

    if (i_mode==2) then
      sprintf "%s/sshscript", s_dir name="s_command"
      sys $s_command
    elseif (i_mode==3) then
      sprintf "%s/sshscript", s_dir name="s_command"
      sys $s_sshcommand $s_command
#    elseif (i_mode==4) then
#      s_mkdircommand = s_sshcommand +" 'mkdir -p "+s_remotedir+"'"
#      sys $s_mkdircommand

#      s_scpcommand = Field(Replace(s_sshcommand "ssh" "rsync") 1 " ")
#      s_scpcommand = s_scpcommand +" -aruz T_input.icb T_input.sdf _msAPFpredictCluster qsubscript sshscript "+Field(s_sshcommand 2 " ")+":"+s_remotedir+"/"
#      sys $s_scpcommand

#      sprintf "%s/sshscript", s_remotedir name="s_command"
#      sys $s_sshcommand $s_command

    endif
  endif
  delete $s_predicttab
  read binary s_predicttab+".icb"
  keep $s_predicttab
endmacro
#
macro chemblapi s_query ("") s_source ("target") s_tabname ("") l_loadall (no) r_TaniSim (0.75) i_limit (250) auto
HELP = """
  Search ChEMBL using its API:

  Keyword Search is implemented for the following: activity|assay|chembl_id_lookup|document|molecule|protein_class|target
  Search requiring empty or specified query: atc_class|binding_site|biotherapeutic|cell_line|compound_record|compound_structural_alert|document_similarity|document_term|drug|drug_indication|go_slim|mechanism|metabolism|molecule_form|organism|protein_class|similarity|source|substructure|target_component|target_prediction|target_relation|tissue|xref_source

  Syntax: chemblapi <s_query> <s_source> <s_tabname> <l_loadall> <r_TaniSim>
  <s_query>: Can be simple term such as: CHEMBLID or complicated terms such as: target_chembl_id=CHEMBL231&relationship_type=D&assay_type=B
             To force retrieval of single entry, begin query term with '/' e.g. '/chembl25'
             See https://www.ebi.ac.uk/chembl/ws and https://www.ebi.ac.uk/chembl/api/data/docs for more examples
  <s_source>: Keyword search are implemented for the following: activity|assay|chembl_id_lookup|document|molecule|protein_class|target
              For other sources, one can either 1. leave the <s_query> empty to search for all entries
                                                2. if the particular id is known, put that in <s_query> e.g. 'chembl25'
                                                3. or if a particular field is known, put that in <s_query> e.g. 'molecule_chembl_id=CHEMBL25'
  <s_tabname>: Name of the new table, if unspecified, a name will be assigned based on query term
  <l_loadall>: Whether to load all entries, if not, a button in the tools panel allow user to load additional entries later
  <r_TaniSim>: Tanimoto similarity used for similar compound search, must be between 0.7 and 1.0

  Example:
  chemblapi  # Search for all targets
  chemblapi 'esr1' # Search for target esr1
  chemblapi 'CHEMBL135' 'molecule' # Search for molecule with the specified CHEMBL ID
  chemblapi 'CHEMBL135' 'similarity' 0.8 # Search for molecule with Tanimoto Similarity >= 0.8 to specified chemical
  chemblapi 'C1=CC=CC(=C1C1)C=CC=1' 'substructure' # Search for molecule containing the specified subtructure
  chemblapi 'BSYNRYMUTXBXSQ-UHFFFAOYSA-N' 'similarity' 0.8 Search for molecule with Tanimoto Similarity >= 0.8 to specified inchi key
  chemblapi 'parent_molecule_chembl_id=CHEMBL25' 'activity' # Search for all activities in which the parent molecule is CHEMBL25
  chemblapi '' 'drug_indication' # Search for all entries in drug_indication table
  chemblapi 'molecule_chembl_id=CHEMBL25' 'mechanism' # Search for mechanism of CHEMBL25 aka Aspirin

  Note: Additional actions might be available in the Tools Panel for Cross-Reference search
"""
  l_commands = l_info = l_warn = no
  errorAction = "none"
#  i_limit = 250
  s_query = Trim(s_query all)
  s_query = Replace(s_query " " "+")
  s_tabname = Trim(s_tabname all)
  s_query = Replace(Replace(s_query "&amp;" "&") "^[?]" "" )
  S_source = {"activity","assay","molecule","target","document","substructure","similarity","chembl_id_lookup","protein_class"}
  S_source2 = {"target","molecule","substructure","similarity","activity","assay","document","atc_class","binding_site","biotherapeutic","cell_line","chembl_id_lookup","compound_record","compound_structural_alert","document_similarity","document_term","drug","drug_indication","go_slim","mechanism","metabolism","molecule_form","organism","protein_class","source","target_component","target_prediction","target_relation","tissue","xref_source"}
  if (Index(S_source2 s_source)==0) then
    print "Cannot perform ChEMBL search on source specified"
    print "Allowed sources are:" Sum(Unique(Sort(S_source2  ) ) ", ")
    return
  endif
  s_fullquery2 = ""
  s_fullquery3 = ""
  s_fullquery = "https://www.ebi.ac.uk/chembl/api/data/"+s_source

  l_smiles = no
  if (Length(s_query)>7) then
    if (s_query[1:7]=="smiles:") l_smiles=yes
  endif
  if ((!l_smiles) & ((r_TaniSim > 1.) | (r_TaniSim < 0.7))) return "Tanimoto similarity should be between 0.7 and 1."
  if (s_query=="") then
    if ((s_source == "similarity")|(s_source == "substructure")) return "Chemical Smiles or ChEMBL ID required for similarity or substructure search"
    s_fullquery += ".json?"
  else
    if (l_smiles) then
      if ((s_source != "molecule") & (s_source != "similarity") & (s_source != "substructure")) return "Smiles input detected, please use either molecule|similarity|substructure as source"
      if (!Exist(s_icmhome+"data/chembl/ChEMBLCompound27.molt") & !Exist(s_userDir+"data/chembl/ChEMBLCompound27.molt")) \
      return "Please download ChEMBLCompound27.molt.gz from our ftp site and unzip it to s_icmhome/data/chembl/ or s_userDir/data/chembl"
      if Exist(s_icmhome+"data/chembl/ChEMBLCompound27.molt") s_file=s_icmhome+"data/chembl/ChEMBLCompound27.molt"
      if Exist(s_userDir+"data/chembl/ChEMBLCompound27.molt") s_file=s_userDir+"data/chembl/ChEMBLCompound27.molt"
      delete T_macrotmp l_warn=no
      if (s_source == "substructure") then
        print " Info> Performing substructure search on local ChEMBL database"
        find molcart table=Name(s_file) filename=s_file sstructure Replace(s_query "smiles:" "") number=i_limit name="T_macrotmp" field="ChEMBLCompound27.mol,CHEMBLID,NAME"
      elseif (s_source == "similarity") then
        print " Info> Performing similarity search on local ChEMBL database, similarity >=" r_TaniSim
        find molcart table=Name(s_file) filename=s_file similarity Replace(s_query "smiles:" "") 1.-r_TaniSim number=i_limit name="T_macrotmp" field="ChEMBLCompound27.mol,CHEMBLID,NAME"
      elseif (s_source == "molecule") then
        print " Info> Performing exact search on local ChEMBL database"
        find molcart table=Name(s_file) filename=s_file exact Replace(s_query "smiles:" "") number=i_limit name="T_macrotmp" field="ChEMBLCompound27.mol,CHEMBLID,NAME"
      endif
      if (Nof(T_macrotmp)==0) return "Cannot find any compound after substructure/similarity search, please modify query"
      rename T_macrotmp.NAME "pref_name"
      rename T_macrotmp.CHEMBLID "molecule_chembl_id"
      add column T_macrotmp Iarray(Nof(T_macrotmp) 0) name="chk" index=1
      set property T_macrotmp.chk logical
      add header T_macrotmp name="toolsPanel" ""
      T_macrotmp.toolsPanel += """
# b_Get_Activities_of_Checked_Compounds (if (Nof(Index( %@.chk==1))!=0) chemblapi "molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.molecule_chembl_id)[Index( %@.chk==1)])) ",") "activity" "" no 0.75 250) [BEGINFRAME: Activity Search]
# r_Tanimoto_Similarity:tani (0.75)  [BEGINFRAME: Chemical Search]
# b_Get_Molecules_Similar_to_First_Selected_Compound (if Nof(Index( %@ selection cursor))==1 chemblapi "smiles:"+Smiles(%@.mol[Index( %@ selection cursor)])[1] "similarity" "" no $tani 250)
# b_Get_Molecules_Superstructure_to_First_Selected_Compound (if Nof(Index( %@ selection cursor))==1 chemblapi "smiles:"+Smiles(%@.mol[Index( %@ selection cursor)])[1] "substructure" "" no 0.75 250)
"""
      T_macrotmp.pref_name[Index(T_macrotmp.pref_name=="")]=Sarray(T_macrotmp.molecule_chembl_id )[Index(T_macrotmp.pref_name=="")]
      if (s_tabname!="") then
        delete $s_tabname l_warn=no
      else
        s_tabname = Name(Toupper(s_source 1)+"_smiles" unique)
      endif
      rename T_macrotmp s_tabname
      set property $s_tabname header
      keep $s_tabname global
      return
    endif
    if ((s_source == "similarity")|(s_source == "substructure")) then
      if (Index(s_query "/chembl/api/data/")==1) then
        s_fullquery = "https://www.ebi.ac.uk"+s_query
      else
        if (Index(Toupper(s_query) "CHEMBL") == 1) then
          s_fullquery += "/"+Toupper(s_query)
        else
          s_fullquery += "/"+s_query
        endif
        if (s_source == "similarity") s_fullquery+="/"+String(Integer(r_TaniSim*100))
        s_fullquery+="?format=json"+"&limit="+Tostring(i_limit)+"&offset=0"
      endif
#      if (Index(Toupper(s_query) "CHEMBL") == 1) then
#        s_fullquery += ".json?chembl_id="+Replace(Toupper(s_query) "CHEMBL_ID=" "")
#      elseif (Index(Toupper(s_query) "STANDARD_INCHI_KEY") == 1) then
#        s_fullquery += ".json?standard_inchi_key="+Replace(Toupper(s_query) "STANDARD_INCHI_KEY=" "")
#      else
#        s_fullquery += ".json?smiles="+Replace(s_query "smiles:" "")
#      endif
    elseif ((s_query[1] == "/") | ((Index(Toupper(s_query) "CHEMBL")==1) & (Nof(s_query "=")==0))) then
      if (Index(s_query "/chembl/api/data/")==1) then
        s_fullquery = "https://www.ebi.ac.uk"+s_query
      else
        s_fullquery = "https://www.ebi.ac.uk/chembl/api/data/"+s_source+"/"+Replace(Toupper(s_query) "/" "")+"?format=json"+"&limit="+Tostring(i_limit)+"&offset=0"
      endif
    else
      if (Nof(s_query "=")==0) then
#        if (s_source=="target"|s_source=="molecule"|s_source=="tissue"|s_source=="go_slim") s_fullquery2 = s_fullquery+".json?"+"pref_name__icontains="+s_query+"&limit="+Tostring(i_limit)+"&offset=0"
        if (s_source=="molecule"|s_source=="tissue"|s_source=="go_slim") s_fullquery2 = s_fullquery+".json?"+"pref_name__icontains="+s_query+"&limit="+Tostring(i_limit)+"&offset=0"
        if (s_source=="activity") then
          s_fullquery3 = s_fullquery+".json?"+s_source+"_id="+Toupper(s_query)+"&limit="+Tostring(i_limit)+"&offset=0"
        elseif (Index(S_source s_source)!=0) then
          s_fullquery3 = s_fullquery+".json?"+s_source+"_chembl_id="+Toupper(s_query)+"&limit="+Tostring(i_limit)+"&offset=0"
        else
#          s_fullquery3 = s_fullquery+".json?chembl_id="+Toupper(s_query)+"&limit="+Tostring(i_limit)+"&offset=0"
#          s_fullquery3 = "https://www.ebi.ac.uk/chembl/api/data/"+s_source+"/"+s_query+"?format=json"+"&limit="+Tostring(i_limit)+"&offset=0"
        endif
        if ((Index(S_source s_source)==0)) then
          s_fullquery= "https://www.ebi.ac.uk/chembl/api/data/"+s_source+"/"+s_query+"?format=json"+"&limit="+Tostring(i_limit)+"&offset=0"
        else
          s_fullquery += "/search.json?q="+s_query
        endif
        if (s_source=="target") then
          read binary s_icmhome+"/models/ChEMBLTarget.icb"
          if (Nof(s_query "_")==0) then
            I_tmp = Index(ChEMBLTarget.Entry_name ~Toupper(s_query)+"_*")//Index(ChEMBLTarget.Entry==Toupper(s_query))
            ChEMBLTarget.Gene_names = Toupper(ChEMBLTarget.Gene_names)
            I_tmp //= Index(ChEMBLTarget.Gene_names==Toupper(s_query)|ChEMBLTarget.Gene_names~Toupper(s_query)+" *"|ChEMBLTarget.Gene_names~"* "+Toupper(s_query))
            if (Nof(I_tmp)!=0) I_tmp = Unique(Sort(I_tmp))
          else
            I_tmp = Index(ChEMBLTarget.Entry_name==Toupper(s_query))
          endif
          if (Nof(I_tmp)!=0) s_fullquery= "https://www.ebi.ac.uk/chembl/api/data/"+s_source+".json?target_chembl_id__in="+Sum(ChEMBLTarget.chembl_id[I_tmp] ",")+"&limit="+Tostring(i_limit)+"&offset=0"
        endif
      else
        s_fullquery += ".json?"+s_query
      endif
    endif
  endif
#  if (s_source == "similarity") s_fullquery += "&similarity="+String(Integer(r_TaniSim*100))
  if (Index(s_fullquery "limit=")==0) s_fullquery += "&limit="+Tostring(i_limit)
  if (Index(s_fullquery "offset=")==0) s_fullquery += "&offset=0"
  l_ask = no
  N = 1
  while (s_fullquery != "")
    l_error = Error()
    if (s_fullquery3!="") then
      delete x_macro l_warn=no
      delete s_macro l_warn=no
      read string s_fullquery3 name="s_macro"
      if (s_macro!="") x_macro = Collection(s_macro)
#      read json s_fullquery3 name="x_macro"
      if (Error()|(Type(x_macro)=="unknown"))  print "Error retrieving:" s_fullquery3
      delete t_macrotmp l_warn=no
      t_macrotmp = Table(x_macro)
      if ((t_macrotmp.page_meta ["total_count"]==Toreal("ND" )) | (Nof(t_macrotmp)==0)) then
        s_fullquery3 = ""
        delete t_macrotmp l_warn=no
      else
        print "Found Entries:" s_fullquery3
        s_fullquery2 = ""
        s_fullquery = ""
      endif
    endif
    if (s_fullquery2!="") then
      delete x_macro l_warn=no
      delete s_macro l_warn=no
      read string s_fullquery2 name="s_macro"
      if (s_macro!="") x_macro = Collection(s_macro)
#      read json s_fullquery2 name="x_macro"
      if (Error()|(Type(x_macro)=="unknown"))  print "Error retrieving:" s_fullquery2
      delete t_macrotmp l_warn=no
      t_macrotmp = Table(x_macro)
      if ((t_macrotmp.page_meta ["total_count"]==Toreal("ND" )) | (Nof(t_macrotmp)==0)) then
        s_fullquery2 = ""
        delete t_macrotmp l_warn=no
      else
        print "Found Entries:" s_fullquery2
        s_fullquery = ""
      endif
    endif
    l_singleentry = no
    if (s_fullquery!="") then
      print " Info> Performing ChEMBL search:" s_fullquery
      delete x_macro l_warn=no
      delete s_macro l_warn=no
      read string s_fullquery name="s_macro"
      if (s_macro!="") x_macro = Collection(s_macro)
#      read json s_fullquery name="x_macro"
      if (Error()|(Type(x_macro)=="unknown")) then
        print "Error retrieving, trying one more time..."
        delete x_macro l_warn=no
        delete s_macro l_warn=no
        read string s_fullquery name="s_macro"
        if (s_macro!="") x_macro = Collection(s_macro)
#        read json s_fullquery name="x_macro"
        if (Error()|(Type(x_macro)=="unknown"))  then
          print "Error retrieving:" s_fullquery
          if (Type(T_macrotmp)!="unknown") break
          return
        endif
      endif
      delete t_macrotmp l_warn=no
      t_macrotmp = Table(x_macro)
      if (Type(t_macrotmp.error_message)!="unknown") then
        if (Type(T_macrotmp)!="unknown") break
        return "Cannot find anything with the query: "+s_fullquery
      elseif  ((Nof(Name(t_macrotmp))>1)&(Type(t_macrotmp.page_meta)=="unknown")) then
        l_singleentry = yes
      elseif (Type(t_macrotmp.page_meta)=="unknown") then
        if (Type(T_macrotmp)!="unknown") break
        return "Cannot find anything with the query: "+s_fullquery
      elseif ((t_macrotmp.page_meta ["total_count"]==Toreal("ND" )) | (Nof(t_macrotmp)==0)) then
        if (Type(T_macrotmp)!="unknown") break
        return "Cannot find anything with the query: "+s_fullquery
      endif
    endif
    s_fullquery = ""
    if (l_singleentry) then
      S_col = Name(x_macro)
      for i_col = 1, Nof(S_col)
        s_col = S_col[i_col]
        if (Type(x_macro[s_col])=="array") then
          group table t_macrotmp2 Array(x_macro[s_col]) s_col append
        elseif ((Type(x_macro[s_col])=="real")|(Type(x_macro[s_col])=="string")|(Type(x_macro[s_col])=="integer")) then
          group table t_macrotmp2 Sarray(1 Tostring(x_macro[s_col])) s_col append
        else
          group table t_macrotmp2 Array(x_macro[s_col]) s_col append
        endif
      endfor
    else
      i_total_count = Integer(t_macrotmp.page_meta["total_count"])
      if ((i_total_count > i_limit) & (!l_ask)) then
        if (l_loadall) then; s_ask = "yes"; l_ask = yes; endif
        if (!l_ask) s_ask = Askg("There are "+Tostring(i_total_count)+" total entries, want to load all?","yes/no",simple )
        if ((s_ask=="yes")|(s_ask=="y")|(s_ask=="YES")|(s_ask=="Y")) then
          l_loadall = yes
          N = Integer(Toreal(i_total_count)/i_limit); print bar "Loading from ChEMBL" N l_info=yes
        endif
        l_ask = yes
      endif
      if ((l_loadall) & (!t_macrotmp.page_meta ["next"]==Toreal("ND"))) \
      s_fullquery = Replace("https://www.ebi.ac.uk"+Tostring(t_macrotmp.page_meta["next"]) "&amp;" "&")
      if (s_source == "target") then
        S_col = Name(t_macrotmp.targets[1])
        for i_col = 1, Nof(S_col)
          s_col = S_col[i_col]
          group table t_macrotmp2 t_macrotmp.targets[s_col] s_col append
        endfor
      elseif (s_source == "activity") then
        S_col = Name(t_macrotmp.activities[1])
        for i_col = 1, Nof(S_col)
          s_col = S_col[i_col]
          group table t_macrotmp2 t_macrotmp.activities[s_col] s_col append
        endfor
      elseif ((s_source == "molecule")|(s_source == "similarity")|(s_source == "substructure")) then
        S_col = Name(t_macrotmp.molecules[1])
        for i_col = 1, Nof(S_col)
          s_col = S_col[i_col]
          group table t_macrotmp2 t_macrotmp.molecules[s_col] s_col append
        endfor
      elseif (s_source == "assay") then
        S_col = Name(t_macrotmp.assays[1])
        for i_col = 1, Nof(S_col)
          s_col = S_col[i_col]
          group table t_macrotmp2 t_macrotmp.assays[s_col] s_col append
        endfor
      elseif (s_source == "document") then
        S_col = Name(t_macrotmp.documents[1])
        for i_col = 1, Nof(S_col)
          s_col = S_col[i_col]
          group table t_macrotmp2 t_macrotmp.documents[s_col] s_col append
        endfor
      else
        s_colname = Name(t_macrotmp)[1]
        S_col = Name($s_colname[1])
        for i_col = 1, Nof(S_col)
          s_col = S_col[i_col]
          group table t_macrotmp2 $s_colname[s_col] s_col append
        endfor
      endif
    endif
    S_col = Name(t_macrotmp2 column)
    for i_col = 1, Nof(S_col)
      s_col = S_col[i_col]
      if (Type($s_col) != "array") continue
      if ((Type($s_col[1]) == "array")|(Type($s_col[1]) == "collection")) continue
      S_tmp = Sarray($s_col)
      delete $s_col
      add column t_macrotmp2 S_tmp index=i_col name=Field(s_col 2 ".")
    endfor
    if (Type(T_macrotmp)=="unknown") then
      rename t_macrotmp2 "T_macrotmp"
    else
      add T_macrotmp t_macrotmp2; delete t_macrotmp2
    endif
    print bar N
  endwhile
  print bar "End\n" l_info=yes
  if (Type(T_macrotmp)=="unknown") return "Cannot find anything with the query: "+s_query
  if (Type(t_macrotmp.page_meta)!="unknown") add header T_macrotmp t_macrotmp.page_meta name="page_meta"
  delete t_macrotmp l_warn=no
  if (s_source == "target") then
    add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="Uniprot_Accession"
    add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="Gene"
    add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="GoComponent"
    add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="GoFunction"
    add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="GoProcess"
    for i_entry = 1, Nof(T_macrotmp)
      if (T_macrotmp.target_components[i_entry]==Collection()) continue
      delete t_macrotmp l_warn=no
#      if (!l_singleentry) then
        t_macrotmp = Table(T_macrotmp.target_components[i_entry])
#      else
#        t_macrotmp = Table(T_macrotmp.target_components)
#      endif
      if (Nof(t_macrotmp)==0) continue
      T_macrotmp.Uniprot_Accession[i_entry] = Replace(Trim(Sum(Unique(Sort(Sarray(t_macrotmp.accession ) )) " ") all) " " ", ")
      add column t_macrotmp Sarray(Nof(t_macrotmp) "") name="Gene"
      add column t_macrotmp Sarray(Nof(t_macrotmp) ) name="GoComponent"
      add column t_macrotmp Sarray(Nof(t_macrotmp) ) name="GoFunction"
      add column t_macrotmp Sarray(Nof(t_macrotmp) ) name="GoProcess"
      for i_macro = 1, Nof(t_macrotmp)
        if (Index(Sarray(t_macrotmp.target_component_synonyms[i_macro]["syn_type"]) "GENE_SYMBOL")!=0) t_macrotmp.Gene[i_macro] = Sarray(t_macrotmp.target_component_synonyms [i_macro]["component_synonym"])[Index(Sarray(t_macrotmp.target_component_synonyms[i_macro]["syn_type"]) "GENE_SYMBOL")]
        t_macrotmp.GoComponent[i_macro] = Sum(Sarray(t_macrotmp.target_component_xrefs[i_macro]["xref_name"])[Index(Sarray(t_macrotmp.target_component_xrefs[i_macro]["xref_src_db"]) "GoComponent" all)] "\n")
        t_macrotmp.GoFunction[i_macro] = Sum(Sarray(t_macrotmp.target_component_xrefs[i_macro]["xref_name"])[Index(Sarray(t_macrotmp.target_component_xrefs[i_macro]["xref_src_db"]) "GoFunction" all)] "\n")
        t_macrotmp.GoProcess[i_macro] = Sum(Sarray(t_macrotmp.target_component_xrefs[i_macro]["xref_name"])[Index(Sarray(t_macrotmp.target_component_xrefs[i_macro]["xref_src_db"]) "GoProcess" all)] "\n")
      endfor
      T_macrotmp.Gene[i_entry] = Sum(Unique(Sort(t_macrotmp.Gene [Index(t_macrotmp.Gene!="")])) ", ")
      T_macrotmp.GoComponent[i_entry] =  Sum(Unique(Sort(Split(Sum(t_macrotmp.GoComponent [Index(t_macrotmp.GoComponent!="")] "\n")"\n"))) "\n")
      T_macrotmp.GoFunction[i_entry] =  Sum(Unique(Sort(Split(Sum(t_macrotmp.GoFunction [Index(t_macrotmp.GoFunction!="")] "\n")"\n"))) "\n")
      T_macrotmp.GoProcess[i_entry] =  Sum(Unique(Sort(Split(Sum(t_macrotmp.GoProcess [Index(t_macrotmp.GoProcess!="")] "\n")"\n"))) "\n")
    endfor
    delete t_macrotmp l_warn=no
    read binary s_icmhome+"models/ChEMBLTarget.icb"
    S_tmp = Sarray(T_macrotmp.target_chembl_id)
    delete T_macrotmp.target_chembl_id l_warn=no
    add column T_macrotmp S_tmp name="target_chembl_id"
    join left T_macrotmp.target_chembl_id ChEMBLTarget.chembl_id name="T_jointmp"
    add column T_macrotmp T_jointmp.Nof_Molecule name="Nof_Compounds"
    add column T_macrotmp T_jointmp.Nof_Activity name="Nof_Activities"
    add column T_macrotmp T_jointmp.ChEMBLTarget_pref_name name="Protein_Class"
    delete T_jointmp l_warn=no
    S_tmp = Unique(Sort(Split(Sum(T_macrotmp.Uniprot_Accession[Index(T_macrotmp.Uniprot_Accession!="")] ", ") ", " regexp)))
    add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="Uniprot_ID"
    if (Nof(S_tmp)!=0) then
      group table t_macrotmp S_tmp "Uniprot_Accession"
      join left t_macrotmp.Uniprot_Accession ChEMBLTarget.Entry name="T_jointmp"
      delete t_macrotmp l_warn=no
      T_macrotmp.Uniprot_ID = Replace(T_macrotmp.Uniprot_Accession T_jointmp.Uniprot_Accession T_jointmp.Entry_name )
      delete T_jointmp l_warn=no
    endif
    delete ChEMBLTarget l_warn=no
    S_order = {"target_chembl_id","pref_name","target_type","Uniprot_ID","Nof_Compounds","Nof_Activities","Uniprot_Accession","Gene","organism"}
    S_order //= {"Protein_Class","GoComponent","GoFunction","GoProcess"}
    S_type = Sarray(Nof(S_order) "sarray")
    S_type [{5,6}] = "iarray"
    S_name = S_order
  elseif (s_source == "assay") then
    read binary s_icmhome+"models/ChEMBLAssay.icb"
    S_tmp = Sarray(T_macrotmp.assay_chembl_id)
    delete T_macrotmp.assay_chembl_id l_warn=no
    add column T_macrotmp S_tmp name="assay_chembl_id"
    join left T_macrotmp.assay_chembl_id ChEMBLAssay.chembl_id name="T_jointmp"
    add column T_macrotmp T_jointmp.Nof_Molecule name="Nof_Compounds"
    add column T_macrotmp T_jointmp.pubmed_id name="pubmed_id"
    delete ChEMBLAssay T_jointmp l_warn=no
    read binary s_icmhome+"models/ChEMBLTarget.icb"
    S_tmp = Sarray(T_macrotmp.target_chembl_id)
    delete T_macrotmp.target_chembl_id l_warn=no
    add column T_macrotmp S_tmp name="target_chembl_id"
    join left T_macrotmp.target_chembl_id ChEMBLTarget.chembl_id name="T_jointmp"
    add column T_macrotmp T_jointmp.target_type name="target_type"
    add column T_macrotmp T_jointmp.target_pref_name name="target_pref_name"
    delete ChEMBLTarget T_jointmp l_warn=no
    S_order = {"assay_chembl_id","assay_type","assay_organism","description","Nof_Compounds","bao_label","confidence_score"}
    S_order //= {"target_pref_name","target_type","target_chembl_id","document_chembl_id","pubmed_id"}
    S_type = Sarray(Nof(S_order) "sarray")
    S_type[{5,7}] = "iarray"
    S_name = S_order
  elseif (s_source == "activity") then
    add column T_macrotmp Toreal(Sarray(Nof(T_macrotmp) "ND")) name="pAct"
    read binary s_icmhome+"models/ChEMBLAssay.icb"
    S_tmp = Sarray(T_macrotmp.assay_chembl_id)
    delete T_macrotmp.assay_chembl_id l_warn=no
    add column T_macrotmp S_tmp name="assay_chembl_id"
    join left T_macrotmp.assay_chembl_id ChEMBLAssay.chembl_id name="T_jointmp"
    add column T_macrotmp T_jointmp.confidence_score name="confidence_score"
    add column T_macrotmp T_jointmp.pubmed_id name="pubmed_id"
    delete ChEMBLAssay T_jointmp l_warn=no

    read binary s_icmhome+"models/ChEMBLTarget.icb"
    S_tmp = Sarray(T_macrotmp.target_chembl_id)
    delete T_macrotmp.target_chembl_id l_warn=no
    add column T_macrotmp S_tmp name="target_chembl_id"
    join left T_macrotmp.target_chembl_id ChEMBLTarget.chembl_id name="T_jointmp"
    add column T_macrotmp T_jointmp.target_type name="target_type"
    sort ChEMBLTarget.chembl_id
    group ChEMBLTarget.chembl_id ChEMBLTarget.Entry "uniq,"  ChEMBLTarget.Entry_name "uniq,"  all "first"  header  name="ChEMBLTarget_1"
    delete T_jointmp l_warn=no
    join left T_macrotmp.target_chembl_id ChEMBLTarget_1.chembl_id name="T_jointmp"
    add column T_macrotmp Replace(T_jointmp.uniq_Entry "," "\n") name="Uniprot_Accession"
    add column T_macrotmp Replace(T_jointmp.uniq_Entry_name "," "\n") name="Uniprot_ID"
    add column T_macrotmp T_jointmp.pref_name name="target_class"
    delete T_jointmp ChEMBLTarget ChEMBLTarget_1 l_warn=no

    S_order = {"molecule_pref_name","pAct","Uniprot_ID","target_pref_name","confidence_score","target_type","bao_label","activity_comment"}
    S_order //= {"Uniprot_Accession","target_class","standard_type","relation","standard_value"}
    S_order //= {"standard_units","pchembl_value","data_validity_comment","assay_type","assay_description","activity_id","assay_chembl_id"}
    S_order //= {"molecule_chembl_id","parent_molecule_chembl_id","target_chembl_id","target_organism","document_chembl_id","pubmed_id"}
    S_type = Sarray(Nof(S_order) "sarray")
    S_type[{2,13,15}] = "rarray"
    S_type[5] = "iarray"
    S_name = S_order
  elseif ((s_source == "molecule")|(s_source == "similarity")|(s_source == "substructure")) then
    add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="canonical_smiles"
    add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="parent_chembl_id"
    if (Type(T_macrotmp.molecule_hierarchy["parent_chembl_id"])!="real") T_macrotmp.parent_chembl_id =  Sarray(T_macrotmp.molecule_hierarchy["parent_chembl_id"])
    if (Type(T_macrotmp.molecule_structures["canonical_smiles"])!="real") T_macrotmp.canonical_smiles =  Sarray(T_macrotmp.molecule_structures["canonical_smiles"])
    add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="molecule_synonym"
    if (Type(T_macrotmp.molecule_synonyms)!="unknown") then
#      add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="molecule_synonym"
      for i_entry = 1, Nof(T_macrotmp)
        if (Nof(T_macrotmp.molecule_synonyms[i_entry])==0) continue
        delete t_macrotmp l_warn=no
#        if (!l_singleentry) then
          t_macrotmp = Table(T_macrotmp.molecule_synonyms[i_entry])
#        else
#          t_macrotmp = Table(T_macrotmp.molecule_synonyms)
#        endif
        if (Nof(t_macrotmp)!=0) T_macrotmp.molecule_synonym[i_entry] = Sum(Unique(Sort(Trim(t_macrotmp.molecule_synonym all)))", ")
      endfor
    endif
    delete t_macrotmp l_warn=no
    S_order = {"pref_name","molecule_chembl_id","molecule_synonym","parent_chembl_id","max_phase","indication_class"}
    S_type = Sarray(Nof(S_order) "sarray")
    S_type[5] ="iarray"
    S_name = S_order
  elseif (s_source == "document") then
    S_order = {"document_chembl_id","journal","doc_type","pubmed_id","patent_id","doi","year","volume","title","abstract"}
    S_type = Sarray(Nof(S_order) "sarray")
    S_type[7] = "iarray"
    S_name = S_order
  elseif (s_source == "chembl_id_lookup") then
    S_order = {"chembl_id","entity_type","resource_url","status"}
    S_type =  Sarray(Nof(S_order) "sarray")
    S_name = S_order
  elseif (s_source == "protein_class") then
    S_order = {"l1","l2","l3","l4","l5","l6","l7","l8","protein_class_id"}
    S_type =  Sarray(Nof(S_order) "sarray")
    S_name = S_order
  else
    if (Type(T_macrotmp.molecule_hierarchy)!="unknown") then
      add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="parent_chembl_id"
      T_macrotmp.parent_chembl_id =  Sarray(T_macrotmp.molecule_hierarchy["parent_chembl_id"])
    endif
    if (Type(T_macrotmp.molecule_synonyms)!="unknown") then
      add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="molecule_synonym"
      for i_entry = 1, Nof(T_macrotmp)
        if (Nof(T_macrotmp.molecule_synonyms[i_entry])==0) continue
        delete t_macrotmp l_warn=no
#        if (!l_singleentry) then
          t_macrotmp = Table(T_macrotmp.molecule_synonyms[i_entry])
#        else
#          t_macrotmp = Table(T_macrotmp.molecule_synonyms)
#        endif
        if (Nof(t_macrotmp)!=0) T_macrotmp.molecule_synonym[i_entry] = Sum(Unique(Sort(Trim(t_macrotmp.molecule_synonym all)))", ")
      endfor
    endif
    if (Type(T_macrotmp.molecule_structures)!="unknown") then
      add column T_macrotmp Sarray(Nof(T_macrotmp) "") name="canonical_smiles"
      T_macrotmp.canonical_smiles =  Sarray(T_macrotmp.molecule_structures["canonical_smiles"])
      add column T_macrotmp Chemical(T_macrotmp.canonical_smiles smiles) name="mol" index=1
    endif
  endif
  S_col = Name(T_macrotmp column)
  if (Index(S_source s_source)==0) then
    for i_col = 1, Nof(S_col)
      s_col = S_col[i_col]
      if (Type($s_col[1])=="string") then
        S_tmp = Sarray($s_col)
        delete $s_col l_warn=no
        add column T_macrotmp S_tmp name=Field(s_col 2 ".") index=i_col
      elseif (Type($s_col[1])=="integer") then
        I_tmp = Iarray($s_col)
        delete $s_col l_warn=no
        add column T_macrotmp I_tmp name=Field(s_col 2 ".") index=i_col
      elseif (Type($s_col[1])=="real") then
        R_tmp = Rarray($s_col)
        delete $s_col l_warn=no
        add column T_macrotmp R_tmp name=Field(s_col 2 ".") index=i_col
      endif
      set property $s_col view
    endfor
  else
    for i_col = 1, Nof(S_col)
      s_col = S_col[i_col]
      set format $s_col show off
    endfor
    for i_col = 1, Nof(S_order)
      s_col = "T_macrotmp."+S_order[Nof(S_order)-i_col+1]
      if (Type($s_col)=="unknown") continue
      if (S_type[Nof(S_order)-i_col+1]=="sarray") then
        S_tmp = Sarray($s_col)
        delete $s_col
        add column T_macrotmp S_tmp name=Field(s_col 2 ".") index=1
      elseif (S_type[Nof(S_order)-i_col+1]=="rarray") then
        if (Type($s_col)=="sarray") $s_col[Index($s_col=="")] = "ND"
        R_tmp = Rarray($s_col)
        delete $s_col
        add column T_macrotmp R_tmp name=Field(s_col 2 ".") index=1
      elseif (S_type[Nof(S_order)-i_col+1]=="iarray") then
        if (Type($s_col)=="sarray") $s_col[Index($s_col=="")] = "0"
        I_tmp = Iarray($s_col)
        delete $s_col
        add column T_macrotmp I_tmp name=Field(s_col 2 ".") index=1
      endif
      set format $s_col name=S_name[Nof(S_order)-i_col+1] show
    endfor
  endif
  add header T_macrotmp name="toolsPanel" ""

  if (!l_singleentry) then
    if (T_macrotmp.page_meta ["next"] != Toreal("ND" )) then
      T_macrotmp.toolsPanel = """
# b_Get_Next_Batch_of_Entries ( if ( %@.page_meta["next"]!=Toreal("ND")) chemblapi %@.page_meta["next"] Split( %@.page_meta ["next"] "/.")[5] Name( %@ table) no 0.75 250)
"""
    endif
  endif

  if (s_source == "document") then
    T_macrotmp.toolsPanel += """
# b_Get_Activities_of_Checked_Documents (if (Nof(Index( %@.chk==1))!=0) chemblapi "document_chembl_id__in="+Sum(Unique(Sort( %@.document_chembl_id [Index( %@.chk==1)] ))",") "activity" "" no 0.75 250) [BEGINFRAME: Activity Search]
# b_Get_Checked_Assays (if (Nof(Index( %@.chk==1))!=0) chemblapi "document_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.document_chembl_id)[Index( %@.chk==1)])) ",") "assay" "" no 0.75 250) [BEGINFRAME: Cross Reference Search]

"""
  elseif (s_source == "target") then
    T_macrotmp.toolsPanel += """
# b_Get_Activities_of_Checked_Targets (if (Nof(Index( %@.chk==1))!=0) chemblapi "target_chembl_id__in="+Sum(Unique(Sort( %@.target_chembl_id [Index( %@.chk==1)])) ",") "activity" "" no 0.75 250) [BEGINFRAME: Activity Search]
# b_Get_Checked_Assays (if (Nof(Index( %@.chk==1))!=0) chemblapi "target_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.target_chembl_id)[Index( %@.chk==1)])) ",") "assay" "" no 0.75 250) [BEGINFRAME: Cross Reference Search]

"""
    sort reverse T_macrotmp.Nof_Activities

  elseif (s_source == "assay") then
    T_macrotmp.toolsPanel += """
# b_Get_Activities_of_Checked_Assays (if (Nof(Index( %@.chk==1))!=0) chemblapi "assay_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.assay_chembl_id)[Index( %@.chk==1)])) ",") "activity" "" no 0.75 250) [BEGINFRAME: Activity Search]
# b_Get_Activities_of_Checked_Targets (if (Nof(Index( %@.chk==1))!=0) chemblapi "target_chembl_id__in="+Sum(Unique(Sort( %@.target_chembl_id [Index( %@.chk==1)])) ",") "activity" "" no 0.75 250)
# b_Get_Activities_of_Checked_Documents (if (Nof(Index( %@.chk==1))!=0) chemblapi "document_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.document_chembl_id)[Index( %@.chk==1)])) ",") "activity" "" no 0.75 250)
# b_Get_Checked_Targets (if (Nof(Index( %@.chk==1))!=0) chemblapi "target_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.target_chembl_id)[Index( %@.chk==1)])) ",") "target" "" no 0.75 250) [BEGINFRAME: Cross Reference Search]
# b_Get_Checked_Documents (if (Nof(Index( %@.chk==1))!=0) chemblapi "document_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.document_chembl_id)[Index( %@.chk==1)])) ",") "document" "" no 0.75 250)

"""
    sort reverse T_macrotmp.confidence_score
    sort reverse T_macrotmp.Nof_Compounds

  elseif ((s_source == "molecule")|(s_source == "similarity")|(s_source == "substructure")) then
    T_macrotmp.toolsPanel += """
# b_Get_Activities_of_Checked_Parent_Compounds (if (Nof(Index( %@.chk==1))!=0) chemblapi "parent_molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.parent_chembl_id)[Index( %@.chk==1)])) ",") "activity" "" no 0.75 250) [BEGINFRAME: Activity Search]
# b_Get_Activities_of_Checked_Compounds (if (Nof(Index( %@.chk==1))!=0) chemblapi "molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.molecule_chembl_id)[Index( %@.chk==1)])) ",") "activity" "" no 0.75 250)
# b_Get_Checked_Parent_Compounds (if (Nof(Index( %@.chk==1))!=0) chemblapi "molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.parent_chembl_id)[Index( %@.chk==1)])) ",") "molecule" "" no 0.75 250) [BEGINFRAME: Chemical Search]
# r_Tanimoto_Similarity:tani (0.75)
# b_Get_Molecules_Similar_to_First_Selected_Compound (if Nof(Index( %@ selection cursor))==1 chemblapi "smiles:"+Smiles(%@.mol[Index( %@ selection cursor)])[1] "similarity" "" no $tani 250)
# b_Get_Molecules_Superstructure_to_First_Selected_Compound (if Nof(Index( %@ selection cursor))==1 chemblapi "smiles:"+Smiles(%@.mol[Index( %@ selection cursor)])[1] "substructure" "" no 0.75 250)
"""
    T_macrotmp.pref_name[Index(T_macrotmp.pref_name=="")]=Sarray(T_macrotmp.molecule_chembl_id )[Index(T_macrotmp.pref_name=="")]
    move T_macrotmp.molecule_properties Nof(S_col)+1
    set format T_macrotmp.molecule_properties show
    set property T_macrotmp.molecule_properties view
    add column T_macrotmp function='Integer(molecule_properties["num_ro5_violations"])' name='num_ro5_violations'
    add column T_macrotmp function='Integer(molecule_properties["ro3_pass"])' name='ro3_pass'
    print " Info> Converting chemical ..."
    add column T_macrotmp Chemical(Sarray(T_macrotmp.canonical_smiles ) smiles) name="mol" index=1
    sort reverse T_macrotmp.max_phase

  elseif (s_source == "activity") then
    T_macrotmp.toolsPanel += """
# b_Get_Activities_of_Checked_Parent_Compounds (if (Nof(Index( %@.chk==1))!=0) chemblapi "parent_molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.parent_molecule_chembl_id)[Index( %@.chk==1)])) ",") "activity" "" no 0.75 250) [BEGINFRAME: Activity Search]
# b_Get_Activities_of_Checked_Compounds (if (Nof(Index( %@.chk==1))!=0) chemblapi "molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.molecule_chembl_id)[Index( %@.chk==1)])) ",") "activity" "" no 0.75 250)
# b_Get_Activities_of_Checked_Targets (if (Nof(Index( %@.chk==1))!=0) chemblapi "target_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.target_chembl_id)[Index( %@.chk==1)])) ",") "activity" "" no 0.75 250)
# b_Get_Activities_of_Checked_Assays (if (Nof(Index( %@.chk==1))!=0) chemblapi "assay_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.assay_chembl_id)[Index( %@.chk==1)])) ",") "activity" "" no 0.75 250)
# b_Get_Activities_of_Checked_Documents (if (Nof(Index( %@.chk==1))!=0) chemblapi "document_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.document_chembl_id)[Index( %@.chk==1)])) ",") "activity" "" no 0.75 250)
# b_Get_Checked_Parent_Compounds (if (Nof(Index( %@.chk==1))!=0) chemblapi "molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.parent_molecule_chembl_id)[Index( %@.chk==1)])) ",") "molecule" "" no 0.75 250) [BEGINFRAME: Chemical Search]
# b_Get_Checked_Compounds (if (Nof(Index( %@.chk==1))!=0) chemblapi "molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.molecule_chembl_id)[Index( %@.chk==1)])) ",") "molecule" "" no 0.75 250)
# r_Tanimoto_Similarity:tani (0.75)
# b_Get_Molecules_Similar_to_First_Selected_Compound (if Nof(Index( %@ selection cursor))==1 chemblapi "smiles:"+Smiles(%@.mol[Index( %@ selection cursor)])[1] "similarity" "" no $tani 250)
# b_Get_Molecules_Superstructure_to_First_Selected_Compound (if Nof(Index( %@ selection cursor))==1 chemblapi "smiles:"+Smiles(%@.mol[Index( %@ selection cursor)])[1] "substructure" "" no 0.75 250)
# b_Get_Checked_Targets (if (Nof(Index( %@.chk==1))!=0) chemblapi "target_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.target_chembl_id)[Index( %@.chk==1)])) ",") "target" "" no 0.75 250) [BEGINFRAME: Cross Reference Search]
# b_Get_Checked_Assays (if (Nof(Index( %@.chk==1))!=0) chemblapi "assay_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.assay_chembl_id)[Index( %@.chk==1)])) ",") "assay" "" no 0.75 250)
# b_Get_Checked_Documents (if (Nof(Index( %@.chk==1))!=0) chemblapi "document_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.document_chembl_id)[Index( %@.chk==1)])) ",") "document" "" no 0.75 250)
# l_Combine_Mammalian:mammal (yes) [BEGINFRAME:  Extract pKd table]
# l_Keep_Only_Small_Molecules:filter (yes)
# l_Remove_PubChem_BioAssay_Data:remove (yes)
# b_Extract_pKd_Data (chemblcompress Name(variable %@) $mammal $filter $remove)
"""
    T_macrotmp.pchembl_value[Index(T_macrotmp.pchembl_value==0.)] = Toreal("ND")
    I_tmp = Index(T_macrotmp.standard_units=="nM" & T_macrotmp.standard_value<=0.)
    if (Nof(I_tmp)!=0) T_macrotmp.standard_value[I_tmp] = Toreal("ND")
    I_tmp = Index(T_macrotmp.standard_units=="nM")
    if (Nof(I_tmp)!=0) T_macrotmp.pAct[I_tmp] = 9.-Log(T_macrotmp.standard_value[I_tmp] 10.)
    I_tmp = Index(T_macrotmp.standard_units=="nM" & T_macrotmp.relation ==">")
    if (Nof(I_tmp)!=0) T_macrotmp.pAct[I_tmp] = Toreal(Sarray(Nof(I_tmp) "<" ) +9.-Log(T_macrotmp.standard_value[I_tmp] 10.))
    I_tmp = Index(T_macrotmp.standard_units=="nM" & T_macrotmp.relation ==">=")
    if (Nof(I_tmp)!=0) T_macrotmp.pAct[I_tmp] = Toreal(Sarray(Nof(I_tmp) "<=" ) +9.-Log(T_macrotmp.standard_value[I_tmp] 10.))
    I_tmp = Index(T_macrotmp.standard_units=="nM" & T_macrotmp.relation =="<")
    if (Nof(I_tmp)!=0) T_macrotmp.pAct[I_tmp] = Toreal(Sarray(Nof(I_tmp) ">" ) +9.-Log(T_macrotmp.standard_value[I_tmp] 10.))
    I_tmp = Index(T_macrotmp.standard_units=="nM" & T_macrotmp.relation =="<=")
    if (Nof(I_tmp)!=0) T_macrotmp.pAct[I_tmp] = Toreal(Sarray(Nof(I_tmp) ">=" ) +9.-Log(T_macrotmp.standard_value[I_tmp] 10.))
    set format T_macrotmp.pAct "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
    T_macrotmp.molecule_pref_name[Index(T_macrotmp.molecule_pref_name=="")]=Sarray(T_macrotmp.molecule_chembl_id )[Index(T_macrotmp.molecule_pref_name=="")]
    print " Info> Converting chemical..."
    add column T_macrotmp Chemical(Sarray(T_macrotmp.canonical_smiles ) smiles) name="mol" index=1
    sort reverse T_macrotmp.pAct
  elseif (s_source == "chembl_id_lookup") then
    T_macrotmp.toolsPanel += """
# b_Get_Checked_Compounds (if (Nof(Index( %@.chk==1 & %@.entity_type=="COMPOUND"))!=0) chemblapi "molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.chembl_id)[Index( %@.chk==1 & %@.entity_type=="COMPOUND")])) ",") "molecule" "" no 0.75 250)
# b_Get_Checked_Activities (if (Nof(Index( %@.chk==1 & %@.entity_type=="ACTIVITY"))!=0) chemblapi "activity_id__in="+Sum(Unique(Sort(Sarray( %@.chembl_id)[Index( %@.chk==1 & %@.entity_type=="ACTIVITY")])) ",") "activity" "" no 0.75 250)
# b_Get_Checked_Targets (if (Nof(Index( %@.chk==1 & %@.entity_type=="TARGET"))!=0) chemblapi "target_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.chembl_id)[Index( %@.chk==1 & %@.entity_type=="TARGET")])) ",") "target" "" no 0.75 250)
# b_Get_Checked_Assays (if (Nof(Index( %@.chk==1 & %@.entity_type=="ASSAY"))!=0) chemblapi "assay_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.chembl_id)[Index( %@.chk==1 & %@.entity_type=="ASSAY")])) ",") "assay" "" no 0.75 250)
# b_Get_Checked_Documents (if (Nof(Index( %@.chk==1 & %A.entity_type=="DOCUMENT"))!=0) chemblapi "document_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.chembl_id)[Index( %@.chk==1 & %A.entity_type=="DOCUMENT")])) ",") "document" "" no 0.75 250)
"""
  else
    if ((Type(T_macrotmp.mol)=="unknown")&((Type(T_macrotmp.molecule_chembl_id)=="sarray")|(Type(T_macrotmp.parent_chembl_id)=="sarray")|(Type(T_macrotmp.parent_molecule_chembl_id)=="sarray")|(Type(T_macrotmp.drug_chembl_id)=="sarray"))) then
      read binary s_icmhome+"models/ChEMBLCompound.icb"
      delete T_macrotmp.canonical_smiles l_warn=no
      if (Type(T_macrotmp.parent_chembl_id)=="sarray") then
        join left T_macrotmp.parent_chembl_id ChEMBLCompound.chembl_id name="T_jointmp"
        add column T_macrotmp T_jointmp.canonical_smiles name="canonical_smiles"
        add column T_macrotmp Chemical(T_macrotmp.canonical_smiles smiles) name="mol" index=1
      elseif (Type(T_macrotmp.parent_molecule_chembl_id)=="sarray") then
        join left T_macrotmp.parent_molecule_chembl_id ChEMBLCompound.chembl_id name="T_jointmp"
        add column T_macrotmp T_jointmp.canonical_smiles name="canonical_smiles"
        add column T_macrotmp Chemical(T_macrotmp.canonical_smiles smiles) name="mol" index=1
      elseif (Type(T_macrotmp.molecule_chembl_id)=="sarray") then
        join left T_macrotmp.molecule_chembl_id ChEMBLCompound.chembl_id name="T_jointmp"
        T_jointmp.parent_molregno[Index(T_jointmp.parent_molregno==0)] = T_jointmp.molregno[Index(T_jointmp.parent_molregno==0)]
        join left T_jointmp.parent_molregno ChEMBLCompound.molregno name="T_jointmp2"
        add column T_macrotmp T_jointmp2.ChEMBLCompound_canonical_smiles name="canonical_smiles"
        add column T_macrotmp Chemical(T_macrotmp.canonical_smiles smiles) name="mol" index=1
        delete T_jointmp2 l_warn=no
      elseif (Type(T_macrotmp.drug_chembl_id)=="sarray") then
        join left T_macrotmp.drug_chembl_id ChEMBLCompound.chembl_id name="T_jointmp"
        T_jointmp.parent_molregno[Index(T_jointmp.parent_molregno==0)] = T_jointmp.molregno[Index(T_jointmp.parent_molregno==0)]
        join left T_jointmp.parent_molregno ChEMBLCompound.molregno name="T_jointmp2"
        add column T_macrotmp T_jointmp2.ChEMBLCompound_canonical_smiles name="canonical_smiles"
        add column T_macrotmp Chemical(T_macrotmp.canonical_smiles smiles) name="mol" index=1
        delete T_jointmp2 l_warn=no
      endif
      delete ChEMBLCompound T_jointmp l_warn=no
    endif
    if (Type(T_macrotmp.target_chembl_id)=="sarray") then
      read binary s_icmhome+"models/ChEMBLTarget.icb"
      join left T_macrotmp.target_chembl_id ChEMBLTarget.chembl_id name="T_jointmp"
      add column T_macrotmp T_jointmp.target_type name="target_type"
      sort ChEMBLTarget.chembl_id
      group ChEMBLTarget.chembl_id ChEMBLTarget.Entry "uniq,"  ChEMBLTarget.Entry_name "uniq,"  all "first"  header  name="ChEMBLTarget_1"
      delete T_jointmp l_warn=no
      join left T_macrotmp.target_chembl_id ChEMBLTarget_1.chembl_id name="T_jointmp"
      add column T_macrotmp Replace(T_jointmp.uniq_Entry "," "\n") name="Uniprot_Accession"
      add column T_macrotmp Replace(T_jointmp.uniq_Entry_name "," "\n") name="Uniprot_ID"
      add column T_macrotmp T_jointmp.pref_name name="target_class"
      add column T_macrotmp T_jointmp.target_type name="target_type"
      add column T_macrotmp T_jointmp.target_pref_name name="target_pref_name"
      delete T_jointmp ChEMBLTarget ChEMBLTarget_1 l_warn=no
    endif
    if (s_source == "compound_structural_alert") then
      add column T_macrotmp function='Integer(alert["alert_id"])' name='alert_id'
      add column T_macrotmp function='String(alert["alert_name"])' name='alert_name'
      add column T_macrotmp function='String(alert["smarts"])' name='smarts'
    endif
    if (Type(T_macrotmp.parent_chembl_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Get_Checked_Parent_Compounds (if (Nof(Index( %@.chk==1))!=0) chemblapi "molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.parent_chembl_id)[Index( %@.chk==1)])) ",") "molecule" "" no 0.75 250)
"""
    if (Type(T_macrotmp.molecule_chembl_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Get_Checked_Compounds (if (Nof(Index( %@.chk==1))!=0) chemblapi "molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.molecule_chembl_id)[Index( %@.chk==1)])) ",") "molecule" "" no 0.75 250)
"""
if (Type(T_macrotmp.activity_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Get_Checked_Activities (if (Nof(Index( %@.chk==1))!=0) chemblapi "activity_id__in="+Sum(Unique(Sort(Sarray( %@.activity_id)[Index( %@.chk==1)])) ",") "activity" "" no 0.75 250)
"""
if (Type(T_macrotmp.target_chembl_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Get_Checked_Targets (if (Nof(Index( %@.chk==1))!=0) chemblapi "target_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.target_chembl_id)[Index( %@.chk==1)])) ",") "target" "" no 0.75 250)
"""
if (Type(T_macrotmp.related_target_chembl_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Get_Checked_Related_Targets (if (Nof(Index( %@.chk==1))!=0) chemblapi "target_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.related_target_chembl_id)[Index( %@.chk==1)])) ",") "target" "" no 0.75 250)
"""
if (Type(T_macrotmp.assay_chembl_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Get_Checked_Assays (if (Nof(Index( %@.chk==1))!=0) chemblapi "assay_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.assay_chembl_id)[Index( %@.chk==1)])) ",") "assay" "" no 0.75 250)
"""
if (Type(T_macrotmp.document_chembl_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Get_Checked_Documents (if (Nof(Index( %@.chk==1))!=0) chemblapi "document_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.document_chembl_id)[Index( %@.chk==1)])) ",") "document" "" no 0.75 250)
"""
if (Type(T_macrotmp.metabolite_chembl_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Get_Checked_Metabolite (if (Nof(Index( %@.chk==1))!=0) chemblapi "molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.metabolite_chembl_id)[Index( %@.chk==1)])) ",") "molecule" "" no 0.75 250)
"""
if (Type(T_macrotmp.substrate_chembl_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Get_Checked_Substrate (if (Nof(Index( %@.chk==1))!=0) chemblapi "molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.substrate_chembl_id)[Index( %@.chk==1)])) ",") "molecule" "" no 0.75 250)
"""
if (Type(T_macrotmp.parent_chembl_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Add_Parent_Mol_Column (delete %@.mol_parent chemblmol Name(variable %@ ) "parent_chembl_id" "mol_parent")
"""
if ((Type(T_macrotmp.molecule_chembl_id)!="unknown")&(Type(T_macrotmp.mol)=="unknown")) T_macrotmp.toolsPanel += """
# b_Add_Mol_Column (chemblmol Name(variable %@ ) "molecule_chembl_id" "mol")
"""
if (Type(T_macrotmp.metabolite_chembl_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Add_Metablite_Mol_Column (delete %@.mol_metabolite l_warn=no; chemblmol Name(variable %@ ) "metabolite_chembl_id" "mol_metabolite")
"""
if (Type(T_macrotmp.substrate_chembl_id)!="unknown") T_macrotmp.toolsPanel += """
# b_Add_Substrate_Mol_Column (delete %@.mol_substrate l_warn=no; chemblmol Name(variable %@ ) "substrate_chembl_id" "mol_substrate")
"""

  endif
  add column T_macrotmp Iarray(Nof(T_macrotmp) 0) name="chk" index=1
  set property T_macrotmp.chk logical
  S_colname = {"Uniprot_ID","Uniprot_Accession","accession","molecule_chembl_id","parent_chembl_id","parent_molecule_chembl_id","assay_chembl_id"}
  S_colname //= {"drug_chembl_id","metabolite_chembl_id","substrate_chembl_id","target_chembl_id","related_target_chembl_id","document_chembl_id"}
  S_colname //= {"document_1_chembl_id","document_2_chembl_id","pubmed_id","doi","cell_chembl_id","tissue_chembl_id"}
  S_html = Sarray(3 "<a href=http://www.uniprot.org/uniprot/%1>%1</a>")
  S_html //= Sarray(6 "<a href=https://www.ebi.ac.uk/chembl/compound/inspect/%1>%1</a>")
  S_html //= Sarray(1 "<a href=https://www.ebi.ac.uk/chembl/assay/inspect/%1>%1</a>")
  S_html //= Sarray(2 "<a href=https://www.ebi.ac.uk/chembl/target/inspect/%1>%1</a>")
  S_html //= Sarray(3 "<a href=https://www.ebi.ac.uk/chembl/doc/inspect/%1>%1</a>")
  S_html //= Sarray(1 "<a href=https://www.ncbi.nlm.nih.gov/pubmed/%1>%1</a>")
  S_html //= Sarray(1 "<a href=https://doi.org/%1>%1</a>")
  S_html //= Sarray(1 "<a href=https://www.ebi.ac.uk/chembl/cell/inspect/%1>%1</a>")
  S_html //= Sarray(1 "<a href=https://www.ebi.ac.uk/chembl/tissue/inspect/%1>%1</a>")
  S_col = Name(T_macrotmp column)
  for i_col = 1, Nof(S_col)
    s_col = S_col[i_col]
    i_tmp = Index(S_colname Field(s_col 2 "."))
    if (i_tmp==0) continue
    set format $s_col S_html[i_tmp]
  endfor

  if (s_tabname!="") then
    if (Type($s_tabname)=="table") then
      $s_tabname.page_meta = T_macrotmp.page_meta
      $s_tabname.toolsPanel = T_macrotmp.toolsPanel
      add $s_tabname T_macrotmp
    else
      delete $s_tabname l_warn=no
      rename T_macrotmp s_tabname
    endif
  else
    if (s_query == "") then
      s_tabname = Name(Toupper(s_source 1)+"_all" unique)
    elseif ((s_source=="substructure")|(s_source=="similarity")) then
      s_tabname = Name(Toupper(s_source 1)+"_"+T_macrotmp.parent_chembl_id [1] unique)
    else
      if (Nof(s_query "=")==0) then
        s_tabname = Name(Toupper(s_source 1)+"_"+Field(s_query 1 "=,") unique)
      else
        s_tabname = Name(Toupper(s_source 1)+"_"+Replace(Field(s_query 2 "=,") "/" "") unique)
      endif
    endif
    rename T_macrotmp s_tabname
  endif
  set property $s_tabname header
  keep $s_tabname global
endmacro
#
macro iupharapi s_query ("") s_source ("targets") auto
HELP="""
  Search IUPHAR using its API: https://www.guidetopharmacology.org/webServices.jsp
  A local search is first performed for targets, ligands, and interactions; if entries are found, the API search will not be performed

  Syntax: iupharapi <s_query> <s_source>
  <s_query>: Empty string will return all entries, local search is implemented for primary id, Name, etc
             If field matches the local table's column name, a local search will be performed, e.g. 'target_id=1387&ligand_id=8752' in interactions table
             If local search fails, online API search will be performed
  <s_source>: 'targets','ligands','interactions','diseases','refs'

  Example:
  iupharapi # local search for all targets
  iupharapi '' 'targets' # same as above
  iupharapi 'ESR*' 'targets' # local search for all ESRs in Uniprot Prefix or GENE name
  iupharapi '1' 'targets' # local search for targets with target_id == 1
  iupharapi '1,2,3' 'targets' # local search for targets with target_id equals 1, 2, or 3
  iupharapi 'accession=ENSG00000097007&database=EnsemblGene' 'targets' # online search using IUPHAR's API, see https://www.guidetopharmacology.org/webServices.jsp
  iupharapi '221/interactions?type=Agonist&affinityType=pKi&affinity=7' 'targets' # another example for online search

  iupharapi '' 'ligands' # local search for all ligands
  iupharapi 'venetoclax' 'ligands' # local search for compound name
  iupharapi '1,2,3' 'ligands' # local search for ligands with ligand_id equals 1, 2, or 3
  iupharapi 'similarity?smiles=CC(CN(C)C)CN1c2ccccc2Sc2ccccc12&similarityGt=80' 'ligands' # online search using IUPHAR's API, see https://www.guidetopharmacology.org/webServices.jsp
  iupharapi 'substructure?smiles=Nc1cnc(Cl)c(N)n1&logpGt=0&logpLt=2' 'ligands' # another example for online search

  iupharapi '' 'interactions' # local search for all interactions
  iupharapi 'target_id=1387&ligand_id=8752' 'interactions' # local search using both criteria
  iupharapi 'affinityType=pki&approved=true&targetType=GPCR' 'interactions' # online search using IUPHAR's API, see https://www.guidetopharmacology.org/webServices.jsp

  iupharapi '' 'diseases' # online search for all diseases, might take a while, see https://www.guidetopharmacology.org/webServices.jsp
  iupharapi 'database=DOID&accession=6688' 'diseases' # another example for online search

  iupharapi '' 'refs' # online search for all references, will definitely take a while
"""
  l_info = l_warn = l_commands = no
  s_query = Trim(s_query all)
  s_source = Trim(s_source all)
  S_source = {"targets","ligands","interactions","diseases","refs"}
  if (Index(S_source s_source)==0) return "s_source can only be 'targets','ligands','interactions','diseases','refs'"
  if (s_source == "") s_source = "targets"
  delete t_macrotmpfin t_macrotmp l_warn=no
  if (s_source == "targets") then
    s_tabname = Name("IUPHAR_Target" unique)
    s_tabnameAPI = s_tabname+"API"
    if (Type(IUPHARTarget) =="unknown") then
      read binary s_icmhome+"models/IUPHARTarget.icb"
      l_loaded = no
    else
      l_loaded = yes
    endif
    I_tmpmacro = Iarray(0)
    l_localsearch = no
    if (s_query=="") then
      l_localsearch = yes
      t_macrotmpfin = IUPHARTarget
      I_tmpmacro = Count(Nof(t_macrotmpfin))
    elseif ((Nof(s_query "/")==0)&(Field(s_query 1 "/")!="families")) then
      l_localsearch = yes
      if (Nof(s_query "=")==0) then
        if (Nof(s_query ",")==0) then
          I_tmpmacro = Index(IUPHARTarget.Target ~ Toupper(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Target_id == s_query)
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.HGNC_symbol ~ Toupper(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Human_SwissProt ~ Toupper(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Rat_SwissProt ~ Toupper(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Mouse_SwissProt ~ Toupper(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Type ~ Replace(Tolower(s_query) " " "_"))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Target_name~ s_query+"*" )
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.HGNC_name~ s_query+"*" )
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Protein_names~ Toupper(s_query 1)+"*" )
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Family_name~ Toupper(s_query 1 )+"*" )
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(Index(IUPHARTarget.synonyms s_query simple) 1 all) // Index(IUPHARTarget.synonyms "*|"+s_query all) // Index(IUPHARTarget.synonyms "*|"+s_query+"|*" all)
        else
          S_macrotmp = Split(s_query ",")
          I_tmpmacro = Index(IUPHARTarget.Target==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Target_id==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.HGNC_symbol==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Human_SwissProt==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Rat_SwissProt==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Mouse_SwissProt==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARTarget.Type==Replace(Tolower(S_macrotmp) " " "_"))
        endif
        if (Nof(I_tmpmacro)!=0) t_macrotmpfin = IUPHARTarget[I_tmpmacro]
      else
        S_query = Split(s_query "&")
        S_field = Field(S_query 1 "=")
        S_query = Field(S_query 2 "=")
        l_localsearch = yes
        for i_field = 1, Nof(S_field)
          s_field = S_field[i_field]
          if (Type(IUPHARTarget.$s_field)!="sarray") l_localsearch = no
        endfor
        if (l_localsearch) then
          s_field = S_field[1]
          if (Nof(S_query[1] ",")==0) then
            t_macrotmpfin = IUPHARTarget.$s_field == S_query[1]
          else
            t_macrotmpfin = IUPHARTarget.$s_field == Split(S_query[1] ",")
          endif
          for i_field = 2, Nof(S_field)
            s_field = S_field[i_field]
            if (Nof(S_query[i_field] ",")==0) then
              t_macrotmpfin = t_macrotmpfin.$s_field == S_query[i_field]
            else
              t_macrotmpfin = t_macrotmpfin.$s_field == Split(S_query[i_field] ",")
            endif
          endfor
          I_tmpmacro = Count(Nof(t_macrotmpfin))
        endif
      endif
    endif
    if (!l_localsearch) then
      s_fullquery = "https://www.guidetopharmacology.org/services/"+s_source
      if ((s_query[1]=="/") | (s_query[1]=="?")) then
        s_fullquery = s_fullquery+s_query
      elseif ((Tointeger(Field(s_query 1 "/")) !=0)|(Field(s_query 1 "/")=="families")) then
        s_fullquery = s_fullquery+"/"+s_query
      else
        s_fullquery = s_fullquery+"?"+s_query
      endif
      delete x_macro l_warn=no
      delete s_macro l_warn=no
      i_out = 0
      print " Info> Searching:" s_fullquery
      read string s_fullquery name="s_macro" l_warn=yes
      if (((i_out)!=404)&(s_macro!="")) then
        x_macro = Collection(s_macro)
        t_macrotmp = Table(x_macro)
        if (Type(t_macrotmp.targetId)!="unknown") then
          t_macrotmpfin = IUPHARTarget.Target_id == Tostring(t_macrotmp.targetId)
        elseif (Type(t_macrotmp.targetIds)!="unknown") then
          I_tmpmacro = Iarray(0)
          for i_macrotmp = 1, Nof(t_macrotmp)
            I_tmpmacro //= t_macrotmp.targetIds[i_macrotmp]
          endfor
          I_tmpmacro = Unique(Sort(I_tmpmacro))
          t_macrotmpfin = IUPHARTarget.Target_id == Tostring(I_tmpmacro)
        endif
        if (Nof(t_macrotmpfin)==0) then
          if (Nof(t_macrotmp column)<=1) print x_macro
          if (Type(x_macro["targetId"])=="iarray") then
            t_macrotmpfin = IUPHARTarget.Target_id == Tostring(x_macro["targetId"])
          elseif (Type(x_macro["targetIds"])=="iarray") then
            t_macrotmpfin = IUPHARTarget.Target_id == Tostring(x_macro["targetIds"])
          elseif (Tointeger(Replace(s_query "^/" "" ) )!=0) then
            t_macrotmpfin = IUPHARTarget.Target_id == Field(Tostring(Replace(s_query "^/" "" )) 1 "/")
          endif
        endif
      endif
    endif
    if (!l_loaded) delete IUPHARTarget l_warn=no
    if (Type(t_macrotmpfin)=="unknown") return " Info> Target search cannot find anything, please check your query term"
  elseif (s_source == "ligands") then
    s_tabname = Name("IUPHAR_Ligand" unique)
    s_tabnameAPI = s_tabname+"API"
    if (Type(IUPHARLigand) =="unknown") then
      read binary s_icmhome+"models/IUPHARLigand.icb"
      l_loaded = no
    else
      l_loaded = yes
    endif
    I_tmpmacro = Iarray(0)
    l_localsearch = no
    if (s_query=="") then
      l_localsearch = yes
      t_macrotmpfin = IUPHARLigand
      I_tmpmacro = Count(Nof(t_macrotmpfin))
    elseif ((Nof(s_query "/")==0)&(Nof(s_query "?")==0)&(Field(s_query 1 "/")!="families")) then
      l_localsearch = yes
      if (Nof(s_query "=")==0) then
        if (Nof(s_query ",")==0) then
          I_tmpmacro = Index(IUPHARLigand.Ligand_id == s_query)
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(Index(IUPHARLigand.Name s_query simple) 1 all)
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.INN ~ Tolower(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.ChEMBl_ID ~ Toupper(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.Chebi_ID ~ Toupper(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.CAS ~ Toupper(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.DrugBank_ID ~ Toupper(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.smiles ~ s_query)
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.Type ~ Toupper(Tolower(s_query) 1))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(Index(IUPHARLigand.Synonyms s_query simple) 1 all) // Index(IUPHARLigand.Synonyms "*|"+s_query all) // Index(IUPHARLigand.Synonyms "*|"+s_query+"|*" all)
        else
          S_macrotmp = Split(s_query ",")
          I_tmpmacro = Index(IUPHARLigand.Ligand_id==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.Name==S_macrotmp)
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.INN==Tolower(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.ChEMBl_ID==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.Chebi_ID==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.CAS==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.DrugBank_ID==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.smiles==S_macrotmp)
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARLigand.Type==Toupper(S_macrotmp))
        endif
        if (Nof(I_tmpmacro)!=0) t_macrotmpfin = IUPHARLigand[I_tmpmacro]
      else
        S_query = Split(s_query "&")
        S_field = Field(S_query 1 "=")
        S_query = Field(S_query 2 "=")
        l_localsearch = yes
        for i_field = 1, Nof(S_field)
          s_field = S_field[i_field]
          if (Type(IUPHARLigand.$s_field)!="sarray") l_localsearch = no
        endfor
        if (l_localsearch) then
          s_field = S_field[1]
          if (Nof(S_query[1] ",")==0) then
            t_macrotmpfin = IUPHARLigand.$s_field == S_query[1]
          else
            t_macrotmpfin = IUPHARLigand.$s_field == Split(S_query[1] ",")
          endif
          for i_field = 2, Nof(S_field)
            s_field = S_field[i_field]
            if (Nof(S_query[i_field] ",")==0) then
              t_macrotmpfin = t_macrotmpfin.$s_field == S_query[i_field]
            else
              t_macrotmpfin = t_macrotmpfin.$s_field == Split(S_query[i_field] ",")
            endif
          endfor
          I_tmpmacro = Count(Nof(t_macrotmpfin))
        endif
      endif
    endif
    if (!l_localsearch) then
      s_fullquery = "https://www.guidetopharmacology.org/services/"+s_source
      if ((s_query[1]=="/") | (s_query[1]=="?")) then
        s_fullquery = s_fullquery+s_query
      elseif ((Tointeger(Field(s_query 1 "/")) !=0)|(Field(s_query 1 "/")=="families")) then
        s_fullquery = s_fullquery+"/"+s_query
      elseif ((Field(s_query 1 "?")=="similarity")|(Field(s_query 1 "?")=="exact")|(Field(s_query 1 "?")=="substructure")) then
        s_fullquery = s_fullquery+"/"+s_query
      else
        s_fullquery = s_fullquery+"?"+s_query
      endif
      delete x_macro l_warn=no
      delete s_macro l_warn=no
      i_out = 0
      print " Info> Searching:" s_fullquery
      read string s_fullquery name="s_macro" l_warn=yes
      if (((i_out)!=404)&(s_macro!="")) then
        x_macro = Collection(s_macro)
        t_macrotmp = Table(x_macro)
        if (Type(t_macrotmp.ligandId)!="unknown") then
          t_macrotmpfin = IUPHARLigand.Ligand_id == Tostring(t_macrotmp.ligandId)
        elseif (Type(t_macrotmp.ligandIds)!="unknown") then
          I_tmpmacro = Iarray(0)
          for i_macrotmp = 1, Nof(t_macrotmp)
            I_tmpmacro //= t_macrotmp.ligandIds[i_macrotmp]
          endfor
          I_tmpmacro = Unique(Sort(I_tmpmacro))
          t_macrotmpfin = IUPHARLigand.Ligand_id == Tostring(I_tmpmacro)
        endif
        if (Nof(t_macrotmpfin)==0) then
          if (Nof(t_macrotmp column)<=1) print x_macro
          if (Type(x_macro["ligandId"])=="iarray") then
            t_macrotmpfin = IUPHARLigand.Ligand_id == Tostring(x_macro["ligandId"])
          elseif (Type(x_macro["ligandIds"])=="iarray") then
            t_macrotmpfin = IUPHARLigand.Ligand_id == Tostring(x_macro["ligandIds"])
          elseif (Tointeger(Replace(s_query "^/" "" ) )!=0) then
            t_macrotmpfin = IUPHARLigand.Ligand_id == Field(Tostring(Replace(s_query "^/" "" )) 1 "/")
          endif
        endif
      endif
    endif
    if (!l_loaded) delete IUPHARLigand l_warn=no
    if (Type(t_macrotmpfin)=="unknown") return " Info> Ligand search cannot find anything, please check your query term"
  elseif (s_source == "interactions") then
    s_tabname = Name("IUPHAR_Interaction" unique)
    s_tabnameAPI = s_tabname+"API"
    if (Type(IUPHARInteraction) =="unknown") then
      read binary s_icmhome+"models/IUPHARInteraction.icb"
      l_loaded = no
    else
      l_loaded = yes
    endif
    I_tmpmacro = Iarray(0)
    l_localsearch = no
    if (s_query=="") then
      l_localsearch = yes
      t_macrotmpfin = IUPHARInteraction
      I_tmpmacro = Count(Nof(t_macrotmpfin))
    elseif ((Nof(s_query "/")==0)&(Length(Tostring(Tointeger(s_query)))!=Length(s_query))) then
      l_localsearch = yes
      if (Nof(s_query "=")==0) then
        if (Nof(s_query ",")==0) then
          I_tmpmacro = Index(Index(IUPHARInteraction.ligand s_query simple) 1 all)
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARInteraction.Target ~ Toupper(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARInteraction.target ~ s_query)
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(Index(IUPHARInteraction.target_gene_symbol s_query simple) 1 all)
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARInteraction.target_uniprot ~ Toupper(s_query))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARInteraction.smiles ~ s_query)
        else
          S_macrotmp = Split(s_query ",")
          I_tmpmacro = Index(IUPHARInteraction.ligand==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARInteraction.Target==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARInteraction.target==S_macrotmp)
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARInteraction.target_gene_symbol==S_macrotmp)
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARInteraction.target_uniprot==Toupper(S_macrotmp))
          if (Nof(I_tmpmacro)==0) I_tmpmacro = Index(IUPHARInteraction.smiles==S_macrotmp)
        endif
        if (Nof(I_tmpmacro)!=0) t_macrotmpfin = IUPHARInteraction[I_tmpmacro]
      else
        S_query = Split(s_query "&")
        S_field = Field(S_query 1 "=")
        S_query = Field(S_query 2 "=")
        l_localsearch = yes
        for i_field = 1, Nof(S_field)
          s_field = S_field[i_field]
          if (Type(IUPHARInteraction.$s_field)!="sarray") l_localsearch = no
        endfor
        if (l_localsearch) then
          s_field = S_field[1]
          if (Nof(S_query[1] ",")==0) then
            t_macrotmpfin = IUPHARInteraction.$s_field == S_query[1]
          else
            t_macrotmpfin = IUPHARInteraction.$s_field == Split(S_query[1] ",")
          endif
          for i_field = 2, Nof(S_field)
            s_field = S_field[i_field]
            if (Nof(S_query[i_field] ",")==0) then
              t_macrotmpfin = t_macrotmpfin.$s_field == S_query[i_field]
            else
              t_macrotmpfin = t_macrotmpfin.$s_field == Split(S_query[i_field] ",")
            endif
          endfor
          I_tmpmacro = Count(Nof(t_macrotmpfin))
        endif
      endif
    endif
    if (!l_localsearch) then
      s_fullquery = "https://www.guidetopharmacology.org/services/"+s_source
      if ((s_query[1]=="/") | (s_query[1]=="?")) then
        s_fullquery = s_fullquery+s_query
      elseif (Tointeger(Field(s_query 1 "/")) !=0) then
        s_fullquery = s_fullquery+"/"+s_query
      else
        s_fullquery = s_fullquery+"?"+s_query
      endif
      delete x_macro l_warn=no
      delete s_macro l_warn=no
      i_out = 0
      print " Info> Searching:" s_fullquery
      read string s_fullquery name="s_macro" l_warn=yes
      if (((i_out)!=404)&(s_macro!="")) then
        x_macro = Collection(s_macro)
        t_macrotmp = Table(x_macro)
        if ((Type(t_macrotmp.ligandId)!="unknown") & (Type(t_macrotmp.targetId)!="unknown")) then
          I_tmpmacro = Iarray(0)
          if (Type(t_macrotmp.ligandId) == "integer") then
            I_tmpmacro //= Index(IUPHARInteraction.ligand_id == Tostring(t_macrotmp.ligandId) &  IUPHARInteraction.target_id == Tostring(t_macrotmp.targetId))
          else
            for i_cpd = 1, Nof(t_macrotmp.ligandId)
              I_tmpmacro //= Index(IUPHARInteraction.ligand_id == Tostring(t_macrotmp.ligandId[i_cpd]) &  IUPHARInteraction.target_id == Tostring(t_macrotmp.targetId[i_cpd]))
            endfor
          endif
          I_tmpmacro = Unique(Sort(I_tmpmacro))
          t_macrotmpfin = IUPHARInteraction[I_tmpmacro]
        elseif ((Type(t_macrotmp.ligandIds)!="unknown") & (Type(t_macrotmp.targetIds)!="unknown")) then
          I_tmpmacro = Iarray(0)
          for i_cpd = 1, Nof(t_macrotmp.ligandIds)
            I_tmpmacro //= Index(IUPHARInteraction.ligand_id == Tostring(t_macrotmp.ligandIds[i_cpd]) &  IUPHARInteraction.target_id == Tostring(t_macrotmp.targetIds[i_cpd]))
          endfor
          I_tmpmacro = Unique(Sort(I_tmpmacro))
          t_macrotmpfin = IUPHARInteraction[I_tmpmacro]
        endif
        if (Nof(t_macrotmpfin)==0) then
          if (Nof(t_macrotmp column)<=1) print x_macro
        endif
      endif
    endif
    if (!l_loaded) delete IUPHARInteraction l_warn=no
    if (Type(t_macrotmpfin)=="unknown") return " Info> Interaction search cannot find anything, please check your query term"
  elseif ((s_source == "diseases")|(s_source == "refs")) then
    s_tabnameAPI = Name("IUPHAR_"+Toupper(s_source 1)+"API" unique)
    s_tabname = Replace(s_tabnameAPI "API" "")
    I_tmpmacro = Iarray(0)
    l_localsearch = no
    if (!l_localsearch) then
      s_fullquery = "https://www.guidetopharmacology.org/services/"+s_source
      if (s_query == "") then
      elseif ((s_query[1]=="/") | (s_query[1]=="?")) then
        s_fullquery = s_fullquery+s_query
      elseif (Tointeger(Field(s_query 1 "/")) !=0) then
        s_fullquery = s_fullquery+"/"+s_query
      else
        s_fullquery = s_fullquery+"?"+s_query
      endif
      delete x_macro l_warn=no
      delete s_macro l_warn=no
      i_out = 0
      print " Info> Searching:" s_fullquery
      read string s_fullquery name="s_macro" l_warn=yes
      if (((i_out)!=404)&(s_macro!="")) then
        x_macro = Collection(s_macro)
        t_macrotmp = Table(x_macro)
        if (Nof(t_macrotmp column)<=1) print x_macro
      endif
    endif
  endif
  if (Type(t_macrotmp)!="unknown") then
    delete $s_tabnameAPI l_warn=no
    rename t_macrotmp s_tabnameAPI
    keep $s_tabnameAPI
  endif
  if (Type(t_macrotmpfin)!="unknown") then
    rename t_macrotmpfin s_tabname
    keep $s_tabname
    set foreground $s_tabname
  endif
endmacro
#
macro chemblcompress s_origtab ("") l_combinemammal (yes) l_filterbysize (yes) l_removePubChem (yes) auto
  l_info = l_commands = l_warn = no
  s_origtab = Trim(s_origtab all)
  if (s_origtab=="") return "Please specify ChEMBL Activity Table name"
  if (Type($s_origtab.chk)=="unknown") then
    add column $s_origtab Iarray(Nof($s_origtab) 0) name="chk" index=1
    set property $s_origtab.chk logical
  endif
  if ((Type($s_origtab.mol)!="parray") & (Type($s_origtab.Smiles)=="sarray")) then
#    $s_origtab = $s_origtab.Smiles != ""
    add column $s_origtab Chemical($s_origtab.Smiles smiles) name="mol" index=2
  endif
  if (Type($s_origtab.mol)!="parray") return "Please specify ChEMBL Activity Table name"
  if (Type($s_origtab.molecule_pref_name)=="unknown") then
    add column $s_origtab Sarray(Nof($s_origtab) "") name="molecule_pref_name" index=3
    if (Type($s_origtab.Molecule_Name)=="sarray") then
      $s_origtab.molecule_pref_name = $s_origtab.Molecule_Name
#      delete $s_origtab.Molecule_Name l_warn=no
    endif
    if (Type($s_origtab.Molecule_ChEMBL_ID)=="sarray") then
      $s_origtab.molecule_pref_name [Index($s_origtab.molecule_pref_name=="")] = ($s_origtab).Molecule_ChEMBL_ID[Index($s_origtab.molecule_pref_name=="")]
      add column $s_origtab $s_origtab.Molecule_ChEMBL_ID name="molecule_chembl_id"
      add column $s_origtab $s_origtab.Molecule_ChEMBL_ID name="parent_molecule_chembl_id"
#      delete  $s_origtab.Molecule_ChEMBL_ID l_warn=no
    endif
  endif
  I_tmp = Iarray(0)
  if (Type($s_origtab.chk)=="iarray") then
    I_tmp = Index($s_origtab.chk==1)
  endif
  if (Nof(I_tmp)==0) then
    if (Nof(Index($s_origtab selection cursor))!=1) then
      I_tmp = Index($s_origtab selection cursor)
    else
      I_tmp = Count(Nof($s_origtab))
    endif
  endif
  T_macrotmp = $s_origtab[I_tmp]
  if (Type(T_macrotmp.pAct)=="unknown") then
    if (Type(T_macrotmp.pChEMBL_Value)!="unknown") then
      add column T_macrotmp Toreal(T_macrotmp.pChEMBL_Value) name="pAct" index=3
      T_macrotmp = T_macrotmp.Standard_Value != ""
      add column T_macrotmp Toreal( T_macrotmp.Standard_Value ) name="tmpvalid"
      T_macrotmp = T_macrotmp.tmpvalid > 0.
      I_tmp = Index(T_macrotmp.Standard_Relation == "'='" & T_macrotmp.Standard_Units == "nM")
      T_macrotmp.pAct[I_tmp] =  -Log(Toreal(T_macrotmp.Standard_Value[I_tmp]) 10)+9.
      I_tmp = Index(T_macrotmp.Standard_Relation == "'>'" & T_macrotmp.Standard_Units == "nM")
      T_macrotmp.pAct[I_tmp] =  -Log(Toreal(Sarray(Nof(I_tmp)">")+T_macrotmp.Standard_Value[I_tmp]) 10)+9.
      I_tmp = Index(T_macrotmp.Standard_Relation == "'>='" & T_macrotmp.Standard_Units == "nM")
      T_macrotmp.pAct[I_tmp] =  -Log(Toreal(Sarray(Nof(I_tmp)">=")+T_macrotmp.Standard_Value[I_tmp]) 10)+9.
      I_tmp = Index(T_macrotmp.Standard_Relation == "'<'" & T_macrotmp.Standard_Units == "nM")
      T_macrotmp.pAct[I_tmp] =  -Log(Toreal(Sarray(Nof(I_tmp)"<")+T_macrotmp.Standard_Value[I_tmp]) 10)+9.
      I_tmp = Index(T_macrotmp.Standard_Relation == "'<='" & T_macrotmp.Standard_Units == "nM")
      T_macrotmp.pAct[I_tmp] =  -Log(Toreal(Sarray(Nof(I_tmp)"<=")+T_macrotmp.Standard_Value[I_tmp]) 10)+9.
    endif
  endif
  if (Type(T_macrotmp.pAct)!="rarray") return "Need pAct Column"
  T_macrotmp = T_macrotmp.pAct != Toreal("ND")
  if (Nof(T_macrotmp)==0) return "No Chemical with pAct"
  if (Type(T_macrotmp.target_type)=="unknown") then
    if (Type(T_macrotmp.Target_Type)!="unknown") rename T_macrotmp.Target_Type "target_type"
  endif
  if (Type(T_macrotmp.target_type)!="sarray") return "Need target_type Column"
#  T_macrotmp = T_macrotmp.target_type == "SINGLE PROTEIN" | T_macrotmp.target_type == "PROTEIN-PROTEIN INTERACTION" |  T_macrotmp.target_type == "PROTEIN FAMILY" | T_macrotmp.target_type == "PROTEIN COMPLEX"
  if (Nof(T_macrotmp)==0) return "No Chemical in SINGLE PROTEIN target"
  if (Type(T_macrotmp.Uniprot_ID)=="unknown")  then
    add column T_macrotmp T_macrotmp.Target_ChEMBL_ID name="Uniprot_ID" index=4
  endif
  if (Type(T_macrotmp.Uniprot_ID)!="sarray") return "Need Uniprot_ID Column"
  S_mammalian = {"HUMAN","MOUSE","RAT","BOVIN","PIG","RABIT","CANLF","CAVPO","MACMU","SHEEP","MACFA","CRIGR","MESAU","HORSE","CHLAE","CALJA","FELCA","MICOH","MUSCR","PANTR","CAPHI","CRILO","MERUN"}
  add column T_macrotmp T_macrotmp.Uniprot_ID name="Uniprot" index=5
  set format T_macrotmp.Uniprot "" name="Uniprot"
  if (l_combinemammal) then
    T_macrotmp.Uniprot = Replace(T_macrotmp.Uniprot Sarray(Nof(S_mammalian )"_")+S_mammalian "")
    T_macrotmp = T_macrotmp.Uniprot !~ "*_*"
    if (Nof(T_macrotmp)==0) return "No Mammalian entries"
  endif
  modify T_macrotmp.mol delete salt
  modify T_macrotmp.mol delete salt simple
  delete hydrogen T_macrotmp.mol
  modify T_macrotmp.mol auto
  modify T_macrotmp.mol delete charge
  T_macrotmp = T_macrotmp.mol != Chemical("")
  if (Type( T_macrotmp.data_validity_comment)=="unknown") rename T_macrotmp.Data_Validity_Comment "data_validity_comment"
  T_macrotmp = T_macrotmp.data_validity_comment == ""
  if (Type( T_macrotmp.activity_comment)=="unknown") rename T_macrotmp.Comment "activity_comment"
  T_macrotmp = T_macrotmp.activity_comment!~"[Ii]nactive*"&T_macrotmp.activity_comment!~"[Ii]nconclusive*"&T_macrotmp.activity_comment!~"[Nn]ot [Aa]ctive*"
  if (l_filterbysize) then
    add column T_macrotmp function="MolWeight(mol)" index=3 name="molWeight" append format="%.3f"
    add column T_macrotmp function="Nof_RotB(mol)" index=3 name="nof_RotB" append
    T_macrotmp = T_macrotmp.molWeight <= 700.
    T_macrotmp = T_macrotmp.nof_RotB <= 15.
    delete T_macrotmp.molWeight T_macrotmp.nof_RotB l_warn=no
  endif
  if (Nof(T_macrotmp)==0) return "No Chemical after filtering off MW>700 & nof_RotB>15"
  if (Type(T_macrotmp.assay_description)=="unknown") rename T_macrotmp.Assay_Description "assay_description"
  if (l_removePubChem) then
    T_macrotmp = T_macrotmp.assay_description !~ "PUBCHEM_BIOASSAY:*"
    T_macrotmp = T_macrotmp.assay_description !~ "PubChem*"
  endif
#  add column T_macrotmp T_macrotmp.Uniprot + Smiles(T_macrotmp.mol unique cistrans) name="uniqid"
  add column T_macrotmp Smiles(T_macrotmp.mol unique cistrans) name="smiles"
#  add column T_macrotmp T_macrotmp.Uniprot + T_macrotmp.parent_molecule_chembl_id name="uniqid"
  add column T_macrotmp T_macrotmp.Uniprot + T_macrotmp.smiles name="uniqid"
  sort reverse T_macrotmp.pAct
  sort T_macrotmp.uniqid

  if (Type(T_macrotmp.Uniprot_Accession)=="unknown") add column T_macrotmp T_macrotmp.Uniprot name="Uniprot_Accession"
  if (Type(T_macrotmp.activity_id)=="unknown") add column T_macrotmp T_macrotmp.Assay_ChEMBL_ID name="activity_id"
  if (Type(T_macrotmp.assay_chembl_id)=="unknown") rename T_macrotmp.Assay_ChEMBL_ID "assay_chembl_id"
  if (Type(T_macrotmp.target_chembl_id)=="unknown") rename T_macrotmp.Target_ChEMBL_ID "target_chembl_id"
  if (Type(T_macrotmp.document_chembl_id)=="unknown") rename T_macrotmp.Document_ChEMBL_ID "document_chembl_id"
  if (Type(T_macrotmp.target_pref_name)=="unknown") rename T_macrotmp.Target_Name "target_pref_name"

  group T_macrotmp.uniqid T_macrotmp.mol T_macrotmp.molecule_pref_name "unique,name" T_macrotmp.Uniprot "unique,Target" T_macrotmp.pAct "count,count" \
  T_macrotmp.pAct "min,min" T_macrotmp.pAct "max,max" T_macrotmp.pAct "mean,mean" T_macrotmp.pAct "rmsd,rmsd" name="T_macrotmp2" \
  T_macrotmp.Uniprot_ID "unique,Uniprot_ID" T_macrotmp.target_pref_name "unique,Target_Name" T_macrotmp.Uniprot_Accession "unique,Uniprot_Accession" \
  T_macrotmp.activity_id "unique,activity_id" T_macrotmp.assay_chembl_id "unique,assay_id" T_macrotmp.molecule_chembl_id "unique,molecule_id" \
  T_macrotmp.parent_molecule_chembl_id "unique,parent_id" T_macrotmp.target_chembl_id "unique,target_id" T_macrotmp.document_chembl_id "unique,document_id"
  add column T_macrotmp2 Rarray(Nof(T_macrotmp2)) name="pKd"
  for i_macro = 1, Nof(T_macrotmp2)
    tmp = T_macrotmp.uniqid == T_macrotmp2.uniqid [i_macro]
    sort tmp.pAct reverse
    T_macrotmp2.pKd[i_macro] = tmp.pAct [Integer(Ceil(Nof(tmp) * 0.2))]
    delete tmp
  endfor
  if (Type(T_macrotmp2.chk)=="unknown") then
    add column T_macrotmp2 Iarray(Nof(T_macrotmp2) 0) name="chk" index=1
    set property T_macrotmp2.chk logical
  endif
  move T_macrotmp2.Target 3
  move T_macrotmp2.pKd 4
  move T_macrotmp2.name 3
  delete T_macrotmp2.uniqid l_warn=no
  s_pKdcomment = "pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value"
  set format T_macrotmp2.pKd "%.1f" name="pKd" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_pKdcomment
  sort T_macrotmp2.Target
  sort T_macrotmp2.pKd reverse

  add header T_macrotmp2 name="toolsPanel" ""
T_macrotmp2.toolsPanel += """
# b_Get_Original_Activities_of_Selected_Entries (chemblapi "parent_molecule_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.parent_id)[Index( %@ selection cursor)])) ",")+"&target_chembl_id__in="+Sum(Unique(Sort(Sarray( %@.target_id)[Index( %@ selection cursor)])) ",") "activity" "" no 0.75 250) [BEGINFRAME: Activity Search]
"""
  s_tabname = Name("pKd_"+Replace(s_origtab "Activity_" "") unique)
  rename T_macrotmp2 s_tabname
  set property $s_tabname header
  keep $s_tabname
endmacro
#
macro chemblmol s_origtab ("") s_chemblid ("") s_molname ("") auto
  l_info = l_commands = l_warn = no
  s_origtab = Trim(s_origtab all)
  if (s_origtab == "") return "Please specify a table name"
  if (Type($s_origtab )!="table") return "Please specify the name of the table"
  s_chemblid = Trim(s_chemblid all)
  if (s_chemblid !="") then
    s_chemblidcol = s_origtab+"."+s_chemblid
    if (Type($s_chemblidcol)=="unknown") return "Please specify the ChEMBL molecule_id column name"
  elseif (Type($s_origtab.parent_molecule_chembl_id)!="unknown") then
    s_chemblidcol = s_origtab+".parent_molecule_chembl_id"
  elseif (Type($s_origtab.parent_chembl_id)!="unknown") then
    s_chemblidcol = s_origtab+".parent_chembl_id"
  elseif (Type($s_origtab.molecule_chembl_id)!="unknown") then
    s_chemblidcol = s_origtab+".molecule_chembl_id"
  else
    return "Please specify the ChEMBL molecule_id column name"
  endif
  s_molname = Trim(s_molname all)
  if (s_molname=="") s_molname="mol"
  s_molcol = s_origtab+"."+s_molname
  read binary s_icmhome+"models/ChEMBLCompound.icb"
  delete $s_origtab.canonical_smiles l_warn=no
  join left $s_chemblidcol ChEMBLCompound.chembl_id name="T_jointmp"
  T_jointmp.parent_molregno[Index(T_jointmp.parent_molregno==0)] = T_jointmp.molregno[Index(T_jointmp.parent_molregno==0)]
  join left T_jointmp.parent_molregno ChEMBLCompound.molregno name="T_jointmp2"
  add column $s_origtab T_jointmp2.ChEMBLCompound_canonical_smiles name="canonical_smiles"
  add column $s_origtab Chemical($s_origtab.canonical_smiles) name=s_molname index=Index(Name($s_origtab) s_origtab+".mol")+1
  delete ChEMBLCompound T_jointmp T_jointmp2 l_warn=no
endmacro
#
macro fdaapi s_query ("") s_field ("generic_name") P_result (Collection()) i_skip (0) i_limit (100) auto
HELP = """
  Search FDA's Drug Label using its API:

  Syntax: fdaapi <s_query> <s_field> <P_result> <i_skip> <i_limit>
  <s_query>: Drug name or other terms
  <s_field>: generic_name, brand_name, etc
  Please see https://open.fda.gov/apis/openfda-fields/ for searchable fields
  <P_result>: A collection can be pre-read as the input, this macro returns a collection C_fda, which can be used in subsequent runs without calling the FDA API again
  <i_skip>: Default 0 will read from the first record of the collection, <i_skip> will skip the first i_skip records
  <i_limit>: Default 100 will return at most 100 records, use this in combination with i_skip to retrieve beyond this limit

  Example:
  fdaapi 'venetoclax'
  fdaapi 'aspirin' 'brand_name'
  fdaapi 'aspirin' 'brand_name' 100 200 # retrieve records: 101-300
"""
  l_info = l_commands = l_warn = no
  s_query = Trim(s_query all)
  s_query = Replace(s_query " " "+")
  s_field = Trim(s_field all)
  i_limit = Max(Min(i_limit 1000) 1)
  i_skip = Min(Max(0 i_skip) 25000)
  S_fields = {"abuse","abuse_table","controlled_substance","controlled_substance_table","dependence","dependence_table","drug_abuse_and_dependence","drug_abuse_and_dependence_table"}
  S_fields //= {"overdosage","overdosage_table","adverse_reactions","adverse_reactions_table","drug_and_or_laboratory_test_interactions","drug_and_or_laboratory_test_interactions_table"}
  S_fields //= {"drug_interactions","drug_interactions_table","clinical_pharmacology","clinical_pharmacology_table","mechanism_of_action","mechanism_of_action_table","pharmacodynamics","pharmacodynamics_table"}
  S_fields //= {"pharmacokinetics","pharmacokinetics_table","effective_time","id","set_id","version","active_ingredient","active_ingredient_table","contraindications","contraindications_table","description"}
  S_fields //= {"description_table","dosage_and_administration","dosage_and_administration_table","dosage_forms_and_strengths","dosage_forms_and_strengths_table","inactive_ingredient","inactive_ingredient_table"}
  S_fields //= {"indications_and_usage","indications_and_usage_table","purpose","purpose_table","spl_product_data_elements","spl_product_data_elements_table","animal_pharmacology_and_or_toxicology"}
  S_fields //= {"animal_pharmacology_and_or_toxicology_table","carcinogenesis_and_mutagenesis_and_impairment_of_fertility","carcinogenesis_and_mutagenesis_and_impairment_of_fertility_table","nonclinical_toxicology"}
  S_fields //= {"nonclinical_toxicology_table","application_number","brand_name","generic_name","is_original_packager","manufacturer_name","original_packager_product_ndc","nui","package_ndc","pharm_class_cs","pharm_class_epc"}
  S_fields //= {"pharm_class_moa","pharm_class_pe","product_ndc"}

  S_fields //= {"product_type","route","rxcui","spl_id","spl_set_id","substance_name","unii","upc","laboratory_tests","laboratory_tests_table","microbiology","microbiology_table","package_label_principal_display_panel"}
  S_fields //= {"package_label_principal_display_panel_table","recent_major_changes","recent_major_changes_table","spl_unclassified_section","spl_unclassified_section_table","ask_doctor","ask_doctor_or_pharmacist"}
  S_fields //= {"ask_doctor_or_pharmacist_table","ask_doctor_table","do_not_use","do_not_use_table","information_for_owners_or_caregivers","information_for_owners_or_caregivers_table","information_for_patients"}
  S_fields //= {"information_for_patients_table","instructions_for_use","instructions_for_use_table","keep_out_of_reach_of_children","keep_out_of_reach_of_children_table","other_safety_information"}
  S_fields //= {"other_safety_information_table","patient_medication_information","patient_medication_information_table","questions","questions_table","spl_medguide","spl_medguide_table","spl_patient_package_insert"}
  S_fields //= {"spl_patient_package_insert_table","stop_use","stop_use_table","when_using","when_using_table","clinical_studies","clinical_studies_table","references","references_table","geriatric_use"}
  S_fields //= {"geriatric_use_table","labor_and_delivery","labor_and_delivery_table","nursing_mothers","nursing_mothers_table","pediatric_use","pediatric_use_table","pregnancy","pregnancy_or_breast_feeding"}
  S_fields //= {"pregnancy_or_breast_feeding_table","pregnancy_table","teratogenic_effects","teratogenic_effects_table","use_in_specific_populations","use_in_specific_populations_table","how_supplied"}
  S_fields //= {"how_supplied_table","safe_handling_warning","safe_handling_warning_table","storage_and_handling","storage_and_handling_table","boxed_warning","boxed_warning_table","general_precautions"}
  S_fields //= {"general_precautions_table","precautions","precautions_table","user_safety_warnings","user_safety_warnings_table","warnings","warnings_table"}

  S_fields //= {"accessories","accessories_table","alarms","alarms_table","assembly_or_installation_instructions","assembly_or_installation_instructions_table","calibration_instructions","calibration_instructions_table"}
  S_fields //= {"cleaning","cleaning_table","compatible_accessories","compatible_accessories_table","components","components_table","diagram_of_device","diagram_of_device_table","disposal_and_waste_handling"}
  S_fields //= {"disposal_and_waste_handling_table","environmental_warning","envoronmental_warning_table","food_safety_warning","food_safety_warning_table","guaranteed_analysis_of_feed","guaranteed_analysis_of_feed_table"}
  S_fields //= {"health_care_provider_letter","health_care_provider_letter_table","health_claim","health_claim_table","intended_use_of_the_device","intended_use_of_the_device_table"}
  S_fields //= {"nonteratogenic_effects","nonteratogenic_effects_table","pharmacogenomics","pharmacogenomics_table","residue_warning","residue_warning_table","risks","risks_table","route_table"}
  S_fields //= {"spl_indexing_data_elements","spl_indexing_data_elements_table","statement_of_identity","statement_of_identity_table","summary_of_safety_and_effectiveness","summary_of_safety_and_effectiveness_table"}
  S_fields //= {"troubleshooting","troubleshooting_table","warnings_and_cautions","warnings_and_cautions_table"}

  if (s_query=="") then
    if (Nof(P_result)==0) return "Please specify either a search term or a Collection of result"
  else
    if (s_field=="") return "Please specify a search field"
    if (Index(S_fields s_field)==0) return "Please specify a valid search field specified in: https://open.fda.gov/apis/drug/label/searchable-fields/"
    s_field = Replace(s_field "openfda." "")
    if (Index(S_fields s_field)>=53 & Index(S_fields s_field)<=73) s_field = "openfda."+s_field
    i_out = 0
    print " Info> Reading from:" 'https://api.fda.gov/drug/label.json?search='+s_field+':"'+s_query+'"&limit='+Tostring(i_limit)+'&skip='+Tostring(i_skip)+'&sort=effective_time:desc'
    read collection 'https://api.fda.gov/drug/label.json?search='+s_field+':"'+s_query+'"&limit='+Tostring(i_limit)+'&skip='+Tostring(i_skip)+'&sort=effective_time:desc' name="C_tmp"
    if ((i_out==404) & Name(C_tmp)==Sarray(1 "error")) return " Info> Cannot find anything, please either modify the search term or field"
    P_result = C_tmp
  endif
  if (Nof(P_result["results"] )==0) return "Cannot find anything, please either modify the search term or field"
  i_total = P_result ["meta"]["results"]["total"]
  i_limit = P_result ["meta"]["results"]["limit"]
  i_skip = P_result ["meta"]["results"]["skip"]
  N =  Nof(P_result["results"] )
  print " Info> Total number of records:" i_total ", retrieving record number:" i_skip+1 "to" i_skip+N
  if (i_total > i_skip+N) print " Info> Next batch: use i_skip =" i_skip+N
  print bar "Processing..." N l_info=yes
  S_missingfields = Sarray(0)
  for i_result = 1,  Nof(P_result["results"] )
    print bar N
    group table t_tmpmacro Sarray(1 "") S_fields[1]
    for i_field = 2, Nof(S_fields)
      add column t_tmpmacro Sarray(1 "") name=S_fields[i_field]
    endfor
    S_resultfield = Name(P_result["results"][i_result])
    for i_resultfield = 1, Nof(S_resultfield)
      s_resultfield = S_resultfield[i_resultfield]

      if (s_resultfield=="openfda") then
        S_resultfield2 = Name(P_result["results"][i_result]["openfda"])
        for i_resultfield2 = 1, Nof(S_resultfield2)
          s_resultfield2 = S_resultfield2[i_resultfield2]
          if (Index(S_fields s_resultfield2 )==0) then
#            if (s_resultfield2=="is_original_packager") continue
#            if (s_resultfield2=="original_packager_product_ndc") continue
            #print "Missing field:" s_resultfield2
            S_missingfields//=s_resultfield2; continue
          endif
          if (Type(P_result["results"][i_result]["openfda"][s_resultfield2 ])=="sarray") then
            t_tmpmacro.$s_resultfield2[$] = Sum(P_result["results"][i_result]["openfda"][s_resultfield2 ] "\n")
          elseif (Type(P_result["results"][i_result]["openfda"][s_resultfield2 ])=="string") then
            t_tmpmacro.$s_resultfield2[$] = P_result["results"][i_result]["openfda"][s_resultfield2]
          else
            #print "Missing field:" s_resultfield2
            S_missingfields//=s_resultfield2; continue
          endif
        endfor
        continue
      endif

      if (Index(S_fields s_resultfield )==0) then
        #print "Missing field:" s_resultfield
        S_missingfields//=s_resultfield; continue
      endif
      if (Type(P_result["results"][i_result][s_resultfield ])=="sarray") then
        t_tmpmacro.$s_resultfield[$] = Sum(P_result["results"][i_result][s_resultfield ] "\n")
      elseif (Type(P_result["results"][i_result][s_resultfield ])=="string") then
        t_tmpmacro.$s_resultfield[$] = P_result["results"][i_result][s_resultfield ]
      else
        #print "Missing field:" s_resultfield
        S_missingfields//=s_resultfield; continue
      endif
    endfor

    S_columns = {"Pharmacokinetics","Absorption","Effect_of_Food","Distribution","Elimination","Metabolism","Excretion","Specific_Populations","Interaction_Clinical","Interaction_in_Vitro"}
    for i_column = 1, Nof(S_columns)
      s_column = S_columns[i_column]
      add column t_tmpmacro Sarray(1 "") name=s_column index=i_column
    endfor
    add column t_tmpmacro Sarray(1 "") name="Half_life" index=1 comment="Half-life auto-extracted from pharmacokinetics column,\nplease check that column to confirm"
    add column t_tmpmacro Sarray(1 "") name="Volume_of_Distribution" index=2 comment="Volume of Distribution auto-extracted from pharmacokinetics column,\nplease check that column to confirm"
    add column t_tmpmacro Sarray(1 "") name="Clearance" index=3 comment="Clearance auto-extracted from pharmacokinetics column,\nplease check that column to confirm"
    add column t_tmpmacro Sarray(1 "") name="Protein_Binding" index=4
    add column t_tmpmacro Sarray(1 "") name="Inhibitor" index=5
    add column t_tmpmacro Sarray(1 "") name="Not_Inhibitor" index=6
    add column t_tmpmacro Sarray(1 "") name="Substrate" index=7
    add column t_tmpmacro Sarray(1 "") name="Not_Substrate" index=8

    if (t_tmpmacro.pharmacokinetics[$]!="") then
      S_tmp = Split(Replace(t_tmpmacro.pharmacokinetics[$] ". " "\n") "\n")
      I_tmp = Iarray(1 1)
      I_tmp //= Index(Index(S_tmp "^Absorption" regexp) 1)
      I_tmp //= Index(Index(S_tmp "^Effect [Oo]f [Ff]ood" regexp) 1)
      I_tmp //= Index(Index(S_tmp "^Distribution" regexp) 1)
      I_tmp //= Index(Index(S_tmp "^Elimination" regexp) 1)
      I_tmp //= Index(Index(S_tmp "^Metabolism" regexp) 1)
      I_tmp //= Index(Index(S_tmp "^Excretion" regexp) 1)
      I_tmp //= Index(Index(S_tmp "^Specific [Pp]opulations" regexp) 1)
      I_tmp //= Index(Index(S_tmp "^Drug [Ii]nteraction" regexp) 1)
      I_tmp //= Index(Index(S_tmp "^In [Vv]itro [Ss]tudies" regexp) 1)
      i_en = Nof(S_tmp)
      S_replace = {"Pharmacokinetics ","Absorption ","Effect of Food ","Distribution ","Elimination ","Metabolism ","Excretion ","Specific Populations ","Clinical Studies ","In Vitro Studies "}
      S_replace = Sarray(Nof(S_replace) "*")+S_replace
      for i_tmp = Nof(I_tmp), 1, -1
        if (I_tmp[i_tmp]==0) continue
        i_st = I_tmp[i_tmp]
        S_tmp[i_st] = Replace(S_tmp[i_st] S_replace[i_tmp] "")
        s_column = "t_tmpmacro."+S_columns[i_tmp]
#        print i_st i_en
        if (i_st>i_en) continue
        $s_column[$] = Sum(S_tmp[i_st:i_en] "\n")
        i_en = i_st-1
        S_tmp2 = Split(Replace(Replace($s_column[$] "u00b1" "+/-") " - " "-") "\n")
        if (Nof(S_tmp2)==0) continue
        if (i_tmp==10) then
          S_tmp3 = S_tmp2 ~"*[Ii]nhibit*"
          if (Nof(S_tmp3)!=0) then
            t_tmpmacro.Not_Inhibitor[$] = Sum(S_tmp3~"*[Nn]ot *" "\n")
            t_tmpmacro.Inhibitor[$] = Sum(S_tmp3!~"*[Nn]ot *" "\n")
          endif
          S_tmp3 = S_tmp2 ~"*[Ss]ubstrate*"
          if (Nof(S_tmp3)!=0) then
            t_tmpmacro.Not_Substrate[$] = Sum(S_tmp3~"*[Nn]ot *" "\n")
            t_tmpmacro.Substrate[$] = Sum(S_tmp3!~"*[Nn]ot *" "\n")
          endif
        elseif (i_tmp==9) then
          S_tmp3 = S_tmp2 ~"*[Ii]nhibit*"
          if (Nof(S_tmp3)!=0) then
            t_tmpmacro.Not_Inhibitor[$] = Trim(Sum(Sarray(t_tmpmacro.Not_Inhibitor[$])//S_tmp3~"*[Nn]ot *" "\n") all)
            t_tmpmacro.Inhibitor[$] = Trim(Sum(Sarray(t_tmpmacro.Inhibitor[$])//S_tmp3!~"*[Nn]ot *" "\n") all)
          endif
          S_tmp3 = S_tmp2 ~"*[Ss]ubstrate*"
          if (Nof(S_tmp3)!=0) then
            t_tmpmacro.Not_Substrate[$] = Trim(Sum(Sarray(t_tmpmacro.Not_Substrate[$])//S_tmp3~"*[Nn]ot *" "\n") all)
            t_tmpmacro.Substrate[$] = Trim(Sum(Sarray(t_tmpmacro.Substrate[$])//S_tmp3!~"*[Nn]ot *" "\n") all)
          endif
        elseif (i_tmp==5) then

          S_tmp3 = Split(Sum(Match(Replace(Replace(S_tmp2 "[\[(,~)]" " ") "]" " ") "[Hh]alf[ -][Ll]i[fv]e(.*?)") " ") " +" regexp)
          if (Nof(S_tmp3)!=0) then
            S_units = {"[Hh]our","[Hh]r","[Dd]ay","[Ww]eek","[Mm]inute","[Mm]onth","[Yy]ear"}
            S_units2 = {"H","h"}
            I_units = Iarray(0)
            for i_unit = 1, Nof(S_units)
              I_units//=Index(Index(S_tmp3 S_units[i_unit] regexp ) 1 all)
            endfor
            for i_unit = 1, Nof(S_units2)
              I_units//=Index(S_tmp3 S_units2[i_unit] all)
            endfor
            I_units = Unique(Sort(I_units))
            if (Nof(I_units)!=0) then
              for i_unit = 1,Nof(I_units)
                if (I_units[i_unit]>3) then
                  if (Toreal(S_tmp3[I_units[i_unit]-3])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Half_life[$] = Sum(S_tmp3[i_en2-3:i_en2] " "); break
                  endif
                endif
                if (I_units[i_unit]>2) then
                  if (Toreal(S_tmp3[I_units[i_unit]-2])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Half_life[$] = Sum(S_tmp3[i_en2-2:i_en2] " "); break
                  endif
                endif
                if (I_units[i_unit]>1) then
                  if (Toreal(S_tmp3[I_units[i_unit]-1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Half_life[$] = Sum(S_tmp3[i_en2-1:i_en2] " "); break
                  endif
                endif
                if (Nof(S_tmp3)>I_units[i_unit]) then
                  if (Toreal(S_tmp3[I_units[i_unit]+1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Half_life[$] = S_tmp3[i_en2+1]+" "+S_tmp3[i_en2]; break
                  endif
                endif
              endfor
            endif
          endif

          S_tmp3 = Split(Sum(Match(Replace(Replace(S_tmp2 "[\[(,~)]" " ") "]" " ") "[Cc]learance(.*?)") " ") " +" regexp)
          if (Nof(S_tmp3)!=0) then
            S_units = {"[Ll]/[Hh]","[Ll]iter/[Hh]","[Mm][Ll]/[Hh]","[Ll]/[Dd]ay","[Mm][Ll]/[Dd]ay","[Ll]/[Mm]in","[Mm][Ll]/[Mm]in","[Mm][Ll]/kg/[Mm]in"}
            I_units = Iarray(0)
            for i_unit = 1, Nof(S_units)
              I_units//=Index(Index(S_tmp3 S_units[i_unit] regexp ) 1 all)
            endfor
            I_units = Unique(Sort(I_units))
            if (Nof(I_units)!=0) then
              for i_unit = 1,Nof(I_units)
                if (I_units[i_unit]>3) then
                  if (Toreal(S_tmp3[I_units[i_unit]-3])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Clearance[$] = Sum(S_tmp3[i_en2-3:i_en2] " ");break
                  endif
                endif
                if (I_units[i_unit]>2) then
                  if (Toreal(S_tmp3[I_units[i_unit]-2])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Clearance[$] = Sum(S_tmp3[i_en2-2:i_en2] " ");break
                  endif
                endif
                if (I_units[i_unit]>1) then
                  if (Toreal(S_tmp3[I_units[i_unit]-1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Clearance[$] = Sum(S_tmp3[i_en2-1:i_en2] " ");break
                  endif
                endif
                if (Nof(S_tmp3)>I_units[i_unit]) then
                  if (Toreal(S_tmp3[I_units[i_unit]+1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Clearance[$] = S_tmp3[i_en2+1]+" "+S_tmp3[i_en2];break
                  endif
                endif
              endfor
            endif
          endif

        elseif (i_tmp==4) then
          t_tmpmacro.Protein_Binding[$] = Sum(S_tmp2 ~ "*[Pp]lasma*" "\n")
          S_tmp3 = Split(Trim(Sum(Match(Replace(S_tmp2 "[(,)]" " ") "[Vv]olume[ -][Oo]f[ -][Dd]istribution(.*?)") " ") all) " +" regexp)
          S_tmp3 //= Split(Trim(Sum(Match(Replace(Replace(S_tmp2 "[\[(,~)]" " ") "]" " ") "[Dd]istribution[ -][Vv]olume(.*?)") " ") all) " +" regexp)
          if (Nof(S_tmp3)!=0) then

            S_units2 = {"L","Liter","liter","liters","Liters","L/kg","L/Kg","liter/kg","mL/kg","L/m"}
            I_units = Iarray(0)
            for i_unit = 1, Nof(S_units2)
              I_units//=Index(S_tmp3 S_units2[i_unit] all)
            endfor
            I_units = Unique(Sort(I_units))
            if (Nof(I_units)!=0) then
              for i_unit = 1,Nof(I_units)
                if (I_units[i_unit]>3) then
                  if (Toreal(S_tmp3[I_units[i_unit]-3])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Volume_of_Distribution[$] = Sum(S_tmp3[i_en2-3:i_en2] " ");break
                  endif
                endif
                if (I_units[i_unit]>2) then
                  if (Toreal(S_tmp3[I_units[i_unit]-2])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Volume_of_Distribution[$] = Sum(S_tmp3[i_en2-2:i_en2] " ");break
                  endif
                endif
                if (I_units[i_unit]>1) then
                  if (Toreal(S_tmp3[I_units[i_unit]-1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Volume_of_Distribution[$] = Sum(S_tmp3[i_en2-1:i_en2] " ");break
                  endif
                endif
                if (Nof(S_tmp3)>I_units[i_unit]) then
                  if (Toreal(S_tmp3[I_units[i_unit]+1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Volume_of_Distribution[$] = S_tmp3[i_en2+1]+" "+S_tmp3[i_en2];break
                  endif
                endif
              endfor
            endif
          endif
        endif
      endfor

      S_tmp2 = Split(Replace(Replace(Replace(Replace(Replace(t_tmpmacro.pharmacokinetics[$] "u00b1" "+/-") "[\[(,~)]" " ") "]" " ") ". " "\n") " - " "-") "\n")
      if (Nof(S_tmp2)!=0) then
        if (t_tmpmacro.Half_life[$]=="") then
          S_tmp3 = Split(Sum(Match(S_tmp2 "[Hh]alf[ -][Ll]i[fv]e(.*?)") " ") " +" regexp)
          if (Nof(S_tmp3)!=0) then

            S_units = {"[Hh]our","[Hh]r","[Dd]ay","[Ww]eek","[Mm]inute","[Mm]onth","[Yy]ear"}
            S_units2 = {"H","h"}
            I_units = Iarray(0)
            for i_unit = 1, Nof(S_units)
              I_units//=Index(Index(S_tmp3 S_units[i_unit] regexp ) 1 all)
            endfor
            for i_unit = 1, Nof(S_units2)
              I_units//=Index(S_tmp3 S_units2[i_unit] all)
            endfor
            I_units = Unique(Sort(I_units))
            if (Nof(I_units)!=0) then
              for i_unit = 1,Nof(I_units)
                if (I_units[i_unit]>3) then
                  if (Toreal(S_tmp3[I_units[i_unit]-3])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Half_life[$] = Sum(S_tmp3[i_en2-3:i_en2] " "); break
                  endif
                endif
                if (I_units[i_unit]>2) then
                  if (Toreal(S_tmp3[I_units[i_unit]-2])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Half_life[$] = Sum(S_tmp3[i_en2-2:i_en2] " "); break
                  endif
                endif
                if (I_units[i_unit]>1) then
                  if (Toreal(S_tmp3[I_units[i_unit]-1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Half_life[$] = Sum(S_tmp3[i_en2-1:i_en2] " "); break
                  endif
                endif
                if (Nof(S_tmp3)>I_units[i_unit]) then
                  if (Toreal(S_tmp3[I_units[i_unit]+1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Half_life[$] = S_tmp3[i_en2+1]+" "+S_tmp3[i_en2]; break
                  endif
                endif
              endfor
            endif
          endif
        endif
        if (t_tmpmacro.Clearance[$]=="") then
          S_tmp3 = Split(Sum(Match(S_tmp2 "[Cc]learance(.*?)") " ") " +" regexp)
          if (Nof(S_tmp3)!=0) then

            S_units = {"[Ll]/[Hh]","[Ll]iter/[Hh]","[Mm][Ll]/[Hh]","[Ll]/[Dd]ay","[Mm][Ll]/[Dd]ay","[Ll]/[Mm]in","[Mm][Ll]/[Mm]in","[Mm][Ll]/kg/[Mm]in"}
            I_units = Iarray(0)
            for i_unit = 1, Nof(S_units)
              I_units//=Index(Index(S_tmp3 S_units[i_unit] regexp ) 1 all)
            endfor
            I_units = Unique(Sort(I_units))
            if (Nof(I_units)!=0) then
              for i_unit = 1,Nof(I_units)
                if (I_units[i_unit]>3) then
                  if (Toreal(S_tmp3[I_units[i_unit]-3])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Clearance[$] = Sum(S_tmp3[i_en2-3:i_en2] " ");break
                  endif
                endif
                if (I_units[i_unit]>2) then
                  if (Toreal(S_tmp3[I_units[i_unit]-2])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Clearance[$] = Sum(S_tmp3[i_en2-2:i_en2] " ");break
                  endif
                endif
                if (I_units[i_unit]>1) then
                  if (Toreal(S_tmp3[I_units[i_unit]-1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Clearance[$] = Sum(S_tmp3[i_en2-1:i_en2] " ");break
                  endif
                endif
                if (Nof(S_tmp3)>I_units[i_unit]) then
                  if (Toreal(S_tmp3[I_units[i_unit]+1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Clearance[$] = S_tmp3[i_en2+1]+" "+S_tmp3[i_en2];break
                  endif
                endif
              endfor
            endif

          endif
        endif
        if (t_tmpmacro.Volume_of_Distribution[$]=="") then
          S_tmp3 = Split(Trim(Sum(Match(S_tmp2 "[Vv]olume[ -][Oo]f[ -][Dd]istribution(.*?)") " ") all) " +" regexp)
          S_tmp3 //= Split(Trim(Sum(Match(S_tmp2 "[Dd]istribution[ -][Vv]olume(.*?)") " ") all) " +" regexp)
          if (Nof(S_tmp3)!=0) then

            S_units2 = {"L","Liter","liter","liters","Liters","L/kg","L/Kg","liter/kg","mL/kg","L/m"}
            I_units = Iarray(0)
            for i_unit = 1, Nof(S_units2)
              I_units//=Index(S_tmp3 S_units2[i_unit] all)
            endfor
            I_units = Unique(Sort(I_units))
            if (Nof(I_units)!=0) then
              for i_unit = 1,Nof(I_units)
                if (I_units[i_unit]>3) then
                  if (Toreal(S_tmp3[I_units[i_unit]-3])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Volume_of_Distribution[$] = Sum(S_tmp3[i_en2-3:i_en2] " ");break
                  endif
                endif
                if (I_units[i_unit]>2) then
                  if (Toreal(S_tmp3[I_units[i_unit]-2])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Volume_of_Distribution[$] = Sum(S_tmp3[i_en2-2:i_en2] " ");break
                  endif
                endif
                if (I_units[i_unit]>1) then
                  if (Toreal(S_tmp3[I_units[i_unit]-1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Volume_of_Distribution[$] = Sum(S_tmp3[i_en2-1:i_en2] " ");break
                  endif
                endif
                if (Nof(S_tmp3)>I_units[i_unit]) then
                  if (Toreal(S_tmp3[I_units[i_unit]+1])!=Toreal("ND")) then
                    i_en2 = I_units[i_unit]; t_tmpmacro.Volume_of_Distribution[$] = S_tmp3[i_en2+1]+" "+S_tmp3[i_en2];break
                  endif
                endif
              endfor
            endif

          endif
        endif
      endif
    endif

    add header t_tmpmacro String("") name="doubleClick" append
    t_tmpmacro.doubleClick = """
if (Type(FDAlabelhtml)!="unknown") delete FDAlabelhtml
makeNewHtml 'FDAlabelhtml' yes Replace(%@.%^[%#] "\n" "<br>")
"""
    add header t_tmpmacro String("") name="toolsPanel" append
    t_tmpmacro.toolsPanel = """
# txt_Hints (Double Click on any cell to expand it into html)
"""
    if (Type(FDAlabel)!="table") delete FDAlabel l_warn=no
    if (Type(FDAlabel)=="unknown") then
      rename t_tmpmacro "FDAlabel"
    else
      add FDAlabel t_tmpmacro
      delete t_tmpmacro l_warn=no
    endif
  endfor
  print bar "Finished\n" N l_info=yes
  move FDAlabel.substance_name 1
  move FDAlabel.brand_name 1
  move FDAlabel.generic_name 1

  group table t_tmpmacro2 Name(FDAlabel column) "A"
  add column t_tmpmacro2 Toreal(Sarray(Nof(t_tmpmacro2) "ND")) name="B"
  for i_col = 1, Nof(t_tmpmacro2)
    s_col = t_tmpmacro2.A[i_col]
    t_tmpmacro2.B[i_col] = Max(Toreal($s_col))
  endfor
  sort t_tmpmacro2.B reverse
  for i_col = 1, Nof(t_tmpmacro2)
    if (t_tmpmacro2.B[i_col] == Toreal("ND")) continue
    if ((t_tmpmacro2.B[i_col] > 50)| (t_tmpmacro2.B[i_col] < 1.)) continue
    s_col =  t_tmpmacro2.A[i_col]
    if (s_col == "FDAlabel.Half_life") continue
    if (s_col == "FDAlabel.Clearance") continue
    if (s_col == "FDAlabel.Volume_of_Distribution") continue
    if (s_col == "FDAlabel.unii") continue
    s_col2 = s_col+"_table"
    if (Type($s_col2)=="sarray") move $s_col2 22
    move $s_col 22
  endfor
  delete t_tmpmacro2 l_warn=no

  S_col = Name(FDAlabel column)
  for i_col = 1, Nof(S_col)
    s_col = S_col[i_col]
    if (Type($s_col)!="sarray") continue
    if (Nof(Index($s_col "" all))==Nof(FDAlabel)) then
      set format $s_col show off
    else
      set format $s_col show
    endif
  endfor
  S_missingfields = Unique(Sort(S_missingfields))
#  if (Nof(S_missingfields)!=0) print "Missing fields stored in S_missingfields"
  C_fda = P_result
  keep FDAlabel S_missingfields C_fda
  delete FDAlabelhtml l_warn=no
  makeNewHtml 'FDAlabelhtml' yes Replace(FDAlabel.pharmacokinetics[$] "\n" "<br>")
  print " Info> To look at the pharmacokinetics field: "
  print " makeNewHtml 'FDAlabelhtml' yes Replace(FDAlabel.pharmacokinetics[$] '\\n' '<br>')"
  print " Info> Or Double Click on any cell to expand it into html"
  keep FDAlabelhtml
endmacro
#
macro confGenMolCartBG s_table i_mnconf (30) r_vicinity (30.) r_thoroughness (1.) l_sampleRings (no) i_systematic (5) l_refine (no) i_from (1) i_to (0) l_Force (no) auto
  S_cmdargs = "mnconf="+i_mnconf // "vicinity="+r_vicinity // "effort="+r_thoroughness // "-I"//"-molcart="+Sum(Name(molcart,connect),",")
  S_cmdargs = S_cmdargs // "-q"
  if(l_sampleRings)S_cmdargs = S_cmdargs // "-r"
  S_cmdargs = S_cmdargs // "auto=" + i_systematic
  S_cmdargs = S_cmdargs // "-fr=" + i_from
  S_cmdargs = S_cmdargs // "-to=" + i_to
  if(l_Force) S_cmdargs = S_cmdargs // "-f"
  if(l_refine)     S_cmdargs = S_cmdargs // "-c"
  s_cmd = Path( macro, s_icmhome + "_confGen",  s_table,  s_table+"_conf", S_cmdargs )
  s_cmd
  make background s_cmd info="Conformation Generator finished for table " + s_table
  print " Info> conformation generation started in background. You will be notified when the job is complete."
endmacro
#
macro confGenBG T_t I_idx i_mnconf (50) r_vicinity (30.) r_thoroughness (1.) l_sampleRings (yes) l_cisTrans (no) l_systematic (no) l_refine (no) l_verbose (no) l_keepHydrogens (no) l_pyramide (no) s_options ("") auto
  l_commands = no
  l_info = no
  t = T_t[ I_idx ]
  if (Nof(t)==0) return error "No selected rows"

  fname_in  =  Name( system s_tempDir + "confgenXXXX.sdf" )
  fname_out = s_tempDir + Name( fname_in ) + "_out.sdf"
  fname_inx = s_tempDir + Name( fname_in ) + ".inx"
  write table mol t fname_in delete
  S_cmdargs = "mnconf="+i_mnconf // "vicinity="+r_vicinity // "effort="+r_thoroughness // "-f" // "-I"
  if(l_verbose)  S_cmdargs = S_cmdargs // "-v"
  if(l_sampleRings)S_cmdargs = S_cmdargs // "-r"
  if(l_cisTrans)   S_cmdargs = S_cmdargs // "-d"
  if(l_systematic) S_cmdargs = S_cmdargs // "-s"
  if(l_refine)     S_cmdargs = S_cmdargs // "-c"
  if(l_keepHydrogens) S_cmdargs = S_cmdargs // "-hydrogen"
  if(l_pyramide) S_cmdargs = S_cmdargs // "-p"
  if(Index(s_options "diel=")) S_cmdargs = S_cmdargs // ("diel=" + Field(s_options "diel=" 1))
  if(Index(s_options "maxener=")) S_cmdargs = S_cmdargs // ("maxenergy=" + Field(s_options "maxener=" 1))
  if(Index(s_options "entropy")) S_cmdargs = S_cmdargs // "-e"
  if(Index(s_options "strain")) S_cmdargs = S_cmdargs // "-S"
  if(Index(s_options "predict")) S_cmdargs = S_cmdargs // "-A"
  l_direct=Index(s_options "direct")!=0
  s_cmd = Path( macro, s_icmhome + "_confGen",  fname_in,  fname_out, S_cmdargs )
  s_outName = "conformers"
  if(Index(s_options "entropy")) s_outName = "entropies"
  if(Index(s_options "strain")) s_outName = "strains"
  sprintf "read table mol display \"%s\" name=Name(\""+s_outName+"\",unique)\nadd header $s_out 'read mol delete %%@.mol[%%#];make torsion profile table a_' name='doubleClick'\ndelete system \"%s\" \"%s\" \"%s\" l_info=no", fname_out, fname_in fname_out, fname_inx
#  sprintf "read table mol display \"%s\" name=Name(\""+s_outName+"\",unique)\nadd column $s_out Score( $s_out.mol torsion ) name='tor_score'\nadd header $s_out 'read mol delete %%@.mol[%%#];make torsion profile table a_' name='doubleClick'\ndelete system \"%s\" \"%s\" \"%s\" l_info=no", fname_out, fname_in fname_out, fname_inx
  s_finish=s_out
  if(!l_direct)then
    make background s_cmd command=s_finish info="Conformation Generator finished. Press OK to load the result"
    print " Info> conformation generation started in background. You will be notified when the job is complete."
  else
    sys $s_cmd
    call string s_finish
    keep $s_out
  endif
endmacro
#
macro calcQMdeltaPKaBG s_table I_idx l_dontrun (no) s_options ("") s_gamessPath ("gms") auto
#
  t = $s_table [ I_idx ]
  if (Nof(t)!=2) return error "Need 2-row selection"
  if( Index(Smiles(t.mol)[1] "[*]" regexp) == 0 | Index(Smiles(t.mol)[2] "[*]" regexp) == 0 ) return error "Mark position to be protonated as attachement point in both molecules"
#
  if(l_dontrun) s_tempDir = Path()
  s_cmd = "cd " + s_tempDir
#
  add t 3
  add t 4
  t.mol[3] = Chemical(Replace( Smiles( t.mol[1] ) "[*]" "+" ) )
  t.mol[1] = Chemical(Replace( Smiles( t.mol[1] ) "[*]" "" ) )
  t.mol[4] = Chemical(Replace( Smiles( t.mol[2] ) "[*]" "+" ) )
  t.mol[2] = Chemical(Replace( Smiles( t.mol[2] ) "[*]" "" ) )
  convertTable2Dto3D "t" Count(4) yes yes
#
  calcQMstrainsBG "t" Count(4) l_dontrun no no yes s_options + " water" s_gamessPath
#
  keep QM_minimized_t s_finishQM_QM_minimized_t
#
endmacro
#
macro calcQMstrainsBG s_table I_idx l_dontrun (no) l_relative (yes) l_relax (no) l_minimize (yes) s_options ("") s_gamessPath ("rungms") auto
  l_commands = no
  l_info = no
#
  l_torScan=no
  if(s_table~"_STACK*")then
    t = Table(stack)
    if(Nof(I_idx)==0) I_idx = Count(Nof( t ))
    t = t [ I_idx ]
    if(Index(s_table "torScan")!=0) l_torScan=yes
  else
    if(Nof(I_idx)==0) I_idx = Count(Nof( $s_table ))
    t = $s_table [ I_idx ]
  endif
  if (Nof(t)==0) return error "No selected rows"
#
  if(l_dontrun) s_tempDir = Path()
  l_win = Version() ~ "*WIN*"
  s_cmd = "cd " + s_tempDir
  if(l_torScan)then
    if( Type( a_ 2 ) != "ICM" ) return error "Current object is not ICM"
    if(Nof(vs_out & a_)!=1)     return error "One torsion should be selected in vs_out"
    l_relax = yes
  endif
  if(l_relax)     l_minimize = yes
  if(!l_minimize) s_restab = "QM_energies"
  if(l_minimize)  s_restab = "QM_minimized"
  if(l_relax)     s_restab = "QM_relaxed"
  if(s_table~"_STACK*")then
    s_restab = s_restab + "_st_" + (Name( a_ )[1])
  else
    s_restab = s_restab + "_" + Replace(s_table { "QM_energies_" "QM_minimized_" "QM_relaxed_" } { "" "" "" })
  endif
  if(Type( $s_restab )!="unknown") delete $s_restab
  group table s_restab Chemical(Nof(t))  "mol" Rarray(Nof(t)) "Energy" Sarray(Nof(t)) "fname"
  if(s_table!~"_STACK*") $s_restab.mol =  t.mol
  s_finishQM = ""
  if(s_table~"_STACK*") s_finishQM = "set object a_" + (Name( a_ )[1])
  s_water=""
  if(Index(s_options "water")!=0) s_water = "water"
  if(Index(s_gamessPath "qsub")!=0)then
    s_rungms = Field( s_gamessPath Nof(Split(s_gamessPath)) " ")
    s_gamessPath = Replace( s_gamessPath " "+s_rungms " \""+s_rungms)
  endif
  i_level = Integer(Field(s_options "level=" 1 ))
  s_wrgmopt = ""
  if(i_level==2) s_wrgmopt = "type=\"MP2\""
  if(i_level==3) s_wrgmopt = "type=\"DFT\""
  for i_row = 1 Nof(t)
    fname_in  =  Name( system s_tempDir + "QMicmXXXX.inp" )
    fname_out = s_tempDir + Name( fname_in ) + ".log"
    fname_dat = s_tempDir + Name( fname_in ) + ".dat"
    if(s_table~"_STACK*")then
      load conf t.i [i_row]
    else
      read mol input = String( t.mol [i_row] ) name = "TMPQMOBJ"
    endif
    if( Nof( a_//h* ) ==0 ) print " Warining> No hydrogens in the molecule, make sure this is correct"
    if(l_minimize)then
      if( l_torScan)then
        write gamess a_ fix = vs_out fname_in $s_water
      else
        if( l_relax)  then
          convert auto a_
          write gamess a_ fix = v_//T fname_in $s_wrgmopt $s_water # relax bond lengths/angles, try to keep overall conformation
        else
          write gamess cartesian a_ fname_in $s_wrgmopt $s_water
        endif
      endif
    else
      write gamess cartesian energy a_ fname_in type="MP2" $s_water # no minimization, but MP2 level
    endif
    delete system s_tempDir + Name( fname_in ) + ".dat"
    s_pref = ""
    if (l_win) s_pref = "call "
    s_cmd = s_cmd + ";" + Sum( (s_pref + s_gamessPath) // Name(fname_in) // " > " // fname_out )
    if (l_win) s_cmd += ";echo " + String(Integer(Ceil(Real(i_row)/Nof(t)*100))) + "%% gamess 1>&2"   # progress
    if(Index(s_gamessPath "qsub")!=0)s_cmd = s_cmd + '"'
    s_finishQM = s_finishQM + "read string '" + fname_out + "'\n"
    s_finishQM = s_finishQM + "l_out = s_out ~ '*TERMINATED NORMALLY*'\n"
    s_finishQM = s_finishQM + "if(l_out)then\n"
    if(l_minimize)then
      s_finishQM = s_finishQM + "  read gamess \"" + fname_out  + "\" name=\"XYZ\"\n"
      s_finishQM = s_finishQM + "  " + s_restab +".Energy[" + i_row +  "] = r_out\n"
      s_finishQM = s_finishQM + "  read mol input = String(" + s_restab +".mol ["+i_row+"]) name = \"TMPQMOBJ\"\n"
      if( l_relax) s_finishQM = s_finishQM + "  set a_//* XYZ[Index(Name( a_//!vt* ) S_out index)]\n"
      if(!l_relax) s_finishQM = s_finishQM + "  set a_//* XYZ\n"
      s_finishQM = s_finishQM + "  " + s_restab +".mol ["+i_row+"] = Chemical( a_ exact hydrogen )\n"
      s_finishQM = s_finishQM + "  delete a_\n"
    else
      if(s_water=="") s_finishQM = s_finishQM + "  read gamess energy type=\"MP2\" \"" + fname_out  + "\"\n"
      if(s_water!="") s_finishQM = s_finishQM + "  read gamess energy water \"" + fname_out  + "\"\n"
      s_finishQM = s_finishQM + "  " + s_restab +".Energy[" + i_row +  "] = r_out\n"
    endif
#    s_finishQM = s_finishQM + "  delete system \"" + fname_in + "\" \"" + fname_dat + "\" \"" + fname_out + "\"\n"
    s_finishQM = s_finishQM + "else\n"
    s_finishQM = s_finishQM + "  print \" Error> QM calculations failed for row " + i_row + "\"\n"
    s_finishQM = s_finishQM + "endif\n"
    $s_restab.Energy [i_row] = ND
    $s_restab.fname  [i_row] = fname_in
    if(s_table!~"_STACK*") delete a_
  endfor
  if(l_relative) s_finishQM = s_finishQM + s_restab +".Energy = " + s_restab +".Energy - Min(" + s_restab +".Energy )\n"
  if(!l_minimize & s_water=="") s_finishQM = s_finishQM + " rename " + s_restab +".Energy \"Energy_MP2\"\n"
  if(!l_minimize & s_water!="") s_finishQM = s_finishQM + " rename " + s_restab +".Energy \"Energy_MP2solv\"\n"
  s_finishQM = s_finishQM + "set property display " + s_restab + "\n"
#  sprintf "read table mol display \"%s\" name=Name(\""+s_outName+"\",unique)\ndelete system \"%s\" \"%s\" \"%s\" ", fname_out, fname_in fname_out, fname_inx
  s_out = ""
  if(Index(s_gamessPath,"qsub")!=0) l_dontrun=yes # don't run if it is to be submitted to the queueing system. To be refined
  if (l_win) then
    s_gmsdirs = ""
    s_gmsdirs += "GAMESSDIR=" + Path(s_gamessPath) + "\n"
    s_gmsdirs += "AUXDATADIR=" + Path(s_gamessPath) + "/auxdata\n"
    s_gmsdirs += "RESTARTDIR=" + s_tempDir + "\n"
    s_gmsdirs += "SCRATCHDIR=" + s_tempDir + "\n"
    write string delete Replace(s_gmsdirs,"/","\\") s_tempDir + "rungms.gms"

    write string delete Replace( s_cmd ";" "\n" ) s_tempDir + "gms_job.bat"
    s_com = "c:/Windows/System32/cmd.exe"
    if (Existenv("COMSPEC" )) s_com = Getenv("COMSPEC" )
    s_cmd = s_tempDir + "gms_job.bat"
    if (!l_dontrun) s_cmd = s_com + " /C " + '"' + s_cmd + '"'
    s_cmd
  endif
  if(l_dontrun)then
    set property command s_finishQM
    keep  s_finishQM
    s_ = "s_finishQM_"+ s_restab
    if(Type( $s_ )!="unknown") delete $s_
    rename s_finishQM "s_finishQM_"+ s_restab
    print " Run this from UNIX command line:\n"
    print Replace( s_cmd ";" "\n" )
    print "\n After the jobs are finished, execute the s_finishQM script to load results"
  else
    make background s_cmd command=s_finishQM info="QM evaluation of conformers finished. Press OK to load the result"
    print " Info> GAMESS QM calculations started in background. You will be notified when the job is complete."
  endif
  add header $s_restab   l_minimize name="l_minimize"
  add header $s_restab   s_water name="s_water"
  add header $s_restab   l_relative name="l_relative"
  add header $s_restab   l_relax name="l_relax"
  keep $s_restab
endmacro
#
macro loadQMstrainsResult s_restab
#  load object $s_restab.OBJECT
#  load stack a_
  for i = 1 Nof( $s_restab )
    fname_in = $s_restab.fname [i]
    fname_out= Replace( fname_in ".inp" ".log")
    fname_dat= Replace( fname_in ".inp" ".dat")
    s_grep = "\"TERMINATED NORMALLY\" " + fname_out
    read sys grep $s_grep
    if(s_out!="")then
      if( $s_restab.l_minimize )then
        read gamess fname_out name="XYZ"
        $s_restab.Energy [i] = r_out
        read mol input = String( $s_restab.mol [i]) name = "TMPQMOBJ"
        if(  $s_restab.l_relax ) set a_//* XYZ[Index(Name( a_//!vt* ) S_out index)]
        if(! $s_restab.l_relax ) set a_//* XYZ
        $s_restab.mol [i] = Chemical( a_ exact hydrogen )
        delete a_
      else
        if( $s_restab.s_water =="") read gamess energy type="MP2" fname_out
        if( $s_restab.s_water !="") read gamess energy water fname_out
        $s_restab.Energy [i] = r_out
      endif
#     delete system fname_in + " " + fname_dat + " " + fname_out
    else
      print " Error> QM calculations failed or didn't finish for row " + i
    endif
  endfor
  if(! $s_restab.l_minimize & $s_restab.s_water =="") rename $s_restab.Energy "Energy_MP2"
  if(! $s_restab.l_minimize & $s_restab.s_water !="") rename $s_restab.Energy "Energy_MP2solv"
  if( $s_restab.l_relative ) $s_restab.dEnergy = $s_restab.Energy - Min( $s_restab.Energy )
  set property display $s_restab
endmacro
#
macro confGenFileBG s_inputFile s_outputFile i_mnconf (50) r_vicinity (30.) r_thoroughness (1.) l_sampleRings (yes) l_cisTrans (no) l_systematic (no) l_refine (no) l_warnings (no) l_keepHydrogens (no) l_pyramide (no) auto
  l_commands = no
  l_info = no
  S_cmdargs = "mnconf="+i_mnconf // "vicinity="+r_vicinity // "effort="+r_thoroughness // "-f" // "-I"
  if(!l_warnings)  S_cmdargs = S_cmdargs // "-q"
  if(l_sampleRings)S_cmdargs = S_cmdargs // "-r"
  if(l_systematic) S_cmdargs = S_cmdargs // "-s"
  if(l_refine)     S_cmdargs = S_cmdargs // "-c"
  if(l_cisTrans)   S_cmdargs = S_cmdargs // "-d"
  if(l_keepHydrogens) S_cmdargs = S_cmdargs // "-hydrogen"
  if(l_pyramide) S_cmdargs = S_cmdargs // "-p"
  if (Tolower(Extension( s_inputFile )) == ".molt") then
    s_cmd = Path( macro, s_icmhome + "_confGen",  s_inputFile, S_cmdargs )
  else
    s_cmd = Path( macro, s_icmhome + "_confGen",  s_inputFile,  s_outputFile, S_cmdargs )
  endif
  make background s_cmd command="" info="Conformation Generator finished. Output file :" + s_outputFile
  print " Info> conformation generation started in background. You will be notified when the job is complete."
endmacro
#
macro chemSuperBG as_template s_table I_idx r_thoroughness (1.) l_sampleRings (no) l_sampleCisTrans (no) l_occupancy (no) l_score (no) l_tableOutput (no) l_mulipose (no) l_tautomer (no) l_envelope (no) l_strain (no) r_LipoWeight (1.) r_PolarWeight (1.) r_APFcutoff (0.) as_subtmpl (a_NONE.) i_nproc (1) s_optn ("") as_exclude (a_NONE.) r_Xweight (3.)  auto
  l_commands = no
  l_info = no
  if(I_idx=={-1})then
    fname_in = s_table
  else
    T_t = $s_table
    t = T_t[ I_idx ]
    if (Nof(t)==0) return error "No selected rows"
    fname_in  = Name( system s_tempDir + "super_XXXX_in.sdf" )
    write table mol t fname_in delete
  endif
  #
  excl_fname_in = ""
  if (Nof( as_exclude ) != 0) then
    excl_fname_in = Name( system s_tempDir + "super_excl_XXXX_in.ob" )
    if ( Type( Obj( as_exclude ) 2 ) == "ICM") then
      copy Obj( as_exclude ) selection delete "tmp_exclude"
      strip a_tmp_exclude. virtual
      write object a_tmp_exclude. & as_exclude excl_fname_in delete
      delete a_tmp_exclude.
    else
      write object as_exclude excl_fname_in delete
    endif
  endif
#
  if (l_tableOutput) then
    fname_out = Name( system s_tempDir + "super_XXXX_out.sdf" )
  else
    fname_out = Name( system s_tempDir + "super_XXXX_out.ob" )
  endif
#
  if (Nof(as_template)==0) return error "No template selected"
  if(Type(Obj(as_template)[1] 2)=="ICM" | Type(Obj(as_template)[1] 2)=="Pharmacophore")then
    fname_tpl = s_tempDir + "templ_tmp.ob"
    if(Type(as_template 1)!="object" & Type(as_template 1)!="molecule")then
       if(Nof(Atom(as_template)) != Nof(Atom(Mol(as_template)))) return error "Partial molecule selection is only supported for non-ICM templates"
       as_template = Mol( as_template )
    endif
    if(Type(as_template 1) == "molecule" & as_template != Mol(Obj(as_template)))then
      copyMol as_template "TEMP_chemSuper"
      write object a_TEMP_chemSuper. fname_tpl delete
      delete a_TEMP_chemSuper.
    else
      write object Obj(as_template) fname_tpl delete
    endif
  else
    if(l_occupancy) return error "Occupancy option is only supported for ICM object templates"
    fname_tpl = s_tempDir + "templ_tmp.sdf"
    write mol as_template fname_tpl delete
  endif
  S_cmdargs = Sarray( 1 "effort="+r_thoroughness)    # chemsuper
  if(Nof(as_subtmpl)!=0)then
    fname_stpl  = Name( system s_tempDir + "super_subtpl_XXXX.sdf" )
    write mol as_subtmpl fname_stpl delete
    S_cmdargs = S_cmdargs // "constraint="+fname_stpl
  else
    fname_stpl  = ""
  endif
  icShape = Index(s_optn "shape")>0
  if(l_sampleRings)   S_cmdargs = S_cmdargs // "-r"
  if(l_sampleCisTrans)S_cmdargs = S_cmdargs // "-d"
  if(l_occupancy)     S_cmdargs = S_cmdargs // "-o"
  if(l_score)     S_cmdargs = S_cmdargs // "-s"
  if(l_mulipose)  S_cmdargs = S_cmdargs // "-m"
  if(l_tautomer)  S_cmdargs = S_cmdargs // "-t"
  if(l_envelope)  S_cmdargs = S_cmdargs // "-e"
  if(l_strain)    S_cmdargs = S_cmdargs // "-F"
  if(excl_fname_in != "")  S_cmdargs = S_cmdargs // ("exclude=" + excl_fname_in)
  if(Index(s_optn "racemic")>0) S_cmdargs = S_cmdargs // "-C"
  if(Index(s_optn "rigid")>0)   S_cmdargs = S_cmdargs // "-R"
  if(icShape)   S_cmdargs = S_cmdargs // "-shape"
  if(i_nproc>1)   S_cmdargs //= "proc=" + i_nproc
  if(r_LipoWeight!=1.) S_cmdargs = S_cmdargs // ("lipo=" + r_LipoWeight)
  if(r_PolarWeight!=1.)   S_cmdargs = S_cmdargs // ("polar=" + r_PolarWeight)
  if(r_APFcutoff!=0.)   S_cmdargs = S_cmdargs // ("APFcutoff=" + r_APFcutoff)
  if(r_Xweight!=3.) S_cmdargs = S_cmdargs // ("Xweight=" + r_Xweight)
  s_cmd = Path( macro, s_icmhome + "_chemSuper",  fname_tpl, fname_in,  fname_out, S_cmdargs )

  if(I_idx=={-1}) fname_in = "" # so that it is not removed

  S_tmpFiles = fname_tpl // fname_in // fname_out
  if (fname_stpl != "") S_tmpFiles = S_tmpFiles // fname_stpl
  if (excl_fname_in != "") S_tmpFiles = S_tmpFiles // excl_fname_in

  s_tmpFiles = Sum( Sarray( Nof(S_tmpFiles), "\"" ) + S_tmpFiles + "\"" , "," )

  if (l_tableOutput) then
    sprintf "read table mol display \"%s\" name=Name(\"super_%s\",unique)\ndelete system %s", fname_out,Name(Obj(as_template))[1], s_tmpFiles
  else
    sprintf "read object \"%s\"\ndelete system %s", fname_out, s_tmpFiles
  endif

  make background s_cmd command=s_out info="Chemical 3D Superposition finished. Press OK to load the result"
  print " Info> Chemical 3D Superposition started in background. You will be notified when the job is complete."
endmacro

macro chemAlignBG T_t I_idx i_mniter r_LipoWeight (1.) r_PolarWeight (1.) r_lambda (1.4) s_wtcol ("") i_nproc (1) auto
  l_commands = no
  l_info = no
  t = T_t[ I_idx ]
  if (Nof(t)==0) return error "No selected rows"
  if(s_wtcol != "" & Type( T_t.$s_wtcol ) != "rarray" ) return error "weights column should be a rarray"
  fname_in  = s_tempDir + "align_tmp.sdf"
  fname_out = s_tempDir + "align_tmp_out.ob"
  write table mol t fname_in delete
  S_cmdargs = Sarray( 1 "output="+fname_out )
  S_cmdargs = S_cmdargs // ("mniter="+i_mniter)
  S_cmdargs = S_cmdargs // ("-r")
  if(r_LipoWeight!=1.)    S_cmdargs = S_cmdargs // ("lipo=" + r_LipoWeight)
  if(r_PolarWeight!=1.)   S_cmdargs = S_cmdargs // ("polar=" + r_PolarWeight)
  if(r_lambda !=1.4 )     S_cmdargs = S_cmdargs // ("radius=" + r_lambda)
  if(s_wtcol != "")       S_cmdargs = S_cmdargs // ("wtcol=" + s_wtcol)
  if (i_nproc > 1) S_cmdargs = S_cmdargs // ("proc="+i_nproc)
  s_cmd = Path( macro, s_icmhome + "_chemAlign", fname_in, S_cmdargs )
  sprintf "read object \"%s\"\ndelete system \"%s\" \"%s\"", fname_out, fname_in fname_out
  s_cmd
  make background s_cmd command=s_out
  print " Info> Chemical 3D alignment started in background. You will be notified when the job is complete."
endmacro
#
macro mutantCompStabilityBG auto as_ s_mutation ("ala") s_AAtable s_grp s_part1 s_part2 l_terms (no) i_batch (0)
  l_commands = no
  l_info = no
  if (String(Res(as_))=="") return error "No template selected"
  s=String(Res(as_) number)
  nT=Index(s ".")
  s_obj=s[3:(nT-1)]
  s1=s[1:$nT]
  s_res=Replace(s s1 "")
  print "mutantCompStabilityBG " s_obj s_res
  as_template=a_$s_obj.
  S_1=Split(s_part1 ",")
  S_2=Split(s_part2 ",")
#  if(Index(S_1 s_chainMutate)==0 & Index(S_2 s_chainMutate)==0)return " Error> Chain with mutatable residue is not in any interacting part"
  i_proc = i_batch == 0 ? Iproc() : i_batch
  fname_out = Path() + s_obj + "_" + i_proc + "_mutant.icb"
  s_terms=String(l_terms)
  fname_in = Path() + s_obj + "_" + i_proc + ".ob"
  write object Obj(as_template) fname_in delete
#
  S_cmdargs = "ChainRes="+"\""+s_res+"\"" // "newResidue="+s_mutation
  S_cmdargs = S_cmdargs // "aaTabl="+"\""+s_AAtable+"\"" // "groups="+"\""+s_grp+"\"" // "part1="+s_part1
  S_cmdargs = S_cmdargs // "part2="+s_part2 // "eneTerms="+s_terms
  s_cmd = Path( macro, s_icmhome + "_protDesign", fname_in, fname_out, S_cmdargs ) +" > " + s_obj + "_ddG.ou"
  s_cmd
  if (i_batch) then
    unix $s_cmd
    delete system fname_in
  else
    #sprintf "read binary \"%s\"", fname_out
    sprintf "read binary %s\nprocessProtD1\ndelete system %s", String(fname_out string), String(fname_in string)
    make background s_cmd command=s_out info="Binding energy calculations finished. Press OK to load the result"
    print " Info>  Binding energy calculations started in background. You will be notified when the job is complete."
    print " Info>  Mutations to Pro for residues with phi angle <-90 and >-60 deg. are not considered"
  endif
#  s_Probcomment = "-Log(probability) relative to approved drugs decoy, capped at 10\n1: Top 10 percent\n2: Top 1 percent\n3: Top 0.1 percent"
#  s_Classcomment = "Classification Score:\nfor kcc models:\nProbability of being a positive, assume 0.5% hitrate\nfor others:\n1: Median value of actives\n0: Median value of inactives"
#  s_Zscorecomment = "Z-Score\n>3. indicates 3 standard deviation above approved drugs decoy"
#  s_Scorecomment = "MolpKd adjusted by MolSim, \nScore of 3. or above indicates binder"
#  s_pKdcomment = "Prediction of pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND indicates disimilarity to known binders"
#  s_pKderrorcomment = "Estimated total uncertainty/error for pKd prediction, including experimental error of ~1. pKd unit"
#  s_DockScorecomment = "ICM docking score, \nScore < -32. are in general significant, \nbut may vary from structure to structure"
#  set format modelposetmp.pPvalue "%.2f" name="" color="rainbow='#FFFFFF/#FFFF00/#FF0000,1.:3.,pinwheel'" comment=s_Probcomment
#  set format modelposetmp.MolScore "%.1f" name="" color="rainbow='#FFFFFF/#FFFF00/#FF0000,3.:7.,pinwheel'" comment=s_Scorecomment
#  set format modelposetmp.MolpKd "%.1f" name="" color="rainbow='#FFFFFF/#FFFF00/#FF0000,5.:7.,pinwheel'" comment=s_pKdcomment
#  set format modelposetmp.MolpKd_Error "%.1f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,1.5:2.5,pinwheel'" comment=s_pKderrorcomment
#  set format modelposetmp.MolZScore "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,1.:3.,pinwheel'" comment=s_Zscorecomment
#  set format modelposetmp.MolClass "%.2f" name="" color="rainbow='#FFFFFF/#FFFFDC/#FFDCDC,0.5:1.,pinwheel'" comment=s_Classcomment
#  set format modelposetmp.MolRecScore "%.1f" name="" color="rainbow='#FFDCDC/#FFFFDC/#FFFFFF,-32.:-20.,pinwheel'" comment=s_DockScorecomment
endmacro

macro mutantPeptCompStabilityBG s_inp s_mutation ("ala") s_AAtable s_grp s_part1 s_part2 l_scan1 (no) l_scan2 (no)
  l_commands = no
  l_info = no
  if (s_inp=="") return error "No template selected"
  s_obj=Field(s_inp 1 ".")
  s_chainMutate=Field(Field(s_inp 2 ".") 1 "/")
  s_resMutate=Field(s_inp 2 "/")
  as_template=a_$s_obj.
  S_1=Split(s_part1 ",")
  S_2=Split(s_part2 ",")
  if(Index(S_1 s_chainMutate)==0 & Index(S_2 s_chainMutate)==0)return " Error> Chain with mutatable residue is not in any interacting part"
  if(Index(S_1 s_chainMutate)==0 )return " Error> Interacting part 1 is not a peptide"
  if(l_scan1)then
    s_scanSeq="yes"
  else
    s_scanSeq="no"
  endif
  if(l_scan2)then
    s_scanSurf="yes"
  else
    s_scanSurf="no"
  endif
  fname_out = Path() + s_obj + "_mutant.icb"
#fname_out = Name( system s_tempDir + "protd_" + s_obj + "_XXXX_mutant.icb" )
  if(Type(Obj(as_template)[1] 2)=="ICM")then
   fname_in = Path() + s_obj + ".ob"
   write object Obj(as_template) fname_in delete
  else
   fname_in = Path() + s_obj + "_new.pdb"
   write pdb Obj(as_template) fname_in delete
  endif
  S_cmdargs = "chain="+s_chainMutate // "mutResidue="+s_resMutate// "newResidue="+s_mutation
  S_cmdargs = S_cmdargs // "aaTableList="+"\""+s_AAtable+"\"" // "aaList="+"\""+s_grp+"\"" // "part1="+s_part1
  S_cmdargs = S_cmdargs // "part2="+s_part2 // "scanSeq="+s_scanSeq // "scanSurf="+s_scanSurf
  s_cmd = Path( macro, s_icmhome + "_mutantPeptComplex", fname_in, fname_out, S_cmdargs ) +" > " + s_obj + "_ddG.ou"
  sprintf "read binary %s", String(fname_out string)
  sprintf "read binary %s\nprocessProtD1 ", String(fname_out string)
  print "Launching " + s_cmd
  make background s_cmd command=s_out info="Binding energy calculations finished. Press OK to load the result"
  print " Info>  Binding energy calculations started in background. You will be notified when the job is complete."
  print " Info>  Mutations to Pro for residues with phi angle <-90 and >-60 deg. are not considered"
endmacro

macro mutantProteinLigandBG rs_recRes s_mutation ("ala") ms_ligand l_scan (no)
  l_commands = no
  l_info = no
  rs_recRes = Res(rs_recRes) # just in case
  if (Nof(rs_recRes & a_.A )==0) return error "No receptor residues selected"
  if(Index(s_mutation "all")!=0)s_mutation = "all"
  s_chainMutate=Name(Mol(rs_recRes))[1] # multiple chains not supported yet
  s_resMutate=Field(String(rs_recRes number) 2 "/")
  s_ligand=Name(ms_ligand)[1]
  os_rec=Obj(rs_recRes)[1]
  s_obj=Name( os_rec )[1]
  set object os_rec
  fname_out = Path() + s_obj + ".icb"
  if(Type(a_ 2)=="ICM")then
   fname_in = Path() + s_obj + ".ob"
   write object fname_in delete
  else
   fname_in = Path() + s_obj + "_new.pdb"
   write pdb fname_in delete
  endif
  if(Nof(a_$s_ligand)==0)return " Error> Protein and ligand must be in the same object"
  S_cmdargs = "chain="+s_chainMutate // "mutResidue="+s_resMutate// "newResidue="+s_mutation
  S_cmdargs = S_cmdargs // "ligand="+s_ligand // "scanSurf="+( l_scan?"yes":"no"  )
  s_cmd = Path( macro, s_icmhome + "_mutateProtLig", fname_in, fname_out, S_cmdargs ) # +" > " + s_obj + "_ddG.ou"
  sprintf "read binary %s\nprocessProtD1 ", String(fname_out string)
  make background s_cmd command=s_out info="Binding energy calculations finished. Press OK to load the result"
  print " Info>  Binding energy calculations started in background. You will be notified when the job is complete."
endmacro

macro processProtD1 s_tab ("results") auto
 l_commands = l_info = no
 s_mutTab = "mutations_" + ( $s_tab.prot [1] )
 if(Type( $s_mutTab )!="unknown")then
   add $s_mutTab $s_tab
   delete $s_tab
 else
   set format $s_tab.obj show off
   add header name="doubleClick" $s_tab """
   load object %@.obj [%#] delete name=Name( %@.prot[1] ) + "_mut"
   display a_ ribbon
   display a_H xstick
   display a_$%@.chain[%#]/$%@.residue[%#] & a_*.//c* xstick cyan
   display a_$%@.chain[%#]/$%@.residue[%#] xstick cpk
   display residue label a_$%@.chain[%#]/$%@.residue[%#]
   display a_$%@.chain[%#]/cys* xstick
   display Res(Sphere( a_$%@.chain[%#]/$%@.residue[%#] a_ 3.)) wire
   center a_$%@.chain[%#]/$%@.residue[%#] margin=7.
   """
   rename $s_tab s_mutTab
 endif
endmacro
#
# compute change in protein stability upon mutation
macro mutantStabilityBG auto as_ s_mutation ("ala") s_AAtable s_grp l_allChains (no) l_daa (no) l_foreground (no) i_nproc (1) auto
  l_commands = no
  l_info = no
  if (String(Res(as_))=="") return error "No template selected"
  s=String(Res(as_) number)
  nT=Index(s ".")
  s_obj=s[3:(nT-1)]
  s1=s[1:$nT]
  s_res=Replace(s s1 "")
  print "mutantStabilityBG calculation for object/residues:" s_obj s_res
#  s_chainMutate=Field(Field(s_inp 2 ".") 1 "/")
#  s_resMutate=Field(s_inp 2 "/")
  as_template=a_$s_obj.
  s_allChains="no"
  if(l_allChains)s_allChains="yes"
#  if(l_scan)then
#    s_scanSeq="yes"
#  else
#    s_scanSeq="no"
#  endif
  s_daa="no"
  if(l_daa)s_daa="yes"
  fname_out = Path() + s_obj + "_mutant.icb"
  if(Type(Obj(as_template)[1] 2)=="ICM")then
   fname_in = Path() + s_obj + ".ob"
   write object Obj(as_template) fname_in delete
  else
   fname_in = Path() + s_obj + "_new.pdb"
   write pdb Obj(as_template) fname_in delete
  endif
  S_cmdargs = "ChainRes="+"\""+s_res+"\"" // "newResidue="+s_mutation
#  S_cmdargs = S_cmdargs // "aaTabl="+"\""+s_AAtable+"\"" // "groups="+"\""+s_grp+"\"" // "scanSeq="+s_scanSeq
  S_cmdargs = S_cmdargs // "aaTabl="+"\""+s_AAtable+"\"" // "groups="+"\""+s_grp+"\""
  S_cmdargs = S_cmdargs // "allChains="+s_allChains // "daa="+s_daa
  S_cmdargs = S_cmdargs // ("proc=" + i_nproc)
#  s_cmd = Path( macro, s_icmhome + "_mutantStability", fname_in, fname_out, S_cmdargs ) +" > " + s_obj + "_ddG.ou"
  s_cmd = Path( macro, s_icmhome + "_mutantStabilityAve", fname_in, fname_out, S_cmdargs ) +" > " + s_obj + "_ddG.ou"
  print "Launching: " s_cmd
  if ( !l_foreground ) then
    sprintf "read binary %s\nprocessProtD1 ", String(fname_out string)
    make background s_cmd command=s_out info="Mutant stability calculations finished. Press OK to load the result"
    print " Info>  Mutant stability calculations started in background. You will be notified when the job is complete."
    print " Info>  Mutations to Pro for residues with phi angle <-100 and >-50 deg. are not considered"
  else
    unix $s_cmd
  endif
endmacro
#
# compute aggregation propensity of a polypeptide chain
#macro aggregSeqBG s_seq l_curr (no) s_tabl ("") s_fout ("")
macro aggregSeqBG s_seq l_curr (no) s_fout ("")
  l_commands = no
  l_info = no
  l_foreground = no
  if (s_seq=="") return error "No sequence provided"
  if(s_fout!="")fname_out = Path() + s_fout + "_aggreg.icb"
  S_cmdargs = "sequence="+s_seq
  s_cmd = Path( macro, s_icmhome + "_aggregPropencity", fname_out, S_cmdargs ) +" > " + "aggreg.ou"
#  print "COM" s_cmd
  if ( !l_foreground ) then
   sprintf "read binary %s\nprocessAggreg1 ", String(fname_out string)
   make background s_cmd command=s_out info="Aggregation propensity calculations finished. Press OK to load the result"
   print " Info>  Aggregation propensity calculations started in background. You will be notified when the job is complete."
  else
    unix $s_cmd
  endif
endmacro

# compute effect of mutation on aggregation propensity of a polypeptide chain
#macro aggregMutantBG s_seq s_res ("") s_mutation ("ala") l_scan (no) s_mult ("") s_fout ("")
#  l_commands = no
#  l_info = no
#  l_foreground = no
#  if (s_seq=="") return error "No sequence provided"
#  if(s_fout!="")fname_out = Path() + s_fout + "_aggreg.icb"
#  S_cmdargs = "sequence="+s_seq // "resNum="+s_res // "mutateAA="+s_mutation // "scan="+l_scan // "mutMult="+s_mult
#  s_cmd = Path( macro, s_icmhome + "_aggregMutant", fname_out, S_cmdargs ) +" > " + "aggreg.ou"
##  print "COM" s_cmd
#  if ( !l_foreground ) then
#   sprintf "read binary \"%s\"\nprocessAggreg1 ", fname_out
#   make background s_cmd command=s_out info="Aggregation propensity calculations finished. Press OK to load the result"
#   print " Info>  Aggregation propensity calculations started in background. You will be notified when the job is complete."
#  else
#    unix $s_cmd
#  endif
#endmacro

macro processAggreg1 s_tab1 ("results") s_tab2 ("t1") auto
 l_commands = l_info = no
# set format $s_tab.obj show off
# add header name="doubleClick" $s_tab """
# load object %@.obj [%#]
# unds %@.2
# center %@.1 margin=7.
# for ij=1,Nof(s_tab1)
  make plot $s_tab2 "x=resNum;y=aggCalc;size=6;style=connected;;" output="plot.png" size = {800,800}
  read image "plot.png"
  print "tab" s_tab1
  s_tab1col = s_tab1+".a4v"
  $s_tab1col[1] = album [1]
  delete album
  make plot $s_tab2 "x=resNum;y=NHSA;size=6;style=connected;;" output = "plot1.png" size = {800,800}
  read image "plot1.png"
  s_tab2col = s_tab1+".NHSA"
  $s_tab2col[1] = album [1]
# endfor
endmacro

# predict new stabilizing/destabilizing disulfide bonds
macro SSpredictBG s_inp l_allChains (no)
  l_commands = no
  l_info = no
  if (s_inp=="") return error "No template selected"
  s_obj=Field(s_inp 1 ".")
#  s_chainMutate=Field(Field(s_inp 2 ".") 1 "/")
  s_resMutate=Field(s_inp 2 "/")
  s_chainMutate=Field(Field(s_inp 2 ".") 1 "/")
  as_template=a_$s_obj.
  s_allChains="no"
  if(l_allChains)s_allChains="yes"
  fname_out = Path() + s_obj + "_mutant.icb"
  if(Type(Obj(as_template)[1] 2)=="ICM")then
   fname_in = Path() + s_obj + ".ob"
   write object Obj(as_template) fname_in delete
  else
   fname_in = Path() + s_obj + "_new.pdb"
   write pdb Obj(as_template) fname_in delete
  endif
  S_cmdargs = "chain="+s_chainMutate // "mutResidue="+s_resMutate// "allChains="+s_allChains
  s_cmd = Path( macro, s_icmhome + "_predictSS", fname_in, fname_out, S_cmdargs ) +" > " + s_obj + "_ddG.ou"
  sprintf "read binary %s", String(fname_out string)
  sprintf "read binary %s\nprocessProtDSS ", String( fname_out string )
  make background s_cmd command=s_out info="New disulfide bond prediction finished. Press OK to load the result"
  print " Info>  Disulfide bond prediction started in background. You will be notified when the job is complete."
endmacro
#
macro processProtDSS
 l_commands = l_info = no
 display a_1. ribbon
 set format results.obj show off
 add header name="doubleClick" results """
 unds a_*. & !a_1.
 delete a_!1.
 load object results.obj [%#]
 display a_ ribbon
 display a_$%@.chain[%#]/$%@.n1[%#] xstick cyan
 display a_$%@.chain[%#]/$%@.n2[%#] xstick cyan
 center a_$%@.chain[%#]/$%@.n1[%#],$%@.n2[%#]
 """
endmacro

# compute melting temperature of a protein
#macro calcTm as_ (a_A) s_Tenv s_Host
macro calcTm as_ (a_A) s_Tenv
  l_commands = no
  l_info = no
  l_display=no
  s_Host=""
  set term only "bb,vw,14,hb,el,to,cn,sf,en"
  as_
  copyMol as_  Name("tTm" object )
  set object tTm
#read library
  S_lig={"nad", "plp", "hem", "hec", "fe", "a80", "fes", "epe", "sf4", "gdp", "cmp", "adp", "rea", "ap5", "atp", "nap", "iph"}
# gly,ala,ser,thr,cys,val,leu,ile,met,pro,phe,tyr,trp,asp,glu,asn,gln,his,lys,arg
  S_aa={"gly","ala","ser","thr","cys","val","leu","ile","met","pro","phe","tyr","trp","asp","glu","asn","gln","his","lys","arg","hie"}
  S_a1={"G","A","S","T","C","V","L","I","M","P","F","Y","W","D","E","N","Q","H","K","R"}
  R_maxSA={84.,106.,130.,142.,135.,142.,164.,169.,188.,136.,197.,222.,227.,160.,196.,160.,196.,184.,205.,248.,184.}
#weights of the scoring function
  if(s_Tenv=="" & s_Host=="")then
# 1 SAburried; 2 sphere; 3 entropy; 4 metC_cysF; 5 SA; 6 bondCys; 7 SA_char; 8 charge; 9 el; 10 Asn; 11 Lys; 12 ProL; 13 SA_polar; 14 secStr; 15 nRes; 16 His; 17 SA_polarBurried; 18 Ser; 19 Cys
   R_w={-1.80524, 2137.13, -126.612, 1109.91, 0.548167, 560.762, 129.616, -76.2978, -28.01, -174.637, 90.3764, 186.57, 99.3154, 27.0636, 0.00916263, -154.214, -118.842, -65.3881, -205.346}
   w_Tenv=0.
   z=-145.950812
  else
# Tenv included
# 1 SAburried; 2 sphere; 3 metC_cysF; 4 bondCys; 5 entropy; 6 SA; 7 charge; 8 secStr; 9 ProL; 10 SA_char; 11 SA_polar; 12 el; 13 Lys; 14 Ser; 15 Asn; 16 SA_polarBurried; 17 His; 18 nRes; 19 Cys
   R_w={-1.27358, 1544.57, 1056.8, 489.726, -85.6558, 0.41196, -68.8579, 27.5029, 177.68, 82.7081, 77.1158, -16.8103, 59.7861, -77.009, -86.9312, -104.691, -104.71, 0.00471862, -71.429}
   w_Tenv=0.533352
   z=-112.76829
  endif
  i_fe=0
  i_zn=0
  i_cu=0
  i_ca=0
  i_cd=0
  as_lig=a_H
  nlg=Nof(as_lig)
#  print "Nlig" nlg
  delete a_W
#  s_deleteL=""
#  if(nlg!=0)then
#   for il=1,nlg
#    s0=Name(as_lig)[il]
#    s=s0[2:Length(s0)]
#    print "S0" s0 s Index(S_lig s)
#    if(Index(S_lig s)==0)s_deleteL=s_deleteL+s0+","
#   endfor
#  endif
#  delete a_$s_deleteL
#  a_*.*
  set comment a_//Aa " "
  delete a_//A
  delete a_//Na*,k*
  if(Type(a_ 2)!="ICM")then
   convertObject a_ 1==1 yes yes yes yes yes no
  endif
  for kk=1,Nof(a_*)
   if(Nof(a_$kk &a_A)>0)then
    s1=Name((a_$kk/*)[1])[1]
    print "First residue" s1
    if(Index(S_aa s1)!=0)modify "nh3+" Res(a_$kk/*)[1]
   endif
  endfor
  nr=Nof(a_A/*)
  r_chain=Nof(a_A)
  r_q=(1.0*(Nof(a_/lys,arg,nh3+)+Nof(a_/asp,glu,coo-)))/nr
  r_ser=(1.0*Nof(a_/ser))/nr
  r_cys=(1.0*Nof(a_/cys)-1.0*Nof(Sphere(a_A/cys/s* a_//Fe* 2.5)))/nr
  r_asn=(1.0*Nof(a_/asn))/nr
  r_lys=(1.0*Nof(a_/lys))/nr
  r_his=(1.0*Nof(a_/his,hip,hie))/nr
#  print "Test a 1"
#  a_*
#
  r_gMet1=(1.0*Nof(a_M,H//Cu*,Fe*,Ca*,Cd*,Zn*,Mn*,Mg*,Ga*,Co*,Ni*))/nr
# ligand covalently bound to Cys, S-S bonds
  p1=Nof(Sphere(a_1.H//!vt*,h*,Fe* a_/cys*/s* 2.0))+Nof(a_/cyss)/2
  p2=Nof(Sphere(a_//Fe* a_A//s* 2.5))
  if(p2==4)then
   p2=2
  else
   p2=0
  endif
  r_cysB=(1.0*p1)/nr
  r_cysBfe=(1.0*p2)/nr
  S_m=Split(Field(String(a_M//Fe*,Cu*,Zn*,Ca*,Cd*,Mn*,Mg*,Ga*,Co*,Ni*) 2 "//") ",")
  print "Metal string" S_m
  if(Nof(a_M,H//Fe)!=0 & (p2/Nof(a_//Fe))>3)i_feS=p2
  nmet=Nof(S_m)
  for im=1,nmet
   cn=0
   cnM=0
   sm=S_m[im]
#   cn=Nof(Res(Sphere((a_M,H//$sm) (a_A//s*,n*,o*) 3.0)))
   cn=Nof(Sphere(a_M,H//$sm a_A//s*,n*,o* 3.0))
   cnM=Nof(Sphere((a_M,H//$sm) (a_M,H//!$sm,vt*) 4.5))
   print "CN" cn cnM
   nm=(Name(a_M,H//$sm)[1])[1:2]
#   print "Metal name" nm cn  "metal neighbours" cnM
   if(nm=="Fe")then
    cn1=Nof(Sphere(a_M,H//$sm a_//n*,o* 3.0))
    cn2=Nof(Sphere(a_M,H//$sm a_//s* 3.0))
    if(cn2==0)then
     if(cn1>3)i_fe=i_fe+1
    else
     if((cn1+cn2)>3 & cn2<4)i_fe=i_fe+1
    endif
   endif
   if(nm=="Zn" & cn>3)i_zn=i_zn+1
   if(nm=="Ca" & cn>3)i_ca=i_ca+1
   if(nm=="Cd" & cn>3)i_cd=i_cd+1
  endfor
  r_gMet=(1.0*(i_fe+i_zn+i_ca+i_cd))/nr
  show surface volume a_ mute
  r_vol=r_out/nr
  r_mass=Mass(a_)
  set term "sf,en"
  show area surface mute
  r_sasa0=Sum(Area(a_A/*))
  r_sasa=Sum(Area(a_A/*))/nr
  r_sphere=1./nr
# polar surface
  r2=Sum(Area(a_//n* & ! a_//C231,C232))+Sum(Area(a_//C62,C63))+Sum(Area(a_//C81,C84,C85))
# charged
  r3=Sum(Area(a_//C231))+Sum(Area(a_//C232))+Sum(Area(a_//C71))
  r_saPolar=r2/r_sasa0
  r_saChar=r3/r_sasa0
#
  show energy "en"
  etmp=Energy("en")
  assign sstructure a_
  make sequence
  i_h= Nof(String(Sstructure(a_ )) "H")
  i_e= Nof(String(Sstructure(a_ )) "E")
  r_ss=(1.*(i_h+i_e))/nr
  kx=1
  if(Nof(a_//oxt)!=0)then
   kl=Nof(a_$kx/*)
   as_oo=(a_$kx/*)[kl] & a_//c,o,oxt
   print "Test C-term"
   as_oo
   if(Nof(a_*)>1)then
    for ik=2,Nof(a_*)
     kl=Nof(a_$ik/*)
     print "Chain" ik
     (a_$ik/*/c,o,oxt)[kl]
     as_oo=as_oo | ((a_$ik/*)[kl] & a_//c,o,oxt)
    endfor
   endif
   print "Final"
   as_oo
   show energy "el" a_A/arg,lys,nh3+ (a_A/glu,asp,coo- | as_oo)
  else
   show energy "el" (a_A/arg,lys,nh3+) (a_A/glu,asp,coo-)
  endif
  r_el=Energy("el")/nr
#
  s=String(Sstructure(a_ ))
  s1=String(Sequence(a_))
  k=0
  for i=1,Length(s)
   if(s[i]=="_" & s1[i]=="P")k=k+1
  endfor
  r_proL=(1.*k)/nr
  ent180=0.0
  satmp=0.0
#  print "Test a 2"
#  a_*
  r_s1U=0.
  r_s2U=0.
  r_s3U=0.
  for ik=1,Nof( a_*)
   if(Nof(a_$ik & a_A)>0)then
    copyMol a_$ik Name("chn" object )
    set object a_chn.
#    print "Test chain " ik
#    a_*
    set v_//phi,psi 180.
    show energy "en"
    ent180=ent180+Energy("en")
#    print "Entropy" etmp ent180
    show area surface
    satmp=satmp+Sum(Area(a_A/*))
# N neutral
    r_s2U=r_s2U+Sum(Area(a_//n* & ! a_//C231,C232))+Sum(Area(a_//C62,C63))+Sum(Area(a_//C81,C84,C85))
    delete a_chn.
   endif
  endfor
  tmpBur=r_sasa0-satmp
  r_saBur=(r_sasa0-satmp)/nr
#  r_saPolarBurried=(r_s2U-r2)/r_sasa0
   r_saPolarBurried=(r_s2U-r2)/tmpBur
  r_ent=(etmp-ent180)/nr
#  ds as_ ribbon
  cool
#
# calculate Tm
  if(s_Tenv=="" & s_Host=="")then
# 1 SAburried; 2 sphere; 3 entropy; 4 metC_cysF; 5 SA; 6 bondCys; 7 SA_char; 8 charge; 9 el; 10 Asn; 11 Lys; 12 ProL; 13 SA_polar; 14 secStr; 15 nRes; 16 His; 17 SA_polarBurried; 18 Ser; 19 Cys
    Tm=R_w[1]*r_saBur + R_w[2]*r_sphere + R_w[3]*r_ent + R_w[4]*(r_gMet + r_cysBfe) + R_w[5]*r_sasa + R_w[6]*r_cysB + R_w[7]*r_saChar + R_w[8]*r_q + R_w[9]*r_el + R_w[10]*r_asn + R_w[11]*r_lys + R_w[12]*r_proL + R_w[13]*r_saPolar + R_w[14]*r_ss + R_w[15]*nr + R_w[16]*r_his + R_w[17]*r_saPolarBurried + R_w[18]*r_ser + R_w[19]*r_cys
    Tm=Tm+z
  else
# Tenv included
# 1 SAburried; 2 sphere; 3 metC_cysF; 4 bondCys; 5 entropy; 6 SA; 7 charge; 8 secStr; 9 ProL; 10 SA_char; 11 SA_polar; 12 el; 13 Lys; 14 Ser; 15 Asn; 16 SA_polarBurried; 17 His; 18 nRes; 19 Cys
   Tm=R_w[1]*r_saBur + R_w[2]*r_sphere + R_w[3]*(r_gMet + r_cysBfe) + R_w[4]*r_cysB + R_w[5]*r_ent + R_w[6]*r_sasa + R_w[7]*r_q + R_w[8]*r_ss + R_w[9]*r_proL + R_w[10]*r_saChar + R_w[11]*r_saPolar + R_w[12]*r_el + R_w[13]*r_lys + R_w[14]*r_ser + R_w[15]*r_asn + R_w[16]*r_saPolarBurried + R_w[17]*r_his + R_w[18]*nr + R_w[19]*r_cys
   Tm = Tm + w_Tenv*Toreal(s_Tenv) + z
  endif
#
#  delete a_
  print " Info>  Melting temperature is " Tm "deg."
  sprintf "Melting temperature is %.2f deg. C", Tm
endmacro
#
# identify reactive Cys
macro reactiveCys as_ (a_A) l_allChains (no)
  l_commands = no
  l_info = no
  l_display=no
  LIBRARY.res = {"icmff"}
  read library
  electroMethod = "distance dependent"
  dielConst = 2.
  set term only "bb,vw,14,hb,el,to,cn,sf,en"
  ncys=Nof(Res(as_) & a_./cys,cyss)
  scys=String(Res(as_) & a_./cys,cyss number)
  nT=Index(scys ".")
  s1=scys[1:$nT]
  s_res=Replace(scys s1 "")
#
  nameProt=Name(a_)
  copyMol Mol( as_ ) Name("tmp" object )
  set object a_tmp.
  randomize a_// 0.001
  delete a_W,M,N
  set comment a_//Aa " "
  delete a_//A
  stmp=Sum(Name(Mol(as_)) ",")
  if(l_allChains==no)delete a_ & !a_$stmp
  if(Type(a_ 2)!="ICM")then
   convertObject a_ 1==1 yes no yes no yes no
  endif
  icmPocketFinder a_!H,W 4.6 no no
  set term "sf,en"
  S_chain=Sarray(ncys)
  I_cys=Iarray(ncys)
  R_areaSC=Rarray(ncys)
  R_areaP=Rarray(ncys)
  R_nplus=Rarray(ncys 999.0)
  R_hip=Rarray(ncys)
  R_esp=Rarray(ncys)
  R_hbondBB=Rarray(ncys)
  R_hbondSC=Rarray(ncys)
  R_dist=Rarray(ncys)
  S_name=Sarray(ncys)
  S_mol=Split(s_res "|")
#  print "M" S_mol
  ijk=1
  for i=1,Nof(S_mol)
   s_chain=Split(S_mol[i] "/")[1]
   s2=Split(S_mol[i] "/")[2]
   S_x=Split(s2 ",")
#   print "S_x" S_x
   for j2=1,Nof(S_x)
    S_x1=Split(S_x[j2] ":")
#    print "S_x1" S_x1
    if(Nof(S_x1)>1)then
     ix=Length(S_x1[1])
#     nf=Integer((S_x1[1])[3:Length(S_x1[1])])
     nf=Integer(S_x1[1])
     nl=Integer(S_x1[2])
#     print "NF" nf nl
    else
     nf=Integer(S_x1[1])
     nl=Integer(S_x1[1])
    endif
#    print "NF,NL" nf nl
    m=1
    for j3=nf,nl
#     print "RES" j3
     I_cys[ijk]=j3
     show area surface vwExpand=0.8 a_ a_ & ! a_$s_chain/$j3/hg,hb* mute
     S_chain[ijk]=s_chain
     R_areaSC[ijk]=Sum(Area(a_$s_chain/$j3/sg,cb))
     print "NAME" Name( a_$s_chain/$j3 full ) Name( a_$s_chain/$j3 full )[1]
     snm=Name( a_$s_chain/$j3 full )[1]
     S_name[ijk]=Split(snm ".")[2]
#
     if(Nof(Sphere(a_$s_chain/$j3/sg,cb a_//C215,C231,C232 500.))!=0)R_nplus[ijk]=Min(Distance(a_$s_chain/$j3/sg,cb a_//C215,C231,C232 all))
     if(Nof(Sphere(a_$s_chain/$j3/sg,cb a_/hi*/!ca,cb,c,o,n,h* 500.))!=0)R_hip[ijk]=Min(Distance(a_$s_chain/$j3/sg,cb a_/hi*/!ca,cb,c,o,n,h* all))
     show hbond exact a_$s_chain/$j3/sg a_//n,hn,c,o 3.5 ffMethod="ecepp"
     R_hbondBB[ijk]=Sum(Field(a_//*))
     show hbond exact a_$s_chain/$j3/sg a_//!n,hn,c,o 3.5 ffMethod="ecepp"
     R_hbondSC[ijk]=Sum(Field(a_//*))
     as_q=Res(Sphere(a_$s_chain/$j3/sg,cb a_A//C62,C63,C71,C215,C231,C232,C252 & !a_$s_chain/$j3/* 15.))
     make boundary # was: as_q ; wrong
     R_esp[ijk]=Potential(a_$s_chain/$j3/sg as_q )
#     S_name[ijk]=nameProt
     if(ijk==1)OBJECTS=Parray(object a_)
     if(ijk!=1)OBJECTS//=Parray(object a_)
     for ip = 1, Nof(POCKETS)
      jp = POCKETS.i[ip]
      s_temp = "g_pocket_tmp_1"+String(jp)
      if ( Type( $s_temp ) != "grob" ) continue
#     print "POCKET" Nof(Sphere($s_temp a_$s_chain/$j3/!ca,c,o,n,h* 2.0)) Nof(Sphere($s_temp a_$s_chain/$j3/!ca,c,o,n,h* 2.5))
#      if(Nof(Sphere($s_temp a_$s_chain/$j3/!ca,c,o,n,h* 2.5))!=0)then
      if(Nof(Sphere($s_temp a_$s_chain/$j3/cb,sg* 3.0))!=0)then
       print "Pocket " ip "residue" j3
       R_areaP[ijk]=POCKETS.Area[ip]
      endif
     endfor
     vwExpand=0.8
     M_surf=Matrix(Xyz( a_ 1. surface ))
     R_cysX=Xyz(a_$s_chain/$j3/sg)[1]
     rmin=10000.
     for js=1,Nof(M_surf)
      rr=Sqrt((M_surf[js,1]-R_cysX[1])*(M_surf[js,1]-R_cysX[1])+(M_surf[js,2]-R_cysX[2])*(M_surf[js,2]-R_cysX[2])+(M_surf[js,3]-R_cysX[3])*(M_surf[js,3]-R_cysX[3]))
      if(rr<rmin)rmin=rr
     endfor
#     print "Rmin" rmin
     R_dist[ijk]=rmin-2.5999
     ijk=ijk+1
     m=m+1
    endfor
   endfor
  endfor
  delete a_tmp.
  delete POCKETS
  group table allCys S_name "residue" R_dist "distToSurface" R_areaSC "saSC" R_areaP "pocketArea25" R_nplus "nearNplus" R_hip "nearHip" R_esp "esp1" R_hbondBB "hbondBB" OBJECTS "obj"
  set format allCys.nearHip "%.2f"
  set format allCys.nearNplus "%.2f"
  set format allCys.distToSurface "%.2f"
  set format allCys.saSC "%.2f"
  read binary s_icmhome + "models/reactiveCys.icb"
  predict label1pred allCys key
  rm allCys.label1pred
  rename allCys.label1predv "score"
  sort allCys.score
  move allCys.score 4
  set format allCys.score "%.2f"
#  set format allCys.score "%.2f" name="" color="rainbow='#FFFFFF/#FFFFFF/#FF5500,0.30:1.,pinwheel'"
  set format allCys.score color=" _ <0.52 ? '#ffffff' : _ <=1.0 ? '#ff5500' : ''"
  rcut=0.52
  S_active=Sarray(Nof(allCys))
  for i=1,Nof(allCys)
   if(allCys.score[i]>=rcut)S_active[i]="reactive"
  endfor
  add column allCys S_active name="reactivity"
  set format allCys.obj show off
  add header name="doubleClick" allCys """
  load object %@.obj [%#] name='cysreact_tmp' delete
  undisplay a_*.
  display a_ ribbon
  display a_H stick
  display a_$%@.residue[%#] & a_*.//c* xstick cyan
  display a_$%@.residue[%#] xstick
  display residue label a_$%@.residue[%#]
  display a_$%@.residue[%#] xstick
  display Res(Sphere( a_$%@.residue[%#] a_ 3.)) wire
  center a_$%@.residue[%#] margin=7.
  """
  keep allCys
endmacro

# compute water displacement energy upon ligand binding (aquaSites)
macro waterDisplacement as_ligand s_tabName ("AQUASITES") r_distCutoff (1.9)
  l_commands = no
  l_info = no
 if (Nof(as_ligand)==0) return error "No template selected"
 s_oldObj = Name( a_ )[1]
 set object Obj( as_ligand )
 s_mol = Name(Mol(as_ligand))[1]
 nw_g=Nof($s_tabName)
 nat_H=Nof(a_.$s_mol//!vt*,C10:31)
 S_ligN=Sarray(nat_H)
 S_ligN=Name(a_.$s_mol//!vt*,C10:31)
 R_lig=Rarray(nw_g)
 for i=1,nw_g
  R_in=Rarray($nat_H)
  R_1= $s_tabName.Xo [i]// $s_tabName.Yo [i]// $s_tabName.Zo [i]
  for j=1,$nat_H
   snm=S_ligN[j]
   R_2=Xyz(a_.$s_mol//$snm)[1]
   R_in[j]=Distance(R_1 R_2)
  endfor
  R_lig[i]=Min(R_in)
 endfor
 Gdispl=0.0
 for j=1,nw_g
  r_d=0.
  if(R_lig[j]<=r_distCutoff)r_d=1.0
  Gdispl=Gdispl+( $s_tabName.deltaG [j])*r_d*Trim(2.*(1.-R_lig[j]/r_distCutoff) 0. 1. )
 endfor
 set object a_$s_oldObj.
 add column $s_tabName R_lig name="Rlig" append
 print "Water displacement energy upon ligand binding" Gdispl
 keep Gdispl
endmacro
#
macro calcQMpocketBG as_ligand r_cutoff (5.) l_cleanup (no) l_dontrun (yes) s_gamessPath ("qsub -cwd /usr/local/bin/gms")
  l_commands = no
  l_info = no
  if (Nof(as_ligand)==0) return error "No ligand selected"
  s_obj = Name(Obj(as_ligand))[1]
  s_lig = Name(Mol(as_ligand))[1]
  rCutoff=r_cutoff
  set object Obj(as_ligand)
  copy a_ "copy"
  set object a_copy.
#  findSymNeighbors Res(Sphere(a_/$s_lig a_A 7.0))  & ( Obj(  a_*. )[1] ) 7.0 no 2 no no
  delete a_//A &! a_//Aa
  if(l_cleanup) convertObject a_ no yes no no yes no no ""
  if(Type( a_ object )=="ICM") strip
  s_objna = Name(Name(s_obj+"_trimmed" simple),object)
  rename a_ $s_objna
  delete a_//vt*
  if(l_cleanup) delete a_//h* & !a_//P
  delete a_* & !Res(Sphere(a_$s_lig//!h* a_A//n*,c*,o*,s* rCutoff)) & !a_$s_lig & !Mol(Sphere(a_$s_lig//!h* a_W//o* | a_M rCutoff))
  natom=6
  S_atoms={"n","o","c","ca","cb","cg*"}
  nres=Nof(a_A/*)
  I_res=Iarray(nres)
  S_ch=Sarray(nres)
  S_res=Name(a_A/*)
  for i=1,nres
   I_res[i]=Iarray(Res(a_A/*)[i] number)[1]
   S_ch[i]=Field(Field(String(Res(a_A/*)[i]) 2 ".") 1 "/")
  endfor
  for i=1,nres
   ires=I_res[i]
   R_dist=Rarray(natom)
   rmin=1000.0
   ch=S_ch[i]
   for j=1,natom
    sname=S_atoms[j]
    if(Nof(a_$ch/$ires/$sname)!=0)R_dist[j]=Distance(Xyz(a_$ch/$ires/$sname) Xyz(a_H//!vt*,h*) minimize)
   endfor
   if(S_res[i]=="ser" & Nof(a_$ch/$ires/og1)!=0)R_dist[6]=Distance(Xyz(a_$ch/$ires/og) Xyz(a_H//!vt*,h*) minimize)
   if(S_res[i]=="cys" & Nof(a_$ch/$ires/sg)!=0)R_dist[6]=Distance(Xyz(a_$ch/$ires/sg) Xyz(a_H//!vt*,h*) minimize)
   nsw=0
   if($i!=1 & $i!=nres)then
    if(I_res[$i-1]==(I_res[i]-1) & I_res[i+1]==(I_res[i]+1))nsw=1
   endif
   if(R_dist[5]>R_dist[4] & R_dist[6]>R_dist[4])then         # sc pointing outside
    if(R_dist[1]>=rCutoff & R_dist[2]>=rCutoff & R_dist[4]>=rCutoff)then
     if(nsw==1)then
      delete a_$ch/$ires/!ca,c,o,n,cb
     else
      delete a_$ch/$ires
     endif
    else
     if(R_dist[6]>R_dist[5])delete a_$ch/$ires/!ca,c,o,n,cb
    endif
   else             # sc pointing inside
    if(R_dist[1]>=$rCutoff & R_dist[2]>=$rCutoff & R_dist[4]>=$rCutoff & nsw==0)then
     delete a_$ch/$ires/o,n,c,hn
     if(S_res[i]=="arg" | S_res[i]=="lys")then
      for j=4,natom
       sname=S_atoms[j]
       if(R_dist[j]>=$rCutoff)then
        delete Next(a_$ch/$ires/$sname tree) & a_//h*
        delete a_$ch/$ires/$sname
       endif
      endfor
     endif
     if(S_res[i]=="gln" | S_res[i]=="glu" | S_res[i]=="met")then
      for j=4,natom-1
       sname=S_atoms[j]
       if(R_dist[j]>=$rCutoff)then
        delete Next(a_$ch/$ires/$sname tree) & a_//h*
        delete a_$ch/$ires/$sname
       endif
      endfor
     endif
     if(S_res[i]=="trp" | S_res[i]=="tyr" | S_res[i]=="phe" )then
      sname=S_atoms[4]
      if(R_dist[4]>=$rCutoff)then
       delete Next(a_$ch/$ires/$sname tree) & a_//h*
       delete a_$ch/$ires/$sname
      endif
     endif
    endif
   endif
   if(Nof(Atom(a_$ch/$ires/!h*))<3 | Distance(Xyz(a_$ch/$ires/!vt*,!h) Xyz(a_H//!vt*,h*) minimize)>$rCutoff)delete Res(a_$ch/$ires)
  endfor
  build hydrogen
  display a_
#  s_cmd = "cd " + s_tempDir
  s_cmd = ""
  fname_in  =  s_tempDir + s_obj+"_trimmed"
  fname_in1  =  Name( fname_in )+".inp"
#  fname_out1 = s_tempDir + Name( fname_in ) + ".log"
  fname_out1 = Name( fname_in ) + ".log"
  fname_dat = s_tempDir + Name( fname_in ) + ".dat"
  write gamess cartesian fix=a_!H  a_* fname_in1
  delete system s_tempDir + Name( fname_in ) + ".dat"
#  s_cmd = s_cmd + ";" + Sum( s_gamessPath // Name(fname_in1) // "-l" // fname_out1 )
  s_cmd = Sum( s_gamessPath // Name(fname_in1) // "-l" // fname_out1 )
  print " Run this from UNIX command line:\n"
  print Replace( s_cmd ";" "\n" )
#
  s_finishQM = ""
  s_finishQM = s_finishQM + "read sys grep \"TERMINATED NORMALLY\" " + fname_out1 + "\n"
  s_finishQM = s_finishQM + "if(s_out!=\"\")then\n"
  s_finishQM = s_finishQM + "  read gamess \"" + fname_out1  + "\" name=\"XYZ\"\n"
  s_finishQM = s_finishQM + "  print \"QM_minimized_Energy =\", r_out\n"
  s_finishQM = s_finishQM + "  set object  a_." + s_objna +  "\n"
  s_finishQM = s_finishQM + "  set a_// XYZ"
# s_finishQM = s_finishQM + "  delete system \"" + fname_in1 + "\" \"" + fname_dat + "\" \"" + fname_out1 + "\"\n"
  s_finishQM = s_finishQM + "  delete system \"" + fname_dat + "\"\n"
  s_finishQM = s_finishQM + "else\n"
  s_finishQM = s_finishQM + "  print \" Error> QM calculations failed " + "\"\n"
  s_finishQM = s_finishQM + "endif\n"
  set property command s_finishQM
  keep s_finishQM
  print "\n After the jobs are finished, execute the s_finishQM script to load results"
  writeProject s_obj+"_trimmed"
endmacro
#
macro align2chemAPF as_mol1 as_mol2 l_static_m1 (no) l_rigid_m2 (no) l_super (no) r_thoroughness
  l_commands = no
  l_info = no
  l_minRedraw=no
  GRAPHICS.l_redraw=no
  if(Nof(pmf)==0)read pmf s_icmhome+"APF"
#
  if(l_super)l_static_m1 = yes
  if(l_super)l_rigid_m2  = yes
  if(l_rigid_m2) l_static_m1 = yes
#
  as_mol1 = Mol( as_mol1 )
  if(Nof(as_mol1)!=1)then
    return error "first selection should contain a single chemical"
  endif
  as_mol2 = Mol( as_mol2 )
  if(Nof(as_mol2)!=1)then
    return error "second selection should contain a single chemical"
  endif
  copyMol as_mol1 "align_" + Name(Obj(as_mol1))[1] + "_" + Name(Obj(as_mol2))[1]
  iob = Nof( a_. )
  set object a_$iob.
  if(Type( a_ 2)!="ICM")then
    build hydrogen
    set type mmff
    convert
    minimize "to" v_//T11,T16
    delete a_$iob.
    rename a_ "align_" + Name(Obj(as_mol1))[1] + "_" +  Name(Obj(as_mol2))[1]
  endif
  copyMol as_mol2 "tmpchem2"
  if(Type( a_tmpchem2. 2)!="ICM")then
    set object a_tmpchem2.
    build hydrogen
    set type mmff
    convert
    minimize "to" v_//T11,T16
    delete a_tmpchem2.
    rename a_ "tmpchem2"
    set object a_$iob.
  endif
  l_fix2vt = (Nof( v_tmpchem2.//?vt* )==0) # special case for r group alignement
  if(!l_fix2vt) translate a_tmpchem2. Mean(Xyz(a_))
  move a_tmpchem2. a_
  if(l_fix2vt) fix v_2//?vt*
#
  if(Nof(v_2//?vt*)==6)then
    b = Eigen(Tensor(Xyz(a_2//!vt*)))
    c = Mean( Xyz( a_2//!vt* ) )
    v = Value( v_2//* )
    delete stack
    store conf
    rotate a_2 Rot( b[?,2] / Length(  b[?,2] ) 180. )
    translate a_2 c
    store conf
    set v_2 v
    rotate a_2 Rot( b[?,1] / Length(  b[?,1] ) 90. )
    translate a_2 c
    store conf
    rotate a_2 Rot( b[?,1] / Length(  b[?,1] ) 180. )
    translate a_2 c
    store conf
    rotate a_2 Rot( b[?,1] / Length(  b[?,1] ),-90. )
    translate a_2 c
    store conf
    rotate a_2 Rot( b[?,2] / Length(  b[?,2] ) 180. )
    translate a_2 c
    store conf
    rotate a_2 Rot( b[?,2] / Length(  b[?,2] ) 90. )
    translate a_2 c
    store conf
    rotate a_2 Rot( b[?,2] / Length(  b[?,2] ) 180. )
    translate a_2 c
    store conf
  else
    store conf
  endif
#
  mybox = Box( a_ 5. )
  make map potential "gc" a_.//vt1 mybox
  GRID.gcghExteriorPenalty = 1
  GRID.maxVw = 10.
#
  vwMethod="soft"
  vwSoftMaxEnergy= 5.
  set term only "vw,14,hb,to,gc,mf"
  if(Nof( v_//r* )>0) set term "bb,bs,af"
  mnvisits=5
  visitsAction = "stackjump"
#  visitsAction = "heat"
#
  compare static a_//!h*,vt*
  vicinity = 2.
#  set symmetry exact
#
  temperature=2000.
  autoSavePeriod = 0
  mcShake=5.
  l_intraMolVW=yes
#
  s_chiral = ""
  mcvar = v_2//?vt*                    # at least position/rotation of the second mol
  if(!l_rigid_m2) mcvar = v_2          # flexible second molecule
  if(!l_static_m1) mcvar = mcvar | v_1//!?vt*  # flexible first mol too

  if(Nof(mcvar)>0)then
    mncallsMC= 10000 + Integer(r_thoroughness*Power(Nof( mcvar & v_//!M,T3 ) 4))
    print mncallsMC
    minimize stack mcvar
    load conf 0
    montecarlo reverse append mcvar mute s_chiral
    load conf 0
  endif
  if(!l_static_m1)then
    vicinity = 0.5*vicinity
    compareMethod = "chemical superimposed"
    compress stack l_info = yes
  endif
#  compareMethod = "chemical static"
#  compress stack l_info = yes
  store stack a_
  if(l_super)then
    superimpose a_2 as_mol2
    delete a_
  endif
  GRAPHICS.l_redraw=yes
  display new
#
endmacro
# statistics

macro tTest R_sample1 R_sample2 r_mu0 (0.0) r_confidence (0.05) s_tail ("2sided") l_paired (no) l_varEqual (yes) auto
# 1 t-test for a population mean (variance unknown) if Nof(R_data2)==0 and r_mu0 is provided
# 2 t-test for two population means (variances unknown but equal)
# 3 t-test for two population means (variances unknown and unequal)
# 4 t-test for two population means (paired comparrisons)

HELP="""
  Arguments:
  R_sample1                non-empty numeric vector of data value
  R_sample2                optional numeric vector of data value, If not provided: test for R_sample1 population mean
  r_mu0          (0.0)     true value of the mean (or difference in means between two samples)
  r_confidence   (0.05)    significance level
  s_tail         ("2sided") string specifying alternative hypothesis ("2sided","less", or "greater")
  l_paired       (no)      logical indicating whether the t-test is paired or not
  l_varEqual     (yes)     logical parameter indicating whether to treat variances of two distributions as being equal
  Result:
  R_out                    R_out[1] - tp; R_out[2:3] - confidence interval; R_out[4] - p-value
"""

 l_commands = no ; l_info=no ; l_show_results = no
 if (Nof(R_sample1) == 0 ) return error " Sample distribution is not provided"
 if (l_paired==yes & Nof(R_sample1)!=Nof(R_sample2) ) return error "Sizes of two datasets for paired test are not equal"
 if(r_confidence > 1. | r_confidence <0.)quit "Error> confidence level is out of [0.-1.] range"
 if(s_tail=="2sided")r_confidence = r_confidence/2.

# R_out[1] - tp; R_out[2] - lower confidence interval; R_out[3] - upper confidence interval; R_out[4] - p-value
R_out=Rarray(4)
#
n1 = Nof(R_sample1)
n2 = Nof(R_sample2)
if(n2==0)then
# t-test 1
 r_mean = Mean(R_sample1)
 s = Sum(Power((R_sample1-r_mean),2))
 sp = Sqrt(s/(n1-1))
 tt = (r_mean - r_mu0)/(sp/Sqrt(n1))
 nu = n1-1
 x1=Sqrt(nu)
else
 r_mean1 = Mean(R_sample1)
 r_mean2 = Mean(R_sample2)
 if(l_paired==no)then
# t-tests 2 and 3
  s21 = Sum((R_sample1 - r_mean1)*(R_sample1 - r_mean1))/(n1-1)
  s22 = Sum((R_sample2 - r_mean2)*(R_sample2 - r_mean2))/(n2-1)
  x = (r_mean1 - r_mean2) - r_mu0
  if(l_varEqual)then
# t-test 2
   s2 = ((n1-1)*s21 + (n2-1)*s22)/(n1+n2-2)
   x1 = Sqrt(1./n1+1./n2)
   x2 = Sqrt(s2)*x1
   sp = Sqrt(s2)
   nu = n1 + n2 -2
   tt = x/x2
  else
# t-test 3
   ttt = s21/n1+s22/n2
   x1 = Sqrt(ttt)
   nu = ttt*ttt
   x2 = (s21/n1)*(s21/n1)/(n1-1) + (s22/n2)*(s22/n2)/(n2-1)
   sp=1.
   nu = Integer(nu/x2)
   tt = x/x1
  endif
 else
# t-test 4
  R_diff = R_sample1 - R_sample2
  dMean = Mean(R_sample1 - R_sample2)
  r_mean1 = Mean(R_sample1)
  r_mean2 = Mean(R_sample2)
  nu = n1 - 1
  x1=Sqrt(n1)
  sp=Sqrt(Sum((R_diff-dMean)*(R_diff-dMean))/nu)
  tt = dMean*x1/sp
 endif
endif
R_out[1] = tt
#
#compute p-value from a t-distribution
 if(s_tail=="2sided")pValue = calcPValue(R_out[1],nu)[1]
 if(s_tail=="less")pValue = calcPValue(R_out[1],nu)[2]
 if(s_tail=="greater")pValue = calcPValue(R_out[1],nu)[3]
 R_out[4]=pValue
 tp = calcTp(r_confidence,nu)
# calculate confidence interval (CI)
 if(s_tail=="less")then
  tp1 = calcTp((1.-r_confidence),nu)
  if(n2!=0)then
   if(!l_paired)then
    R_out[2] = r_mean1 - r_mean2 + sp*x1*tp1
   else
    R_out[2] = dMean + sp*tp1/x1
   endif
  else
   R_out[2] = r_mean + sp*tp1/x1
  endif
 endif
 if(s_tail=="greater")then
  tp1 = calcTp((1.-r_confidence),nu)
  if(n2!=0)then
   if(!l_paired)then
    R_out[2] = r_mean1 - r_mean2 - sp*x1*tp
   else
    R_out[2] = dMean - sp*tp1/x1
   endif
  else
   R_out[2] = r_mean - sp*tp1/x1
  endif
 endif
 if(s_tail=="2sided")then
  if(n2!=0)then
   if(!l_paired)then
    R_out[2] = r_mean1 - r_mean2 - sp*tp*x1
    R_out[3] = r_mean1 - r_mean2 + sp*tp*x1
   else
    R_out[2] = dMean - sp*tp/x1
    R_out[3] = dMean + sp*tp/x1
   endif
  else
   print "TT" sp tp x1
   R_out[2] = r_mean - sp*tp/x1
   R_out[3] = r_mean + sp*tp/x1
  endif
 endif
#
 if(n2==0)print "Mean and std %f8.2 %f8.2" r_mean sp
 if(n1!=0 & n2!=0 & l_paired==no)printf "Mean and std: Sample 1  %8.2f %6.2f    Sample 2  %8.2f  %6.2f\n" r_mean1 Sqrt(s21) r_mean2 Sqrt(s22)
 if(l_paired==yes)printf "Mean and std:  %8.2f %6.2f\n" dMean sp
 if(s_tail=="2sided")then
  printf "t0 = %6.2f for p = %5.2f and df = %6d\n" R_out[1] r_confidence*2. Integer(nu)
  printf "95 percent confidence interval: [%5.2f , %5.2f]  p-value = %6.4f\n" R_out[2] R_out[3] pValue
 endif
 if(s_tail=="less")then
  printf "t0 = %6.2f for p = %4.2f and df = %6d\n" R_out[1] r_confidence nu
  printf "95 percent confidence interval: <%5.2f  p-value = %6.4f\n" R_out[2] pValue
 endif
 if(s_tail=="greater")then
  printf "t0 = %6.2f for p = %4.2f and nu = %36\n" R_out[1] r_confidence nu
  printf "95 percent confidence interval: >%5.2f  p-value = %6.4f\n" R_out[2] pValue
 endif
 if(pValue>r_confidence)then
   print "Accept null hypotesis: Abs(mu1-mu2)=0"
 else
   print "Reject null hypotesis: Abs(mu1-mu2)=0"
 endif
 keep R_out
endmacro

function calcPValue r_tp i_nu
# compute p-value from a t-distribution
# i_nu is n1+n2-2 degrees of freedom
# (Eqs. 26.7.3 and 26.7.4 from "Handbook of Mathemtical Functions" by Abramowitz & Stegun 1972)
 theta=Atan(r_tp/Sqrt(1.0*i_nu))
 thetaRadians=theta*Pi/180.
 cosTheta=Cos(theta)
 sinTheta=Sin(theta)
 xodd=i_nu-2*(i_nu/2)
 if(i_nu==1)r_a = 2.*thetaRadians/Pi
 sum_cosine=0.0
 if(i_nu>1 & xodd!=0)then
  k=(i_nu-1)/2
  for i=1,k
   kp=i*2-1
   tmp = Power(cosTheta,kp)
   for j = 3,kp,2
    in1 = j - 1
    in2 = j
    tmp = in1*tmp/in2
   endfor
   sum_cosine = sum_cosine + tmp
  endfor
  r_a = (thetaRadians + sinTheta*sum_cosine)*2./Pi
 elseif(i_nu>1 & xodd==0)then
  k = i_nu/2
  for i = 1,k
   kp = (i-1)*2
   tmp = Power(cosTheta,kp)
   if(i_nu>2)then
    for j = 2,kp,2
     in1 = j -1
     in2 = j
     tmp = in1*tmp/in2
    endfor
   endif
   sum_cosine = sum_cosine + tmp
  endfor
  r_a = sinTheta*sum_cosine
 endif
 R_pValue=Rarray(3)
# less
 R_pValue[1] = (1. - Abs(r_a))
 R_pValue[2] =(1. - Abs(r_a))/2.
 R_pValue[3] =(1. - r_a)/2.
# print "p value" r_tp i_nu r_a "Old" (1.-r_a)/2. "New" pValue
 return R_pValue
endfunction

function calcTp r_confidence i_nu
# compute critical values of a Student's t-distribution (Eqs. 26.7.5 and 26.2.23 from "Handbook of Mathemtical Functions" by Abramowitz & Stegun 1972)
#
 if(r_confidence>0.5)r_confidence = 1. - r_confidence
 t=Sqrt(Log(1./(r_confidence*r_confidence)))
# epsilon(p)<4.5*Power(10.,-4)
 c0=2.515517
 c1=0.802853
 c2=0.010328
 d1=1.432788
 d2=0.189269
 d3=0.001308
#
 t2=t*t
 t3=t*t*t
 xtmp = (c0+c1*t+c2*t2)/(1+d1*t+d2*t2+d3*t3)
 if(r_confidence<0. & r_confidence<=0.5)then
  xp = (c0+c1*t+c2*t2)/(1+d1*t+d2*t2+d3*t3) - t
 else
  xp = t - (c0+c1*t+c2*t2)/(1+d1*t+d2*t2+d3*t3)
 endif
#
 xp2 = xp*xp
 xp3 = xp*xp*xp
 xp5 = xp3*xp2
 xp7 = xp5*xp2
 xp9 = xp7*xp2
#
 g1 = (xp3 + xp)/4.
 g2 = (5.*xp5 + 16.*xp3 + 3.*xp)/96.
 g3 = (3.*xp7 + 19.*xp5 + 17.*xp3 - 15.*xp)/384.
 g4 = (79.*xp9 + 776.*xp7 + 1482.*xp5 - 1920.*xp3 - 945.*xp)/92160.
 nu2 = i_nu*i_nu
 nu3 = nu2*i_nu
 nu4 = nu3*i_nu
 if(r_confidence<1. & r_confidence>=0.5)then
  tp = xp + g1/i_nu + g2/nu2 + g3/nu3 + g4/nu4
 else
  tp = - (xp + g1/i_nu + g2/nu2 + g3/nu3 + g4/nu4)
 endif
 tp = Abs(tp)
 return tp
# print "tp" r_confidence tp
endfunction

function CorrPval R_X R_Y
# p-value by Y-randomization
 l_info = no
 n = Nof(R_X)
 e=0
 ac = Abs(Corr(R_X R_Y))
 n1=1
 n2=1000
 for o = 1 3
   for i = n1 n2
     group table "Trand" Random(0. 1. n) "R" R_Y+0. "Y"
     sort Trand.R
     if(Abs(Corr(R_X Trand.Y))>=ac) e=e+1
   endfor
   if(e>100) break
   n1=n2+1
   n2=n2*10
 endfor
 p = Real(e)/n2
 if(e==0) p = Real( "<" + 1./n2 )
 return p
endfunction

function CorrConfInt R_X R_Y
# confidence interval by bootstrapping
 n = Nof(R_X)
 nsample=1000
 C =  Rarray(nsample)
 for i = 1 nsample
   ixR = Random(1 n n)
   X = R_X[ixR]
   Y = R_Y[ixR]
   if(Min(X)!=Max(X) | Min(Y)!=Max(Y))then
     C[i]=Corr(X Y)
   endif
 endfor
 sort C
 r05 = C[Integer(nsample*0.05)]
 r95= C[Integer(nsample*0.95)]
 printf "Correlation %f confidence interval [%4.3f : %4.3f]\n" Corr(R_X R_Y) r05 r95
 return r05 // r95
endfunction
#
function SimDict S_X S_Y
  S_out =  Unique(Sort(S_X))//Unique(Sort(S_Y))
  add column tmp_out Unique(S_out number)
  return 100.*Nof(tmp_out.A==2)/Real(Nof(tmp_out))
endfunction
#
#ifdef Chemistry

macro consensusPh4byAPF ms_ligands R_5thresholds ( { 0.75 0.75 0.75 0.5 0.5 } ) l_blobsOnly (yes) l_display (yes) l_occupancy (no)
  l_info = no
#  ms_ligands = Mol(ms_ligands)
  nlig = Nof(Mol(ms_ligands))
#
  if(Nof(R_5thresholds)!=5)then
    return error "provide 5 thresholds as a rarray"
  endif
#
  grStep = 0.5
  if(l_blobsOnly & l_display) grStep = 0.25
  mybox = Box( ms_ligands 3. )
  make map potential "gc" a_.//vt1 grStep mybox simple # empty box
  GRID.gpGaussianRadius = 1.2
  m_donor  =m_gc
  m_accept =m_gc
  m_sp2    =m_gc
  m_lipo   =m_gc
  m_charge =m_gc
  s_occ = ""
  if(l_occupancy)s_occ = "occupancy"
  wt = 3./(GRID.gpGaussianRadius*GRID.gpGaussianRadius*nlig)
  for i = 1 Nof( Obj(ms_ligands) )
    set object Obj(ms_ligands) [i]
    make map potential "gp" mybox ms_ligands & a_ grStep $s_occ
    m_donor = m_donor +wt*m_g1
    m_accept= m_accept+wt*m_g2
    m_sp2   = m_sp2   +wt*m_g3
    m_lipo  = m_lipo +wt*m_g4
    m_charge= m_charge+wt*m_g6
  endfor
  delete g_donor g_accept g_aroma g_lipo g_positive g_negative
  make grob solid  m_donor  exact R_5thresholds[1]
  make grob solid  m_accept exact R_5thresholds[2]
  make grob solid  m_charge exact R_5thresholds[3] name="g_positive"
  make grob solid  m_charge exact -R_5thresholds[3] name="g_negative"
  make grob solid  m_lipo * Trim( m_sp2 0. 1. ) exact R_5thresholds[4] name="g_aroma"
  make grob solid  m_lipo * (1.-Trim( m_sp2 0. 1. )) exact R_5thresholds[5] name="g_lipo"
#
#  l_commands=yes
#
  if(l_blobsOnly)then
    if(l_display)then
      color g_donor blue
      color g_accept red
      color g_aroma white
      color g_lipo yellow
      color g_positive lightblue
      color g_negative pink
      display g_donor g_accept g_aroma g_lipo g_positive g_negative transparent smooth
      print "Color key:\n Donor: blue\n Acceptor: red\n Aromatic: white\n Lipophyl: yellow\n Positive: lightblue\n Negative: pink"
    endif
    keep grob
    return
  endif
#
  if(Nof(a_pharma.)!=0)delete a_pharma.
# Extract donors
  nGr0 = Nof(grob)
  split grob g_donor
  nGr1 = Nof(grob)
  if(nGr0==nGr1)g_donor1=g_donor
  if(Nof(g_donor)!=0 & nGr0==nGr1) nGr1=nGr1+1
  for i = nGr0+1,nGr1
    mXYZ = Xyz( Next(Select( a_*.//h* grob[i]) bond))
    XYZ = Mean(mXYZ)
    xyz = Mean(Xyz( Select( a_*.//h* grob[i])))-XYZ
    xyz = xyz/Length(xyz)
    build string "se oh"
    rename a_//o1 "Qd"
    rename a_//ho "Qv"
    set a_//Qd Matrix(XYZ)
    set a_//Qv Matrix(XYZ+xyz)
    set type a_//Qd,Qv {316,322}
    for ir = 1 14
      if(Nof( Sphere( a_//Qd a_*.//n*,o* ir*0.1 )) >= nlig/2) break
    endfor
    set bfactor a_//Qd ir*0.1 # 2.*Rmsd(mXYZ -Transpose( Matrix( XYZ Rarray(Nof(mXYZ) 1.))))
    set bfactor a_//Qv 0.5
    display xstick blue
    if(Nof(a_pharma.)==0)rename a_ "pharma"
    if(Nof(a_pharma.)!=0)move a_  a_pharma.
  endfor
# Extract acceptors
  nGr0 = Nof(grob)
  split grob g_accept
  nGr1 = Nof(grob)
  if(nGr0==nGr1)g_accept1=g_accept
  if(Nof(g_accept)!=0 & nGr0==nGr1) nGr1=nGr1+1
  for i = nGr0+1,nGr1
    mXYZ = Xyz( Select( a_*.//o*,n* grob[i]))
    XYZ = Mean(mXYZ)
    xyz = XYZ-Mean(Xyz( Next(Select( a_*.//o*,n* grob[i]) bond)))
    xyz = xyz/Length(xyz)
    build string "se oh"
    rename a_//o1 "Qa"
    rename a_//ho "Qv"
    set a_//Qa Matrix(XYZ)
    set a_//Qv Matrix(XYZ+xyz)
    set type a_//Qa,Qv {315,322}
    for ir = 1,14
      if(Nof( Sphere( a_//Qa a_*.//n*,o* ir*0.1 )) >= nlig/2) break
    endfor
    set bfactor a_//Qa ir*0.1 # 2.*Rmsd(mXYZ -Transpose( Matrix( XYZ Rarray(Nof(mXYZ) 1.))))
    set bfactor a_//Qv 0.5
    display xstick red
    if(Nof(a_pharma.)==0)rename a_ "pharma"
    if(Nof(a_pharma.)!=0)move a_  a_pharma.
  endfor
# Extract positive
  nGr0 = Nof(grob)
  split grob g_positive
  nGr1 = Nof(grob)
  if(nGr0==nGr1)g_positive1=g_positive
  if(Nof(g_positive)!=0 & nGr0==nGr1) nGr1=nGr1+1
  for i = nGr0+1,nGr1
    mXYZ = Xyz( Select( a_*.//n* grob[i]))
    XYZ = Mean(mXYZ)
    build string "se o"
    rename a_//o "Qp"
    set a_//Qp Matrix(XYZ)
    set type a_//Qp 319
    for ir = 1,14
      if(Nof( Sphere( a_//Qp a_*.//n* ir*0.1 )) >= nlig/2) break
    endfor
    set bfactor a_//Qp ir*0.1 # 2.*Rmsd(mXYZ -Transpose( Matrix( XYZ Rarray(Nof(mXYZ) 1.))))
    display xstick cpk red
    if(Nof(a_pharma.)==0)rename a_ "pharma"
    if(Nof(a_pharma.)!=0)move a_  a_pharma.
  endfor
# Extract lipophylic
  nGr0 = Nof(grob)
  split grob g_lipo
  nGr1 = Nof(grob)
  if(nGr0==nGr1)g_lipo1=g_lipo
  if(Nof(g_lipo)!=0 & nGr0==nGr1) nGr1=nGr1+1
  for i = nGr0+1,nGr1
    mXYZ = Xyz(grob[i])
    XYZ = Mean(mXYZ)
    build string "se o"
    rename a_//o "Qh"
    set type a_//Qh 318
    set bfactor a_//Qh Rmsd(mXYZ -Transpose( Matrix( XYZ Rarray(Nof(mXYZ) 1.))))
    set a_//Qh Matrix(XYZ)
    display xstick cpk yellow
    if(Nof(a_pharma.)==0)rename a_ "pharma"
    if(Nof(a_pharma.)!=0)move a_  a_pharma.
  endfor
# Extract aromatic - clustering instead of split grob to get more distinct centers
  alias GT group table T Xyz( $1 ) [?,1] "X" Xyz( $1 ) [?,2] "Y" Xyz( $1 ) [?,3] "Z" Count(Nof( $1 )) "Order"
  GT g_aroma
  make tree T full "UPGMC" split="cl" name="tree" column={"X", "Y", "Z"} exact
  split T.cluster 2.*2.
  for i = 1, Max(T.cl)
    Ti = T.cl==i
    mXYZ = Transpose(Matrix( Ti.X // Ti.Y // Ti.Z Nof(Ti)))
    XYZ = Mean(mXYZ)
    delete Ti
    a=Tensor(mXYZ)
    b=Eigen(a)
    xyz = Vector( b[?,1], b[?,2] )
    xyz = xyz/Length(xyz)
    build string "se oh"
    rename a_//o1 "Qm"
    rename a_//ho "Qv"
    set a_//Qm Matrix(XYZ)
    set a_//Qv Matrix(XYZ+0.5*xyz)
    set type a_//Qm,Qv {317,322}
    set bfactor a_// Rmsd(mXYZ -Transpose( Matrix( XYZ Rarray(Nof(mXYZ) 1.))))
    display xstick gray
    if(Nof(a_pharma.)==0)rename a_ "pharma"
    if(Nof(a_pharma.)!=0)move a_  a_pharma.
  endfor
#
  strip a_pharma.
  delete a_pharma.//vt*
  set type a_pharma. "pharmaco"
  if(l_display)then
    display xstick a_pharma.
    display cpk a_pharma.//Qh
  endif
endmacro
#
macro makePocketPh4 ms_rec R_box
  l_info=yes; l_warn=no;
#
  set object Obj( ms_rec ) [1]
  N=5; print bar "Building surface" N l_info=yes

  print bar N
  make map potential "gc" simple Box( R_box 1.0 ) Res( a_ & Box( R_box 5.0 ) ) & ( a_//M5 | a_//!h* ) & ms_rec 0.35
  print bar N
  make grob solid m_gc exact 0.001 name="g_recPocketSurface"
  print bar N

  color g_recPocketSurface a_//H  & ms_rec green add GROB.atomSphereRadius= 1.5  # hydrophobe
  color g_recPocketSurface a_//R  & ms_rec green add GROB.atomSphereRadius= 1.45 # aromatic, maybe refined in the future, for now essentially the same as aliphatic
  color g_recPocketSurface a_//HA & ms_rec lightblue pseudo GROB.atomSphereRadius= 1.6+0.3 # acceptors
  color g_recPocketSurface a_//HA & ms_rec blue pseudo GROB.atomSphereRadius= 1.6
  color g_recPocketSurface a_//HD & ms_rec pink   add GROB.atomSphereRadius= 1.6 # donors
  color g_recPocketSurface a_//HD & ms_rec red   add GROB.atomSphereRadius= 1.6 - 0.3
  print bar "End\n" l_info=yes
  compress g_recPocketSurface 0.2
  g_recPocketSurface = Trim( g_recPocketSurface R_box )
  display g_recPocketSurface
  undisplay g_recPocketSurface
  keep g_recPocketSurface
# extract ph4ic patches
  gA = Grob( g_recPocketSurface { 0.6 1. 0. 0.6 0. 0.6 } )
  gD = Grob( g_recPocketSurface { 0. 0.6  0. 0.6 0.6 1. } )
  gL = Grob( g_recPocketSurface { 0. 0.6  0.6 1. 0. 0.6  } )
#  gR = Grob( g_recPocketSurface { 0.7 1.0 0.7 1. 0.7 1.0  } )
# remove small pieces
  split gA  4. join
  if(Type(gA1)=="unknown")gA1=gA
  split gD  4. join
  if(Type(gD1)=="unknown")gD1=gD
  split gL 8. join
  if(Type(gL1)=="unknown")gL1=gL
#  split gR 6. join
#  if(Type(gR1)=="unknown")gR1=gR
#
  alias GT group table T Xyz( $1 ) [?,1] "X" Xyz( $1 ) [?,2] "Y" Xyz( $1 ) [?,3] "Z" Count(Nof( $1 )) "Order" Iarray(Nof( $1 ) 1) "Count" Xyz( $1 gradient) [?,1] "x" Xyz( $1 gradient) [?,2] "y" Xyz( $1 gradient)[?,3] "z"
# ---- Hydrophobes -----
  GT gL1
  add header T Distance( Xyz( gL1 ) - 0.5*Xyz( gL1 gradient  )  )  name="dimt" # encourage large concavities by extending along normals
  make tree T full "UPGMC" split="cl" name="tree" distance="dimt"
  split T.cluster 1.5
  group T.cl T.X "mean,X"  T.Y "mean,Y"  T.Z "mean,Z"  T.Order "min,Order"  T.ord "min,ord"  T.Count "sum,Count"  T.x "mean,x"  T.y "mean,y"  T.z "mean,z"  name="TL"
  delete TL.Count < 100
  TL.cl = Iarray(Nof(TL) 1)
# ---- Aromatics using the same grob/table
  r2 = 1. - Abs(Rarray( ( Xyz( gL1 gradient)*Transpose(Xyz( gL1 gradient))) )) # non-planarity but allow opposition
  r2 = 100.*r2*r2*r2*r2
  rr = Rarray(Distance(Xyz( gL1 )))
  rr =rr*rr
  T.dimt  = Matrix( rr  + r2 Nof(gL1))  # cluster hydrophobic planes
  delete T.cl
  make tree T full "UPGMC" split="cl" name="tree" distance="dimt"
  split T.cluster 4.0*4.0
  group T.cl T.X "mean,X"  T.Y "mean,Y"  T.Z "mean,Z"  T.Order "min,Order"  T.ord "min,ord"  T.Count "sum,Count"  T.x "mean,x"  T.y "mean,y"  T.z "mean,z"  name="TR"
# redo mean normal without directionality
  for i = 1,Max(T.cl)
    k = Index(TR.cl == i)[1]
    TR.x[k] = 0. ; TR.y[k] = 0. ; TR.z[k] = 0.
    n = Nof(T.cl == i)
    for j = 1,n
      l = Index(T.cl == i)[j]
      if( TR.x[k] * T.x[l] + TR.y[k] * T.y[l] + TR.z[k] * T.z[l] >= 0) then
        TR.x[k] = TR.x[k] + T.x[l] ; TR.y[k] = TR.y[k] + T.y[l] ; TR.z[k] = TR.z[k] + T.z[l]
      else
        TR.x[k] = TR.x[k] - T.x[l] ; TR.y[k] = TR.y[k] - T.y[l] ; TR.z[k] = TR.z[k] - T.z[l]
      endif
    endfor
    TR.x[k] = TR.x[k]/n ; TR.y[k] = TR.y[k]/n ; TR.z[k] = TR.z[k]/n
  endfor
  delete T
#
  delete TR.Count < 200
  TR.cl = Iarray(Nof(TR) 2)
# ---- Acceptors -----
  GT gA1
  make tree T full "UPGMC" split="cl" name="tree" column={"X", "Y", "Z"} exact
  split T.cluster 1.4*1.4
  group T.cl T.X "mean,X"  T.Y "mean,Y"  T.Z "mean,Z"  T.Order "min,Order"  T.ord "min,ord"  T.Count "sum,Count"  T.x "mean,x"  T.y "mean,y"  T.z "mean,z"  name="TA"
  delete T
  TA.cl = Iarray(Nof(TA) 3)
# ---- Donors -----
  GT gD1
  make tree T full "UPGMC" split="cl" name="tree" column={"X", "Y", "Z"} exact
  split T.cluster 1.4*1.4
  group T.cl T.X "mean,X"  T.Y "mean,Y"  T.Z "mean,Z"  T.Order "min,Order"  T.ord "min,ord"  T.Count "sum,Count"  T.x "mean,x"  T.y "mean,y"  T.z "mean,z"  name="TD"
  delete T
  TD.cl = Iarray(Nof(TD) 4)
#
  keep TL TR TD TA
#
  group table ALL TL.X//TR.X//TA.X//TD.X "X" TL.Y//TR.Y//TA.Y//TD.Y "Y" TL.Z//TR.Z//TA.Z//TD.Z "Z" TL.x//TR.x//TA.x//TD.x "x" TL.y//TR.y//TA.y//TD.y "y" TL.z//TR.z//TA.z//TD.z "z" TL.cl//TR.cl//TA.cl//TD.cl "cl" TL.Count//TR.Count//TA.Count//TD.Count "Count"
# create Ph4 object
  build string Sum(Sarray(Nof(ALL),"ml ") + {"hphob","aroma","accept" "donor"}[ALL.cl] + Count(ALL.cl identity) + "\nse oh\n"  "")  name = "site_pharma"
  strip a_
  delete a_//vt*
  set a_//o*  Transpose( Matrix( ALL.X // ALL.Y // ALL.Z  Nof(ALL)) )
  set a_//h*  Transpose( Matrix( ALL.X // ALL.Y // ALL.Z  Nof(ALL)) ) +Transpose( Matrix( ALL.x // ALL.y // ALL.z  Nof(ALL)) )
  for i=Nof(ALL),1,-1
    set type a_//o* [i] { 318 317 315 316 }[ALL.cl[i]]
    set bfactor a_//o* [i] Sqrt( ALL.Count[i]/100. )
    rename a_//o* [i] { "Qh" "Qm" "Qa" "Qd" }[ALL.cl[i]]
    if( ALL.cl[i] != 1) rename a_//ho [i] "Qv"
    if( ALL.cl[i] == 1) delete a_//ho [i]
  endfor
  set type a_//Qv 322
  set bfactor a_//Qv 0.5
  set type a_ "pharmaco"
#
  display xstick
  color a_//C315 red
  color a_//C316 blue
  color a_//C317 white
  color a_//C318 green
  ds cpk a_//C318 yellow
endmacro
#
#endif
#
macro loopmodelBG rs_loop r_thoroughness (1.) l_sidechain (no) l_truncate (no) s_options ("")
  l_info = no
  rs_loop = Res(rs_loop)
  set object Obj(rs_loop)
  if(Nof(Obj(rs_loop))!=1)then
    print " Error> Select loop in a single icm object"
    return
  endif
  s_loop =  Field(  Replace( String( rs_loop ) "[^][A-Z]" "") 2 "." )
  if(Index(s_loop,","))then
    print " Error> Select single continuous loop"
    return
  endif
  print " Loop: " s_loop
  fname_in  = Name( system s_tempDir + "loop_XXXX.ob" )
  fname_out = Name( system s_tempDir + Name(a_)[1] + "_XXXX_loop" +  Replace( s_loop {"^*/" ":"} {"" "_" }) + ".ob" )
  write object a_ fname_in
  S_cmdargs = Sarray( 1 "effort="+r_thoroughness)
  S_cmdargs = S_cmdargs // ("output="+fname_out )
  if(l_sidechain) S_cmdargs = S_cmdargs // "-s"
  if(l_truncate)   S_cmdargs = S_cmdargs // "-t"
  if(Index(s_options "orig")!=0)S_cmdargs = S_cmdargs // "-o"
  s_cmd = Path( macro, s_icmhome + "_loopmodel", fname_in, s_loop, S_cmdargs )
  sprintf "read object \"%s\"\ndelete system \"%s\" \"%s\"", fname_out, fname_in fname_out
  make background s_cmd command=s_out
  print " Info> Loop simulation started in the background. You will be notified when the job is complete."
endmacro

macro dockBG P_chem S_dockPath r_thoroughness (1.) auto
  fiin = s_tempDir + "dock_in.sdf"
  S_cmdargs = Sarray( 1 "effort="+r_thoroughness)
  S_cmdargs = S_cmdargs // "confs=10"
  S_cmdargs = S_cmdargs // "-S"
  S_cmdargs = S_cmdargs // ("input="+fiin)
  S_cmdargs = S_cmdargs // "" # for the output file name
  nargs = Nof(S_cmdargs)
  write String(P_chem) fiin delete
  dockTabs = Sarray(0)
  for i=1,Nof(S_dockPath)
    dockTabs = dockTabs//Sarray( S_dockPath[i]+"*.tab" directory)
    dockTabs = dockTabs//Sarray( S_dockPath[i]+"*/*.tab" directory)
  endfor
  if(Nof(P_chem)==0) return error " Error_dockBG> select chemicals for docking"
  for i=1,Nof(dockTabs)
    docktab = dockTabs[i]
    if(Exist(docktab)) then
      fiou = "dock_out"+String(i)+".ob"
      docktab = Path(docktab)+Name(docktab)
      S_cmdargs[nargs]="name="+Path(fiou)+Name(fiou)
      s_cmd = Path( macro, s_icmhome + "_dockScan",  docktab, S_cmdargs )
      sprintf "read object \"%s\"\ndelete system \"%s\" \"%s\"", fiou, fiin, fiou
# that works
# .. /home/ruben/r/icm/DDD <args> input=/usr/tmp/dock_in.sdf name=dock_out2
#
      print s_cmd
#      make background s_cmd command=s_out info="Docking finished. Press OK to load the result"
      print " Info> Docking started in background. You will be notified when the job is complete."
    else
      print " Warning> can not find project "+docktab
    endif
  endfor
endmacro

macro shakeProtBG rs_2sample r_thoroughness (1.) r_vicinity (15.) r_temperature (600.) l_SCOnly (yes)
  if(Nof(Obj(rs_2sample))!=1 | Type(Obj(rs_2sample) 2) != "ICM")then
    print " Error> Select residues to sample in a single icm object"
    return
  endif
  fname_in  = Name( system s_tempDir + "shakeProt_XXXX.ob" )
  fname_out  = Name( system s_tempDir + "shakeProtOut_XXXX.ob" )
  set object  Obj( rs_2sample )
  write object Obj( rs_2sample ) fname_in
  S_cmdargs = Sarray( 1 "thorough="+r_thoroughness)
  S_cmdargs = S_cmdargs // ("vicinity="+r_vicinity)
  S_cmdargs = S_cmdargs // ("output="+fname_out)
  S_cmdargs = S_cmdargs // ("-s")
  if( Nof(Res( a_A )) != Nof(Res( a_A & rs_2sample ))) S_cmdargs = S_cmdargs // ("residues=" + Replace(String( Res( a_A & rs_2sample ) ) "a_*." "" ))
  s_cmd = Path( macro, s_icmhome + "_shakeProt", fname_in, S_cmdargs )
  print "command line= " + s_cmd
  sprintf "read object \"%s\"\ndelete system \"%s\" \"%s\"", fname_out, fname_in fname_out
  make background s_cmd command=s_out
  print " Info> Monte-Carlo sampling of your protein started in the background. You will be notified when the job is complete."
endmacro

macro pepSampleBG s_pepseq s_runName r_thoroughness (1.)
  fname_in  = Name( system s_tempDir + s_runName + "_XXXX.se" )
  fname_out  = Name( system s_tempDir + s_runName + "_XXXX.ob" )
  write s_pepseq fname_in
  S_cmdargs = Sarray( 1 "effort="+r_thoroughness)
#  S_cmdargs = S_cmdargs // ("vicinity="+r_vicinity)
  S_cmdargs = S_cmdargs // ("output="+fname_out)
  s_cmd = Path( macro, s_icmhome + "bin/pepSample.icm", "seq=" + fname_in,  S_cmdargs )
  print "command line= " + s_cmd
  sprintf "read object \"%s\"\ndelete system \"%s\" \"%s\"\ndisplay xstick", fname_out, fname_out,  fname_in
  make background s_cmd command=s_out
  print " Info> Monte-Carlo sampling of your peptide started in the background. You will be notified when the job is complete."
endmacro

macro alignTwoSequences &seq_1 &seq_2 s_aliName ("NewAlignment") s_comp_matrix  ("") s_alignmentAlgorithm ("ZEGA") r_GapOpen (2.4) r_GapExtension (0.15) i_maxPenalizedGap (99)
  if seq_1 == seq_2 return error "\n sequences are identical\n"
  if Type( seq_1 1) != Type( seq_2 1) return error "\n Error in alignTwoSequences: Can not align sequences of different type\n"
  if s_comp_matrix != "" & s_comp_matrix != "default" read comp_matrix s_icmhome + s_comp_matrix
  alignMethod = s_alignmentAlgorithm
  gapFunction[1] = r_GapOpen
  gapFunction[2] = r_GapExtension
  if(i_maxPenalizedGap!=99) gapFunction = gapFunction[1:2]//Real(i_maxPenalizedGap)//0.1
  s_aliName = Name(s_aliName, unique)
  if s_alignmentAlgorithm == "frame-H-align" then
    if Type( seq_1 1 ) == Type( seq_2 1) return
    if Type( seq_1 1 ) == "nucleotide" $s_aliName = Align( seq_1 seq_2 )
    if Type( seq_2 1 ) == "nucleotide" $s_aliName = Align( seq_2 seq_1 )
  else
    $s_aliName = Align( seq_1 seq_2 )
  endif
	read comp_matrix
	gapFunction[1] = 2.4
	gapFunction[2] = 0.15
  keep $s_aliName
endmacro
#:)

macro dsChemical as_ s_style l_dsHydrogens
  if (l_dsHydrogens) then
    display $s_style as_
  else
    display $s_style as_ & a_//!h*
  endif
endmacro
#
macro makeMini
  OBJECT.auto=no
  OBJECT.bfactor=no
  OBJECT.charge=no
  OBJECT.display=no
  OBJECT.library=no
  OBJECT.occupancy=yes
  OBJECT.sites=yes
  delete a_W,FCO,FO4S
#  delete a_//Ab,Ac,Ad,Ae,Af,Ag,A2,A3,A4,A5,A6,A7
  delete a_//AS
  delete a_//h*
  delete a_N//!c4,c6,n3,o,p*,c5[*],o5[*]
  if (Type(a_ 2 )!="Ca-trace") delete a_A//!c,o
endmacro

macro mutateResidue rs_ s_res
 l_info=l_warn=l_commands=no
 rs_ = Res( rs_ ) & Obj( rs_ )[1]  # residue level and only in one object
 if Nof( rs_ & a_*.A,N )== 0  return
 objName = Name(Obj(rs_))[1]
 set object a_$objName.
 modify rs_ s_res
 rs_ = rs_ & ! a_/$s_res  # was wrong before. It subtracts the successfully mutated
 if( s_res[1:3] == "pro") return
 build string "se "+s_res name="tmp" delete
 set object a_$objName.
 as_out = Res( rs_ & a_N )
 for i=1,Nof( as_out )
   modify Next( as_out [i] & a_//c1[*] bond ) & a_//n*  Next( a_tmp.//c1[*] bond ) & a_tmp.//n*
   rename as_out[i] s_res
 endfor
 as_out = Res( rs_ & a_/!pro* & a_/A )
 for i=1,Nof( as_out )
   modify as_out [i] & a_//cb  a_tmp.//cb
   rename as_out[i] s_res
 endfor
 delete a_tmp.
endmacro

macro mutateResidueExt rs_ s_res
  l_info=l_warn=l_commands=no
  tt = ((Length(s_res) < 6 )?AminoAcids.ID:AminoAcids.NAME_ )  == s_res
  if (Nof(tt)==0) return error "cannot find " + s_res  + " in the library"
  cuob = a_
  load object tt.ob[1] delete name="modres"
  set object Obj( rs_ )
  modify rs_ & a_//cb a_modres.//cb
  rename rs_ tt.ID[1] type
  delete a_modres.
  set object cuob
endmacro

macro evalSidechainFlex rs_residues (a_) r_Temperature (600.) l_atomRmsd (yes) l_color (yes) l_bfactor (no) l_entropyBfactor (no)
  HELP = """
    Evaluates side chain flexibility for  selected residues in a converted ICM object.
"""
  l_info = no
  l_minRedraw=no
  s_oldterms = Info(term)
  set object Obj( rs_residues )[1]
  rs_residues = Res( rs_residues & a_/A )
  if(Type(a_ 2)!="ICM") return error " Error> cannot sample residues in unconverted object."
  if(Nof(rs_residues)==0) return error " Error> empty residue selection "
  Temp = Boltzmann( )*r_Temperature
  set term only "vw,14,to,hb,el,ss"
  S = Rarray( Nof( rs_residues ) )
  set symmetry exact v_ & rs_residues
  set symmetry v_/tyr/xi2 & rs_residues 2
  vicinity = 15.
  prop = "field"
  if(l_bfactor) prop = "bfactor" # under this one we fill occupancies as well
  set field Atom(Obj(rs_residues)) 0.
  set $prop Atom(Obj(rs_residues)) 0.
  n = Nof( rs_residues )
  if Type(SIDECHAIN_FLEX)!="unknown" delete SIDECHAIN_FLEX
  l_showResCodeInSelection=yes
  global group table SIDECHAIN_FLEX Count(n) "i" Sarray( rs_residues residue) "Sel" Name(rs_residues) "Res" Rarray(n) "Entropy" Rarray(n) "MaxDev" header "center a_%2\nas_graph= a_%2/" "cursor"
  make plot SIDECHAIN_FLEX "x=i;y=MaxDev;color=Entropy;size=8;title=Residue Deviations and Entropies"
  for i = 1, n
    vs = v_//xi* & (rs_residues [i])
    if(Nof(vs & v_//!T9)>0)then
      printf " Sampling residue %s ..\r" String( rs_residues [i] )
      v=Value( vs )
      compare vs
      ssearch vs
      set vs v
      if(Nof(conf)!=1)compress stack
      if(Nof(conf)==1)continue
      S[i] = Log(Sum(Exp(-(Energy( stack ) - Min( Energy( stack ) ))/Temp)))
      SIDECHAIN_FLEX.Entropy[i]=S[i]
      if(l_atomRmsd)then
        load conf 1
        c0 = Xyz(rs_residues [i])
        N = Nof( c0 )
        r = Rarray(3*N)
        ss=1.
        for j=2,Nof(conf)
          load conf j
          d = Rarray(Xyz(rs_residues [i])-c0)
          w = Exp(-(Energy("ener") - Min( Energy( stack ) ))/Temp)
          r = r+d*d*w
          ss = ss+w
        endfor
        D=Sqrt((r[3*Count(N)-2] + r[3*Count(N)-1] + r[3*Count(N)])/ss)
        SIDECHAIN_FLEX.MaxDev[i] = Max(D)
        if(!l_entropyBfactor)set field  Atom(rs_residues[i]) D
        if( l_entropyBfactor)set field  Atom(rs_residues[i]) D*S[i]/(Sum(D)+0.01)
        if(prop=="bfactor") then
          set bfactor   Atom(rs_residues[i]) Field(Atom(rs_residues[i]))
          set occupancy Atom(rs_residues[i]) 1./(1.+2.*Field(Atom(rs_residues[i])))
        endif
        set vs v
      endif
    endif
  endfor
  delete SIDECHAIN_FLEX.Entropy==0.
#  if l_color & l_atomRmsd color Atom(rs_residues) Trim(Field(Atom(rs_residues)),0.,5.)//0.//5.
  R_out = S
  printf "\n\n Info> Deviations calculated for  %d  residues. Use: color-by-atom-field\n\n" n
  set term s_oldterms only
endmacro

macro run_bg s_cmds s_inputVars s_outputVars
  job=Name( Name( system, "icmjobXXXin.icb" ) )
  write binary s_cmds $s_inputVars job
  make background name=job[1:Length(job)-2] Path( origin, "-s -e 'read binary INPUT;call string s_cmds;write binary " + s_outputVars + " OUTPUT'" ) command="global read binary OUTPUT"
  s_out=job
  keep s_out
endmacro
#
#ifdef Energy
macro convert2Dto3D os_ l_build_hydrogens (yes) l_fixOmegas (yes) l_display (no) l_overwrite (yes)
 l_commands=no
 l_info=no
 l_warn=yes
 l_minRedraw=no
 s_skipMessages="[69]"
 nRandomStarts = 6
 l_result = yes
 s_oldterms = Info(term)
 if(Nof(mmff)==0) read libraries mmff s_icmhome+"mmff"
 errorAction = "none"
 randomSeedOld = randomSeed
# randomSeed = 123  # have it fixed for reproducibility DONT - anything based on this macro will will always give the same result
 oldGrad = tolGrad
 tolGrad = 0.0001
 dielConst=2.
 os_ = Obj( os_ )
 onams = Name( os_ )
 for iobj=1,Nof(onams)
# skip molecules with more than 200 atoms
  tmpname = onams[iobj]
  if(Type( a_$tmpname. 2 ) == "ICM" | Nof(Atom( a_$tmpname. ))>200) continue
  copy a_$tmpname. "TMPCONVERT" delete
  set object a_TMPCONVERT.
  if Sum(Xyz( a_// )[?,1]) == 0 set cartesian a_ Chemical( a_ hydrogen )  # applies 2D depiction first
  xyzct = Mean( Xyz( a_// ))
  set cartesian a_ # l_info = yes
  c_out["templates"] = s_out
  if (i_out) build hydrogen cartesian  # i_out returns the number of templates, s_out returns the info
  if(l_build_hydrogens) build hydrogen
  if(Type(ringFlexData)=="table" & TOOLS.ringFlexGrade != 5)then
    for ir = 1 Nof(ringFlexData)
      if(ringFlexData.ringRigidGrade[ir]>=5)then # only do 5 (never torsion sample) for now
        find chemical all a_ ringFlexData.mol[ir]
        if(Nof(as_out)>0)then
          print " Found level " + ringFlexData.ringRigidGrade[ir] + " rigid system from ringFlexData[" + ir + "]"
          set field as_out ringFlexData.ringRigidGrade[ir] name="_ringRigidGrade"
        endif
      endif
    endfor
  endif
  set type mmff
  set charge mmff
  randomize a_//!vt* 0.01
  if(l_overwrite) then
    if (Nof(a_//hx) != 0) convert tmpname delete a_//hx
    if (Nof(a_//hx) == 0) convert tmpname delete
  else
    if (Nof(a_//hx) != 0) convert tmpname+"3d" tether a_//hx
    if (Nof(a_//hx) == 0) convert tmpname+"3d" tether
  endif
  if(Type(a_ 2)!="ICM") then
    s_smi = Smiles( Chemical( a_ unique ))
    return error " Error> can not convert" + s_smi
  endif

  set type mmff
  set charge mmff
  set symmetry exact
  if(l_fixOmegas)then
    set v_//T3 180. l_warn=no
    fix v_//T3
  endif
#
  for ixdb = 1 Nof( V_//T49 )
    if(Abs(Value( V_//T49 [ixdb] )[1]) < 90.)then
      print "Cis double bond restrained"
      set vrestraint energy V_//T49 [ixdb] ,{180.}  , 50. 0. 120. # penalize trans
    else
      print "Trans double bond restrained"
      set vrestraint energy V_//T49 [ixdb] ,{0.}    , 50. 0. 120. # penalize cis
    endif
  endfor
#
  vwMethod = "soft"
  unfix V_//a* & !V_//avt*
  v =  Value( v_//a* & !V_//avt* )
  if(Nof(v)>0)then
    m = Matrix( Nof( v) 2 )
    m[?,1] = v
    m[?,2] = Rarray( Nof( v) 170. )
    v = Min (Transpose( m ) )
    set v_//a* & !V_//avt* v
    delete m v
  endif
  fix V_//a* & !V_//avt*
  delete stack
  store conf 1
  P_origobj = Parray(object a_ )
  #find chemical a_// all "[*;R]"   # as_out - ring atoms
  #nRandomStarts = nRandomStarts * (Nof( a_//XLR & as_out )+1)   # increase number of starts proportional to number of chiral centers in rings
  maxIter = 20
  for numIter=1,maxIter
    if (numIter>1) printf " Warning> iteration %d of %d to get correct chiral conformation\n" numIter, maxIter
    for i=2,nRandomStarts
      load conf 1
      randomize a_//!vt* 0.03
      randomize v_//!?vt*
      store conf i
    endfor
    if( Nof( v_//!?vt* ) > 0 ) then
      minimize stack "vw,14,to,hb,rs" v_//!?vt*
    endif
    if(Nof( a_//XLR )!=0) then
      ffMethod="mmff"
      rsChiralWeight = 10.
      minimize stack "rs" V_//FC
    endif
    if(l_display) display xstick a_ center
    minimize cartesian stack 3000 minimizeMethod=2 drop=3. "vw,14,to,el,bb,bs,af,rs"
    if(!Error()) then
      load conf 0
    else
      load conf 1
      l_result = no
    endif
    #
    vwMethod = "exact"
    minimize cartesian 3000 "vw,14,to,hb,el,bb,bs,af,rs"
    if(Error()) then
       l_result = no
    else
       randomize a_//* 0.01
    endif
    if(Nof( a_//XLR )==0) break
    #
    show energy "rs" V_//FC mute
    if( Energy("rs")<=1.) break
    #
    print " Warning> Oops.. chirality got messed up, correcting.."
    ffMethod="mmff"
    vwMethod="soft"
    rsChiralWeight = 100.
    minimize "rs" V_//FC l_warn=no
    minimize 3000 V_//!FC "vw,14,to,hb,el,bb,bs,af,rs"
    minimize cartesian 3000 "vw,14,to,hb,el,bb,bs,af,rs"
    if(Error()) l_result = no
    vwMethod="exact"
    show energy "rs" V_//FC mute
    if( Energy("rs")<=1.) break
    #
    print " Warning> Hmm.. chirality seems still messed up."
    # check stack for "good" conformation
    minimize cartesian stack 1 "rs"
    sort stack
    delete T_tmp l_warn = no
    add column T_tmp Energy(stack ) name="ey"
    delete conf Index( T_tmp.ey > 0 )
    if (Nof(conf) > 0) then
      print " Warning> Trying 'good chiral' conformation from the stack"
      minimize cartesian stack 1 "vw,14,to,hb,bb,bs,af,rs"
      load conf 0
      vwMethod = "exact"
      minimize cartesian 3000 "vw,14,to,hb,el,bb,bs,af,rs"
      if(Error()) l_result = no
      #
      show energy "rs" V_//FC mute
      if( Energy("rs")<=1.) break
    endif
    # this point is reachable only in case when chirality is still messed up
    # load the origical object, delete stack and repeat the procedure
    delete stack
    delete a_
    load object P_origobj
    store conf 1
  endfor
  if (numIter>maxIter) then
    print " Error> 2Dto3D failed (cannot get correct chiral conformation)"
    l_result = no
  endif
  if(Error() | !l_result) then
    print " Error> 2Dto3D failed"
    l_result = no
  endif
  #
  delete stack
  #
  if(Nof(a_//!vt*)==1 ) then
    itype = Type( a_//!vt* 2 )[1]
    if(itype >= 281 & itype < 404 ) set type a_1 "M"
  endif
  translate a_ xyzct # otherwise flies away
#  minimize v_//V "ts" 10 ; delete selftether a_
 endfor
 tolGrad = oldGrad
 if Nof( a_TMPCONVERT. ) > 0 delete a_TMPCONVERT.
 randomSeed = randomSeedOld
 l_out = l_result
 keep l_out
 set term only s_oldterms
endmacro
#
macro convert3Dto3D os_ l_build_hydrogens (yes) l_display (no) l_overwrite (yes)
  for i=1,Nof(os_)
    set object os_ [i]
    if( l_build_hydrogens ) build hydrogens
    set type mmff
    set charge mmff
    name_original = Name( os_ [i] )[1]
    name_new = Name( name_original object unique )
    convert name_new exact graphic
    set link a_$name_original. a_$new_name.   # copy table link information
    if (l_overwrite) then
      delete a_$name_original.
      rename a_$name_new. name_original
    endif
    if(l_display) display xstick a_ center
  endfor
endmacro
#
macro standardizeTautomers &P_m l_pKa (yes)
  l_commands = l_info = l_warn = no
  print bar "Standardize Tautomers"  Nof(P_m) l_info = yes
  for i=1,Nof(P_m)
    if (l_pKa) then
      enumerate tautomer index = Iarray(1,i) P_m name="tmptauto" keep filter predict
      sort tmptauto.pKt
    else
      enumerate tautomer index = Iarray(1,i) P_m name="tmptauto" keep filter
      if (Nof(tmptauto) > 1) then
        add column tmptauto Predict( tmptauto.mol, "MoldHf" ) name="MoldHf"
        sort tmptauto.MoldHf
      endif
    endif
    P_m[i] = tmptauto.mol[1]
    delete tmptauto
    print bar Nof(P_m) l_info = yes
  endfor
  select chemical P_m off
  print bar "End\n" l_info = yes
endmacro
#
macro parrayTo3D P_m l_autoCharge (no) l_fixOmegas (yes) auto
# NOTE: this macro is a part of manual. Correct manual if arguments were changed
  modify P_m fix stereo
  for i=1,Nof(P_m)
    na = Name( P_m[i] )[1]
    if (na == "") na = "m"
    read mol delete P_m[i] name = Name(na, object unique )
    if (l_autoCharge) set charge formal auto a_
    convert2Dto3D a_ yes l_fixOmegas no yes
  endfor
endmacro
#
macro convertFile2Dto3D s_inputFile s_outputFile l_keep_hydrogens (yes) l_fix_omegas (yes)
  l_commands = no
  l_info = no
  S_cmdargs = Sarray(0)
  S_cmdargs = S_cmdargs // "-I"
  S_cmdargs = S_cmdargs // "-f"
  if (!l_keep_hydrogens) S_cmdargs = S_cmdargs // "-H"
  if (!l_fix_omegas    ) S_cmdargs = S_cmdargs // "-O"
  s_cmd = Path( macro, s_icmhome + "_conv2D3D",  s_inputFile,  s_outputFile, S_cmdargs )
  make background s_cmd command="" info="3D generator finished. The output file: " + s_outputFile
  print " Info> 3D generation in background. You will be notified when the job is complete."
endmacro
#
macro chemicalBatchProcess s_inputFile s_outputFile S_options
  l_commands = no
  l_info = no
  S_cmdargs = Sarray(0)
  S_cmdargs = S_cmdargs // "-I"
  S_cmdargs = S_cmdargs // "-f"
  S_cmdargs = S_cmdargs // S_options
  s_cmd = Path( macro, s_icmhome + "_chemBatch",  s_inputFile,  s_outputFile, S_cmdargs )
  make background s_cmd command="" info="Chemical batch process finished. The output file: " + s_outputFile
  print " Info> chemical batch processing started in background. You will be notified when the job is complete."
endmacro
#
macro convertTable2Dto3D s_tableName I_idx l_keep_hydrogens (yes) l_fix_omegas (yes) l_autoCharge (no) auto
  l_commands = no; l_info=no
  if Type( $s_tableName.mol )=="unknown" return error " Error> can not find .mol column"
  for i=1,Nof(I_idx)
    read mol delete $s_tableName.mol [I_idx[i]] name = "tmpmolconv"
    if (l_autoCharge) set charge formal auto a_
    convert2Dto3D a_ yes l_fix_omegas no yes
    if (l_keep_hydrogens) then
      $s_tableName.mol [I_idx[i]] = Chemical( a_ exact hydrogen )[1]
    else
      $s_tableName.mol [I_idx[i]] = Chemical( a_ exact )[1]
    endif
    delete a_
  endfor
endmacro

#macro chemChargeGroups s_tableName I_idx l_charge (yes) s_groups ("primary/secondary/coo/")
#  if(l_charge) then
#     if(Index(Tolower(s_group),"pri"))
#  else
#  endif
#endmacro

#endif
macro chemSuper3D os_in os_template l_flex (no) l_display (no) l_all (no) auto
#
  s_opt = ""
  if (l_all) s_opt = "all"
  l_minRedraw = no
  vwMethod = 2 # soft
  vwSoftMaxEnergy = 0.8
  s_oldterms = Info(term)
  if( Nof(os_template)==0 ) then
    os_template = os_in [1]  # replace by finding the best pair
  endif

  templ = Name( os_template )[1]
  objs = Name( os_in )

  for i=1,Nof(objs)
    s_obj = objs[i]
    set object a_$s_obj.
    l_strip = no
    if( s_obj != templ & Nof(Atom(a_//!h*)) < 100 ) then
      #
      if (l_flex) then
        if Type( a_ 2 ) != "ICM"  then
          convert3Dto3D a_ no no yes
          l_strip = yes
        endif
        #
        find molecule sstructure $s_opt tether a_$templ. & a_*.//!h*   a_ & a_*.//!h*
        unfix V_//T49  # cis trans around double bonds
        tzWeight = 5.
        set symmetry v_//?vt* 1
        minimize "tz" v_//?vt*
        minimize "vw,14,to,hb,tz" Min(Nof(a_//*)+10*Nof(v_//*),1000)
        set symmetry exact
        #
        if (l_strip) strip a_ virtual
      else
        superimpose chemical $s_opt a_$templ. & a_*.//!h*  a_//!h*
      endif
    endif
  endfor
endmacro

macro loadPDB s_code i_type l_deletewater (yes) l_delete_alternatives (yes)
  if i_type==1 then
    pdbDirStyle = 6
    read pdb stack all s_code
  elseif i_type==2 then
    pdbDirStyle = 7
    read pdb stack all s_code
  elseif i_type==3 then
    pdbDirStyle = 5
    read pdb stack all s_code
  elseif i_type==4 then
    read object s_xpdbDir + s_code
  endif
  if !Error() then
    if l_deletewater delete a_W l_warn=no
    if l_delete_alternatives then
      set comment a_//Aa,A1 " "
      delete a_//A
    endif
  endif
  l_info=no
endmacro
#

macro parrayToMol P_m
# NOTE: this macro is a part of manual. Correct manual if arguments were changed
  l_commands = l_info = no
  N = Nof(P_m)
  print bar "Loading molecules " N l_info = yes
  for i=1,Nof(P_m)
    na = Name( P_m[i] )[1]
    if (na == "") na = "m"
    read mol delete P_m[i] name=Name( na, object unique )
    build hydrogen
    set type mmff
    set charge mmff
    print bar N  l_info = yes
  endfor
  print bar "End\n" l_info = yes
endmacro

macro test_header

  if(Version()~"*WIN*") then
    test_dir = s_tempDir + Getenv("USERNAME") + "\\"
  else
    test_dir = s_tempDir + Getenv("USER") + "/"
  endif

  if(!Exist(test_dir)) make directory test_dir
  s_projectsDir=test_dir
  set directory test_dir
  l_need_pause = no
  if (Nof(a_.*)     >0) then
    print "Cleaning ... (objects)"
    l_need_pause = yes
    delete Obj( a_.* )
    print "Cleaned (objects)"
  endif
  if (Nof(grob)     >0) then
    print "Cleaning ... (grobs)"
    l_need_pause = yes
    delete grob
    print "Cleaned (grobs)"
  endif
  delete table
  if (Nof(map)      >0) then
    print "Cleaning ... (maps)"
    l_need_pause = yes
    delete map
  endif
  if (Nof(sequence) >0) then
    print "Cleaning ... (sequences)"
    l_need_pause = yes
    delete sequence
  endif
  if (Nof(alignment)>0) then
    print "Cleaning ... (alignments)"
    l_need_pause = yes
    delete alignment
  endif
  if (Nof(label)    >0) then
    print "Cleaning ... (labels)"
    l_need_pause = yes
    delete label
  endif
  if(l_need_pause) then
    #pause 1
  endif
endmacro

macro mkXpdbFileList
# requires XPDB (s_xpdbDir pointing to your xpdb directory)
  original_path=Path(directory)
  set directory s_xpdbDir
  read sarray name="xpdbList" sys $s_sysLs
  xpdbList = xpdbList ~ "*.ob"
  xpdbList = Sarray(xpdbList,1,4)
  set directory original_path
  write xpdbList
  keep xpdbList
endmacro

macro mkUniqPdbSequences auto i_identPercent ( 1 )
# requires PDB ( s_pdbDir and pdbDirStyle ) and XPDB. Takes about an hour
  l_commands = no
  l_warn=no
  errorAction = "none"
  if(Max(sequence)<100000) return error " Copy $ICMHOME/icm.cfg to ./ and set MnSequences to 100000"
  original_path=Path(directory)

  if(Type(pdbList)!="sarray") then
    delete pdbList
    read sarray "pdbList"
    if Error return " ERROR_mkPdbSequenceNameResList> can not find 'pdbList.sar' file"
  endif
  N=Nof(pdbList)
  print bar "Start making sequences"  N
  for i=1,Nof(pdbList)
    read pdb sequence resolution pdbList[i]
    printf "\r%5d PDB files (of %5d): reading sequences\r" i,N
    print bar N
  endfor
  print bar "End\n"
  delete sequence 12 999999
  group sequence pdbUniq unique="junk" delete nosort
  group sequence pdbUniq unique delete
  group sequence unique delete i_identPercent/100. "pdbUniq"+i_identPercent
  write sequence  "pdbUniq"+i_identPercent
endmacro

macro mkMolSphere rs_ ( as_graph ) r_margin (0.) s_newObjName ("new")
# if r_margin = 0. no maps are calculated
# known problems:  Cys-Cys between disconnected pieces becomes broken
  l_info = yes
  l_commands = no
  mncalls = 1000
  tolgrad = 0.000001
  rs_ = Select(Res( rs_ ),3) # heal the gaps of 1 2 or 3 residues.
  if( Nof(Obj(rs_))>1 | Nof(Obj(rs_))<1 | Name(Obj(rs_))[1] == "temp" ) return error "wrong selection"
  obna = Name(Obj( rs_ ))[1]
  delete a_$s_newObjName.

  S_loops = Sarray( rs_ )
  for i=1,Nof(S_loops)
    copy Obj( rs_ ) "temp" strip delete
    sloop = Replace( S_loops[i], obna+".","temp.")
    delete a_temp. & ! a_$sloop
#    delete a_temp./* [1] & a_temp.//hn
    set object a_temp.
    rename a_temp.1 "abcdefghklmnopqrstuvwxyzABCDEFGHKLMNOPQRSTUVWXYZ" [i]
    if(Type(Obj(rs_) 2)=="ICM") then
      convert a_  delete
      set a_//vt1
    endif
    if i==1 rename a_ s_newObjName
    if i!=1 move a_1 a_$s_newObjName.
  endfor
  delete a_temp.
  if r_margin > 0. & Type(Obj(rs_) 2)=="ICM" then
    set object Obj( rs_ ) # new for gl
    make map potential "gc,gh,ge,gb,gs" Res(Sphere( rs_ ( Obj(rs_) & !rs_ ) r_margin )) Box( Sphere( rs_ r_margin + 2. ) )
    m_gb = 2.5*m_gb
    m_ge = 2.0*m_ge
    m_gs = 4.3*m_gs
    set object a_$s_newObjName.
    keep m_gc m_gh m_ge m_gb m_gs m_gl
  endif
endmacro

macro dsDistances i_mode r_min r_max
  l_commands = no
  n=Nof(as_graph)
  if n>0 then
  if(i_mode == 1) then
    if (n==1) g_distances //= Grob("distance",as_graph[1],Sphere(as_graph[1] a_*.//DD r_max) r_min r_max)
    if (n!=1) print " Select one Atom"
  elseif (i_mode == 2) then
    if (n==2) g_distances //= Grob("distance",as_graph[1],as_graph[2])
    if (n!=2) print " Select two Atoms"
  elseif (i_mode== 3) then
    if(Nof(Obj(as_graph))>=2) then
      printf " Dev = %.2f nAtoms = %d\n",Srmsd( as_graph & Obj(as_graph)[1] as_graph & Obj(as_graph)[2] align ),Nof(as_out)
      g_distances //= Grob("distance_align",as_out as2_out,r_min,r_max)
    else
      print "Select atoms in two objects"
    endif
  else
    print "wrong arguments in dsDistances"
  endif
  endif
  clear selection
  if Type(g_distances)=="grob"  display g_distances
endmacro

macro icmMacroShape auto as_ ( a_A,N ) i_complexity (8) r_gridStep (0.) r_contourLevel (0.) l_colorByDepth (yes) l_fast (no) l_display (no) s_rainbow ("")
HELP="""
  i_complexity   (8)  the number of harmonics. Use range: 3 ( ~ellipsoid) to 14 (detailed/skin-like)
  r_gridStep     (0.) The default (0.) means it is size dependent. Good values: 1. to 5.
  r_contourLevel (0.) density contour level, normally from 1.2 (loose) to 3. (tight,small molecules)
     0. value is the automated mode in which the level is estimated 12./Log(N_heavy_atoms)
  l_colorByDepth (yes) Additionally colors/emphasizes depth
  l_fast         (no) do not use it unless it is a ribosome :-)
  l_display      (no)
  s_rainbow      ("") grob color or range, e.g. "blue/white"
"""
  l_commands = no
  l_info=no
  s_mainColor = Color( Mol( as_ ) field )[1]
  if (s_mainColor == "") s_mainColor=s_rainbow==""?"blue":(Split(s_rainbow,'/')[1])  # [$]?
  if (s_rainbow == "") s_rainbow = s_mainColor + "/" + "white"
  l_enforceCellSize = no
  i_complexity = Max(i_complexity, 2)  # 1 generates empty hkl tables
  os_old_cur = a_
  as_ = Res(as_ & Obj(as_)[1])
  set object Obj(as_)
  gname = Name("shape_"+ Name(Obj(as_))[1] + "_"+ i_complexity unique )

  if r_gridStep < 1. then
    r_gridStep = 1.
    l_enforceCellSize = yes
  endif
  if r_contourLevel < 0.0001 then
    r_contourLevel = 12./(0.3+Log(Nof(a_//!h*)))  # the larger the molecule, the smaller cutoff, 2. for 1crn, 1.2 for large, 3.5 for small
  endif
  l_smallMol = Nof( as_ & a_//!h* )<= 80  # for small molecules build skin
  if(l_smallMol) make grob skin as_ as_ name=gname
  if(l_smallMol) printf " icmMacroShape> name='%s' small molecule: full skin\n", gname
  if(!l_smallMol) printf " icmMacroShape> name='%s', level=%.1f nHarm=%d gridStep=%.1f\n", gname, r_contourLevel, i_complexity, r_gridStep

  if(!l_smallMol) then
  sz = Integer(2.*r_gridStep)/2.
  bx = Box(as_ sz+2.5+16./i_complexity) # was 2.5 but holes (eg in 3gov)
  d =  Cell(1.//1.//Max(bx[4:6]-bx[1:3]) sz)[3] - sz
  if !l_enforceCellSize & d/sz > 50. then
    sz = Integer((2.*d/50.))/2.
    print "Resolution adjusted to " sz
    bx = Box(as_ sz+1.)
    d =  Cell(1.//1.//Max(bx[4:6]-bx[1:3]) sz)[3] - sz
  endif
  if(l_fast) then
    make map potential as_ "sf" sz*Floor(bx[1:3]/sz)//(sz*Floor(bx[1:3]/sz)+d) sz
    m_gc = 1.-m_ga
  else
    make map potential simple as_ "gc" sz*Floor(bx[1:3]/sz)//(sz*Floor(bx[1:3]/sz)+d) sz # to avoid gl
  endif
  make factor Iarray(3 i_complexity) "F" m_gc simple l_warn=no # drop amplitudes
# show Min(F.h),Max(F.h), Min(F.k), Max(F.k), Min(F.l), Max(F.l), F.HKL
# group table append F Sqrt(Trim(Rarray(F.h*F.h + F.k*F.k + F.l*F.l ),0.,99999999.)) "hkl"
  add column F Sqrt(Trim(Rarray(F.h*F.h + F.k*F.k + F.l*F.l ),0.,99999999.)) name="hkl"
  fsmooth = F.hkl < i_complexity  # this line crashed non-debug icm
  make map factor fsmooth m_gc   # do not make a sphere out of a cube
  mapSigmaLevel = r_contourLevel
  make grob solid m_gc name = gname   # auto-contour. exact 3. is an alternative
 endif
  compress $gname l_smallMol?0.2:0.6                 # new trick. hopefully OK
  link $gname Obj( as_ )[1]
  set property $gname smooth
  if l_display display $gname solid smooth transparent
  color $gname $s_mainColor
  if(l_colorByDepth) then
    if(l_smallMol) then
      color accessibility $gname 0.8
    else
      m_lwres = m_gc
      fsmooth = F.hkl < Max(Sqrt(i_complexity),2)   # still trying here
      make map factor fsmooth m_lwres
      color $gname map -m_lwres+4. {1 2 3 0 5 6 7} GRAPHICS.atomRainbow = s_rainbow
    endif
  endif
  set object os_old_cur
  keep $gname
endmacro

macro assignSimpleCharges auto as_ (a_)
    set charge Atom(as_ & a_*.//!vt*) 0.0
    set charge as_ & a_/arg/nh* 0.5
    set charge as_ & a_*./lys,b3k,lyr,slz,ily,ely,mly,mlz,dly,m3l/nz 1.0
    set charge as_ & a_*./glu,b3d,cgu,dgl/oe* , -0.5
    set charge as_ & a_*./asp,csw,das/od* , -0.5
    set charge as_ & a_*./asl,asb,cyg/o1,o2 , -0.5
    set charge as_ & a_*./hip/nd1,ne2 0.5
    set charge as_ & a_*./2mr/ne,nh* 1/3
    set charge as_ & a_*./it1/op* -2/3
    set charge as_ & a_*./nep/o1p,o2p,o3p -2/3
    set charge as_ & a_*./2zc/n1 +1.
    set charge as_ & a_*./ias/o,oxt -0.5
    set charge as_ & a_*./cr8/o25 -1.
    set charge as_ & a_*./phd/op* -2/3
    set charge as_ & a_*./xpc/nd +1.
    set charge as_ & a_*./uu4/n3 +1.
    set charge as_ & a_*./bfd/Be +2.
    set charge as_ & a_*./da2/ne,nh* 1/3
    set charge as_ & a_*./hso/nd1,ne2 0.5
    set charge as_ & a_*./fgp/o*p -2/3
    set charge as_ & a_*./cyg/n1 1.
    set charge as_ & a_*./dab/nd 1.
    set charge as_ & a_*./csu/od* -1/3
    set charge as_ & a_*./ccs/oz* -0.5
    set charge as_ & a_*./ocs/od* -1/3
    set charge as_ & a_*./ord/ne 1.
    set charge as_ & a_*./orn/ne 1.
    set charge as_ & a_*./tpo/o*p -2/3
    set charge as_ & a_*./sep/o*p -2/3
    set charge as_ & a_*./llp/op* -2/3
    set charge as_ & a_*./llp/n1 1.
    set charge as_ & a_*./llp/o3 -1.
    set charge as_ & a_*./tys/o*s -1/3
    set charge as_ & a_*./ptr/o*p -2/3
    set charge as_ & a_*./kcx/oh* -0.5
    set charge as_ & a_*./csd/og* -0.5
    set charge as_ & a_*./gcu/o6* -0.5
    set charge as_ & a_*./slb/o1* -0.5
    set charge as_ & a_*./sia/o1* -0.5
    set charge as_ & a_*./tym/oh -1.
    set charge as_ & a_*./cym/sg -1.
endmacro

macro dsRebel as_ (a_*) l_assignSimpleCharges ( no ) l_display (no)
  l_commands = no
  l_info = no
  l_wire = no
  l_forceAssignCharge = no
  as_ = Res( as_ ) & Obj(as_)[1]
	ms_ = Mol( as_ )
  set object Obj( ms_ )
  if( Type( Obj( ms_ ) 2) != "ICM" ) print "\n\n  Warning> this object needs conversion for CHARGES to be assigned correctly \n\n"
  oldCharges = Charge(Atom( ms_ ))   # save charge
  if( Rmsd( oldCharges ) == 0. & Mean( oldCharges ) == 0. ) then
    if l_assignSimpleCharges == no l_forceAssignCharge = yes
    l_assignSimpleCharges = yes
  endif
  if(l_assignSimpleCharges) then   # for 1e3e.a simple charges screw up the total charge completely
      assignSimpleCharges ms_
# N- C- termini?? (not added by convert)
  endif
  gname = "g_electro_"+Name(Obj(as_))[1]+"_"+Name(Mol(as_))[1]
  gname = Name(gname,unique)
  if  l_wire  make grob skin wire as_ ms_ gname
  if !l_wire  make grob skin      as_ ms_ gname
  randomize ms_ & a_/arg/hh* 0.0001  # to avoid singularities and complaints
  make boundary ms_

# Max, I temporarily closed it because of the crashes in testing. Will figure out later
#  if( Type( Obj( ms_ ) 2) == "ICM" ) then # test instabilities of boundary element charges and outliers
#    oldElectro = electroMethod
#    electroMethod = 4
#    show energy "el"  # fill out the Field
#    ch_pol = Field(a_//*)
#    ch_excess = Max(Abs( Trim(ch_pol, (1.-10./Max(30,Nof(a_//*))) ) - ch_pol  ))
#    ch
#    if(ch_excess > 0.8) then
#       print "\n ERROR> instability leading to extra BE charge of ", ch_excess, " detected!. Hint: randomize ",String(Select(a_//* , "u>1")|Select(a_//* , "u<-1"))," 0.01"
#       electroMethod = oldElectro
#       return
#    endif
#    electroMethod = oldElectro
#  endif

  if l_display display $gname smooth transparent
  link $gname ms_
#  set $gname full  # dual lighting
  color $gname potential ms_ GRAPHICS.NtoCRainbow = "blue/white/red" heavy
  if( Sum( Abs(Charge( Select ( Atom( ms_ ) off ) formal )) ) != 0. ) print "\n Warning> some formal charges are hidden, - the color is distorted.\n Hint: set a_// on\n "
  if l_assignSimpleCharges set charge Atom(ms_ & a_//!vt*) oldCharges  # restore charge
  if l_info & l_forceAssignCharge  print "\nXXX  No charges found.  To recover: Assigning simple charges..\nXXX  Hint: Convert to ICM for balanced partial charges."
  if l_info print "\nXXX  If you want a more dramatic coloring  XXX"
  if l_info print   "XXX  reduce  maxColorPotential  and rerun  XXX\n"
  s_out = gname
  keep $gname
endmacro
#
macro dsIsoRebel auto as_regOfInterest r_margin (15.) R_5levels ({-5.,-1.,0.,1.,5.})
 set object Obj(as_regOfInterest)
 s_name = Name( a_ ) [1]
 make map potential "ge" electroMethod = "boundary element" Box( as_regOfInterest  r_margin ) vwCutoff = 50.
 l_trimInterior = no
 for i=1,5
   s_solid       =     {"solid" "solid"       ""      "solid"       "solid"}[i]
   s_transparent =     {"solid" "transparent" "wire"  "transparent" "solid"}[i]
   s_color       =     {"red"   "red"         "white" "blue"        "blue" }[i]
   s_grna = Name(Replace("equipot_" + Integer(R_5levels[i]) + "_" + s_name "-" "n"),unique)
   make grob $s_solid m_ge exact R_5levels[i] s_grna
   set property $s_grna smooth $s_transparent only
   link $s_grna a_
   if( R_5levels[i] < 0. ) set $s_grna reverse yes
   display static $s_grna
   color $s_grna $s_color
   if(l_trimInterior)then
     color $s_grna a_//!h*,vt* GROB.atomSphereRadius=1.4 black
     $s_grna = Grob( $s_grna { 0.0001 1. 0.0001 1. 0.0001 1. } )
   endif
 endfor
 keep grob
endmacro
#
macro buildMeshes l_show_wire (no) s_ch r_occ (0.) auto
  l_info = no
  l_commands = no
  if(Nof(object)==0) then
    Alert("No objects found")
    return
  endif
  if(Nof(Select(object))==0) then
    Alert("No objects displayed")
    return
  endif
  tmcuobna = Name(a_ full)[1]
  GRAPHICS.l_redraw=no
  if    (Tolower(s_ch) == "electrostatic") then ## electrostatic
    os_ = Select(object); if Nof( os_ & a_ ) >0 then; os_ = a_ ; else; os_ = os_ [1]; endif
    dsRebel Select(residue) & os_ no yes
    if(l_show_wire & s_out !~ "*Error*") then
      undisplay $s_out
      display wire $s_out
      select $s_out
    elseif (s_out !~ "*Error*" & r_occ != 0.) then
      display $s_out smooth
      color accessibility $s_out  r_occ
    endif
  elseif(Tolower(s_ch) == "binding properties") then ## binding properties
    os_ = Select(object)
    if Nof( os_ & a_ ) >0 then; os_ = a_ ; else; os_ = os_ [1]; endif
    as_out = Select(residue) &  os_
    as_out = Sphere( as_out as_out | (a_*.*/T & os_ )  2. ) & Mol(as_out)
    dsPropertySkin as_out no no
    if(l_show_wire & s_out !~ "*Error*") then
      undisplay $s_out
      display wire $s_out
      select $s_out
    elseif (s_out !~ "*Error*" & r_occ != 0.) then
      display $s_out smooth
      color accessibility $s_out  r_occ
    endif
  elseif(Tolower(s_ch) == "solvent surface") then ## surface
    skin_name = Name( "g_surface_"+Name(Select(object))[1]+"_"+Name(Select(molecule))[1] unique)
    make grob surface  Select(residue) Select(molecule) color skin_name
    select  $skin_name
    display $skin_name smooth (r_occ!=0.? : transparent)
    if (r_occ != 0)  color accessibility $skin_name  r_occ
    link $skin_name Select(molecule) & !a_W
  elseif(Tolower(s_ch) == "contact skins") then ## surface
     molskins Select(residue) yes yes ""
  elseif(Tolower(s_ch) == "residue skins") then ## surface
     molskins Select(residue) yes no "residue"
  elseif(Tolower(s_ch) == "plain solid") then ## plain solid
    skin_name = Name( "g_skin_"+Name(Select(object))[1]+"_"+Name(Select(molecule))[1] unique)
    make grob skin Select(residue) Select(molecule) skin_name
    select  $skin_name
    display $skin_name smooth (r_occ!=0.? : transparent)
    color $skin_name white
    if (r_occ != 0)  color accessibility $skin_name  r_occ
    link $skin_name Select(molecule) & !a_W
  elseif(Tolower(s_ch) == "from display") then ## from display
    skin_name = Name( "g_image_mesh" unique)
    make grob image name=skin_name
    select  $skin_name
    display $skin_name smooth transparent
  endif
  set object $tmcuobna
  GRAPHICS.l_redraw=yes
  display new
  keep grob
endmacro

#ifdef 0
#moved inside ICM
macro shapesReadNames
  l_info=no
  l_commands=no
  read list binary s_icmhome+"shapes"
  S_STD_MESHES = FileContents.name
  set property S_STD_MESHES read write show off
  delete FileContents
  sort S_STD_MESHES
  S_STD_MESHES = S_STD_MESHES // "- all -"
  keep S_STD_MESHES
endmacro

macro readShapes i_nu
  l_info=no
  l_commands=no
  if S_STD_MESHES[i_nu] == "- all -" then
    read binary s_icmhome+"shapes"
    for meshes_idx=1,Nof(S_STD_MESHES)
      if(meshes_idx != i_nu) then
        display $S_STD_MESHES[meshes_idx]
      endif
    endfor
    display center
  else
    read binary s_icmhome+"shapes" name=S_STD_MESHES[i_nu]
    display $S_STD_MESHES[i_nu]
  endif
  keep grob
endmacro
#endif

macro mcMacro vs_ ( v_//x* ) as_tether
  set object Obj(Atom(vs_))[1]
  if Type( a_ 2 )!= "ICM" return error "can not optimize a non-ICM object"
  set symmetry exact
  nvar = Nof( vs_ & v_//phi,psi,H,P ) # number of essential variables
  mncallsMC    = 10000 + Integer(0.008*nvar*nvar*nvar*nvar*nvar) # maximal number of energy evaluations
  mncallsMC    = Min(mncallsMC 40000000) # impose maximal limit
  mncalls      = 170+nvar*3  # max. n_of minimization calls after each random change
  temperature  = 600   # optimal temperature for the simulation
  tolGrad      = 0.01  # exit minimization when gradient is < 0.01
  mcBell       = 1.0   # the default width of the MC probability distributions
  mnconf       = 20 + 2*nvar   # max. n_of low-energy conformations saved in the stack (f1.cnf file)
  mnvisits     = 10 + nvar     # if stuck for >= 25 times, push it out
  visitsAction = "random" # drastic, works better then "heat"
  autoSavePeriod = 1000
  mnreject     = 10    #
  mnhighEnergy = 15 + nvar/2   #
  l_bpmc       = yes   # use biased probability
  vwMethod = 2
  electroMethod = "distance dependent"
  surfaceMethod = "atomic solvation"
  s_oldterms = Info(term)
# initially had no --only since it was meant to be open to 'cn' etc., now 'only' fixes the terms.
  set terms only "vw,14,hb,el,ss,to,sf,en"  # ECEPP/2 energy + solvation + entropy (see icm.hdt file)
  set vrestraints Res(Atom( vs_ ))  # load preferred backbone and side-chain angle zones
  vicinity = 30.0     #
  betaStepPb = 2.
  compare vs_  # use this variables to compare structure

  if(Nof(as_tether)>0) then
    if Obj(as_tether)[1] != a_ print " Warning> the selection not in the optimized object"
    copy a_ "tmp" strip tether delete
    delete tether !as_tether
    tzMethod = "function"
    set terms "tz"
    set area a_tmp.//*  10.
    set charge a_tmp.//*  0.
    set bfactor a_tmp.//*  0.5
#    set term "gc"
#    make map potential Box( as_tether 2. ) !a_ 1. "gc"
#    GRID.margin = 3.
  endif

  montecarlo vs_ # run it and record a trajectory.

  delete a_tmp.
  set term s_oldterms only
endmacro

macro findSymNeighbors as_ ( as_graph ) r_radius (7.) l_append (no) i_extend_by (2) l_keepEntireChain (no) l_display (yes)
  l_info=no
  l_commands=no
  s_skipMessages="[103][217]"
  if ( Nof( as_graph ) == 0 & ( Nof( as_ ) == 0 | Nof( as_ ) > 1000 ) ) return error "\n Select atoms in an object with defined crystallographic symmetry\n"
  os_ = Obj(as_)[1]
  if(Symgroup(os_)=="undefined") return error # " Error_in_findSymNeighbors: symmetry group undefined"
  s_objName = Name(os_ object)[1]
  R_transMatrices = Rarray(0)
  S_neighborAtoms = Sarray(0)
  sel_pos = Xyz(as_ & a_*.//!h)
	center_xyz = Mean(sel_pos)
  show surface area as_ as_ mute
  sel_surf_pos = Xyz(Acc((as_ & a_*.//!h) 0.01))
  show surface area os_ mute
  all_surf_pos = Xyz(Acc((os_ & a_*.//!h) 0.01))
  group_name = Symgroup(as_)
  if Tolower(group_name) == "c121" & Abs((Cell(os_)[6]-90.))>1. return error "\n Permutation is needed for this nonstandard C121 cell. Try: modify rotate "
  n_sym_ops = i_out
  S_neighborAtoms = Sarray(0)
  R_symTrans = Rarray(0)
  nm = s_objName[1:27] + "Sym"  # fixed R
  if( !l_append & Nof(a_$nm.)==1 ) delete a_$nm.
delete a_tempobj.
  for i=1,27*n_sym_ops
    # use only surface atoms to find if there are neighboring atoms
    neigh_atoms = Sphere(Xyz(sel_surf_pos,i,group_name,Cell(os_)//center_xyz,translate), os_, r_radius)
    if Nof(neigh_atoms) != 0 | r_radius == 0. then
       # find all neighboring atoms
       as_symNeighbors = Sphere(Xyz(sel_pos,i,group_name,Cell(os_)//center_xyz,translate), os_ , r_radius)
       if( r_radius == 0. ) as_symNeighbors = os_
       S_neighborAtoms //= String(Res(as_symNeighbors) number ) # was crash with old version.  Added option number
       R_inv = Transform(R_out, inverse)
       R_symTrans //= R_inv
       if (i != 1) then
         #copy Mol(as_symNeighbors) "tmpobj" delete   # TODO: fix 'copy Mol' for 1qll (converted)
         appendMol Mol(as_symNeighbors) "tmpobj"
         transform a_tmpobj. R_inv
         if(Nof(a_$nm.)==1) move a_tmpobj. a_$nm.
         if(Nof(a_$nm.)==0) rename a_tmpobj. nm
       endif
    endif
  endfor  # i
  as2_out = Sphere( as_ a_$nm. r_radius+2. residue )
  if( Type( a_$nm. 2 ) != "ICM" & ! l_keepEntireChain ) delete a_$nm. & !Select(Select( as2_out 3 ),margin, i_extend_by )
  set property a_$nm.* "nobreaks"
  if l_display then
    if( l_keepEntireChain) display ribbon Mol(as2_out) molecule
    if(!l_keepEntireChain) display ribbon Select(Select( as2_out 3 ),margin, i_extend_by ) molecule
    color ribbon as2_out white
    set color xstick cpk wire as2_out & a_*.//c* lightgreen
    if(Nof( as_ & a_*.//DW )>0) display as2_out wire
    if(Nof( as_ & a_*.//DX )>0) display as2_out xstick
    if(Nof( as_ & a_*.//DC )>0) display as2_out cpk
  endif
  nSymNeighbors = Nof(S_neighborAtoms)-1
  if(l_info & Nof(S_neighborAtoms)>=1) printf " %d crystallographic neighbor(s) found within %.1f A\n" Nof(S_neighborAtoms)-1,r_radius
  if(l_info & Nof( os_ "bio")>0) printf " This object also has %d BIOMOLECULE(S) and BIOMT transformations\n", Nof(os_ "bio")
  keep S_neighborAtoms, nSymNeighbors, R_symTrans
endmacro

macro findSymNeighborsOld as_ ( as_graph ) r_radius (7.) l_makeObjects (yes) l_merge (no) l_display (yes)   # obsolete
  l_info=no
  s_skipMessages="[103]"
  if ( Nof( as_graph ) == 0 & ( Nof( as_ ) == 0 | Nof( as_ ) > 1000 ) ) return error "\n Select atoms in an object with defined crystallographic symmetry\n"
  os_ = Obj(as_)[1]
  if(Symgroup(a_)=="undefined") return error # " Error_in_findSymNeighbors: symmetry group undefined"
  s_objName = Name(os_ object)[1]; s_objName=s_objName[1:26]  # patch added for long names.
  R_transMatrices = Rarray(0)
  S_neighborAtoms = Sarray(0)
  sel_pos = Xyz(as_ & a_*.//!h)
	center_xyz = Mean(sel_pos)
  show surface area as_ as_ mute
  sel_surf_pos = Xyz(Acc((as_ & a_*.//!h) 0.01))
  show surface area os_ mute
  all_surf_pos = Xyz(Acc((os_ & a_*.//!h) 0.01))
  group_name = Symgroup(as_)
  n_sym_ops = i_out
  S_neighborAtoms = Sarray(0)
  R_symTrans = Rarray(0)
  count = 0
  for i=1,27*n_sym_ops
    # use only surface atoms to find if there are neighboring atoms
    neigh_atoms = Sphere(Xyz(sel_surf_pos,i,group_name,Cell(os_)//center_xyz,translate), os_, r_radius)
    if Nof(neigh_atoms) != 0 then
       # find all neighboring atoms
       as_symNeighbors = Sphere(Xyz(sel_pos,i,group_name,Cell(os_)//center_xyz,translate), os_ , r_radius)
       S_neighborAtoms //= String(Res(as_symNeighbors))
       R_inv = Transform(R_out, inverse)
       R_symTrans //= R_inv
       if l_makeObjects & (i != 1) then
         count += 1
         nm = s_objName+"Sym"+String(count)
         copy os_ nm delete
         delete a_$nm. & !Select(Mol(as_symNeighbors), a_$nm.)
         transform a_$nm. R_inv
         if l_display display a_$nm.
         delete Sphere( os_ a_$nm. 0.001 )
       endif
    endif
  endfor  # i

  if l_makeObjects & l_merge then
    nm = s_objName+"Sym*"
    move a_$nm. os_ delete
    store display delete Obj( os_ )
  endif

  if l_display then
    gCrystCell = Grob ("cell" Cell(as_))
    display gCrystCell magenta
    display origin
    keep gCrystCell
  endif

  nSymNeighbors = Nof(S_neighborAtoms)-1
  if(l_info & Nof(S_neighborAtoms)>=1) printf " %d crystallographic neighbor(s) found within %.1f A\n" Nof(S_neighborAtoms)-1,r_radius
  if(l_info & Nof( os_ "bio")>0) printf " This object also has %d BIOMOLECULE(S) and BIOMT transformations\n", Nof(os_ "bio")
  keep S_neighborAtoms, nSymNeighbors, R_symTrans
endmacro

macro makeBioMT os_pdb (a_) l_makeall (yes)
  l_info_old=l_info
  l_info=no
  s_skipMessages="[103]"
  if Nof(os_pdb "bio") == 0 then
    print "No BioMT information in the object"
    return
  endif
  if l_makeall then
    n_bio = Nof(os_pdb "bio")
  else
    n_bio = 1
  endif
  I_out = n_bio//0 # n biomolecules and total transoformations
  nm = Name(os_pdb)[1]
  for i=1, n_bio
    new_nm = nm+"B"+String(i)
    copy os_pdb new_nm
    as_bio = Select(a_$new_nm. "biomt" i)
    copy os_pdb "TMP" delete
    as_tmp_bio = Select(a_TMP. "biomt" i)
    delete a_TMP. & !as_tmp_bio  # needed because of "move" bug
#    m = Transform(a_$new_nm. "bio" i)
#    n_trans=Nof(m)/12
    m1 = Transform(a_$new_nm. "bio" i)
# remove identical transformations
    ntmp=Nof(m1)/12
    I_del=Iarray(ntmp)
    for j=1,ntmp-1
     in1=(j-1)*12+1
     in2=j*12
     for k=j+1,ntmp
      jn1=(k-1)*12+1
      jn2=k*12
      if(m1[in1:in2]==m1[jn1:jn2])I_del[k]=k
     endfor
    endfor
    I_keep=Index(I_del 0 all)
    n_trans=Nof(I_keep)
    m=Rarray(n_trans*12)
    jk=1
    for j=1,n_trans
     iz=I_keep[j]
     for k=1,12
      m[jk]=m1[(iz-1)*12+k]
      jk=jk+1
     endfor
    endfor
#
    I_out[2] = I_out[2] + n_trans
    delete a_$new_nm. & !as_bio
    if(l_info_old) print bar "Biomolecule "+i+" of "+n_bio+" ("+n_trans+" units)" n_trans
    for j=n_trans,1,-1
      ind1 = 12*(j-1)+1
      ind2 = 12*j
      if j > 1 then
        copy a_TMP. "TMP1" delete
        transform a_TMP1. m[ind1:ind2]
        move a_TMP1. a_$new_nm.
      else
        transform as_bio m[ind1:ind2]
      endif
      if(l_info_old) print bar n_trans
    endfor
    if(l_info_old) print bar "\n" 0
  endfor
  delete a_TMP,TMP1.
  new_nm = nm+"B*"
endmacro

macro loadProtein s_proteinID s_proteinFileName
  l_info=no
  l_commands=no
  if(s_proteinID!="") then
    ids = Split(s_proteinID,";")
    for i=1,Nof(ids)
      read sequence genome s_proteinFileName ids[i]
    endfor
    keep sequence
  endif
endmacro

macro loadSwissEntry ms_ l_load_sequence (yes) l_make_alignment (no) l_tranfer_sites_from_swiss (yes)
  l_info = no
  l_commands = no
  if( Nof( Link( ms_ ) ) > 0 ) then

    swiss_id = Link( ms_ )[1]
    mol_full_name = String(ms_)
    mol_seq_name =  Name(Obj(ms_))[1]+"_"+Name(ms_)[1]
    ali_name = swiss_id+"_"+Name(ms_)[1]
    if(Type(WEBLINK)!="table") then
      read table s_icmhome+ "WEBLINK.tab"
      set property delete off WEBLINK
    endif
    sprintf WEBLINK.LINK[Index(WEBLINK.DB,"SP")] swiss_id
    if(Type($swiss_id)!="sequence") then
      read sequence swiss s_out
      if (s_out != swiss_id) rename $swiss_id s_out
    endif

    if( Name(ms_,sequence)[1]!=mol_seq_name ) make sequence Mol( ms_ )
    $ali_name = Align( $mol_seq_name $swiss_id )
    if(l_tranfer_sites_from_swiss) set site swiss $swiss_id ms_ $ali_name
    if(!l_make_alignment) then
      delete $ali_name
      delete $mol_seq_name
    else
      keep alignment
      keep sequence
    endif
    if(l_load_sequence) keep sequence
  endif
endmacro

macro loadPfamEntry auto s_find ("") l_all (no)
   l_commands = no
   s_find = Trim(s_find,all)
   if(s_find=="") return
   #pfam_query = "http://pfam.sanger.ac.uk/search/keyword?query="
   #pfam_align = "http://pfam.sanger.ac.uk/family/alignment/download/format?&acc="
   pfam_query = "http://pfam.xfam.org/search/keyword?query="
   pfam_align = "http://pfam.xfam.org/family/ACC/alignment/seed/format?format=fasta&order=t&case=l&gaps=default&download=0"
   l_kwpfam = Length( Match( s_find, "PF\\d+" ) ) == 0

   if( l_kwpfam )  then  # keyword search
     read table html pfam_query +s_find name="TMP"
     if(Type(TMP)=="table" ) then
       if(Name(TMP)[1]!="TMP.Original_order") return error " Keyword not found "
       delete TMP.Original_order TMP.Pfam TMP.Seq_info TMP.Interpro TMP.Pdb TMP.GO l_warn = no
       if(Type(pfam_hits)=="table") delete pfam_hits
# need to Dehtml ID to use it in double click
       TMP.ID = Replace(TMP.ID, "<.*?>","",regexp)  # dehtml
       add header TMP "loadPfamEntry  Match(pfam_hits.Accession[%#],'<a.*?>(.*?)</a>',1)" + " " + String(l_all)+"\n" name="doubleClick"
       rename TMP "pfam_hits"
       keep pfam_hits
     endif
   else
     #pfam_align += s_find
     pfam_align = Replace( pfam_align, "ACC" s_find )
     if ( l_all ) pfam_align += "&alnType=full"
     read alignment fasta pfam_align name= s_find
     keep sequence alignment
# need to load DR PDB s from TMPSEEDS or FULL
   endif
endmacro
# PF02166

macro findNextName s_def ("icm") s_ext (".png")
  i = 0
  s_name = s_def + s_ext
  while( Exist(s_name) )
    i = i + 1
    s_name = s_def + i + s_ext
  endwhile
  s_out = s_name
endmacro

macro makeBackupList
  l_commands = l_info = no
  delete BACKUPS l_warn=no
  #s_backDir = Getenv("HOME")+"/.icm/bak/"
  s_backDir = s_userDir + "bak/"
  group table "BACKUPS" Sarray(s_backDir +"icmauto*" directory) "File"
  group table append BACKUPS Date(Nof(BACKUPS)) "Date"  Rarray(Nof(BACKUPS)) "File_Size" Sarray(Nof(BACKUPS)) "Objects" Sarray(Nof(BACKUPS)) "Tables"
  for i = 1 Nof(BACKUPS)
    i_fileSize = Integer(Field( File( BACKUPS.File[i] ) 5 ))
    BACKUPS.File_Size[i]  = Real(i_fileSize) / 1024
    if (i_fileSize == 0) continue
    read binary list only BACKUPS.File[i] name="TMPOBJLIST"
    BACKUPS.Date[i] = Date( BACKUPS.File[i] modify )
    TMPOBJLIST.type = Field(TMPOBJLIST.type 1)
    T = TMPOBJLIST.type=="object"
    BACKUPS.Objects[i] = Sum(T.name ", ")
    T = TMPOBJLIST.type=="table"
    BACKUPS.Tables[i] = Sum(T.name ", ")
    delete TMPOBJLIST T
  endfor
  sort BACKUPS.Date reverse
  group table BACKUPS header append "read binary %@.File[ %# ] " "doubleClick"
  group table BACKUPS header append "# b_Clear_workspace (set property delete write BACKUPS off | delete all | set property delete write BACKUPS on) " "cursor"
  set format BACKUPS.File_Size "%.1fKb"
  delete  BACKUPS.File_Size == 0.
  keep BACKUPS
endmacro

macro binaryToc s_file s_outName ("") auto
 s_short = "only"
 s2_out = s_outName == "" ? Name( Name(s_file) + "_TOC" ,unique) : s_outName
 delete $s2_out l_warn=no
 global read binary list $s_short s_file name=s2_out # ONLY to make a shorter  list
 sss = "read binary " + String( s_file string) + " name = " + s2_out + ".name[%#] only"
 global group table $s2_out header append sss "doubleClick"
endmacro

macro assignCodes s_mol_tab_name s_patterns
  l_info = no
  m = Nof( $s_mol_tab_name.mol, $s_patterns.smarts )
  S_res = Sarray(Nof($s_mol_tab_name.mol));
  for i=1,Nof( $s_mol_tab_name.mol )
    group table tmp_ac Iarray( m[i] )
    st = Sum( $s_patterns.ID[ Index( tmp_ac.A > 0 ) ], "," )
    S_res[i] = st
  endfor

  group table $s_mol_tab_name append S_res "Codes"

  keep S_res
endmacro
#
macro getPharmProperties as_at
  S_out = Sarray(10)
  S_out[1] = String( as_at )
  S_out[2] = String( Max( 0.5 Bfactor( as_at  )[1] ) )
  S_out[3] = String( Type( as_at 2  )[1] - 314 )
  keep S_out
endmacro
#
macro setPharmProperties as_at r_tolRadii i_type
  set bfactor as_at r_tolRadii pharmacophore
  set type    as_at Count(315,321)[i_type]
  rename as_at {"Qa","Qd","Qm","Qh","Qp","Qn","Qx"}[i_type]
  color as_at
endmacro
#
macro makeTable s_tableName ("tbl") i_rows (20) i_Scols (2) i_Icols (1) i_Rcols (1) l_chemcol (no) l_rndS (no) l_rndI (no) l_rndR (no)
 l_commands = no
 l_info = no
 l_warn = no
 if(Type( $s_tableName )!= "unknown") delete $s_tableName
  if (l_chemcol) then
    global add column $s_tableName Chemical(Sarray(i_rows,"")) name="mol"
  endif
  for i=1,i_Scols
    if( l_rndS) then
      SS= Random(i_rows,{"John","Mary","Jack","Max","Crystal"})
    else
      SS= Sarray(i_rows)
    endif
    global add column $s_tableName SS
  endfor
  for i=1,i_Icols
    II = Iarray(i_rows)
    if( l_rndI) II = Iarray(Random(1,100,i_rows))
    global add column $s_tableName II
  endfor
  for i=1,i_Rcols
    RR =Rarray(i_rows)
    if( l_rndR) RR = Rarray(Random(0.,10.,i_rows))
    global add column $s_tableName RR
  endfor
endmacro
#
macro makePharma as_obj s_name ("pharm") l_points (yes) l_display (yes) as_exvol (a_NONE.) auto
# NOTE: this macro is a part of manual. Correct manual if arguments were changed
 newName=Name(s_name,object,unique)
 #ms_obj = Mol(ms_obj) # protection
 if (l_points) then
   s_ph4mol = Chemical(as_obj pharmacophore )
   if Smiles( s_ph4mol )[1] == "" return " Warning> no atoms that can be represented by ph4 spheres found"
   read mol s_ph4mol name=newName
   if (Nof(as_exvol)>0) then
     read mol Chemical( Sum(Sarray(Nof(as_exvol),"[Qx]"),".") + "|3D:" +  Sum(Sarray( Rarray( Xyz( as_exvol  ) ) ) ",") ) name="tmp_exvol" delete
     move a_tmp_exvol. a_$newName.
   endif
 else
   s_ph4mol = Sum( Split( Chemical(as_obj exact ), "[R1;!D1]!@[R2;!D1]" ) )
   read mol input = String( s_ph4mol ) name=newName
#   copyMol Mol(as_obj) newName
 endif
 strip a_$newName.
 set type a_$newName.  "pharmaco"
 delete a_$newName.//vt*,h*
 if (l_display) display xstick a_$newName.
endmacro

macro makePharmaAtoms as_  i_type (1) r_radius (0.5) l_display (yes)
# makes excluded volume atoms
  l_info=no
  ph4ty = {321 , 315 , 316 , 317 , 318 , 319 , 320 } # add more types if necessary
  ph4na = {"Qx" ,"Qa" ,"Qd" ,"Qm" ,"Qh" ,"Qp" ,"Qn" } # add more names if necessary
  ph4ml = {"exv","acc","don","aro","hph","pos","neg" } # add more names if necessary
  osCurr = a_
  n = Nof( Atom( as_ ) )
#  if(n>100) return " Warning> skipped. Select less than 12 atoms"
  newName=Name("pharm",object,unique)
  build string Sum(Sarray(n,"ml ")+Sarray(n,ph4ml[i_type])+Count(n)+Sarray(n,"\nse o"),"\n") name=newName
  strip a_ virtual    # will not work for directions
  set a_//o Xyz( as_ )
  set bfactor a_//o r_radius
  set type a_//o ph4ty[i_type]
  rename   a_//o ph4na[i_type]
  set type a_ "pharmaco"
  if(l_display) display xstick a_
  set object osCurr
endmacro

macro refineLigand ms_
# unfinished
  set object Obj( ms_ )
  delete a_tmp.
  copy a_ "tmp" tether
  delete tether ( Obj( ms_ ) & !ms_ ) | Select( Atom(ms_) "o<0.1" )
  tzWeight = 100.
  montecarlo (v_//V & ms_ ) | ( v_//* & Select( Atom(ms_) "o<0.1") )  "vw,14,to,el,hb,to,tz"
  delete a_tmp.
endmacro
#
macro fixChirality l_deb (no)
 # correct chirality
 if(Nof( a_//XLR )!=0)then
   for i=1,Nof(V_//FC)
     show energy "rs" V_//FC [i] mute
     if (l_deb) show V_//FC [i]
     if( Energy("rs")>1.)then
       unfix V_//FC [i]
       v = Value( V_//FC [i] )[1]
       if (v >= 180. | v <= 0. & v >= -180. ) then
         set V_//FC [i] 120.
       else
         set V_//FC [i] -120.
       endif

       # if Nof( Next( Atom( V_//FC [i] ) tree reverse ) ) == 2 then
       #   was_fixed = Nof( v_//T & Next( Atom( V_//FC [i] ) tree reverse ) ) == 0
       #   if (was_fixed) unfix V_//T & Next( Atom( V_//FC [i] ) tree reverse )
       #   set V_//T & Next( Atom( V_//FC [i] ) tree reverse ) Value( V_//FC [i] ) [1] add
       #   if was_fixed fix  V_//T & Next( Atom( V_//FC [i] ) tree reverse )
       # endif

       fix V_//FC [i]
       delete tether Atom( V_//FC [i] ) | Next( Atom( V_//FC [i] ) tree reverse ) | ( Next( Atom( V_//FC [i] ) bond ) & a_//h* )

       minimize "tz"
       if (l_deb) then
         show V_//FC [i]
         display
         display tether
         pause
       endif
       tzWeight=20.  # descrease tzWeight for future minimization
       keep tzWeight
     endif
   endfor
 endif
endmacro
#
macro editSelection auto as_toedit l_display (yes) l_enumerateStereo (no) l_tableOutput (no) s_extraTerms ("") s_mol ("")
 l_commands = no
 l_info = no
 l_warn = no
 l_minRedraw = no
 s_cart_terms = "vw,14,hb,el,to,af,bb,bs,ss"; if (Length(s_extraTerms)) s_cart_terms += "," + s_extraTerms
 #s_totz_terms = "vw,14,hb,el,to,tz"
 s_skipMessages = "[210][211][69]"
 vwMethod = "soft"
 vwCutoff = 6.5
 electroMethod = 2
 l_pharm  = Type( Obj( as_toedit ), 2 ) == "Pharmacophore"

# need to be finished for complete objects and incomplete atom selections
 if Nof( Mol(Next( as_toedit bond )) & ! Mol( as_toedit  ) ) != 0 return error "  Error> Can not edit molecule covalently bonded to another molecule"

 if( Nof(as_toedit) < 1 ) return
 if ( Nof(Obj(as_toedit)) > 1 ) return error "Can edit only a molecule in a single object"
 l_nonicm = Type(Obj(as_toedit),2) != "ICM"

 set object Obj( as_toedit )
 l_delete_h = l_pharm #Nof( as_toedit & a_//h* ) == 0
 ndslig = Nof( as_toedit & a_*.//DWBC )

 s_molOrigName = Name( Mol( as_toedit ) )[1]

 as_tmp = (Next( as_toedit bond ) & a_//h*) | as_toedit
# if (Nof(Next( as_tmp[1] bond ) & a_//vt*) > 0) then   # includes root, include all
   as_toedit = Mol(as_toedit)
# endif

 if(Nof(as_toedit & a_*.//!h* )>100 ) return error " Warning> Molecule is too large for interactive editing"

 as_attach = Next(as_toedit bond) & !as_toedit & a_*.//!vt*,h*
 if(Nof(as_attach)>0|Nof(Next(as_attach bond)&as_toedit)>0)return error " Can only edit complete un-attached ligands"
 as_attach = Next(as_attach bond)&as_toedit
 # as_attach is not used now becase as_toedit is expanded to Mol

 s_nameToEdit = Field( Mol( as_toedit ) "_MOLNAME" )[1]
 if (s_nameToEdit == "") s_nameToEdit = Name( Mol(as_toedit) )[1]

 if ( Length(s_mol) == 0) then
   tmpp = Chemical( as_toedit, object unique )
   set name tmpp s_nameToEdit

   global edit tmpp gui
   if i_out == 0 return
 else
   tmpp = Chemical( s_mol mol )
   set name tmpp s_nameToEdit
 endif

 l_info = no  # reset by edit tmpp for some reason

 molName = Name( Name(tmpp)[1] object unique )  # Name(Mol(as_toedit))[1]

 if Nof( tmpp, chiral, 3 )[1] > 0 & l_enumerateStereo then
   if Askg( "2D compound contains undefined stereo centers. Do you want to enumerate them?" "Yes/No" simple ) != "Yes" l_enumerateStereo= no
 else
   l_enumerateStereo = no
 endif

 if (l_enumerateStereo) then
   enumerate chiral tmpp name="resT"
   l_tableOutput = yes
 else
   l_tableOutput = no
   add column resT tmpp name="mol"
 endif

 reschem = Chemical()

 for num=1,Nof(resT)

   tzWeight = 1.
   ffMethod = 1
   rsChiralWeight = 0.
   tzMethod = 4
   set terms only "vw,14,hb,el,to"

   if (num > 1) delete a_   # from previous iteration

   ligedit=Name("tmpedit",object,unique)
   read mol label delete resT.mol[num] name=ligedit
   as_conserved = as_out

   build hydrogen
   set type mmff
   set charge mmff
   convert auto   # converts inplace, preserves selection
   randomize a_//!vt* 0.01

   rename a_* s_molOrigName

   if (Nof( as_conserved ) == 0)  then
     translate a_ Mean( Xyz( Atom(as_toedit) ) )
   else
     superimpose Atom(as_toedit)  a_$ligedit.//!h* & as_conserved name
     #store conf

     set charge as_toedit 0.
     set area as_toedit 0.
     set bfactor as_toedit 1.
     set bfactor as_toedit & a_*.//h* 0.2

     set tether a_//!h* & as_conserved as_toedit name hydrogen

     minimize "tz"
     #store conf

     if Nof(a_//!T)>0 minimize cartesian V_//* & a_//!T
     #store conf

     set a_//  # set old coordinates from tethers
     #store conf
     build hydrogen a_//!T cartesian  # recalc cartesian coordinates for hydrogens
     #store conf

     ffMethod="mmff"
     rsChiralWeight = 10.

     tzWeight = 500.

     # correct chirality
     fixChirality no
     #store conf
     #return
   endif

   unfix V_//bh*
   set V_//bh* 1.
   s_oldterms = Info(term)
   set terms only s_cart_terms
   if Nof(a_//h* & a_//!T)>0 minimize cartesian a_//h* & a_//!T
   set occupancy a_//!T 0.
   fix V_//bh*

     #store conf
   #
   tolGrad      = 0.001
   set term "tz"  #  adds "tz" term
   if l_pharm tzWeight = 1000.
   if Nof(a_//!T)>0 minimize cartesian a_//!T 1500
     #store conf
     #return
   if(Nof( a_//XLR )!=0)then
     show energy "rs" V_//FC mute
     if( Energy("rs")>1.)then
       print " Oops.. chirality got messed up, correcting.."
       minimize "rs" V_//FC
       #fixChirality l_debug
       minimize cartesian 3000 "vw,14,to,hb,el,bb,bs,af,rs"
       rsChiralWeight = tzWeight
       minimize cartesian 3000 "vw,14,to,hb,el,bb,bs,af,rs,tz"
       show energy "rs" V_//FC mute
       if( Energy("rs")>1.) then
         print " Oops.. chirality got messed up, decreasing tzWeight ..."
         tzWeight = 20.
         minimize cartesian 3000 "vw,14,to,hb,el,bb,bs,af,rs,tz"
         show energy "rs" V_//FC mute
         if( Energy("rs")>1.) print " Hmm.. chirality seems still messed up."
       endif
     endif
   endif
   if !l_pharm tzWeight=1.
   minimize "tz"
     #store conf

   set occupancy a_// 1.

   minimize cartesian 2500
     #store conf

   delete tether a_

   reschem = reschem // Chemical( a_ exact hydrogen )

 endfor

 if (!l_tableOutput) then
   l_nonicm = l_nonicm | l_pharm
   if (Nof(Mol(Obj(as_toedit)) )==1 | Nof(Mol(as_toedit))==Nof(Mol(Obj(as_toedit))) ) then
     set link table Obj(as_toedit) a_$ligedit.   # copy table link information
     na = Name( Obj(as_toedit) )[1]
     delete Obj( as_toedit )
     if l_nonicm strip a_$ligedit. virtual
     if (l_nonicm & l_delete_h) delete a_$ligedit.//h*
     rename a_$ligedit. na
   else
     na = Name( Mol(as_toedit) )[1]
     set object Obj( as_toedit )
     delete Mol( as_toedit )
     if l_nonicm strip a_$ligedit. virtual
     if (l_nonicm & l_delete_h) delete a_$ligedit.//h*
     move a_$ligedit. a_
   endif
   if l_pharm set type a_ "Pharmacophore"
   if l_display then
     display xstick a_H
     display cpk a_//x*
   endif
 else
   global group table LIGAND_STEREO reschem "mol"
   set property display LIGAND_STEREO
   delete a_
 endif
 set term s_oldterms only
endmacro
#
macro switchChirality as_atom
  l_commands = no
  l_info = no
  s_oldObj = Name( a_ )[1]

  set object Obj(as_atom)

  icICM = Type( a_ 2 ) == "ICM"
  if (!icICM) convert auto

  set chiral as_atom 3
  vTemp = V_//FC & Next( as_atom tree )
  if (Nof(vTemp)!=0) then
    unfix vTemp
    set vTemp -Value(vTemp)
    #
    if (Nof( Ring( vTemp ))==1) then
      if (Nof( Ring( v_//!FC &  Next( as_atom tree ) ))==0)then
        set  V_//r* &  Next( as_atom tree ) add -2.*Value( Ring( vTemp ))[1]
      endif
    endif
    #
    fix vTemp
    #
    if(Nof(vTemp)==1) then
      vTempT = V_//r* & (Next( as_atom tree ) & !Atom(vTemp))
      r_out = 2.*Value(vTemp)[1]
      if(Nof(vTempT)==0) r_out=- r_out
      if(Nof(vTempT)==0) vTempT = V_//r* & Next( Next( as_atom tree ) & !Atom(vTemp) tree)
      if(Nof(vTempT)==1) then
        unfix vTempT
        set vTempT add r_out
        fix vTempT
      endif
    endif
  endif
  #if (!icICM) strip virtual
  set object a_$s_oldObj.
endmacro
#
# if ( Nof(as_attach) > 0) then  # only if a part of molecule is selected
#   rename a_//a "cx"
#   set type mmff a_//cx 1
#   build hydrogen a_//cx
#   rename (Next( a_//cx bond) & a_//h* ) [1] "hx"
# endif
#
# if( Nof(a_ligandTemplate. )==1 & l_overwriteTemplate ) delete a_ligandTemplate.
#
# if ( Nof( a_TEMPEDIT. ) > 0 ) then
#   if ( Nof(as_attach) == 0) then
#     # whole object or molecule
#     s_molnam = Name(Mol(as_toedit))[1]
#     rename a_TEMPEDIT.1 s_molnam
#     s_oldName = Name( Obj( as_toedit ))[1]
## move edited molecule from the source to a separate object for tethering
#     if( Nof( a_ligandTemplate. )==0 ) then
#       delete tether Mol( as_toedit )
#  		 copy Obj( as_toedit )[1] "ligandTemplate"
#  		 delete Select( Obj(as_toedit) & ! Mol( as_toedit ) a_ligandTemplate. )
#		 endif
#		 if(ndslig > 0) then
#			 set xstick a_ligandTemplate. 0.15
#		   display xstick a_ligandTemplate.
#			 color a_ligandTemplate.//c* lightgreen
#	   endif
#		 delete Mol( as_toedit )
#
##    convert it
#print 3
#     build hydrogen
#		 set type mmff
#		 set charge mmff
#		 randomize a_//!vt* 0.01
##
#print "before convert"
#		 convert delete
#		 set type mmff
#		 mncalls = 1000
#		 delete a_TEMPEDIT.
#		 rename a_ "TEMPEDIT"
##		 set symmetry exact
#print "before minimize"
#     minimize cartesian 3000
#		 if( i_out <500 ) minimize cartesian 3000
#     minimize cartesian 3000 s_cart_terms
#
#		 if( i_out <500 ) minimize cartesian 3000 s_cart_terms
#		 #find molecule sstructure all tether a_ligandTemplate. a_  # improve by adding polar H
#     set tether a_//!h* a_ligandTemplate.//!h*
##		 set tether a_ append   # now has chain addition effect
#print "before minimize tors"
#     superimpose a_
#     tolGrad = 0.0001
# 		 if(Nof(V_//T49)>0) unfix V_//T49
#     fix v_//F
#		 minimize s_totz_terms
# 		 fix V_//T49
#
#    if( no & Rmsd(a_//T)> 0.1 ) then
#			 superimpose a_
##			 set a_//T
#       minimize cartesian 3000 s_cart_terms
#		   if( i_out <500 ) minimize cartesian 3000 s_cart_terms
#			 superimpose a_
#    	 minimize s_totz_terms
#		 endif
#
#     if(ndslig>0) then
#		   center a_TEMPEDIT.
#		   display xstick a_TEMPEDIT.
#			 display tether a_TEMPEDIT.//T
#		 endif
#		 if(Nof(a_$s_oldName.)==1) then
#  		 move a_TEMPEDIT. a_$s_oldName.
#		 else
#  		 rename a_TEMPEDIT. s_oldName
#		 endif
#		 set object a_$s_oldName.
#		 if( Nof( v_$s_molnam//!?vt* & a_$s_molnam//!T ) > 0 ) then
#  		 mncalls = 100
#       minimize v_$s_molnam//!?vt* & a_$s_molnam//!T s_totz_terms
#       minimize v_$s_molnam//*     & a_$s_molnam//!T s_totz_terms
#	  	 mncallsMC = 1000
#       montecarlo v_$s_molnam//!?vt* & a_$s_molnam//!T  v_$s_molnam//!?vt* & a_$s_molnam//!T  s_totz_terms
#		 endif
#   else
#print "before convert2Dto3D last branch"
#     convert2Dto3D a_ yes yes no yes
#     # modify
#     set type v_//!?vt* [1] 4
#     set symmetry v_//!?vt* [1] 1
#     set object Obj( as_attach )
#     if( Nof( a_ligandTemplate. )==0 ) then
#       delete tether Mol( as_toedit )
#	  	 copy Obj( as_toedit )[1] "ligandTemplate" delete
#	  	 delete Select( Obj(as_toedit) & ! Mol( as_toedit ) a_ligandTemplate. )
#		 endif
#		 if(ndslig > 0) display a_ligandTemplate.
#
#     modify as_attach Next(a_TEMPEDIT.//cx bond) & a_TEMPEDIT.//!h*
#     delete a_TEMPEDIT.
#		 #find molecule sstructure all tether a_ligandTemplate. Mol(as_attach)
#     set tether a_//!h* a_ligandTemplate.//!h*
#		 minimize v_//* & Mol(as_attach) s_totz_terms
#
#   endif
# endif
#
# keep PROPDISTRIB
#


macro fixQuotes s_str ("")
  s_strRes = Replace( s_str, "'", "\"" )
  keep s_strRes
endmacro

#ifdef Product >= browserpro

call "movie.icm" test

#endif

macro dsHit s_hitlist i_index l_dsCPK l_dsHbond l_dsSurf l_labelRes
# relies on ligand name 'm' and receptor name 'rec'
  l_warn = no
  set object a_rec.
  delete a_m
  resvar = $s_hitlist.bindPatchRes
  if (Nof(a_ & (a_*.*//D | a_*.*/D)) == 0) then
    display xstick ($resvar | Mol(Sphere(a_m*. a_H))) & a_//!h*
    color xstick ($resvar | Mol(Sphere(a_m*. a_H))) & a_rec.//c* & a_rec.//!ca,c,cb pink
    color xstick ($resvar | Mol(Sphere(a_m*. a_H))) & a_rec.//ca,c,cb yellow
    display a_ wire gray
  endif
  mname = "m"+(($s_hitlist.IX)[i_index])
  copy a_$mname. "TMPMOL"
  move a_TMPMOL. a_
  if (l_dsCPK) display a_m cpk
  display a_m xstick
  if (l_dsHbond) then
    show hbond mute
    display hbond a_m
  endif
  if (l_dsSurf) then
    display g_pocket_rec
    if (Type(l_colorCode) == "unknown") then
      l_colorCode = yes
      keep l_colorCode
      print " Color code:"
      print " Red   - hydrogen bond acceptor"
      print " Blue  - hydrogen bond donor"
    endif
  else
    undisplay g_pocket_rec
  endif
  if (l_labelRes) then
    display residue label $resvar | Mol(Sphere(a_m*. a_H & a_!m))
  else
    undisplay residue label $resvar | Mol(Sphere(a_m*. a_H & a_!m))
  endif
endmacro

macro moveMol ms_ s_objName ("")
  l_info = no
  s_oldObj = Name( Obj( ms_ ) )
  l_iclig = String( Mol(ms_) ) == String( a_LIG.I )
  ms_ = ms_ & Obj( ms_ )[1]
	if(s_objName=="") s_objName = Name(Obj(ms_))[1]
	s_objName = Name( s_objName object )
  copy Obj(ms_) s_objName selection graphic
	delete Select( Mol( Obj(ms_) & !ms_ ) a_$s_objName. )
  delete Mol( ms_ ) & a_$s_oldObj.
  if (l_iclig) LIGAND.selection = String( Mol(ms_) simple )
endmacro

macro copyMol ms_ s_objName ("") l_oneObj (yes) auto
  HELP = """
     copies molecules from ONE object to one separate object, or splits them into different objects.
     derives object names from parent objects, preserves molecular names
     It does not overwrite the object with the same name, take care of that outside the macro
"""
  l_info=no
  if(Nof(Obj( ms_ ))>1) print " Warning> more than one object selected. using only the 1st one"
  if(Nof(ms_)==0) return error " Empty selection"
  ms_ = ms_ & ( Obj( ms_ )[1] )
  if(!l_oneObj) then # split into objects mode noone wants to take responsibility for
    n = Nof(ms_)
    for i=1,n
      s_name = s_objName=="" ? Name(Obj(ms_[i]))[1] : s_objName
	    s_name = Name( s_name object )
      copy Obj(ms_[i]) s_name
	    delete Select( Mol( Obj(ms_[i]) & !ms_[i] ) a_$s_name. )
    endfor
  else   # vintage, several molecules from one object into another 1 object
     s_name = Name( ( s_objName=="" ? Name(Obj(ms_))[1] : s_objName ) object )
     copy Obj(ms_)[1] s_name
     if(Nof(Mol(Obj(ms_) & ! ms_ ) ) > 0) delete Select( (Obj(ms_ ) & !ms_ ) a_$s_name. )
  endif
endmacro

macro appendMol ms_ s_objName ("")
  HELP="""
    appends selected molecules, from one or many objects, to a new or existing object
    The object type is defined by the 1st molecule in that object.
  """
  l_info=no; i0=1
  l_commands = no; s_msg = " Error> illegal new object name '"+s_objName+"'"
  if(Nof( a_$s_objName. )>1 | Length(s_objName)==0 | s_objName!=Name(s_objName simple)) return  error s_msg
  if(Nof( a_$s_objName. & Obj( ms_ ) )>0 ) return  error " Error> can not append to the same object"
  if(Nof( a_$s_objName. )==0) then
    if (l_info) printf " Info> creating new object and appending %s to a_%s.\n", Name(ms_ [i0] full)[1], s_objName
    copyMol ms_ & (Obj(ms_) [i0] ) s_objName yes
    i0 += 1
  endif
  for i=i0,Nof(Obj(ms_))
    if (l_info) printf " Info> appending %s to a_%s.\n", Name(ms_ & (Obj(ms_) [i]) full)[1], s_objName
    delete a_TMPAPPENDMOL.
    copyMol ms_ & (Obj(ms_)[i]) yes "TMPAPPENDMOL"
    if(Type(a_TMPAPPENDMOL. 2)=="ICM" & Type( a_$s_objName. 2)!="ICM") strip a_TMPAPPENDMOL. virtual
    if(Type(a_TMPAPPENDMOL. 2)!="ICM" & Type( a_$s_objName. 2)=="ICM") then
      convertObject a_TMPAPPENDMOL. yes no yes no yes no yes ""
    endif
    move a_TMPAPPENDMOL. a_$s_objName.
  endfor
endmacro

macro copyResSel rs_ s_objName ("") i_bridgeGapsSmallerThan (3) auto
  l_info=no
  if(Nof(rs_)==0) return error " Empty selection"
  if(Nof(Obj( rs_ ))>1) print " Warning> residues in more than one object selected. using only the 1st one"
  os1=Obj( rs_ )[1]
  if(Type(os1 2)=="ICM") return error " can only do it with unconverted PDBs"
  rs_ = Select( Res( rs_ ) & os1 , i_bridgeGapsSmallerThan )
  s_name = Name( ( s_objName=="" ? Name(os1)[1] : s_objName ) object )
# add treatment for ICM objects
  copy os1 s_name
  if(Nof(Res( os1 & ! rs_ ) ) > 0) delete Select( os1 & !rs_ a_$s_name. )
endmacro

#
macro icmPotential rs_ R_6box r_gridSize (1.) r_potStep (5.) s_term ("el") s_type ("wire")
  l_info=no

  if(Nof(Atom(rs_))>0 | r_gridSize> 0.) then   # skip if the map exists esits
    selRec = Atom( rs_ )
    selRec = selRec & Obj(selRec) [1]
    set object Obj(selRec) [1]

    if R_6box == {0. 0. 0. 0. 0. 0.} return error "\n Error> Please select an area with the purple box\n"
    if(r_potStep <0.0001) r_potStep = 5.
    if(r_gridSize<0.009) r_gridSize = 1.

    if(s_term=="el"|s_term=="ge") then
      vwCutoff = 20.
      electroMethod = "boundary element"
      show energy "el"
      C_temp =  Charge( selRec )
      set charge selRec C_temp + Rarray(Atom( selRec ))
      make map potential s_term selRec R_6box r_gridSize
      set charge selRec C_temp
    else
      make map potential s_term selRec R_6box r_gridSize
    endif
  endif

  sMap = "m_"+s_term
  if(Type( $sMap )!="map") return error " Error> map not found"
  l_confirm = no
  delete grob "gPhi*"
  rmi = Min( $sMap )
  rmx = Max( $sMap )
  make grob $sMap $s_type exact 0. name="gPhi0" white  # zero potential
  RW={1. 1. 1.}  # white
  RB={0. 0. 1.}  # blue
  RR={1. 0. 0.}  # red

  NL=Integer(Floor(rmx/r_potStep))  # number of positive layers
  if(rmx>= r_potStep) then
    for i=1,NL
      QF = 0.3 + 0.7*(2*i/Real(NL)-i*i/(Real(NL*NL)))
      sprintf "gPhiN%03d" Integer(i*r_potStep)
      make grob $sMap $s_type exact i*r_potStep name=s_out rgb=QF*RB + (1.-QF)*RW # blue
    endfor
  endif

  NL=Integer(Floor(-rmi/r_potStep))  # negative layers
  if(rmi<= -r_potStep) then
    for i=1,NL
      QF = 0.3 + 0.7*(2*i/Real(NL)-i*i/(Real(NL*NL)))
      sprintf "gPhiP%03d" Integer(i*r_potStep)
      make grob $sMap $s_type exact -i*r_potStep name=s_out rgb=QF*RR + (1.-QF)*RW # red
    endfor
  endif

  keep $sMap
  keep grob
endmacro

macro icmProteinInterfaceOda ms_ (a_*) l_makeDotsObject (no) l_makeEnergyTables (yes) R_AbsoluteRangeODA ({0. 0.})
  # calculate solvation map based on a series of surface points
  l_info= no
  l_commands=  no
  l_confirm = no

  # l_makeDotsObject :  display surface points colored by ODA value
  r_distanceLigPos = 5.  # optimal value 5.  # increase this for speed
  vwExpand = 3.

                  # calculate different radius values
  i_inirad  = Integer(vwExpand)  # initial radius for detailed search
  i_endrad  = 20  # 20 for detailed search
  i_steprad = 1   # 1 for detailed search

  l_areaBasedSf = yes #  calculates sf energy based on areas instead of the show energy "sf" directly
                      # this could provide more accurate solvation parameters, but then perhaps
                      # optimal parameters obtained from the docking landscapes should be revised (20Mar03)
  l_atomSelect = yes  # surface patches are build by atoms within a sphere from the surface point
                      # the alternative is selecting residues instead of atoms; this is faster, but less accurate
  l_resAvge = yes     # calculates the average value of all points in the vicinity (5A) of a given residue

  if Nof(Obj( ms_ ))==0 return error "\n Error> No ICM objects found. Convert the object to the ICM type first\n"
  ms_  = (Obj(ms_) & a_ICM. )[1]
  set object Obj(ms_)
  ODA_RES_ = "ODA_res_" + Name( Obj( ms_ ))[1]
  SOL_MAP_ = "solvMap_" + Name( Obj( ms_ ))[1]
  if( l_makeEnergyTables ) then
    if(Type( $ODA_RES_ )!="unknown") delete $ODA_RES_
    if(Type( $SOL_MAP_ )!="unknown") delete $SOL_MAP_
  endif
  M_surfacePoints = Xyz(ms_ r_distanceLigPos surface)
  vwExpand =  1.4
  R_dotEnergy = Rarray(Nof( M_surfacePoints) )
  R_optRad = Rarray(Nof( M_surfacePoints) )
  R_optASA = Rarray(Nof( M_surfacePoints) )
  R_dotEl = Rarray(Nof( M_surfacePoints) )
  rs_sele = Res(ms_)
  if (l_atomSelect) then
     show area surface ms_ ms_ & a_//!h* mute
     surfAtomTotal = Acc(ms_ & a_//!h*, 0.000000001)
     rs_sele = surfAtomTotal & a_//!h*  & a_//!vt*
  else
     rs_sele = Res(ms_)
  endif
  if (l_resAvge) then
    R_resSolv = Rarray( Nof(Res(ms_)) )
    S_resName = Sarray( Nof(Res(ms_)) )
    I_res = Count(Nof(Res(ms_)))
  endif
  N = Nof(rs_sele)
  if Exist(gui) print bar "Calculating solvation map" N
  s_oldterms = Info(term)
  set term only "sf"
  surfaceMethod = 3
  if (l_areaBasedSf) show energy "sf"  ms_  ms_ mute
  for i=1,N
      surfAtom = rs_sele [i] & a_//!h*
      surfPolarAtom = surfAtom & a_//!c*
      surfAromAtom = surfAtom & (a_/his,trp/C126 | a_//C124,C125)
      surfAlifAtom = surfAtom & a_//c* & !surfAromAtom
      if (Nof(surfPolarAtom) != 0 ) then
        show energy surfPolarAtom ms_ mute
        Ey_sfPolar = Energy("func")
      else
        Ey_sfPolar = 0.
      endif
      if (Nof(surfAromAtom) != 0 ) then
        if (l_areaBasedSf) then
           Ey_sfHbAr = 0.0177*Sum( Area(surfAromAtom) )
        else
           show energy surfAromAtom ms_ mute
           Ey_sfHbAr = Energy("func")
        endif
      else
        Ey_sfHbAr = 0.
      endif
      if (Nof(surfAlifAtom) != 0 ) then
        if (l_areaBasedSf) then
           Ey_sfHbAl = 0.0151*Sum( Area(surfAlifAtom) )
        else
           show energy surfAlifAtom ms_ mute
           Ey_sfHbAl = Energy("func")
        endif
      else
        Ey_sfHbAl = 0.
      endif
#    r_ene  = (  Ey_sfPolar + Ey_sfHbAr + Ey_sfHbAl )
     r_ene  = (  2.30*Ey_sfPolar + 6.26*Ey_sfHbAr + 1.27*Ey_sfHbAl ) # values from Fernandez-Recio et al; JMB 2004)
      set field (rs_sele [i]) r_ene number=1
      if Exist(gui) print bar N
  endfor
  if Exist(gui) print bar "End\n"
  show area surface (ms_ & a_//!h*) (ms_ & a_//!h*) mute
  set field Res(ms_) Rarray(Nof(Res(ms_))) number=2  # to clean the value stored in field number 2 by default after show energy "sf" command
  i_nofIter = (i_endrad - i_inirad + i_steprad)/i_steprad
  #
  N = Nof(M_surfacePoints)
  if Exist(gui) print bar "Calculating points " N
  for i=1,N
   l_calcSfptValue = yes
   if (l_calcSfptValue ) then
    R_rad = Rarray(i_nofIter)
    R_ene = Rarray(i_nofIter)
    R_ASA = Rarray(i_nofIter)
    r_maxEnergy = -10000.
    r_optRad = 0.
    for i_rad=1,i_nofIter
      R_rad [i_rad] = Real(i_inirad+(i_rad-1)*i_steprad)
      if (l_atomSelect) then
         patchRes =  rs_sele & a_//!h* & Sphere(M_surfacePoints [i] a_  R_rad [i_rad])
      else
         patchRes = Res( rs_sele & a_//!h* & Sphere(M_surfacePoints [i] a_  R_rad [i_rad]) )
      endif
      R_ene [i_rad] = Sum( Field(patchRes 1) )
      R_ASA [i_rad] = Sum( Area(patchRes & a_//!h*) )
      if (R_ene [i_rad] > r_maxEnergy ) then
         if (R_ASA [i_rad] > 0.) r_maxEnergy = R_ene [i_rad]
         r_optRad = R_rad [i_rad]
         r_optASA = R_ASA [i_rad]
      endif
    endfor
    R_dotEnergy [i] = r_maxEnergy
    R_optRad [i] = r_optRad
    R_optASA [i] = r_optASA
    if (l_resAvge) then
      nearSfptRes = Res(ms_ & Sphere(Xyz(M_surfacePoints [i]) 5.) )
      R_fieldEy = Field( nearSfptRes 2)
      R_fieldCount = Field( nearSfptRes 3)
      set field nearSfptRes (R_fieldEy + r_maxEnergy)  number=2
      set field nearSfptRes (R_fieldCount + 1.) number=3
    endif
    r_perc = 100.*Real(i)/Nof(M_surfacePoints)
    if Exist(gui)  printf " %d%% done\r" Integer(r_perc)
   endif
   if Exist(gui) print bar N
  endfor
  if Exist(gui) print bar "End\n"
  print
  M_xyz = M_surfacePoints
  R_ODAvalue = -1.*R_dotEnergy
  R_radopt = R_optRad
  I_point = Count(Nof(M_xyz))
  group table SOL_MAP_ I_point "Number" M_xyz [?,1] "R_x" M_xyz [?,2] "R_y" M_xyz [?,3] "R_z" R_ODAvalue "ODAvalue" R_optASA "ODAarea"
  group table append $SOL_MAP_ header "center %@.R_x[ %# ] // %@.R_y[ %# ] // %@.R_z[ %# ] // 5." "cursor"
  if( l_makeEnergyTables ) write table  $SOL_MAP_

  if (l_resAvge) then
     for i=1,Nof(Res(ms_))
       S_resName [i] = String(Split(Label(Res(ms_) [i]) [1] "  "))
     endfor
     R_avgeODA = -1.*(  Field( Res(ms_) 2) /( Field( Res(ms_) 3) + 0.0000000001 )  )
     group table  $ODA_RES_  I_res "Number" S_resName "residue" R_avgeODA "avgeODA"
     add header $ODA_RES_ "as_graph = a_"+Name(Obj(ms_))[1]+"."+Name(Mol(ms_))[1]+"/%1\ncenter as_graph" name="doubleClick"
     set property $ODA_RES_.doubleClick show off
     write csv  $ODA_RES_
  endif

  if (!l_makeDotsObject) then
    for i=1, Nof(M_surfacePoints)
      if(R_AbsoluteRangeODA[1]!=R_AbsoluteRangeODA[2])then
        a = 1. - Trim(( $SOL_MAP_.ODAvalue [i] - R_AbsoluteRangeODA[1])/(R_AbsoluteRangeODA[2]-R_AbsoluteRangeODA[1])  0. 1.)
      else
        a = (Max( $SOL_MAP_.ODAvalue )- $SOL_MAP_.ODAvalue [i])/(Max( $SOL_MAP_.ODAvalue )-Min( $SOL_MAP_.ODAvalue ))
      endif
      g = Grob( "SPHERE" 0.25+a 3 )
      translate g M_surfacePoints [i,?]
      color g 127.*a
      if(i==1)g_aoda=g
      if(i!=1)g_aoda=g_aoda//g
    endfor
    keep g_aoda
  endif
  if (l_makeDotsObject) then
    if(Nof(a_dots.)>0) delete a_dots.
    build string Sum(Sarray(Nof(M_surfacePoints),"\nml ")+Sarray(Nof(M_surfacePoints),"\nse o")) name="dots"
    ms_ = ms_ & !a_
    set a_//o M_surfacePoints
    if(R_AbsoluteRangeODA[1]!=R_AbsoluteRangeODA[2])then
      klr = 1. - Trim(( $SOL_MAP_.ODAvalue - R_AbsoluteRangeODA[1])/(R_AbsoluteRangeODA[2]-R_AbsoluteRangeODA[1]) 0. 1.)
    else
      klr = (- $SOL_MAP_.ODAvalue - Min(- $SOL_MAP_.ODAvalue ))/(Max( $SOL_MAP_.ODAvalue )-Min( $SOL_MAP_.ODAvalue ))+0.01
    endif
    set xstick a_//o klr
    set field number=1 Res( a_* ) - $SOL_MAP_.ODAvalue
    if(Exist(display))then
      display xstick a_//o
      color xstick a_//o klr // { 0. 1. }
    endif
    set object Obj(ms_) # restore
  endif

  set field Res(ms_) - $ODA_RES_.avgeODA number=1
  if(Exist(display) & Nof( ms_ & a_*.//DWXCS ) > 0 ) color Res(ms_ ) - $ODA_RES_.avgeODA
  if(Exist(display) & Nof( ms_ & a_*./DR     ) > 0 ) then
    color ribbon Res(ms_ ) - $ODA_RES_.avgeODA
    display residue label Select( Res(ms_) "u>10.") # some labels
  endif
  print " Warning> to color by the prediction, select Color by Res. User Field from the Representation popup menu"


  if( l_makeEnergyTables ) keep $SOL_MAP_ R_dotEnergy R_optRad M_surfacePoints
  if (l_resAvge & l_makeEnergyTables ) keep $ODA_RES_
  set term s_oldterms only
endmacro

macro makeNewHtml s_name ("html1") l_pop (yes) s_text ("")
  s_name1 = Name( s_name unique )
  $s_name1 = "<html>\n<head><title>\n"+s_name1+ "\n</title></head>\n<body text=black bgcolor=white>\n\n"
  $s_name1 += s_text
#  $s_name1 += "\n\n<p><!--icmscript name=\"ACTION1\"\nprint \"Edit icm commands here \"\nprint \"Another command\"\n -->\n\n<a name=\"ACTION1\" href=\"#_\">\nAction Link\n</a></p>"
#  $s_name1 += "\n<p><!--icmscript name=\"ACTION2\"\n#dialog{\"Dialog Title\"}\n# i_number1 (3)\n# i_number2 (7)\nprint \"The sum: \", $1 + $2 \n -->\n\n<a name=\"ACTION2\" href=\"#_\">\nDialog Link\n</a></p>"
  $s_name1 += "\n\n</body>\n</html>\n"
  if(   l_pop ) set property html auto $s_name1
  if( ! l_pop ) set property html      $s_name1
  keep $s_name1
endmacro

macro calcBindingArea as_1 as_2
  l_commands = no
  l_info = no
  show surface area mute as_1 as_1
  a1 = r_out
  show surface area mute as_1  as_1 | as_2
  a1x = r_out
  show surface area mute as_2 as_2
  a2 = r_out
  show surface area mute as_2  as_1 | as_2
  a2x = r_out
  if(Type(AREAS)=="table") then
    add AREAS AREAS[1]
  else
    global group table AREAS Sarray(1) "SetA" Sarray(1) "SetB"  Rarray(1) "PatchA" Rarray(1) "AreaA" Rarray(1) "PatchB"  Rarray(1) "AreaB" Rarray(1) "Total_Area" Rarray(1) "ContactMean"  Sarray(1) "Comment"
  endif
  n=Nof(AREAS)
  AREAS.SetA  [n]=((Type(as_1 1)=="molecule"|(Type(as_1 1)=="residue" & Nof(Res(as_1))==Nof(Res(Mol(as_1))))) & Nof(Mol(as_1))==1)?(Name(Mol(as_1) full)[1]):String( Res(as_1) name )
  AREAS.SetB  [n]=((Type(as_2 1)=="molecule"|(Type(as_2 1)=="residue" & Nof(Res(as_2))==Nof(Res(Mol(as_2))))) & Nof(Mol(as_2))==1)?(Name(Mol(as_2) full)[1]):String( Res(as_2) name )
  AREAS.PatchA[n]=Integer(10*(a1-a1x))/10.
  AREAS.AreaA [n]=Integer(10*a1)/10.
  AREAS.PatchB[n]=Integer(10*(a2-a2x))/10.
  AREAS.AreaB [n]=Integer(10*a2)/10.
  AREAS.ContactMean[n]= 0.5*(AREAS.PatchA[n]+ AREAS.PatchB[n])
  AREAS.Total_Area[n] = Integer(10*(a1x+a2x))/10.
  set format  AREAS.PatchA  AREAS.AreaA   AREAS.PatchB  AREAS.AreaB  AREAS.ContactMean AREAS.Total_Area "%.1f"
endmacro

macro calcArea ms_
  l_commands = l_info = no
  ms_ = Mol( ms_ & a_*.!W )
  if(Nof(ms_)==0) return
  add column local t Sarray(0) Rarray(0) Rarray(0) Rarray(0)
  for iobj = 1,Nof(Obj(ms_))
    set object Obj(ms_)[iobj]
    as_out  = ms_ & a_
    show surface area as_out as_out
    add column local tt Name(as_out full)//Name(a_ full) Rarray(Nof(as_out))//r_out Rarray(Nof(as_out))//r_out Rarray(Nof(as_out))//100.
    for iml = 1,Nof(as_out)
      as2_out = as_out & ( as_out [iml] )
      tt.B[iml] = Sum( Area( Res( as2_out )))
    endfor
    for iml = 1,Nof(as_out)
      as2_out = as_out & ( as_out [iml] )
      show surface area as2_out as2_out
      tt.C[iml] = r_out
      tt.D[iml] = 100.*tt.B[iml]/(r_out + 0.0000001)
    endfor
    add t tt
    delete tt
  endfor
  add column t t.C-t.B Rarray(Nof(t),100.)-t.D  name="area_buried"//"percent_buried"
  # add column t Parray(grob, Nof(t)) name="mesh"
  # make grob skin ms_ ms_
  # t.mesh[1] = Parray( $s_out ) ; # delete $s_out
  set format t.A 100 "<!--icmscript name=\"1\"\nas_graph = (as_graph== %1 )?a_!*. :  %1\ncool as_graph\n--><a href=#_>%1</a>"  comment = "molecular selection. click to display and toggle selection"
  set format t.B "%.1f" 70 comment = "solvent exposed area of molecules in the context of selected molecules in the object"
  set format t.C "%.1f" 70 comment = "surface area of one molecule in isolation"
  set format t.D "%.1f" 60 comment = "relative exposure in percents"
  rename t.A "sel"; rename t.B "area_exposed"; rename t.C "area_total"; rename t.D "percent_exposed"
  set format t.area_buried    "%.1f"
  set format t.percent_buried "%.1f" color="rainbow='#FFFFFF/#FFAAAA/#8888FF,0.:100.,pinwheel'"

  if(Type(AREAS)!="unknown") delete AREAS
  rename t 'AREAS'
  keep AREAS
endmacro

macro calcBindArea as_
  l_commands = no
  l_info = no
  if(Type(as_ 1)=="atom") print " Warning> all atoms in selected residue are used to calc. areas."
  as_ = as_ & !a_*.W
  if(Nof(as_)>0) then
    calcBindingArea Res( as_ ) Res( Obj(as_)[1] & !Res(as_) & a_!W/DD )
  else
    calcArea Select(residue) & Select(object)[1] & ! a_*.W
  endif
endmacro

macro calcResContactPairs rs_1 (a_A/) rs_2 (a_A/)
#need new version of Area ( rsi rsj residue )  => R_ to look only on SC
  rs_1 = Res(Obj(rs_1)[1] & rs_1)
  rs_2 = Res(Obj(rs_1)[1] & rs_2)
  l_self = (rs_1 == rs_2) ? yes : no
  if( !l_self) rs_2 = rs_2 & ! rs_1
  ni=Nof(rs_1); nj=Nof(rs_1); nrw = Integer(20*Sqrt(ni*nj)); irw=0;
  tbna = "Contact_"+ Name(Obj(rs_1)[1])[1] + (l_self?"":"_nb")
  tbre = Replace(tbna,"act_","Res_")
  delete $tbna $tbre mute
  global add $tbna  column Iarray(nrw) Iarray(nrw) Iarray(nrw) Sarray(nrw) Sarray(nrw) Rarray(nrw) Rarray(nrw)
  for i=1,nj
    rsi = rs_1[i]
    inum = Iarray(rsi number ) [1]
    for j= (l_self?(i+1):1),nj
      rsj = rs_2[j]
      jnum = Iarray(rsj number ) [1]
      if( Mol(rsi)==Mol(rsj) & inum >= jnum ) continue
      cnij = Area( rsi , rsj , residue )[1]  # includes the whole residue n,ca,c,o,h*
      if( cnij > 0.01 ) then
        irw += 1;
        if(irw>=nrw) continue
        $tbna.A [irw]= inum
        $tbna.B [irw]= jnum
        $tbna.C [irw]= Abs( inum-jnum )
        $tbna.D [irw]= Name( rsi full )[1]
        $tbna.E [irw]= Name( rsj full )[1]
        $tbna.F [irw]= cnij
        $tbna.G [irw]= Area( rsi , rsj , only )[1]
      endif
    endfor
  endfor
  delete $tbna.G < 0.1 & $tbna.F < 0.5
  sort $tbna.G reverse
#
  $tbre = $tbna
  $tbre.A = $tbna.B ; $tbre.B = $tbna.A
  $tbre.D = $tbna.E ; $tbre.E = $tbna.D
  if(l_self) add $tbre $tbna
  sort $tbre.E
  group $tbre.E $tbre.G "sum,GA" $tbre.B "uniq,BA" $tbre.A "uniq,AA" $tbre.D "uniq,D"
  $tbre.D = Replace( $tbre.D , ",a_","|a_")
  set format show off $tbre.AA $tbre.D
#
  set format $tbna.F $tbna.G "%.1f" color="rainbow='#FFFFFF/#FFFF88/#44FF88,0.:2.3,pinwheel'"
  set format $tbre.GA "%.1f" color="rainbow='#FFFFFF/#FFFF88/#44FF88,0.:5.,pinwheel'"
  add header $tbna "center %4 | %5 margin=15.\n display xstick residue label %4 | %5 \n as_graph= Atom( %4 | %5 )" name="doubleClick"
  add header $tbre "center %4 margin=15.; display xstick %3 ; display cpk residue label %4; as_graph= Atom( %4 )" name="doubleClick"

# alignment

  keep $tbna $tbre
endmacro

macro calcResContactAreas rs_1 (a_1) rs_2 (a_2) l_display (yes) i_xstick_zoom (100)
HELP = """
  calculate residue contact areas between ligand and receptor in the same or separate objects.
  Syntax:
   calcResContactAreas <rs_1> <rs_2> l_display (yes) i_xstick_zoom (100)
  Arguments:
    residue selection may be in the same or different objects. Objects do not need to be converted.
    waters are skipped.

"""
  l_commands = no
  l_showResCodeInSelection=yes
  if i_xstick_zoom <= 10 i_xstick_zoom = 0
  r_zoom = i_xstick_zoom/15000.
  if Nof(Obj(rs_1))!=1 | Nof(Obj(rs_2))!=1  return error " Error> multiple objects in one of the two selections"
  os1 = Obj( rs_1 )[1];  os2 = Obj( rs_2 )[1]
  rs_1 = Res( rs_1 ) & os1 & a_*.!W
  rs_2 = Res( rs_2 ) & ! Res(rs_1) & os2 & a_*.!W
  i_out = 0; delete a_TMP. mute  # nof contacts
  if Nof(rs_1)==0  return " Error> the first selection (the source) is empty"
  if Nof(rs_2)==0  return " Error> the second selection is empty"
  if Nof(Sphere(rs_2, rs_1 , -2. ))==0 return " Warning> No contacts. The second selection is empty or too far from the source"
  if Nof(os1 & os2 )==0 then  # if selections in diff. objects, make a single tmp object with both selections.
    rs1old = rs_1 ; rs2old = rs_2
    copy os1 "TMP" ; copy os2 "TMP2" ; rs_1 = Select( rs_1 a_TMP. ) ; rs_2 = Select( rs_2 a_TMP2. ) ;
    delete Obj(rs_1) & ! rs_1 ; delete Obj(rs_2) & ! rs_2 ; move a_TMP2. a_TMP.
  endif

  vwExpand = 0.7   # this parameter will focus on stronger contacts (comp to 1.4)
  show surface area rs_1 rs_1 mute l_info=no  # compute the surfaces with the above params.
  a1 = Area( Res(rs_1))
  at1 = Area( Atom(rs_1))
  show surface area rs_2 rs_2 mute l_info=no
  a2 = Area( Res(rs_2))
  at2 = Area(Atom(rs_2))
  show surface area rs_1 | rs_2  rs_1 | rs_2 mute l_info=no
  a12 = Area( Res(rs_1))
  a21 = Area( Res(rs_2))
  at12= Area(Atom(rs_1))
  at21= Area(Atom(rs_2))
  if ( Type ( Contact  ) != "unknown" )delete Contact
  if ( Type ( Contact2 ) != "unknown" )delete Contact2
  if Nof(a_TMP.)>0  then  # move selection from a_TMP. back to sources for correct references in Contact table
    rs_1 = rs1old
    rs_2 = rs2old
    delete a_TMP.
  endif
  add column Contact  Sarray(Res(rs_1) residue) a1-a12 a1
  sort Contact.B reverse
  add column Contact2 Sarray(Res(rs_2) residue) a2-a21 a2
  sort Contact2.B reverse
  add  Contact Contact2
  delete Contact2
  delete Contact.B<0.01
  add column Contact Trim(Iarray((Contact.B/Contact.C)*100.),0,100) name="PercentBuried"
  add header Contact "as_graph = as_graph | Sphere( Select( Atom( a_%1 ), \"u>0.01\") 1.3)\n" name="doubleClick"
  set format Contact.B Contact.C "%.1f"
  rename Contact.B "ContactArea"
  rename Contact.C "ExposedArea"
  keep global Contact

  add column Contact Sarray(Nof(Contact)) name="Closest_Atom"
  add column Contact Rarray(Nof(Contact)) name="Closest_Dist"
  for i=1,Nof(Contact)
    s_res = Contact.A[i]

    if ( Nof( rs_1 & a_$s_res ) > 0 ) then
      as_atoms = Sphere(  a_$s_res & a_*.//!h*,!vt*  rs_2 & a_*.//!h*,!vt* 5 )
    else
      as_atoms = Sphere(  a_$s_res & a_*.//!h*,!vt*  rs_1 & a_*.//!h*,!vt* 5 )
    endif

    if (Nof(as_atoms) > 0) then
      R_dist = Distance( a_$s_res as_atoms all )
      i_min = Min( index R_dist )
      i_min = Mod( (i_min-1), Nof(as_atoms) ) + 1
      Contact.Closest_Atom[i] =  String( as_atoms [i_min] simple )
      Contact.Closest_Dist[i] =  Min( R_dist )
    endif
  endfor
  set format Contact.Closest_Atom """
  <!--icmscript name="1"
  center static %1 margin=7.
  display atom label %1
  --><a href=#_>%1</a>
"""

  set field Res(rs_1) Trim( (a1-a12), 0., 999. )
  set field Res(rs_2) Trim( (a2-a21), 0., 999. )
  set field Atom(Mol(rs_1|rs_2)) 0.
  set field Atom(rs_1) Trim( (at1-at12) , 0.  999.)
  set field Atom(rs_2) Trim( (at2-at21) , 0.  999.)
  as_out =  Select( Res(rs_1|rs_2) , "u>10." )
  if l_display then
#    add slide "BeforeContacts"  # to be able to restore
    if i_xstick_zoom!=0 set xstick Res(as_out)&a_*.!H,W  Trim( Field(Res(as_out & a_*.!H,W ))*r_zoom , 0.1, 1.)
    if i_xstick_zoom==0 set xstick Res(as_out) 0.
    display ribbon Mol(as_out); # color ribbon rs_1 lightgreen; color ribbon rs_2 lightyellow;
    display xstick Res(as_out)
    set label Select(Atom( rs_1|rs_2 ) "u>0.01")
    display residue label Res(as_out) # white
#    color xstick cpk Select(Atom( rs_1      ) "u>0.01")  & a_*.//c* lightgreen
#    color xstick cpk Select(Atom( rs_2      ) "u>0.01")  & a_*.//c* lightyellow
#    color xstick cpk Select(Atom( rs_1|rs_2 ) "u>0.01")  & a_*.//o* lightcoral
#    color xstick cpk Select(Atom( rs_1|rs_2 ) "u>0.01")  & a_*.//n* lightblue
#    color residue label Select( Res(rs_1|rs_2) , "u>60." ) green
#    color skin cpk Res(as_out) -Trim(Field( Res(as_out) ),-150.,150.) //-150.//150.
#    color skin cpk white !Select(Atom( rs_1) "u>0.01")
  endif
endmacro

macro calcContactAreas ms_ ( a_A )
  l_commands = no
  ms_ = Mol( ms_ ) & a_*.!W,M
  n = Nof( ms_ )
  if n<=1 return
  n = (n*(n-1))/2
  sphRad = 3.8
  delete ContactAreas l_warn = no
  add column ContactAreas Sarray(n) Sarray(n) Iarray(n) Iarray(n) Iarray(n) name={'A','B','ContactArea','AreaA','AreaB'}
  add header ContactAreas "as_graph= Res(Sphere( a_%1 a_%2 -1.4)|Sphere( a_%2 a_%1 -1.4))\n" name="doubleClick"
  ill = 0
  R_out=Rarray( Nof( ms_ ) )
  for i=1,Nof( ms_ ) # precompute areas
    show surface area mute ms_ [i] ms_ [i]
    R_out[i] = r_out
  endfor
  for i=1,Nof( ms_ )-1
    for j=i+1, Nof( ms_ )
      ill= ill+1
      ContactAreas.A[ill]= Name( Obj(ms_ [i] ))[1]+"."+Name( ms_[i] )[1]
      ContactAreas.B[ill]= Name( Obj(ms_ [j] ))[1]+"."+Name( ms_[j] )[1]
      si = Nof(Sphere( ms_ [j] & a_*.//!h* ms_ [i] & a_*.//!h* sphRad ))
      if si > 0 then
        sj = Nof(Sphere( ms_ [i] & a_*.//!h* ms_ [j] & a_*.//!h* sphRad ))
      else
        sj = 0
      endif
      if( Nof(Obj( ms_ )) == 1 & si > 0 & sj > 0 ) then
        show surface area mute  ( ms_ [i] | ms_ [j] ) ( ms_ [i] | ms_ [j] )
        a1=R_out[i]
        a2=R_out[j]
        a12 = r_out
        ContactAreas.ContactArea [ill] = Integer( 0.5*(a1+a2-a12) )
        ContactAreas.AreaA[ill] = Integer( a1 )
        ContactAreas.AreaB[ill] = Integer( a2 )
      endif
    endfor
  endfor
  delete ContactAreas.ContactArea ==0
  sort ContactAreas.ContactArea reverse
  set format ContactAreas.ContactArea color="rainbow='#FFFFFF/#EEEEFF/#88FFFF/#8888FF,0.:1500.,pinwheel'"
  keep ContactAreas
endmacro

macro calcLigContactPairs ms_rec ms_lig
  as_rec = ms_rec & !Mol(ms_lig) & a_*.//!h*
  as_lig = ms_lig & a_*.//!h*
  sn = "di_"+String(Mol(ms_rec) simple molecule)[3:99]+"_"+Name(Mol(ms_lig))[1]
  make distance as_lig as_rec 3.8 name=Name(sn[1:99] simple)  # needs to be -1.2
  if(i_out>0) keep $s_out
endmacro

macro loadEDS s_pdb ("1mui") l_diffmap (no) r_sigma (0.)
  l_commands = no; l_info = no; sdir = ""
  # file cashing
  s_pdb = Tolower(s_pdb)
  s_maptype=l_diffmap?"diff":"2fofc"; s_out = ""
  s_mapext = (l_diffmap?"_diff":"")
  edsu=s_userDir + "/data/eds/"+s_pdb+s_mapext+".map"
  edsg=TOOLS.edsDir+"/"+s_pdb+s_mapext+".map"
  varmap = "m_"+s_pdb+s_mapext
  if(Exist(edsu)) then
    read map edsu
    s_out = " Info> "+s_maptype+" map loaded from "+edsu
  elseif(Exist(edsg)) then
    read map edsg
    s_out = " Info> "+s_maptype+" map loaded from "+edsg
  else
    loadEDSweb s_pdb l_diffmap
    if(Type( $varmap ) == "map" ) then
      s_out = " Info> "+s_maptype+" map loaded from the PDB server"
      if( TOOLS.edsDir!="" ) then
        if( Exist(TOOLS.edsDir write) ) sdir = TOOLS.edsDir
      endif
      if( sdir=="" ) then
         sdir=s_userDir + "/data/eds/"
         if(!Exist(sdir)) make directory sdir
      endif
      write map $varmap sdir+s_pdb+s_mapext
      compress binary sdir+s_pdb+s_mapext+".map" delete
    else
      if(l_warn) print " Warning> could not load "+s_maptype+" map for "+s_pdb+s_mapext+" from Uppsala"
      return
    endif
  endif

  if (r_sigma>0.001)  then
    if (Nof( a_$s_pdb. ) >0 & r_sigma>0.001) then
      make grob $varmap r_sigma Res(Sphere( a_$s_pdb. 6.)) header
    else
      make grob $varmap
    endif
    keep grob
  endif
  if(l_warn) print s_out
  keep $varmap
endmacro

macro loadEDSweb auto s_pdb ("1mui") l_diffmap (no)
  l_commands = l_info = no; s_out = ""
  pdbcode = Tolower(Trim(s_pdb all)[1:4])
  s_mapext = (l_diffmap?"_diff":"")
  varmap = "m_"+s_pdb+s_mapext

  request = "http://www.ebi.ac.uk/pdbe/coordinates/files/" + pdbcode + s_mapext + ".ccp4"
  read map request l_info=yes l_warn=no
  if(Error(2779)|Type($varmap)!="map") s_out = " Warning> map for '"+pdbcode+"' could not be downloaded from PDB server"
  if(l_warn & s_out!="") print s_out
  keep map
endmacro

# the old one
#macro contourEDS s_mapName r_level (1.5) l_display (yes)
#  if(Nof(Select())!=0) then
#    s_out = s_mapName + Name(String(Integer( r_level *10)),simple)
#    s_out[1]="g"
#    s_locMap = Name(s_mapName unique)
#    $s_locMap = Map( $s_mapName Index( $s_mapName Select() ) )
#    make grob $s_locMap r_level name=Name(s_out,unique) lightblue header
#    if(Nof( $s_out )==0) then
#        delete $s_out
#    else
#      if l_display display $s_out
#      keep $s_out $s_locMap
#    endif
#  endif
#endmacro

macro loadToxins
  l_commands = l_info = no
  delete toxins l_warn = no
  read table mol "http://www.t3db.ca/system/downloads/current/structures.zip" name="toxins"
  read json "http://www.t3db.ca/system/downloads/current/moas.json.zip" name="toxin_moas_"
  toxin_moas =  Table(toxin_moas_ )
  read json "http://www.t3db.ca/system/downloads/current/targets.json.zip" name="toxin_targets_"
  toxin_targets = Table( toxin_targets_ )
  delete column toxins 3 34
  keep toxins toxin_moas toxin_targets
endmacro

macro trimMapSelection m_map as_
  make map potential as_ Box( m_map ) name="m_tmp"
  s_trimmedMap = Name("m_local",unique)
  $s_trimmedMap =Bracket(100.*Smooth(Smooth(Smooth(m_tmp,"expand"),"expand"),"expand"),0.,1.)*m_map
  keep $s_trimmedMap
endmacro

macro contourEDS s_mapName R_sigmas ({1.0, 2.5}) S_colors ({"yellow","blue"}) l_display (yes) l_trim (no) as_ (a_NONE.) auto
# this one is for wire only
  l_commands = yes; l_diffmap=no
  if( Type( $s_mapName ) != "map" ) then
     if(Length(s_mapName)==6 | Length(s_mapName)==11) then
       spdb = s_mapName[3:6] ; l_diffmap = no ; if(Length(s_mapName)==11) l_diffmap=yes
       loadEDS spdb l_diffmap 0.
     else
       return error " Error> map not found"
     endif
  endif
  if(Nof(as_)>0) then
    sTrimMapName  = Name( s_mapName ,unique)
    $sTrimMapName = Map( $s_mapName , Res( as_ ) )
    make map potential as_ cell= $sTrimMapName name="maptmp"
    if(l_trim) $sTrimMapName = $sTrimMapName * Trim( maptmp , 0., 1. )
    delete maptmp
  else
    sTrimMapName = s_mapName
  endif
  if(l_diffmap & R_sigmas[1]==1. & R_sigmas[2]==2.5) R_sigmas={2.0,-2.0} # automatically redefine defaults for diff maps
  for isig = 1, Nof( R_sigmas )
    s_gname = sTrimMapName
    s_gname[1]="g"
    s_gname = Name(s_gname,unique)
    make grob $sTrimMapName R_sigmas[isig] name= s_gname header
    s_tmp = S_colors[isig]
    if(Exist(gui)) then
       color $s_gname $s_tmp
       if(l_display) display $s_gname
    endif
  endfor
  keep map
  keep grob
endmacro


macro convertXrayMap2Grid m_map r_gridSize (0.5) l_display
  if(Nof(Select())!=0) then
    make map potential m_map Select() lightblue r_gridSize
    if(Nof( m_xr )==0) then
        delete m_xr
    else
      if l_display display m_xr
      keep m_xr
    endif
  endif
endmacro

macro addSwiss
#  l_commands = yes

  for iter = 1,4
    msp = a_!P & a_A & a_J9
    if (Nof(msp)==0 ) break
    ms1 = msp[1]
    find database fast=90 Trim( Sequence( ms1 ), S_proteinTags ) s_uniprotDir + "spfas" name="hits"
    if Type(hits)=="table" then
      sort reverse hits.SC
      if(Nof(hits)>0 & hits.Ident[1]>96.) then
        set swiss Select( Sequence(ms1) a_A 0.96 0.96 ) hits.NA2[1]
      endif
    else
      set swiss Select( Sequence(ms1) a_A 0.96 0.96 ) "not_found"
    endif
  endfor  # end of iterations
  for i=1,Nof(a_A)
    if( Name( a_A [i] swiss )[1] == "not_found" ) set swiss a_A [i] ""
  endfor


  if( Nof( Name( a_P & a_A , swiss )) >0 ) then
    if(Type(sprot)!="table") then
       if(Exist(s_uniprotDir+"sprot.inx")& Exist(s_uniprotDir+"sprot.dat") ) then
         global read index s_uniprotDir+"sprot.inx"
       else
          print " Warning> can not find readable s_uniprot dat and inx files"
       endif
    endif
    read sequence swiss sprot.ID==Unique(Sort(Name(a_P & a_A , swiss))) l_info=yes
    seqnams = Name(sequence)
    keep sequence
  endif

  make sequence a_P & a_A
  for j=1,Nof(seqnams)
# rd sw names V_ or A_ can not be understood by align, e.g. 2hye. Extend align to return i_out and s_out
    align $seqnams[j] name=Field(seqnams[j],1,"_")+"_ali"  # no spaces $ay[i] !!
    link a_P & a_A  alignment
  endfor
  set site a_P swiss  # transfer sites from swissprot masters
  keep alignment
endmacro

macro readUniprot4pdb
  l_info=no
  if(Exist(s_uniprotDir+"sprot.inx")& Exist(s_uniprotDir+"sprot.dat") ) then
    if(Type(sprot)!="table") global read index s_uniprotDir+"sprot.inx"
    read sequence swiss sprot.ID==Unique(Sort(Name(a_*.P & a_*.A , swiss))) l_info=yes
    if i_out == 0 print " readUniprot4pdb> no uniprot sequences found"
  else
    print " Warning> this macro needs the donwloaded sprot.dat and sprot.inx files in s_uniprotDir"
  endif
  keep sequences
endmacro

macro readUniprotlist S_ids
  l_info=no; if(Nof(S_ids)==0) return " Empty list"
  if(Exist(s_uniprotDir+"sprot.inx")& Exist(s_uniprotDir+"sprot.dat") ) then
     if(Type(sprot)!="table") global read index s_uniprotDir+"sprot.inx"
     if(Type(sprot)=="table") read sequence swiss sprot.ID==S_ids
  else
     printf " Info_readUniprotlist> reading %d sequences from the web\n", Nof(S_ids)
     for i=1,Nof(S_ids)
       read sequence swiss "http://www.uniprot.org/uniprot/"+S_ids[i]+".txt"
     endfor
  endif
  keep sequences
endmacro

alias searchSWS readUniprot
macro readUniprot s_query ("")
  s_query=Trim(s_query,all);  i_out = 0
  if(Exist(s_uniprotDir+"sprot.inx")& Exist(s_uniprotDir+"sprot.dat") ) then
    if(Type(sprot)!="table") global read index s_uniprotDir+"sprot.inx"
    if(s_query=="") return
    if(Type(sprot)=="table") read sequence swiss sprot.ID==s_query
  endif
  if(i_out==0) then
    readUniprotWeb s_query no
    if(Type(swiss_hits)=="table") keep swiss_hits
  endif
  keep sequences
  keep i_2out
endmacro

macro readUniprotWeb auto s_query l_references (no) i_maxHits (200)
  l_commands = no
  l_info=no
  l_warn = no
  errorAction = "none"
  l_ok = no
  s_query = Trim(s_query)
  s_id = s_query
  if (Match( s_query, "^[A-Z0-9]+_[A-Z0-9]+$") != "") then
    read sequence swiss web "mnemonic:" + s_query
    l_ok = !Error()
  elseif (Match( s_query, "^[A-Z][0-9]{3,}$") != "") then
    read sequence swiss web "id:" + s_query
    l_ok = !Error()
  endif
  if (!l_ok) then
    read table header separator = "\t" "http://www.uniprot.org/uniprot/?query=" + String(s_query,html) + "&format=tab&columns=id,entry%20name,reviewed,protein%20names,genes,organism,length&limit=" + i_maxHits name="swiss_hits"
    if Error() | (Type(swiss_hits) != "table") return " Info> No hits found"
    id_col = Name( swiss_hits )[1]
    if (Nof(swiss_hits)==1) s_id = $id_col [1]
  endif

  if (l_ok | Nof(swiss_hits)==1) then
    read string "http://www.uniprot.org/uniprot/" + s_id + ".txt" name="s_tmp"
    if (!l_ok) then
      read sequence swiss input = s_tmp
    endif
    keep global sequence
    if(l_references)then
      if(Type(REFERENCES)!="unknown")delete REFERENCES
      read database input = Sum(Match( Split( s_tmp "\n" ) "^R.*" only) "\n" )
      group table "REFERENCES" $s_out
      REFERENCES.RX = Replace( Match( REFERENCES.RX "PubMed=.*; " ) { "PubMed=" "; " } {"" "" } )
      set format REFERENCES.RX "<a href=https://www.ncbi.nlm.nih.gov/pubmed/%1>%1</a>"
      rename REFERENCES.RX "PubMed"
      keep global REFERENCES
    endif
  else
    id_col = Name( swiss_hits )[1]
    set format $id_col "<a href=http://www.uniprot.org/uniprot/%1>%1</a>"
    id_col = Replace( id_col "swiss_hits" "%@" )
    add header swiss_hits name="doubleClick" "read sequence \"http://www.uniprot.org/uniprot/\" + " + id_col + "[%#] + \".txt\""
    keep global swiss_hits
  endif
endmacro

macro readUniprotCloud S_query S_type l_quiet (no)
    if (Nof(S_query) == 0) return
    l_info = l_warn = no
    XTmp = readUniprotCloudInfoJson(S_query, S_type)
    if (Nof(XTmp) == 0) then
      print " Info> trying direct search in www.uniprot.org ..."
      readUniprotWeb Sum(S_query," ")
      return
    endif
    XTBL = Table(XTmp)
    if ! Exist(XTBL.data) then
        delete XTBL
        return
    endif
    if (!l_quiet) print "Data retrieved, ICM converting..."
    XTBL = readUniprotCloudInfoJsonTable(XTBL)
    # domain info
    XDLST = Unique(Match(Split(Sum(XTBL.Site "\n") "\n") "(\w{1,8}) \(([0-9><\?]{1,999})\-([0-9><\?]{1,999})\) (.*)" 1) sort)
    XDLST = XDLST != "INIT_MET" ; XDLST =  XDLST != "NON_STD" ; XDLST =  XDLST != "SITE" ; XDLST =  XDLST != "MOD_RES" ; XDLST =  XDLST != "DISULFID" ; XDLST =  XDLST != "DISULFID" ; XDLST =  XDLST != "UNSURE" ; XDLST =  XDLST != "CONFLICT" ; XDLST =  XDLST != "NON_CONS" ; XDLST =  XDLST != "NON_TER"
    XDLST = {"All"} // XDLST
    # header
    sprintf "readUniprotCloudLoadSeq Name(variable %%@) Index(%%@ selection cursor);" name="XHD"
    add header XTBL name="doubleClick" XHD
    # cursor
    sprintf """# b_Load_sequence_from_selection (readUniprotCloudLoadSeq Name(variable %%@) Index(%%@ selection cursor))
# b_Make_sequence_alignment_from_selection (readUniprotCloudMakeAlign Name(variable %%@) Index(%%@ selection cursor))
# b_Extract_site_from_selection (readUniprotCloudExtractSite Name(variable %%@) $dtype Index(%%@ selection cursor))
# s_Site_type:dtype (%s) [RDONLY]""", Sum(XDLST,"|") name="XCUR"
    add header XTBL name="cursor" XCUR
    xtblnm = "uniprot_" + Sum(Name(S_query simple) "_")
    if (Nof($xtblnm)!=0) delete $xtblnm
    rename XTBL xtblnm
    keep $xtblnm
    keep i_2out
    print xtblnm, "hit table loaded"
endmacro

function readUniprotCloudInfoJson S_query S_type
    i_cnt = 0
    i_len = 0
    qJson = Sarray()
    XTmp = Collection("data" Array())
    print bar "Requesting data" Nof(S_query) l_info=yes
    for xx = 1, Nof(S_query)
        print bar Nof(S_query) l_info=yes
        if (S_query [xx] == "") continue
        x_query = S_query [xx]
        x_type = S_type [xx]
        if (x_type == 'chem' & Length(x_query) < 3) then
            print HELP + " Warning> minimum word size >= 3"
            continue
        endif
        sprintf '{"name":"%s","type":"%s"}', String(x_query html), String(x_type html) name="stmp"
        i_cnt = i_cnt + 1
        i_len = i_len + Length(stmp)
        qJson = qJson // stmp
        if i_len > 1024*6 | xx == Nof(S_query) then
            sprintf 'http://www.molsoft.com/cloudAPI/getProtInfo?q={"data":[%s],"simple":"1"}', Sum(qJson, ",") name="sJson"
            for jx = 1, 5
                read string sJson name="s_out"
                i_len = 0
                qJson = Sarray()
                if Index(s_out, "Server Error (500)") == 0 then
                    XTmp ["data"] = XTmp ["data"] // Collection(s_out) ["info"]
                    break
                endif
                print " Warning> Server Error (500) "
                return Collection()
            endfor
        endif
    endfor
    QA = Table(Collection("data" XTmp ["data"]))
    print bar "End\n" l_info = yes
    if (!Exist(QA.data)) then
        delete QA
        print " Warning> no data retrieved"
        return Collection()
    endif
    add column QA function="Icm::String(data.Uniprot_ID==null?'':data.Uniprot_ID)" name="name"
    i_cnt = 0
    i_len = 0
    qJson = Sarray()
    XTmp = Collection("data" Array())
    print bar "Fetching data" Nof(QA) l_info=yes
    for xx = 1, Nof(QA)
        print bar Nof(QA) l_info=yes
        x_query = QA.name [xx]
        x_type = "uniprot id"
        sprintf '{"name":"%s","type":"%s"}', String(x_query html), String(x_type html) name="stmp"
        i_cnt = i_cnt + 1
        i_len = i_len + Length(stmp)
        qJson = qJson // stmp
        if i_len > 1024*6 | xx == Nof(QA) then
            sprintf 'http://www.molsoft.com/cloudAPI/getProtInfo?q={"data":[%s]}', Sum(qJson, ",") name="sJson"
            for jx = 1, 5
                read string sJson name="s_out"
                i_len = 0
                qJson = Sarray()
                if Index(s_out, "Server Error (500)") == 0 then
                    XTmp ["data"] = XTmp ["data"] // Collection(s_out) ["info"]
                    break
                endif
                print " Warning> Server Error (500) "
                return
            endfor
        endif
    endfor
    print bar "End\n" l_info = yes
    return XTmp
endfunction

function readUniprotCloudInfoJsonTable T_tbl
    add column T_tbl function="Icm::String(data.Uniprot_ID==null?'':data.Uniprot_ID)" name="Uniprot_ID" static
    add column T_tbl function="Icm::String(data.Uniprot_AC==null?'':data.Uniprot_AC)" name="Uniprot_AC" static
    add column T_tbl Match(T_tbl.Uniprot_ID "(\w{1,5})_(\w{1,5})" 2) name="OrgCode"
    add column T_tbl Match(T_tbl.OrgCode "(\w{3})" 1) name="GenusCode"
    add column T_tbl function="Icm::String(data.Synonyms==null?'':data.Synonyms)" name="Synonyms"
    add column T_tbl function="Icm::String(data.Gene==null?'':data.Gene)" name="Gene" static
    T_tbl.Gene=Field(T_tbl.Gene,1)
    add column T_tbl function="Icm::String(data.GeneID==null?'':data.GeneID)" name="GeneID" static
    add column T_tbl function="Icm::String(data.Fullname==null?'':data.Fullname)" name="Fullname" static
    T_tbl.Fullname=Replace(T_tbl.Fullname,"{*}","")
    add column T_tbl function="Icm::String(data.Sequence==null?'':data.Sequence)" name="Sequence" static
    T_tbl.Sequence = Replace(T_tbl.Sequence,"{*}","")
    add column T_tbl function="Icm::String(data.Domain==null?'':data.Domain)" name="Site" static
    T_tbl.Site=Replace(T_tbl.Site,"{*}","")
    add column T_tbl function="Icm::String(data.Protein_family==null?'':data.Protein_family)" name="Protein_family" static
    T_tbl.Protein_family=Replace(T_tbl.Protein_family,"{*}","")
    add column T_tbl function="Icm::String(data.Organism==null?'':data.Organism)" name="Organism" static
    add column T_tbl function="Icm::String(data.Organism_family==null?'':data.Organism_family)" name="Organism_family" static
    add column T_tbl function="Icm::String(data.Function==null?'':data.Function)" name="Function" static
    T_tbl.Function = Replace(T_tbl.Function,"{*}","")
    add column T_tbl function="Icm::String(data.Tissue==null?'':data.Tissue)" name="Tissue" static
    add column T_tbl function="Icm::String(data.Pathway==null?'':data.Pathway)" name="Pathway" static
    add column T_tbl function="Icm::String(data.Disease==null?'':data.Disease)" name="Disease" static
    add column T_tbl function="Icm::String(data.EC_number==null?'':data.EC_number)" name="EC_number" static
    add column T_tbl function="Icm::String(data.EC_name==null?'':data.EC_name)" name="EC_name" static
    add column T_tbl function="Icm::String(data.PDB==null?'':data.PDB)" name="PDB" static
    add column T_tbl function="Icm::String(data.Patent==null?'':data.Patent)" name="Patent" static
    add column T_tbl function="Icm::String(data.Drugbank==null?'':data.Drugbank)" name="Drugbank" static
    add column T_tbl function="Icm::String(data.Go_Cellular==null?'':data.Go_Cellular)" name="Go_Cellular" static
    T_tbl.Go_Cellular = Replace(T_tbl.Go_Cellular,  {"GO:*:","IEA*."}, "" )
    add column T_tbl function="Icm::String(data.Go_Process==null?'':data.Go_Process)" name="Go_Process" static
    T_tbl.Go_Process  = Replace( T_tbl.Go_Process, {"GO:*:","IEA*."}, "")
    add column T_tbl function="Icm::String(data.Go_Function==null?'':data.Go_Function)" name="Go_Function" static
    T_tbl.Go_Function = Replace( T_tbl.Go_Function,  {"GO:*:","IEA*."}, "" )
    add column T_tbl Sequence(T_tbl.Sequence T_tbl.Uniprot_ID) name="seq" ; set format T_tbl.seq show off
    delete T_tbl.data
    set format T_tbl.Uniprot_ID "<a href=http://www.uniprot.org/uniprot/%1>%1</a>"
    return T_tbl
endfunction

macro readUniprotCloudLoadSeq s_table_name ("") I_row_index ({0}) auto
    l_info = l_warn = no
    tbna = Trim(s_table_name,all)
    if (tbna=="") return "Warning> No table selected"
    if (Nof($tbna)==0) return "Table not found:", tbna
    XSel = (I_row_index == {0}) ? Count(Nof($tbna)) : Index($tbna selection cursor)
    for xx = 1, Nof(XSel)
        xdx = XSel [xx]
        xnm = $tbna.Uniprot_ID [xdx]
        if (Nof($tbna.Site_type) != 0 & Nof($tbna.Start) != 0 & Nof($tbna.End) != 0) then
            xnm = xnm + "_" + $tbna.Site_type [xdx] + "_" + String($tbna.Start [xdx]) + "_" + String($tbna.End [xdx])
        endif
        xdsc = Match($tbna.Sequence [xdx] ">sp\|(\w{6})\|(\w{1,5}_\w{1,5})\|(.*)" 1) + "; " + Match($tbna.Sequence [xdx] ">sp\|(\w{6})\|(\w{1,5}_\w{1,5})\|(.*)" 3)
        $xnm = Sequence(Replace($tbna.Sequence [xdx] Match($tbna.Sequence [xdx] "(>.*\n)" 1 ) "") protein xdsc)
        if Exist($tbna.Site) then
            xdm = Split($tbna.Site [xdx], "\n")
            for yy = 1, Nof(xdm)
                xf = Match(xdm [yy] "(\w{1,8}) \(([0-9><\?]{1,999})\-([0-9><\?]{1,999})\) (.*)" 1)
                xs = Match(xdm [yy] "(\w{1,8}) \(([0-9><\?]{1,999})\-([0-9><\?]{1,999})\) (.*)" 2)
                xe = Match(xdm [yy] "(\w{1,8}) \(([0-9><\?]{1,999})\-([0-9><\?]{1,999})\) (.*)" 3)
                xm = Match(xdm [yy] "(\w{1,8}) \(([0-9><\?]{1,999})\-([0-9><\?]{1,999})\) (.*)" 4)
                xs = Replace(Replace(Replace(xs ">" "" regexp) "<" "" regexp) "\?" "" regexp)
                xe = Replace(Replace(Replace(xe ">" "" regexp) "<" "" regexp) "\?" "" regexp)
                if (xs == "" | xe == "") continue
                sprintf "FT %s %s %s %s", xf, xs, xe, xm name="xt"
                set site $xnm xt
            endfor
#        else
#            xf = $tbna.Site_type [xdx]
#            xs = $tbna.Start [xdx]
#            xe = $tbna.End [xdx]
#            xm = $tbna.Site_name [xdx]
#            sprintf "FT %s %i %i %s", xf, xs, xe, xm name="xt"
#            set site $xnm xt
        endif
    endfor
    keep sequence
endmacro

macro readUniprotCloudExtractSite s_table_name ("") s_type ("all") I_row_index ({0}) auto
    l_info = l_warn = no
    tbna = s_table_name
    if (tbna=="") return "Warning> No table selected"
    if (Nof($tbna)==0) return "Table not found:", tbna
    group table XTBL Sarray() "Uniprot_ID" Sarray() "Uniprot_AC" Sarray() "OrgCode" Sarray() "Site_type" Sarray() "Site_name" Iarray() "Length" Iarray() "Start" Iarray() "End" Sarray() "Sequence" Sarray() "Fullname" Sarray() "Synonyms" Sarray() "Gene" Sarray() "GeneID" Sarray() "Protein_family" Sarray() "Organism" Sarray() "Organism_family" Sarray() "Function" Sarray() "Tissue" Sarray() "Pathway" Sarray() "Disease" Sarray() "EC_number" Sarray() "EC_name" Sarray() "PDB" Sarray() "Patent" Sarray() "Drugbank" Sarray() "Go_Cellular" Sarray() "Go_Process" Sarray() "Go_Function"
    if (s_type == "PFAM") add column XTBL Sarray() name="Site_ID" index=5
    XSel = (I_row_index == {0}) ? Count(Nof($tbna)) : Index($tbna selection cursor)
    for xx = 1, Nof(XSel)
        xdx = XSel [xx]
        xdm = Split($tbna.Site [xdx], "\n")
        for yy = 1, Nof(xdm)
            xf = Match(xdm [yy] "(\w{1,8}) \(([0-9><\?]{1,999})\-([0-9><\?]{1,999})\) (.*)" 1)
            xs = Match(xdm [yy] "(\w{1,8}) \(([0-9><\?]{1,999})\-([0-9><\?]{1,999})\) (.*)" 2)
            xe = Match(xdm [yy] "(\w{1,8}) \(([0-9><\?]{1,999})\-([0-9><\?]{1,999})\) (.*)" 3)
            xm = Match(xdm [yy] "(\w{1,8}) \(([0-9><\?]{1,999})\-([0-9><\?]{1,999})\) (.*)" 4)
            if (Tolower(s_type) != "all" & Tolower(xf) != Tolower(s_type)) continue
            xs = Replace(Replace(Replace(xs ">" "" regexp) "<" "" regexp) "\?" "" regexp)
            xe = Replace(Replace(Replace(xe ">" "" regexp) "<" "" regexp) "\?" "" regexp)
            if (xs == "" | xe == "") continue
            xseq = Match($tbna.Sequence [xdx] "(>.*)" 1) + "|" + xf + "|" + xs + "-" + xe + "|" + xm + "\n" + String(Sequence($tbna.Sequence [xdx]))[Integer(xs):Integer(xe)]
            add XTBL
            xcnt = Nof(XTBL)
            XTBL.Uniprot_ID [xcnt]      = $tbna.Uniprot_ID [xdx]
            XTBL.Uniprot_AC [xcnt]      = $tbna.Uniprot_AC [xdx]
            XTBL.OrgCode [xcnt]         = $tbna.OrgCode [xdx]
            XTBL.Synonyms [xcnt]        = $tbna.Synonyms [xdx]
            XTBL.Gene [xcnt]            = $tbna.Gene [xdx]
            XTBL.GeneID [xcnt]          = $tbna.GeneID [xdx]
            XTBL.Fullname [xcnt]        = $tbna.Fullname [xdx]
            XTBL.Sequence [xcnt]        = xseq
            XTBL.Site_type [xcnt]     = xf
            XTBL.Site_name [xcnt]     = xm
            XTBL.Length [xcnt]   = Integer(xe)-Integer(xs)+1
            XTBL.Start [xcnt]    = Integer(xs)
            XTBL.End [xcnt]      = Integer(xe)
            XTBL.Protein_family [xcnt]  = $tbna.Protein_family [xdx]
            XTBL.Organism [xcnt]        = $tbna.Organism [xdx]
            XTBL.Organism_family [xcnt] = $tbna.Organism_family [xdx]
            XTBL.Function [xcnt]        = $tbna.Function [xdx]
            XTBL.Tissue [xcnt]          = $tbna.Tissue [xdx]
            XTBL.Pathway [xcnt]         = $tbna.Pathway [xdx]
            XTBL.Disease [xcnt]         = $tbna.Disease [xdx]
            XTBL.EC_number [xcnt]       = $tbna.EC_number [xdx]
            XTBL.EC_name [xcnt]         = $tbna.EC_name [xdx]
            XTBL.PDB [xcnt]             = $tbna.PDB [xdx]
            XTBL.Patent [xcnt]          = $tbna.Patent [xdx]
            XTBL.Drugbank [xcnt]        = $tbna.Drugbank [xdx]
            XTBL.Go_Cellular [xcnt]     = $tbna.Go_Cellular [xdx]
            XTBL.Go_Process [xcnt]      = $tbna.Go_Process [xdx]
            XTBL.Go_Function [xcnt]     = $tbna.Go_Function [xdx]
            if s_type == "PFAM" then
                XTBL.Site_ID [xcnt]   = Match(xm "\((PF[0-9]{1,999})\)" 1)
                XTBL.Site_name [xcnt] = Replace(XTBL.Site_name [xcnt] " ("+XTBL.Site_ID [xcnt]+")" "")
            endif
        endfor
    endfor
    add column XTBL Sequence(Replace(XTBL.Sequence Match(XTBL.Sequence "(>.*\n)" 1 ) "") XTBL.Uniprot_ID + "_" + XTBL.Site_type + "_" + XTBL.Start + "_" + XTBL.End) name="seq" ; set format XTBL.seq show off
    if Nof(XTBL) == 0 then
        print "No domain found"
        return
    endif
    # header
    sprintf "readUniprotCloudLoadSeq Name(variable %%@) Index(%%@ selection cursor);" name="XHD"
    add header XTBL name="doubleClick" XHD
    # cursor
    sprintf """# b_Load_sequence_from_selection (readUniprotCloudLoadSeq Name(variable %%@) Index(%%@ selection cursor))
# b_Make_sequence_alignment_from_selection (readUniprotCloudMakeAlign Name(variable %%@) Index(%%@ selection cursor))""" name="XCUR"
    add header XTBL name="cursor" XCUR
    xtblnm = tbna + "_domain"
    if (Nof($xtblnm)!=0) delete $xtblnm
    rename XTBL xtblnm
    keep $xtblnm
    print xtblnm, "hit table loaded"
endmacro

macro readUniprotCloudMakeAlign s_table_name ("") I_row_index ({0}) auto
    l_info = l_warn = no
    HELP =  """
    Align sequence(s) selected in a table

    Parameter:
        's_table_name'  : table name
        'I_row_index' : a integer array of row number

    """
    if (s_table_name=="") return "Warning> No table selected"
    if (Nof($s_table_name)==0) return "Table not found:", s_table_name
    tbna = s_table_name
    XSel = (I_row_index == {0}) ? Count(Nof($s_table_name)) : Index($s_table_name selection cursor)
    readUniprotCloudLoadSeq s_table_name XSel
    XNM = Sarray()
    for xx = 1, Nof(XSel)
        xdx = XSel [xx]
        xnm = $tbna.Uniprot_ID [xdx]
        if (Nof($tbna.Site_type) != 0 & Nof($tbna.Start) != 0 & Nof($tbna.End) != 0) then
            xnm = xnm + "_" + $tbna.Site_type [xdx] + "_" + String($tbna.Start [xdx]) + "_" + String($tbna.End [xdx])
        endif
        XNM //= xnm
    endfor
    XSEQ = Sum(XNM " ")
    group sequence $XSEQ name="XSEQG"
    align XSEQG
    xobjnm = tbna + "_seqalign"
    if (Nof($xobjnm)!=0) delete $xobjnm
    rename XSEQG xobjnm
    keep $xobjnm
endmacro

function funcProtCloudMapping S_query s_fr s_to s_org
    l_info = l_warn = no
    l_caseSensitivity = no
    sprintf """
        funcProtCloudMapping S_query s_xfr s_xto s_org

        s_fr is a query type
        s_to is a return type

        Query types
            Uniprot ID
            Uniprot AC
            Gene ID
            Gene name

        Return types
            Uniprot ID
            Uniprot AC
            Gene ID
            Gene name
            EC number
            EC name
            PDB
            Patent
            GO number
            Pathway
            Fullname
            Organism
            Family
            DrugBank
            Sequence
            Sequence length
            Function
            Disease
            Tissue
            Taxonomic lineage
    """ name="xHelp"
    if (Nof(S_query) == 0) then
        print xHelp
        return Collection()
    endif
    QA = S_query != "" ; if Nof(QA) == 0 then ; print "Warning> all-empty column" ; return Collection() ; endif
    if (s_fr == s_to) then
        print "Warning> mapping to the same item"
        return Collection()
    endif
    XTmp = funcProtCloudMapJson(QA, s_fr, s_to, s_org)
    if (Type(XTmp) != "collection") return error " cannot translate input data"
    XTBL = Table(XTmp)
    if ! Exist(XTBL.data) then
        delete XTBL
        # guess the source of the first non-empty field when no data retrieve
        l_guess = 0
        if Match(QA [1] "\w{1,16}_\w{1,16}") != "" then
            l_guess = 1
            s_fr = "uniprot id"
        elseif Match(Toupper(QA [1]) "[OPQ][0-9][A-Z0-9]{3}[0-9]|[A-NR-Z][0-9]([A-Z][A-Z0-9]{2}[0-9]){1,2}") != "" then
            l_guess = 1
            s_fr = "uniprot ac"
        endif
        if l_guess == 1 then
            print "Initial query not found, guessing applies to source type:", s_fr
            XTmp = funcProtCloudMapJson(QA, s_fr, s_to, s_org)
            XTBL = Table(XTmp)
            if ! Exist(XTBL.data) then
                delete XTBL
                print " Warning> no data retrieved"
                return Collection()
            endif
        else
            print " Warning> no data retrieved"
            return Collection()
        endif
    endif
    XTBL = funcProtCloudMapJsonTable(XTBL, s_fr, s_to, s_org)
    xfr = Name(s_fr simple)
    xto = Name(s_to simple)
    group table OTBL Sarray(Nof(S_query)) xto
    for xx = 1, Nof(S_query)
        xtmp = XTBL.$xfr == S_query [xx]
        OTBL.$xto [xx] = Nof(xtmp) == 0 ? "" : Sum(xtmp.$xto "\n")
    endfor
    XCOL = Collection()
    XCOL[xto] = Collection("_", OTBL.$xto "FORMAT" Collection(OTBL format)[xto])
    return XCOL
endfunction

function funcProtCloudMapJson S_query s_fr s_to s_org
    QA = Unique(S_query sort)
    i_cnt = 0
    i_len = 0
    qJson = Sarray()
    XTmp = Collection("data" Array())
    print bar "Fetching data" Nof(QA) l_info=yes
    for xx = 1, Nof(QA)
        print bar Nof(QA) l_info=yes
        x_query = QA [xx]
        sprintf '"%s"', String(x_query html) name="stmp"
        i_cnt = i_cnt + 1
        i_len = i_len + Length(stmp)
        qJson = qJson // stmp
        if i_len > 1024*6 | xx == Nof(QA) then
            sprintf 'http://www.molsoft.com/cloudAPI/getProtMap?q={"data":[%s],"fr":"%s","to":"%s","org":"%s"}', Sum(qJson, ","), String(s_fr html), String(s_to html), String(s_org html) name="sJson"
            for jx = 1, 5
                read string sJson name="s_out"
                i_len = 0
                qJson = Sarray()
                if Index(s_out, "Server Error (500)") == 0 then
                    XTmp ["data"] = XTmp ["data"] // Collection(s_out) ["info"]
                    break
                endif
                print " Warning> no data retrieved"
                return
            endfor
        endif
    endfor
    print bar "End\n" l_info = yes
    return XTmp
endfunction

function funcProtCloudMapJsonTable T_tbl s_fr s_to s_org
    add column T_tbl function="Icm::String(data.fr==null?'':data.fr)" name=Name(s_fr simple) static
    add column T_tbl function="Icm::String(data.to==null?'':Icm::Sum(data.to, '\n'))" name=Name(s_to simple) static
    delete T_tbl.data
    return T_tbl
endfunction

macro findTCGACloudAliquot s_disease ("") auto
    l_info = l_warn = no
    group table QA Sarray() "name" Sarray() "type"
    if (s_disease != "") then
        add QA
        QA.name [Nof(QA)] = s_disease
        QA.type [Nof(QA)] = "disease"
    endif
    i_cnt = 0
    i_len = 0
    qJson = Sarray()
    XTmp = Collection("data" Array())
    print bar "Fetching data" Nof(QA) l_info=yes
    for xx = 1, Nof(QA)
        print bar Nof(QA) l_info=yes
        x_query = QA.name [xx]
        x_type  = QA.type [xx]
        sprintf '{"name":"%s","type":"%s"}', String(x_query html), String(x_type html) name="stmp"
        i_cnt = i_cnt + 1
        i_len = i_len + Length(stmp)
        qJson = qJson // stmp
        if i_len > 1024*6 | xx == Nof(QA) then
            sprintf 'http://www.molsoft.com/cloudAPI/getTCGAAliquot?q={"data":[%s]}', Sum(qJson, ",") name="sJson"
            for jx = 1, 5
                read string sJson name="s_out"
                i_len = 0
                qJson = Sarray()
                if Index(s_out, "Server Error (500)") == 0 then
                    XTmp ["data"] = XTmp ["data"] // Collection(s_out) ["info"]
                    break
                endif
                print "Warning> please try again"
                return
            endfor
        endif
    endfor
    print bar "End\n" l_info = yes
    XTBL = Table(XTmp)
    if ! Exist(XTBL.data) then
        delete XTBL
        print " Warning> no data retrieved"
        return
    endif
    add column XTBL function="Icm::String(data.aliquot)" name="Aliquot_ID" static
    add column XTBL function="Icm::String(data.disease_code)" name="Disease_Code" static
    add column XTBL function="Icm::String(data.disease_name)" name="Disease_Name" static
    add column XTBL function="Icm::String(data.sample)" name="Sample" static
    add column XTBL function="Icm::String(data.analyte)" name="Analyte" static
    add column XTBL function="Icm::String(data.center_url)" name="Center_URL" static
    add column XTBL function="Icm::String(data.center_name)" name="Center_Name" static
    add column XTBL function="Icm::String(data.center_type)" name="Center_Type" static
    add column XTBL function="Icm::String(data.platform_code)" name="Platform_Code" static
    add column XTBL function="Icm::String(data.platform_name)" name="Platform_Name" static
    add column XTBL function="Icm::String(data.level_1)" name="Level_1" static
    add column XTBL function="Icm::String(data.level_2)" name="Level_2" static
    add column XTBL function="Icm::String(data.level_3)" name="Level_3" static
    delete XTBL.data
    # cursor
    sprintf """# b_Load_data_from_selection (findTCGACloudAliquotLoad Name(variable %%@) $ilvl Index(%%@ selection cursor))
# i_Level:ilvl (1|2|3) [RDONLY]
# txt_ (Data level classification<br><br>Level 1: Raw data<br>Level 2: Processed data<br>Level 3: Segmented/Interpreted data<br><br>Data are requested/downloaded through TCGA.<br><br>Some data required TCGA registration.<br>Please go to https://tcga-data.nci.nih.gov/tcga/tcgaAccessTiers.jsp<br><br>More information in<br>    https://wiki.nci.nih.gov/display/TCGA/Data+level#Datalevel-RelationshipsBetweenDataTypeandDataLevel)""" name="XCUR"
    add header XTBL name="cursor" XCUR
    xtblnm = Name(Name("tcga_aliquot_" + Sum(QA.name, "_"),simple) unique)
    if (Nof($xtblnm)!=0) delete $xtblnm
    rename XTBL xtblnm
    keep $xtblnm
    print xtblnm, "hit table loaded"
endmacro

macro findTCGACloudAliquotLoad s_table_name ("") i_data_level (0) I_row_index ({0}) auto
    l_info = l_warn = no ; errorAction = 1
    HELP =  """
    Load TCGA Aliquot data selected in a table

    Parameter:
        's_table_name'  : table name
        'i_data_level' : data level
        'I_row_index' : a integer array of row number

    """
    if (s_table_name=="") return "Warning> No table selected"
    if (Nof($s_table_name)==0) return "Table not found:", s_table_name
    if (i_data_level==0) return "Warning> No level selected"
    xtblnm = s_table_name + "_dl"
    # create ticket
    XSel = (I_row_index == {0}) ? Count(Nof($s_table_name)) : Index($s_table_name selection cursor)
    group table XTBL Sarray() "Aliquot_ID" Sarray() "Disease_Name" Sarray() "Sample" Sarray() "Analyte" Sarray() "Center_Name" Sarray() "Platform_Name" Iarray() "Level" Iarray() "file_size" Sarray() "url" Sarray() "status"
    for xx = 1, Nof(XSel)
        xdx = XSel [xx]
        # exp, http://tcga-data.nci.nih.gov/tcga/damws/jobprocess/json?disease=GBM&level=2&platform=Mutation%20Calling&center=broad.mit.edu&sampleList=TCGA-02-0003-01A-01D-1490-08&noMeta=false&flattenDir=true&consolidateFiles=true&useCompression=true
        sprintf "Aliquot ID: %s, Disease: %s, Center: %s, Platform: %s", $s_table_name.Aliquot_ID [xdx], $s_table_name.Disease_Code [xdx], $s_table_name.Center_URL [xdx], $s_table_name.Platform_Code [xdx] name="xdnm"
        if $s_table_name.Level_1 [xdx] == "NA" then
            print "Data not available, Ignore... (", xdnm, ")"
            continue
        endif
        if Nof($xtblnm) != 0 & Nof($xtblnm.Level == i_data_level & $xtblnm.Aliquot_ID == $s_table_name.Aliquot_ID [xdx] & $xtblnm.Center_Name == $s_table_name.Center_Name [xdx] & $xtblnm.Platform_Name == $s_table_name.Platform_Name [xdx] & $xtblnm.Disease_Name == $s_table_name.Disease_Name [xdx]) != 0 then
            print "Data has been retrieved, Ignore... (", xdnm, ")"
            continue
        endif
        sprintf 'https://tcga-data.nci.nih.gov/tcga/damws/jobprocess/json?disease=%s&level=%i&platform=%s&center=%s&sampleList=%s&noMeta=false&flattenDir=true&consolidateFiles=true&useCompression=true', String($s_table_name.Disease_Code [xdx] html), i_data_level, String($s_table_name.Platform_Code [xdx] html), String($s_table_name.Center_URL [xdx] html), String($s_table_name.Aliquot_ID [xdx] html) name="xurl"
        sprintf 'https://tcga-data.nci.nih.gov/tcga/damws/jobprocess/json?disease=%s&level=%i&platform=%s&center=%s&sampleList=%s&noMeta=false&flattenDir=true&consolidateFiles=true', String($s_table_name.Disease_Code [xdx] html), i_data_level, String($s_table_name.Platform_Code [xdx] html), String($s_table_name.Center_URL [xdx] html), String($s_table_name.Aliquot_ID [xdx] html) name="xurl"
        read json xurl name="xjson"
        if Error() | Nof(xjson) == 0 | xjson ["status-check-url"] == Real("ND") then
            print "Data not available, Ignore... (", xdnm, ")"
            continue
        endif
        add XTBL ; xcnt = Nof(XTBL)
        XTBL.Aliquot_ID [xcnt]    = $s_table_name.Aliquot_ID [xdx]
        XTBL.Disease_Name [xcnt]  = $s_table_name.Disease_Name [xdx]
        XTBL.Sample [xcnt]        = $s_table_name.Sample [xdx]
        XTBL.Analyte [xcnt]       = $s_table_name.Analyte [xdx]
        XTBL.Center_Name [xcnt]   = $s_table_name.Center_Name [xdx]
        XTBL.Platform_Name [xcnt] = $s_table_name.Platform_Name [xdx]
        XTBL.Level [xcnt]         = i_data_level
        XTBL.file_size [xcnt]     = Integer(xjson ["estimated-size"])
        XTBL.url [xcnt]           = xjson ["status-check-url"]
        XTBL.status [xcnt]        = "Wait"
    endfor
    if Nof(XTBL) == 0 then
        print "No data generated"
        return
    endif
    set format XTBL.url "<a href='%1'>Download</a>"
    # check if ready to download
    while yes
        print "Checking download status..."
        for xx = 1, Nof(XTBL)
            if (XTBL.status [xx] == "Ready") continue
            read json XTBL.url [xx] name="xjson"
            if (xjson ["job-status"] ["status-message"] != "OK") continue
            XTBL.url [xx]    = xjson ["job-status"] ["archive-url"]
            XTBL.status [xx] = "Ready"
        endfor
        if (Nof(XTBL) == Nof(XTBL.status == "Ready")) break
        print "Some data are not ready yet, check after 5 seconds"
        pause 5
    endwhile
    if Nof($xtblnm) !=0 then
        add $xtblnm XTBL
        print "data added to ", xtblnm
    else
        rename XTBL xtblnm
        keep $xtblnm
        print xtblnm, "table loaded"
    endif
endmacro

macro findTCGACloudMaf s_disease ("") auto
    l_info = l_warn = no
    group table QA Sarray() "name" Sarray() "type"
    if (s_disease != "") then
        add QA
        QA.name [Nof(QA)] = s_disease
        QA.type [Nof(QA)] = "disease"
    endif
    i_cnt = 0
    i_len = 0
    qJson = Sarray()
    XTmp = Collection("data" Array())
    print bar "Fetching data" Nof(QA) l_info=yes
    for xx = 1, Nof(QA)
        print bar Nof(QA) l_info=yes
        x_query = QA.name [xx]
        x_type  = QA.type [xx]
        sprintf '{"name":"%s","type":"%s"}', String(x_query html), String(x_type html) name="stmp"
        i_cnt = i_cnt + 1
        i_len = i_len + Length(stmp)
        qJson = qJson // stmp
        if i_len > 1024*6 | xx == Nof(QA) then
            sprintf 'http://www.molsoft.com/cloudAPI/getTCGAMaf?q={"data":[%s]}', Sum(qJson, ",") name="sJson"
            for jx = 1, 5
                read string sJson name="s_out"
                i_len = 0
                qJson = Sarray()
                if Index(s_out, "Server Error (500)") == 0 then
                    XTmp ["data"] = XTmp ["data"] // Collection(s_out) ["info"]
                    break
                endif
                print "Warning> please try again"
                return
            endfor
        endif
    endfor
    print bar "End\n" l_info = yes
    XTBL = Table(XTmp)
    if ! Exist(XTBL.data) then
        delete XTBL
        print " Warning> no data retrieved"
        return
    endif
    add column XTBL function="Icm::String(data.disease_code)" name="Disease_Code" static
    add column XTBL function="Icm::String(data.disease_name)" name="Disease_Name" static
    add column XTBL function="Icm::String(data.center_url)" name="Center_URL" static
    add column XTBL function="Icm::String(data.center_name)" name="Center_Name" static
    add column XTBL function="Icm::String(data.center_type)" name="Center_Type" static
    add column XTBL function="Icm::String(data.platform_code)" name="Platform_Code" static
    add column XTBL function="Icm::String(data.platform_name)" name="Platform_Name" static
    add column XTBL function="Icm::String(data.url)" name="url" static
    set format XTBL.url show off
    delete XTBL.data
    # header
    sprintf "findTCGACloudMafLoad Name(variable %%@) Index(%%@ selection cursor);" name="XHD"
    add header XTBL name="doubleClick" XHD
    # cursor
    sprintf """# b_Load_data_from_selection (findTCGACloudMafLoad Name(variable %%@) Index(%%@ selection cursor))""" name="XCUR"
    add header XTBL name="cursor" XCUR
    xtblnm = Name(Name("tcga_maf_" + Sum(QA.name, "_"),simple) unique)
    if (Nof($xtblnm)!=0) delete $xtblnm
    rename XTBL xtblnm
    keep $xtblnm
    print xtblnm, "hit table loaded"
endmacro

macro findTCGACloudMafLoad s_table_name ("") I_row_index ({0}) auto
    l_info = l_warn = no
    HELP =  """
    Load TCGA Mutation Annotation Format (MAF) data selected in a table

    Parameter:
        's_table_name'  : table name
        'I_row_index' : a integer array of row number

    """
    if (s_table_name=="") return "Warning> No table selected"
    if (Nof($s_table_name)==0) return "Table not found:", s_table_name
    XSel = (I_row_index == {0}) ? Count(Nof($s_table_name)) : Index($s_table_name selection cursor)
    print "Loading ..."
    for xx = 1, Nof(XSel)
        xdx = XSel [xx]
        sprintf "tcga_maf_%s_%s_%s", $s_table_name.Disease_Code [xdx], $s_table_name.Center_URL [xdx], $s_table_name.Platform_Code [xdx] name="xnm"
        xnm = Name(xnm simple)
        if (Nof($xnm) != 0) delete $xnm
        read table header separator="\t" comment $s_table_name.url [xdx] name=xnm
        if (Nof($xnm) == 0) then
            print "no data retrieved:", xnm
        else
            l_caseSensitivity = no
            if Nof(Name($xnm column name) ~ "hugo_symbol" ) != 0 then
                print "Annotating..."
                add column $xnm function="funcProtCloudMapping(Sarray(" + (Name($xnm column name) ~ "hugo_symbol" )[1] + "),'Gene name','Fullname','all')" index=3 name="Fullname" append vector
            endif
            xlst = Name($xnm column name)
            for yy = 1, Nof(xlst)
                ynm = xlst [yy]
                # correction
                if (ynm ~ "chrom") then
                    rename $xnm.$ynm "chromosome"
                else
                    rename $xnm.$ynm Tolower(ynm)
                endif
            endfor
            # cursor
            sprintf """# b_Overview_of_mutation (findTCGACloudMafStat Name(variable %%@))""" name="XCUR"
            add header $xnm name="cursor" XCUR
            print xnm, "hit table loaded"
            keep $xnm
        endif
    endfor
endmacro

macro findTCGACloudMafStat s_table_name
    l_info = l_warn = no
    HELP =  """
    Generate the summary of TCGA Mutation Annotation Format (MAF) data in a table

    Parameter:
        's_table_name'  : table name

    """
    if (Nof($s_table_name)==0) return "Table not found:", s_table_name
    add column $s_table_name Sarray($s_table_name.variant_classification) + Sarray(Nof($s_table_name), " (") + Sarray($s_table_name.start_position) + Sarray(Nof($s_table_name), "-") + Sarray($s_table_name.end_position) + Sarray(Nof($s_table_name), ")") name="variant"
    group $s_table_name.hugo_symbol $s_table_name.entrez_gene_id "uniq,entrez_gene_id" $s_table_name.fullname "uniq,fullname" $s_table_name.hugo_symbol "count,freq" $s_table_name.ncbi_build "uniq,ncbi_build" $s_table_name.chromosome "uniq,chromosome" $s_table_name.strand "uniq,strand" $s_table_name.variant "uniq,variant" name="XTBL"
#    add column XTBL Sarray(Nof(XTBL)) name="variant"
#    for xx = 1, Nof(XTBL)
#        xtmp = $s_table_name.hugo_symbol == XTBL.hugo_symbol [xx]
#        sort xtmp.variant
#        XTBL.variant [xx] = Sum(xtmp.variant "\n")
#    endfor
    delete $s_table_name.variant
    xtblnm = s_table_name + "_stat"
    if (Nof($xtblnm)!=0) delete $xtblnm
    rename XTBL xtblnm
    keep $xtblnm
    print xtblnm, "hit table loaded"
endmacro
#
macro chemAssign2D s_tab s_col ("mol") auto
  l_commands = no

  I_sel = Index( $s_tab selection )

  ic3D = no

  if ( Type( $s_tab.$s_col 2 ) == "3D" & Nof(I_sel) == 0) then
    add column $s_tab Chemical( $s_tab.$s_col ) name="mol3D"
    set format show off $s_tab.mol3D
    ic3D = yes
    keep $s_tab global
  endif

  if (Nof(I_sel) == 0) then
    if (ic3D) then
      $s_tab.$s_col = $s_tab.mol3D
      delete hydrogen  $s_tab.$s_col
      make flat $s_tab.$s_col
    else
      make flat $s_tab.$s_col
    endif
  else
    if (ic3D) then
      $s_tab.$s_col [I_sel] = $s_tab.mol3D [I_sel]
      delete hydrogen  $s_tab.$s_col index=I_sel
      make flat $s_tab.$s_col index=I_sel
    else
      make flat $s_tab.$s_col index=I_sel
    endif
  endif
  set format $s_tab.$s_col show
  #set property display $s_tab off
endmacro
#
macro chemAssign3D s_tab
  l_commands = no

  if (Type( $s_tab.mol )  != "parray") return

  if ( Type( $s_tab.mol3D ) != "parray" | Type( $s_tab.mol3D 2 ) != "3D" ) then
    if (l_warn) print " Warning> table " + s_tab + " doesn't have 3D column"
    return
  endif

  $s_tab.mol = $s_tab.mol3D

  delete $s_tab.mol3D

  keep $s_tab global

endmacro
#
macro dsChemTemp_new auto s_tabName i_row l_link (yes)
  l_commands = no
  l_confirm = no
  l_info=no
  interruptAction = "break all loops"
  #s_objTag = s_tabName + "_tmpmol"
  s_objTag = "tmpmol"
  # remove/undisplay previous
  delete    Select( a_*. s_objTag ) & !Select( a_*. "usedInSlide" )
  undisplay Select( a_*. s_objTag ) &  Select( a_*. "usedInSlide" ) l_warn = no
  #
  s_molCol = "mol"
  if ( Type( $s_tabName.$s_molCol 2) == "2D" & Type(  $s_tabName.mol3D ) == "parray" & Type(  $s_tabName.mol3D 2 ) == "3D" ) s_molCol = "mol3D"
  #
  s_lockObjTag = s_tabName[1:GUI.lockPrefixLength] + "_" + $s_tabName.O [ i_row ]
  os_lockObj = Select( a_*. s_lockObjTag )
  #
  if ( Smiles(  $s_tabName.$s_molCol [i_row] ) != "" ) then
    if (Nof( os_lockObj ) == 0) then
      s_objName =  Name( Name( $s_tabName.$s_molCol [ i_row ] )[1] object unique )
      read mol $s_tabName.$s_molCol [i_row]  name=s_objName l_neutralAcids=yes
      set field a_ name=s_objTag copy off
      set field a_ name=s_lockObjTag copy off
      if (l_link) set property a_ auto
      set link a_ s_tabName $s_tabName.O [i_row]
# for Ox
      if(Type( $s_tabName.symmetry_Int_Tables_number )=="iarray") set symmetry a_ $s_tabName.symmetry_Int_Tables_number [i_row] Rarray( Split(Replace( $s_tabName.cell_length [i_row]+" "+ $s_tabName.cell_angle [i_row]  "(*)" "" ) ))
# for COD
      if(Type( $s_tabName.CELL_LENGTH_A )=="rarray") set symmetry a_ $s_tabName.SYMMETRY_SPACE_GROUP_NAME_H_M [i_row] $s_tabName.CELL_LENGTH_A [i_row] // $s_tabName.CELL_LENGTH_B [i_row] // $s_tabName.CELL_LENGTH_C [i_row] // $s_tabName.CELL_ANGLE_ALPHA [i_row] // $s_tabName.CELL_ANGLE_BETA [i_row] // $s_tabName.CELL_ANGLE_GAMMA [i_row]
# per-atom contribution
      # if(Type( $s_tabName.ATOM_CONTRIB ) == "parray" & Type( $s_tabName.ATOM_CONTRIB, 1 ) == "rvector") color a_//!h* $s_tabName.ATOM_CONTRIB [i_row]
#
    else
      s_objName =  Name( os_lockObj )[1]
    endif
    s_opt = "center"
    if (Nof( a_*.//DD & ! a_$s_objName.// ) != 0) s_opt = ""
    display xstick a_$s_objName. $s_opt
    display hydrogen
    #
    if (Type($s_tabName.$s_molCol [i_row] 2) != '2D') then
      if (Nof(a_$s_objName.//h*) < 1) build hydrogen
      set type charge mmff a_$s_objName.
      if Nof( Obj(a_*.A,N//DD) ) >= 1 then
        make hbond refresh Res(a_$s_objName.//DD) Res(a_*.//DD) name="hbondpairs"
        if (Nof(hbondpairs)>0) then
          display hbondpairs Res(a_*.//DD)
          keep global hbondpairs
        endif
      endif
    endif   # hbond section
  endif
endmacro
#
macro dsChemLock_new auto s_tabName s_prefix i_row l_link (yes)
# Notify Donovan about any changes in this macro
  l_confirm=no
  l_commands=no
  l_info=no
  interruptAction = "break all loops"
  GRAPHICS.l_redraw=no
  delete a_tmpmol.
  s_objTag = s_tabName + "_tmpmol"
  delete    Select( a_*. s_objTag ) & !Select( a_*. "usedInSlide" )
  #
  sel = Index( $s_tabName, selection )
  if (Nof(sel)==0 & i_row != 0) sel = sel // i_row
  #
  if (i_row == 0) sel = Count( Nof( $s_tabName ) )
  if (Nof(sel)==0) return
  #
  s_objTag = s_prefix[1:GUI.lockPrefixLength] + "_" + $s_tabName.O [ sel[1] ]

  os_obj = Select( a_*. s_objTag )
  l_on = Nof( a_*.//DD & os_obj ) == 0
  #
  hasColors   = Type( $s_tabName.KR ) == "iarray"
  hasScaffold = Type( $s_tabName.scaffold ) == "string"
  #
  s_molCol = "mol"
  if ( Type( $s_tabName.$s_molCol 2) == "2D" & Type(  $s_tabName.mol3D ) == "parray" & Type(  $s_tabName.mol3D 2 ) == "3D" ) s_molCol = "mol3D"
  #
  N=Nof(sel)
  if (N>5) print bar "Progress" N l_info=yes
  for i=1,Nof(sel)
    print bar N l_info=yes

    s_objTag = s_prefix[1:GUI.lockPrefixLength] + "_" + $s_tabName.O [ sel[i] ]
    os_obj = Select( a_*. s_objTag )
    if Nof(os_obj)==1 then
      s_objName =  Name( os_obj )[1]
    else
      s_objName =  Name( Name( $s_tabName.$s_molCol [ sel[i] ] )[1] object unique )

    endif
    if l_on then
      if ( Smiles(  $s_tabName.$s_molCol [sel[i]] ) != "" ) then
        # if (Nof(os_obj) == 0) then
          read mol $s_tabName.$s_molCol [sel[i]] name=s_objName l_neutralAcids=yes
          set field a_ name=s_objTag copy off
          if (l_link) set property a_ auto
          set link a_ s_tabName $s_tabName.O [sel[i]]
        # endif
        display xstick a_$s_objName.
        set field a_ name="lockView" copy off
        display hydrogen
        if ( hasScaffold ) then
          find chemical a_ Chemical(  $s_tabName.scaffold mol ) field
          if Nof( Select( a_// "d1" ) | Select( a_// "d2" ) ) == 2 global make distance refresh Select( a_// "d1" ) Select( a_// "d2" ) display name="distpairs"
          if Nof( Select( a_// "a1" ) | Select( a_// "a2" ) | Select( a_// "a3" ) ) == 3 global make distance angle refresh Select( a_// "a1" ) Select( a_// "a2" ) Select( a_// "a3" ) display name="angle_list"
          if Nof( Select( a_// "t1" ) | Select( a_// "t2" ) | Select( a_// "t3" ) | Select( a_// "t4" ) ) == 4 global make distance torsion refresh Select( a_// "t1" ) Select( a_// "t2" ) Select( a_// "t3" ) Select( a_// "t4" ) display name="torsion_list"
        endif
        if ( hasColors ) then
          s_color = Color( system $s_tabName.KR [ sel[i] ] )
          color xstick a_$s_objName.//c*  $s_color
        endif
        # per-atom contribution
        # if(Type( $s_tabName.ATOM_CONTRIB ) == "parray" & Type( $s_tabName.ATOM_CONTRIB, 1 ) == "rvector") color a_$s_objName.//!h* $s_tabName.ATOM_CONTRIB [ sel[i] ] // -2. // 2.
        #
        if (Type($s_tabName.$s_molCol [sel[i]] 2) != '2D') then
          if (Nof(a_$s_objName.//h*) < 1) build hydrogen
          set type charge mmff a_$s_objName.
          if Nof( Obj(a_*.A,N//DD) ) >= 1 then
            #
            make hbond refresh Res(a_$s_objName.//DD) Res(a_*.//DD) name="hbondpairs"
            if (Nof(hbondpairs)>0) then
              display hbondpairs Res(a_*.//DD)
              keep global hbondpairs
            endif
          endif
        endif   # hbond section
      endif
    else
      if Nof( Select( a_$s_objName. "usedInSlide" ) )>0 then
        undisplay a_$s_objName.
      else
        delete a_$s_objName.
      endif
    endif
  endfor
  print bar "End\n" l_info=yes
  GRAPHICS.l_redraw=yes
  display new
endmacro
#
macro dsChemUnlockAll s_tab
  l_commands = l_warn = l_info = no
  delete a_$s_tab*. & !Select( a_*. "usedInSlide") GRAPHICS.l_redraw=no
  delete Select( a_*. s_tab + "_*" ) & !Select( a_*. "usedInSlide") GRAPHICS.l_redraw=no
  undisplay Select( a_*. s_tab +"_*" ) & Select( a_*. "usedInSlide") GRAPHICS.l_redraw=no
  display new
endmacro
#
macro dsChemTemp T_tab i_row
  l_commands = no
  l_confirm = no
  l_info=no
  s_objName = "tmpmol"
  read mol T_tab.mol [i_row] name=s_objName
  set property a_ auto
  display xstick a_$s_objName.
endmacro
#
macro dsChemLock T_tab s_prefix i_row
  l_confirm=no
  l_commands=no
  l_info=no
  delete a_tmpmol.
  s_objName = s_prefix[1:GUI.lockPrefixLength] + T_tab.O [ i_row ]
  l_on = Nof(Name( a_$s_objName. )) == 0
  #
  sel = Index( T_tab, selection )
  if (Nof(sel)==0) sel = sel // i_row
  #
  for i=1,Nof(sel)
    s_objName = s_prefix[1:25] + T_tab.O [ sel[i] ]
    if l_on then
      read mol T_tab.mol [sel[i]] name=s_objName
      set property a_ auto
      display xstick a_$s_objName.
    else
      delete a_$s_objName.
    endif
  endfor
endmacro
#
macro stackFilterConf os_ ( a_ )  r_rmsd (0.5)
  if(Nof(os_ )==0) return error " stackFilterConf> no object selected"
  if(Nof(os_ stack)==0) return error " stackFilterConf> no stack found. Nothing to do."
  oscuol = a_
  set object os_
  delete selftether a_
  set selftether a_//!vt* Xyz( a_//!vt* ) l_info=no
  load conf a_ 1
  I_out = Iarray(0)
  for i=1,Nof(a_ conf)
    load conf a_ i
    rmsdpv = Srmsd(a_//!vt* selftether)
    printf "%d %.1f %s\n", i, rmsdpv, (rmsdpv<r_rmsd)?"DEL?":"OK"
    if(rmsdpv>=r_rmsd) then
       set selftether a_//!vt* Xyz( a_//!vt* ) l_info=no
    else
       I_out //= i  # mark for deletion
    endif
  endfor
  if(L_INFO) printf " Info> deleting %d stack conformations\n",Nof(I_out)
  if(Nof(I_out)>0) then
    delete stack
    load stack a_
    delete conf I_out
    store stack a_
  endif
  delete selftether a_//!vt* l_info=no
  set object oscuol
  l_info=no
endmacro

macro stackExportToMovie os_obj s_outputFile i_ncycle i_frames_before i_frames_after s_opt ("")
  l_commands=l_warn=no
  if (Extension(s_outputFile) == "") s_outputFile += ".mpeg"
  load conf Obj(os_obj) 1
  write movie s_outputFile
  write movie on exact

  if (i_frames_before) write movie frame i_frames_before
  display stack auto keep loop=i_ncycle Obj(os_obj) $s_opt
  if (i_frames_after ) write movie frame i_frames_after

  write movie off
  write movie exit
endmacro
#
macro slidesExportToMovie s_outputFile i_sillFrames (100) i_smooth (2000) i_blend (1000) i_rock (0) auto
  l_commands=l_warn=no
  if (Extension(s_outputFile) == "") s_outputFile += ".mpeg"
  s_trans = ""
  if (i_smooth != 0) s_trans += "move="  + i_smooth + ";"
  if (i_blend  != 0) s_trans += "blend=" + i_blend  + ";"
  write movie s_outputFile
  write movie on exact
  for i=1,Nof(slideshow)
    if (s_trans != "") then
      display slide=slideshow.slides index=i smooth=s_trans
    else
      display slide=slideshow.slides index=i
    endif
    if (i_rock) display display rotate pause i_rock
    write movie frame i_sillFrames
  endfor
  write movie off
  write movie exit
endmacro
#
# macro dsChemRowsLock s_tabName i_label
#   l_confirm=no
#   l_commands=no
#   l_info=no
#   #
#   s_prefix = s_tabName
#   #
#   if (i_label == 0) then
#     sel = Index( $s_tabName, selection )
#   else
#     add column $s_tabName Label( $s_tabName ) name="LBL"
#     sel = Index( $s_tabName.LBL == i_label )
#     delete $s_tabName.LBL
#   endif
#   #
#   if (Nof(sel)==0) return
#   #
#   if (Type( $s_tabName.O ) == "unknown" ) add column $s_tabName Count( Nof( $s_tabName ) ) name="O"
#   set format show $s_tabName.O off
#   #
#   s_objName = s_prefix[1:GUI.lockPrefixLength] + "_" + $s_tabName.O [ sel[1] ]
#   l_on = Nof(Name( a_$s_objName. )) == 0
#   #
#   for i=1,Nof(sel)
#     s_objName = s_prefix[1:GUI.lockPrefixLength] + "_" + $s_tabName.O [ sel[i] ]
#     if l_on then
#       read mol input=String( $s_tabName.mol [sel[i]] ) name=s_objName
#       set property a_ auto
#       set link a_ s_tabName $s_tabName.O [sel[i]]
#       display xstick a_$s_objName.
#       display hydrogen
#     else
#       delete a_$s_objName.
#     endif
#   endfor
# endmacro
#
macro editMoleculeTable3D s_tableName i_r
 l_commands = no
 l_info = no
 l_warn = no
 delete a_tmpedit.
 read mol $s_tableName.mol [i_r] name="tmpedit"
 set type mmff
 if Type( $s_tableName.NAME_ ) != "unknown" set field name="_MOLNAME" Mol( a_tmpedit. ) $s_tableName.NAME_ [ i_r ]
 editSelection a_tmpedit. no no no
 if i_out != 0 then
   l_dstemp = no
   l_dslock = no
   if Name( a_tmpmol. table ) == s_tableName then
     delete a_tmpmol.
     l_dstemp = yes
   endif
   if ( Type( $s_tableName.O ) != "unknown" ) then
     s_objName = s_tableName[1:GUI.lockPrefixLength] + "_" + $s_tableName.O [ i_r ]
     if Name( a_$s_objName. table ) == s_tableName then
       delete a_$s_objName.
       l_dslock = yes
     endif
   endif
   $s_tableName.mol [i_r] = Chemical( a_ exact hydrogen )
   # update locks
   if ( l_dstemp ) dsChemTemp_new String(s_tableName) i_r
   if ( l_dslock ) dsChemLock_new String(s_tableName) String(s_tableName) i_r
 endif
 delete a_tmpedit.
endmacro
#
macro extractLigand ms_lig s_type l_append s_tabName l_opt2D (no) auto
  l_commands = no
  l_info     = no
  ms_sel = ms_lig & Select( Mol(Obj( ms_lig )), "n<20" ) & !a_*.W
  if ( s_type == "2D" ) then
    ch = l_opt2D ? chem3dto2d( Mol( ms_sel ) ) : Chemical( Mol( ms_sel ) )
  endif
  if ( s_type == "3D" ) ch = Chemical( Mol( ms_sel ) exact hydrogen )
  #
  if ( Nof( Mol( Obj(ms_sel) ) ) == 1) then
    na = Name( Obj( ms_sel ))
  else
    na = Name( Mol( ms_sel ))
  endif
  na_full = Name( ms_sel full )
  #
  comm = Namex(  Mol( ms_sel ))
  if (!l_append) then
    s_tabName = Name("chem",unique)
    global group table $s_tabName ch "mol"  na "name" comm "comment" na_full "sel"
    if ( s_type == "3D" ) set property display $s_tabName
  else
    group table T_tmp ch "mol"  na "name" comm "comment" na_full "sel"
    add $s_tabName T_tmp Nof($s_tabName)+1
    delete T_tmp
  endif
  #set format $s_tabName.sel Link( "dsSelection '%1'" command )
endmacro
#
macro modifyGroup as_group s_Group l_reset_MMFF_types (yes) l_reassign_MMFF_charges (yes) l_optimize_geometry (no) i_Number_of_steps (600) auto
  l_info = no
  l_commands = no
  l_minRedraw=no
  set object Obj( as_group )
  if ( Nof(Next( as_group bond ) & a_//vt2 ) != 0 ) then
    convert (Select( Obj( as_group ) bond 1 ) & !as_group )[1] selection graphic
    #return error "can not modify tree root atom"
  endif
  modify as_group Tolower( Trim( s_Group , all) )
  if(Nof(mmff)==0) read libraries mmff s_icmhome+"mmff"
  if( l_reset_MMFF_types ) set type mmff a_
  if( l_reassign_MMFF_charges ) set charge mmff a_
  if( l_optimize_geometry ) minimize cartesian "vw,14,hb,el,to,af,bb,bs,ss" i_Number_of_steps
endmacro

macro modifyGroupSmilesLink as_group s_Group auto
  l_info = no
  l_warn =  no
  l_commands=no
  l_minRedraw=no

  s_oldObj = Name( a_ )[1]
  set object Obj( as_group )

  s_ligObj = Name( a_ )[1]
  icIcm = Type( a_$s_ligObj. 2 ) == "ICM"

  set field name = "EXFIELD_" a_$s_ligObj.//!vt,!h* Count(Nof(a_$s_ligObj.//!vt,!h*))

  if (Nof(Chemical( as_group exact hydrogen )) == 1) then
    scaffold = Chemical( Obj(as_group) as_group split link )
  else
    scaffold = Chemical( as_group split link )
  endif
  i_apo = Nof( Smiles(scaffold) "R\\d+" regexp )[1]
  if (i_apo != 2) return error " Error> selection with two attachment points is required"

  i_apo = Nof( Chemical(s_Group), "[*;**]" )[1]
  if (i_apo != 2) return error " Error> two attachment points are epected in subsitution"

  enumerate library scaffold Chemical(s_Group) name="T_enum"

  #read mol label rename T_enum.mol[1] name="tmplink" delete
  read mol T_enum.mol[1] name="tmplink" delete

  build hydrogen a_
  set type mmff a_
  randomize a_// 0.01
  convert auto a_
  superimpose a_$s_ligObj.//!h* a_//!h* chemical

  S_exfield = Field( a_tmplink.//!h* "EXFIELD_" )
  for i=1,Nof( S_exfield )
    if (S_exfield[i] == "") continue
    set tether Select( a_// "EXFIELD_==" + S_exfield[i] )Select(  a_$s_ligObj.// "EXFIELD_==" + S_exfield[i] ) # l_info = yes
  endfor

#  set tether a_tmplink.//!vt* a_$s_ligObj.//!vt*

  s_minTerms = "mmff,tz,"
  minimize cartesian s_minTerms a_ 1000 tzWeight=10.
  as_graph = a_//!T & a_//!h*,vt*
  delete tether a_tmplink.
  delete field a_// name="EXFIELD_"

  newlig = Chemical( a_ exact hydrogen select )
  delete a_
  delete a_$s_ligObj.
  read mol select newlig name=s_ligObj
#  as_graph = as2_out
  build hydrogen
  set type charge mmff
  randomize a_// 0.01
  if (icIcm) convert auto

  set object a_$s_oldObj.
endmacro

macro modifyGroupSmiles as_group s_Group l_reset_MMFF_types (yes) l_reassign_MMFF_charges (yes) l_optimize_geometry (no) auto
  l_info = no
  l_warn =  no
  l_commands = no
  l_minRedraw=no
  errorAction = "none"

  if (Index( Sarray(1,s_Group) smiles problem ) == {1}) return error " Error> Incorrect smiles"
  if (s_Group !~ "*ca99*") s_Group = Smiles( Chemical( s_Group ) )[1]   # smiles to Keckule notation

  s_oldObj = Name( a_ )[1]
  set object Obj( as_group )

  # check if non-terminal atom
  # if Nof(  Next( as_group bond ) & a_//!h* ) > 1 then
  #  if  ( Nof(  Next( as_group bond ) & a_//h* ) > 0 ) as_group =  ( Next( as_group bond ) & a_//h* )[1]
  # endif

  if Nof(as_group) > 1 then
     if Nof( Next( as_group bond ) & !as_group & !a_//vt* ) != 1 return error " Error> ambiguous group selection"
     if Nof( Next( Next( as_group bond ) & !as_group & !a_//vt* ,  tree ) & as_group ) == 0 then
       if (Nof(a_//h* & !as_group)>0) then
         convert (a_//h* & !as_group) [1] selection graphic
       elseif Nof(a_//* & !as_group)>0) then
         convert (a_//* & !as_group) [1] selection graphic
       else
         return error " Error> ambiguous group selection"
       endif
     endif
     as_group = Next( Next( as_group bond ) & !as_group ,  tree ) & as_group
     if (Nof( as_group ) != 1) return error " Error> ambiguous group selection"
  else
    #if  ( Nof(  Next( as_group bond ) & a_//h* ) > 0 ) as_group =  ( Next( as_group bond ) & a_//h* )[1]
    # check if root
    if ( Nof(Next( as_group bond ) & a_//vt2 ) != 0 ) then
      convert (Select( Obj( as_group ) bond 1 ) & !as_group )[1] selection graphic
    endif
  endif

  # replace APO with '*' and reorder so '*' is first
  s_APO = "\\[([\\w]+)\\*.*?\\]"
  s_APO_Element = Match( s_Group, s_APO, 1 )
  if (s_APO_Element != "") then
    s_Group = Smiles( Chemical( Replace( s_Group, s_APO, "*" regexp ) ) modify label )[1]
    s_Group = Replace( s_Group, "*", "*CC[" + s_APO_Element + "]" , simple )
  else
    s_Group = Replace( Smiles( Chemical( s_Group ) modify label )[1], "*", "*CC" simple )
    if( s_Group[1] != "*") s_Group="*CC"+s_Group
  endif
  #
  read mol label Chemical(s_Group) name="MODIFIER"
  build hydrogen
  set type charge mmff
  #
  randomize a_//* 0.01
  convert a_//x1
  minimize cartesian "vw,14,hb,el,to,af,bb,bs,ss" 5000
  set object Obj( as_group )
  #as_with = Next(Next(Next(a_MODIFIER_1.//x1) bond )[4] bond)[4]
  as_with = Next( Next( Next(a_MODIFIER_1.//x1) bond ) & a_MODIFIER_1.//c* bond )
  if Nof( as_with &  a_MODIFIER_1.//h* ) == 3 then
    as_with = ( as_with &  a_MODIFIER_1.//h* )[1]  # hydroghen modifier
  else
    as_with = ( as_with &  a_MODIFIER_1.//!h* )[2]  # second heavy
  endif
  modify as_group as_with select
  as_graph = as2_out
  #
  delete a_MODIFIER,MODIFIER_1.
  if( Nof(mmff)==0 ) read libraries mmff s_icmhome+"mmff"
  if( l_reset_MMFF_types ) set type mmff a_
  if( l_reassign_MMFF_charges ) set charge mmff a_
  if( l_optimize_geometry ) minimize cartesian "vw,14,hb,el,to,af,bb,bs,ss"  5000

  set object a_$s_oldObj.
endmacro
#
macro minimizeCartesian as_ i_nsteps (1400) l_ts (yes) r_weight (5.) auto
  GRAPHICS.l_redraw = no
  l_warn = no
  dielConst = 2.
  if(Nof(mmff)==0) read libraries mmff s_icmhome+"mmff"
  set object Obj( as_ )
  as_ = as_ | ( Next( as_ bond ) & a_//h* )
  if( Nof( Obj( as_ ) ) !=1 ) return error " minimizeCartesian_error> zero or more than one objects selected"
  if( Type( a_ 2 )!= "ICM"  ) return error " minimizeCartesian_error> object must be converted to ICM type"
  set type mmff a_
  set charge mmff a_
  if( l_ts ) set selftether as_ & a_//!h*
  minimize cartesian as_ "vw,14,hb,el,to,af,bb,bs,ss"+(l_ts?",ts":"") i_nsteps TOOLS.tsWeight = 5.  l_minRedraw = no
  if( l_ts ) delete selftether as_
  GRAPHICS.l_redraw = yes
  display new
endmacro

macro orientXYZ l_vertical (yes)
translate a_ -Mean( Xyz( a_ ) ) add
a = Tensor( Xyz( a_ ) )
b = Eigen( a )
if(l_vertical)then
  a[?,3] = b[?,1] / Length(  b[?,1] )
  a[?,1] = b[?,2] / Length(  b[?,2] )
  a[?,2] = Vector( a[?,3], a[?,1] )
  b=a
else
  b[?,1] = b[?,1] / Length(  b[?,1] )
  b[?,2] = b[?,2] / Length(  b[?,2] )
  b[?,3] = Vector( b[?,1], b[?,2] )
endif
rotate a_ Transpose( b )
endmacro

macro bindingScore ms_rec ( a_1 ) ms_lig ( a_2 ) r_ligVwhbtoFree (0.) s_covModRes ("") auto
HELP="""
 Docking binding score.
 Input: icm-converted objects with the default variable fixation
 Output: r_bindingScore variable contains the score and
          R_bindingScoreComponents contains score contributions:
           {Score, dE_ligstrain, dE_vw_steric, dE_conf_entropy_torsions,
            dE_electro_desolvation, dE_hbonds, dE_hydrophobic, dE_buried_hb}
"""
  l_warn = no
  l_commands = no
  l_info = no
  l_minRedraw=no

if Version(full) ~ "*Vls*" then

# params and methods are returned upon exit from macro (terms are never explicitly set)
  if(Nof(ms_rec)<1) return " bindingScoreError> empty receptor selection"
  if(Nof(ms_lig)<1) return " bindingScoreError> empty ligand selection"
  ms_rec = ms_rec & Obj(ms_rec)[1] & a_ICM.
  ms_lig = ms_lig & Obj(ms_lig)[1] & a_ICM.
  vwMethod = "soft"
  vwSoftMaxEnergy = 2.5

  surfaceMethod    = "constant tension"
  surfaceAccuracy = 5
  vwCutoff = 7.5
  electroMethod    = "generalized Born"  # will be used for the lig as well
#
# isolated receptor treatment
#
  if(Type(Obj(ms_rec),2)!="ICM"|Type(Obj(ms_lig),2)!="ICM") return " bindingScore_error> hint: both ligand and receptor must be converted to ICM type"

  s_oldCurrent = Name( a_ )[1]

  copy  Obj(ms_rec) "DOTMREC" delete
  set object a_DOTMREC.
  delete a_* & !Mol(Select(ms_rec a_))
  s_recMol = Sum(Name(a_*),",")
  set type mmff
  set charge mmff
  make born
  show energy "el" V_* mute  vwCutoff = 15.  # to consider ALL part. charge pairs
  eyElSolvRec = Energy("el")
  unfix V_//S only  # positionals V_//V are fixed here
  show hbond exact mute  # fills the 'u'ser field in atoms
  as_hbound = Select( a_//* "u>0.8" )
  recInternalHbond = Field( Atom( aHbDoAcSel on ))  # aHbDo.. selects ONLY in the current object anyway
  fix v_//*  # ? why or why?
  show area surface mute
  eygssf = Area( aHbDoAcSel & !as_hbound )
  qfdoacsf = 1./( Area( Atom( aHbDoAcSel on) )/5.+1.)

  show energy "sf" aHphobSel a_* mute
  eyHphobicRec = Energy("sf")
#  keep eyElSolvRec eygssf qfdoacsf eyHphobicRec as_hbound recInternalHbond
#
# isolated ligand treatment. fixation NOT changed
#
  copy  Obj(ms_lig) "DOTMLIG" delete
  set object a_DOTMLIG.
  delete a_* & !Mol(Select(ms_lig a_))
  set type mmff
  set charge mmff
  unfix V_//V  # just in case, do not touch internal fixation
  if(r_ligVwhbtoFree==0.) then
    ey0= 0.
  else
    show energy "vw,14,hb,to" mute # hb?
    ey0  = Energy("vw,14,hb,to" ) - r_ligVwhbtoFree  # for internal ligand strain.
  endif
  make born
  show energy "el" V_* mute vwCutoff = 15.
  eyElSolvLig = Energy("el")
  show area surface aHbDoAcSel a_* mute
  eygssf1 = Area( aHbDoAcSel )
  show energy "sf" aHphobSel a_* mute
  eyHphobicLig = Energy("sf")
# now only for the ligand
  nva=Nof( v_//!V,r* & v_//!M,T3,T43,T16,T15,T11,T48 ) # skip 'hard' torsions for entropy evaluation
#  keep eyLigFF eyElSolvLig eygssf1 eyHphobicLig nva
#
# calculating the joint score
#
  set object a_DOTMREC.
  move a_DOTMLIG. a_DOTMREC.  # rec=current. rec - fully fixed, lig as is
  set symmetry v_ 1
  set tether a_!$s_recMol ms_lig only

  if Length( s_covModRes ) then
    s_modResName = Field( s_covModRes, 2, "/" )
    #set a_// on  # turn on all atoms
    set a_/$s_modResName/ on  # turn on all atoms in s_modResName
    make bond a_!$s_recMol//cb99 a_/$s_modResName/ca simple
    set  a_!$s_recMol//ca99  off
    set  Next( a_!$s_recMol//ca99 bond ) & a_//h*  off
    set  a_$s_recMol//!n,c,o,ca,hn,ha & a_/$s_modResName/ off
  endif

  minimize 100 "tz,vw,14,el,hb,to,bb,bs,af" tzWeight = 10.

 # unfix only v_!$s_recMol | ( v_$s_recMol//x* & Res(Sphere( a_!$s_recMol a_$s_recMol//!h*,ca,cb,c,n,o 5.)))
   unfix V_//S only

# silently sets "hb" and restores
  show hbond exact a_$s_recMol a_$s_recMol |( aHbDoAcSel & a_!$s_recMol ) mute  # ? aHbDo with a_rec?
  eygb = -2.*Sum(Trim(Field( Atom( aHbDoAcSel & a_$s_recMol on ))-recInternalHbond,0.,10.)*qfdoacsf)  # check if sizes are the same
  make born
  show energy "el" V_* mute vwCutoff = 15.
  eyel= Energy("el") - (eyElSolvRec+eyElSolvLig)
  show area surface aHbDoAcSel & !as_hbound a_* mute

  #eysf = -2.*Sum((Area( aHbDoAcSel & !as_hbound) - (eygssf // eygssf1))/(Area( aHbDoAcSel & !as_hbound ) + (eygssf // eygssf1) + 5. ))
  R_area = Area( aHbDoAcSel & !as_hbound)
  R_ey = eygssf // eygssf1
  eysf = -2.*Sum((R_area - R_ey)/(R_area + R_ey + 5. ))

  show energy "sf" aHphobSel a_* mute
  eyhp = Energy("sf") - (eyHphobicRec+eyHphobicLig)
  show energy "vw,hb" a_!$s_recMol a_$s_recMol mute vwMethod = "soft" vwSoftMaxEnergy = 1.
  eySter= Energy("vw")
  r_bindingScore = ey0 + eySter + 0.6*nva + 0.66*eyel + 2.53*eygb + 0.67*eyhp + 0.75*eysf
#  print  "Ein=", ey0 ," EeySter=", eySter ," nva=", 0.6*nva , " eyel=", 0.66*eyel ," eygb=", 2.53*eygb ," eyhb=", 0.67*eyhp ," eysf=", 0.75*eysf
  if (l_info) print  "LigStrain=", ey0 ," Steric=", eySter ," Torsion=", nva , " Electro=", eyel ," Hbond=", eygb ," Hydroph=", eyhp ," Surface=", eysf
  if (l_info) print " r_bindingScore=" r_bindingScore
  R_bindingScoreComponents  = r_bindingScore // ey0 // eySter // nva // eyel // eygb // eyhp // eysf // 0.
  keep global r_bindingScore R_bindingScoreComponents
# delete temp objects
  delete a_DOTMREC.
  set object a_$s_oldCurrent.
else
  r_bindingScore = 0.
  R_bindingScoreComponents  = Rarray( 9 )
  keep global r_bindingScore R_bindingScoreComponents
endif
endmacro

macro branchScore as_
HELP = """
  Covalent ligand score evaluation.
  Returns the score of covalently attached ligands that may or may not be separated into a molecule
  Takes a branch in an ICM object and splits the object into two parts:
    a ligand   : a molecule containing the branch
    a receptor : the rest of the object
  then it applies bindingScore macro to calculate the Docking-VLS binding score .
  Output: r_bindingScore variable contains the score and
          R_bindingScoreComponents contains score contributions:
           {Score, dE_ligstrain, dE_vw_steric, dE_conf_entropy_torsions,
            dE_electro_desolvation, dE_hbonds, dE_hydrophobic, dE_buried_hb}

  Example:
    read pdb '2dca'
    convertObject a_ yes yes yes no yes no yes ''
    branchScore a_2

"""
  l_commands = no
  l_info = no
  as_ =  as_ & a_ICM.
  if(Nof(Obj(as_))!=1|Type(Obj( as_ ),2)!="ICM") return " Error> select a branch in ICM object"
  osoldcurr =  a_
  set object Obj(as_ );  ossrc=a_
  aslig = Atom(Select(as_ hydrogen)  )
  asrec = a_// & ! aslig
  set field aslig name="BSLIG"
  set field asrec name="BSREC"
  delete a_tmprec,tmplig.
  copy ossrc "tmprec" ; set object a_tmprec. ; modify Select(a_// "BSLIG")[1] a_//h* [2]
  copy ossrc "tmplig" ; set object a_tmplig. ; strip l_warn=no; delete Select(a_// "BSREC") ; convert exact a_ name="tmplig"
  delete field Atom(Obj(aslig | asrec |a_ | a_tmp*. )) name="BSREC"
  delete field Atom(Obj(aslig | asrec |a_ | a_tmp*. )) name="BSLIG"
  bindingScore a_tmprec. a_tmplig. 0.  ""
  delete a_tmprec,tmplig.
  set object osoldcurr
  printf " Info_branchScore> %s r_bindingScore=%.2f\n",Sum(Name(Res( as_ ) full )), r_bindingScore
  keep r_bindingScore R_bindingScoreComponents
endmacro

macro setApfTypes
 l_info=no
set type property index=1  { 0.   0.    0.    0.    0.    0.    0.   } Count( 1 49 )                     l_info=no   # generic hydrogens
set type property index=2  { 1.5 ,-.5  ,0.   ,-1.  ,-1.  ,0.   ,1.   } {6}//Count( 10 31 )               l_info=no   # hb donor hydrogens
set type property index=3  { -.5 ,1.5  ,-.5  ,-.5  ,0.   ,0.   ,-1.  } Count( 50 89)                     l_info=no   # generic oxygen
set type property index=4  { -.5 ,1.5  ,1.   ,-.5  ,0.   ,0.   ,-1.  } {61,62,64}//Count(80 85)          l_info=no   # oxygen sp2
set type property index=5  { -.5 ,1.5  ,1.   ,-1.  ,0.   ,-1.5 ,-1.  } {53,71,72}                        l_info=no   # oxygen negative
set type property index=6  { -.5 ,0.5  ,1.   ,0.   ,0.   ,0.   ,-1.  } {56,73}                           l_info=no   # oxygen aromatic/NO2
set type property index=7  { -.5 ,-.5  ,-.5  ,0.5  ,-.5  ,0.   ,-1.  } Count(  90  91)                   l_info=no   # F
set type property index=8  { -.5 ,-.5  ,-.5  ,1.   ,1.   ,0.   ,-.5  } Count(  92  97)                   l_info=no   # Cl Br I
set type property index=9  { -.5 ,-.5  ,-.5  ,1.   ,0.5  ,0.   , 1.  } Count( 100 180)                   l_info=no   # generic carbon
set type property index=10 { -.5 ,-.5  ,-.5  ,1.   ,1.   ,0.   , 1.  } Count( 108 114)                   l_info=no   # aliphatic carbon
set type property index=11 { -.5 ,-.5  , 1.  ,0.5  ,0.5  ,0.   , 0.5 } Count(102 107)//Count( 120 127)   l_info=no   # aromatic/sp2 carbon
set type property index=12 { -.5 ,-.5  , 1.  ,0.   ,0.5  ,1.5  , 0.5 } {103}                             l_info=no   # guanidium carbon "positive"
set type property index=13 { -.5 ,-.5  ,0.   ,-.5  ,0.   ,0.   ,-.5  } Count( 190 244)                   l_info=no   # generic nitrogen
set type property index=14 { -.5 ,-.5  ,1.   ,-.5  ,0.   ,0.   ,-.5  } {191,208,211,212,215,218,219,224,227,232,235} l_info=no # nitrogen sp2
set type property index=15 { -.5 ,1.5  ,1.   ,-.5  ,0.   ,0.   ,-.5  } {207,217,220,221,222,223,228,236} l_info=no   # nitrogen sp2 hb acceptor
set type property index=16 { -.5 ,-.5  ,1.   ,-1.  ,0.   ,1.5  , 0.  } {202,203,204,233}                 l_info=no   # nitrogen sp2 positive
set type property index=17 { -.5 ,1.5  ,0.   ,-.5  ,0.   ,0.   ,-.5  } {210,213,214,216,225,226,229}     l_info=no   # nitrogen hb acceptor
set type property index=18 { -.5 ,-.5  ,-.5  ,-1.  ,0.   ,1.5  , 0.  } {231,238}                         l_info=no   # nitrogen positive
set type property index=19 { -.5 ,0.   ,-.5  ,0.5  ,1.   ,0.   ,-.5  } Count(245,258)                    l_info=no   # generic sulfur
set type property index=20 { -.5 ,-.5  ,1.   ,1.   ,1.   ,0.   ,-.5  } {248}                             l_info=no   # aromatic sulfur
set type property index=21 { -.5 ,1.   ,1.   ,0.   ,1.   ,0.   ,-.5  } {246}                             l_info=no   # sp2 monocoord sulfur
set type property index=22 { -.5 ,1.5  ,0.   ,0.   ,1.   ,-1.5 ,-.5  } {255}                             l_info=no   # charged  sulfur
set type property index=23 { -.5 ,-.5  ,-.5  ,0.   ,1.   ,0.   , 0.  } Count(260,264)                    l_info=no   # generic phosphorus
#
set type property index=24 { 1.5 ,-.5  ,0.   ,-1.  ,0.   ,1.5  ,1.   } Count(287,297)                    l_info=no   # metal ions
# pharmacophoric centers for chemical-to-ph4 APF superposition
set type property index=25 { -.5 ,1.5  ,0.   ,-1.  ,0.   ,0.   ,0.   } {315}  l_info=no  # HBA
set type property index=26 { 1.5 ,-.5  ,0.   ,-1.  ,0.   ,0.   ,0.   } {322}  l_info=no  # HBD
set type property index=27 { -.5 ,0.   ,1.5  , .75 ,0.   ,0.   ,0.   } {317}  l_info=no  # aromatic
set type property index=28 { -.5 ,-.5  ,0.   , 1.5 ,0.   ,-.5  ,0.   } {318}  l_info=no  # hydrophobic
set type property index=29 { 0.  ,-.5  ,0.   ,-1.  ,0.   ,1.5  ,0.   } {319}  l_info=no  # positive
set type property index=30 { -.5 ,0.   ,0.   ,-1.  ,0.   ,-1.5 ,0.   } {320}  l_info=no  # negative
# set type property { -.5 ,-.5  ,0.   , 0.  ,0.   ,0.   ,0.   } {321} l_info=no   # excluded volume
set type property refresh
endmacro
#
macro clusterTableAPF s_tableName
  l_commands = l_info = no
  if ( Type( $s_tableName.mol ) != "parray" ) return error "cannot find 'mol' column"
  GRAPHICS.l_redraw = no
  for i=1,Nof( $s_tableName )
    read mol $s_tableName.mol [i] name="tmpapflig" delete
    build hydrogen
    set type charge mmff a_
     $s_tableName.mol [i] = Chemical( a_ exact hydrogen )
    delete a_
  endfor
  l_info = yes
  add header $s_tableName Score( $s_tableName.mol distance ) name="dm"
  l_info = no
  make tree $s_tableName full split="cl" distance = "dm"

  sort $s_tableName.ord
  keep global $s_tableName
endmacro
#
macro setChargeNN ms_x
  TOOLS.molGuessQfm = no
  if(Type(nnPartialCharge)=="unknown")then
    read binary s_icmhome + "nnPartialCharge.inm"
    keep nnPartialCharge
  endif
  ms_x = Mol(ms_x & ! a_.M )
  for i = 1 Nof(ms_x)
    ms_1 = Atom( ms_x [i] on )
    group table T_tmp_mol Chemical( ms_1 exact hydrogen object simple nosort) "mol"
    nat = Nof(T_tmp_mol.mol[1] atom)[1]
    predict T_tmp_mol nnPartialCharge
    partQ = T_tmp_mol.nnPartialCharge[1][1:nat]
    delete T_tmp_mol
    r_corr = -(Sum(partQ) - Sum(Charge(ms_1 formal)))/nat
    partQ=partQ + r_corr
    if(l_info) print " setChargeNN> corr./atom (total) = " r_corr "(" r_corr*nat ")"
    set charge Atom(ms_1) & ! a_.//vt* partQ
  endfor
endmacro
#
macro setChargeAliH ms_1
  as_ = ms_1 & a_.//C1,C3:5
  for i = 1 Nof( as_ )
    as_heavy = (Next( as_ [i] bond ) & a_//!vt* )[1]
    set charge as_heavy Sum(Charge(as_[i] | as_heavy))
    set charge as_ [i] 0.
  endfor
endmacro
#
macro setChargeAliC ms_1 r_q
  as_ = ms_1 & a_.//M1
  for i = 1 Nof( as_ )
    as_nb = (Next( as_ [i] bond ) & a_//!vt* )
    nh = Nof( as_nb & a_//h* ) # -1
    set charge as_nb & a_//h*  Charge(as_nb & a_//h* ) - r_q*nh*1.3
    set charge as_nb & a_//!h*  Charge(as_nb & a_//!h* ) - r_q*nh
    set charge as_ [i] Charge(as_ [i] ) + r_q*nh*(Nof( as_nb & a_//h* )*1.3 + Nof( as_nb & a_//!h* ))
  endfor
endmacro
#
macro setChargeNC ms_1 r_q
  as_ = ms_1 & a_.//n*
  for i = 1 Nof( as_ )
    as_nb = Next( as_ [i] bond ) & a_//M1
    set charge as_nb Charge(as_nb) - r_q
    set charge as_ [i] Charge(as_ [i] ) + r_q*Nof( as_nb )
  endfor
endmacro
#
macro mkSeqQsarTable s_aliName
# l_commands = yes
 tName = Name( s_aliName[1]+"q", unique) # alignment and Qsar
 if( Type(I_out)!="iarray"|Min(I_out)<1| Max(I_out)>Length( $s_aliName ) ) I_out = Count(Length( $s_aliName ) )
 $tName = Table( $s_aliName , I_out, label )
 S_out = Name( $tName )
 for i=2,Nof(S_out)
   s_out = S_out[i]
   SAAi = Sarray( $s_out , 1,1)
   AAs = Unique(Sort(SAAi))
   if(Nof(AAs)> 1) then
    for j=2,Nof(AAs)  # to avoid redundancy
      stmp = s_out + AAs[j]
      add column $tName Rarray( SAAi AAs[j] )  name=stmp
    endfor
   endif
 endfor
 print " Hint>  Add Column with Sequence Activities and Click on it and use Learn"
 keep $tName
endmacro

macro morph2tz i_nIter rs_loop l_store_in_object (no) l_play_morph (yes) i_mncalls (1000)
# You need initial ICM object tethered to the destination object (that can be PDB).
# rs_loop can contain multiple loops
  l_info=l_commands=no
  TZW = 100.
  VIC = 0.2
  rs_loop = Res(rs_loop)
  set object Obj(rs_loop)
  if(Type(Obj(rs_loop) 2) != "ICM" ) return " Error> the morphed fragment must belong to an ICM object tethered to the destination"
  if(Nof(a_//T & rs_loop)==0 ) return " Error> No tethers found. The morphed fragment needs to be tethered to the destination atoms"
  if(i_nIter<1) return
  delete stack
  v=Value(v_//*)
  printf " morph2tz> calculating the target torsions for %d residues\n", Nof(rs_loop)
  minimize tether rs_loop l_info=no  l_minRedraw=no
  delete vrestraint l_info=no
  vs_out = v_//* & rs_loop
  for i=1,Nof( vs_out )
    set vrestraint energy vs_out [i]  -20., 0., 200.   l_info=no
  endfor
  set v_//* v l_info=no
  store conf 1   # memorize initial conformation
  nSet = Nof( a_//* & ! Res( rs_loop ) )
  if(nSet>0) xyz = Xyz( a_//* & ! Res( rs_loop ) )  # memorize the non-loop regions.
  for i=1,i_nIter
     tsw = (i_nIter-i)/Real(i_nIter)
     tsw=TZW*Power(tsw,1.5)
     tzw=TZW-0.95*tsw
     rsw=10.+tsw
     minimize vs_out "vw,14,to,ts,tz,rs" selftether=a_//!vt* TOOLS.tsWeight=tsw mncalls=i_mncalls l_info=no vwCutoff=4.5 tzMethod=1 tzWeight=tzw rsWeight=rsw vwMethod=2 l_minRedraw=no
     if(nSet>0) set a_//* & ! Res( rs_loop  ) xyz l_info=no
     store conf i+1
     store frame
     printf " morph2tz> conf %d srmsd= %.2f angles=%.2f vw=%.2f\n" i+1,Srmsd( rs_loop & a_//T ),10.+10.*Energy("rs")/(20.*rsw*Nof(vrestraint)), Energy("vw")/Real(Nof(a_//!h*))
   endfor
#   store frame write # to close the trajectory file. DOES NOT WORK IF w='-' dir
   load conf 1 # restore the beginning
   if(l_store_in_object) store stack a_
   if(l_play_morph) display stack cartesian 80. loop=2
endmacro

macro morphFrames auto i_n (10) l_minimize (no) l_bb (no)
HELP="""
  Makes intermediate frames between stack conformations in the current object
  It makes Cartesian interpolation for the backbone and angular between side chains.
"""
  if(Nof(a_ conf)==0) return " Warning> nothing to do, no stored stack found in the current object"
  delete stack  # cleaning external stack
  load conf a_ 1;  store conf
#
#stack
  oldfix = v_//
  unfix V_//
  vars = v_//!V & a_//!ca,c,n,o,ha,hn
  if(l_minimize) vwMethod = "soft"
  for i=1,Nof(a_ conf)-1
    load conf a_ i  ;  X1 = Xyz( a_// ) ; sc1 = Value( vars )
    load conf a_ i+1 ; X2 = Xyz( a_// ) ; sc2 = Value( vars sc1 )  # uses ref values for smooth var interpol
    for j = 1,i_n
      X = (X1*(i_n-j) + X2 *j)/Real(i_n)
      if(!l_bb) set a_// X  # more expensive way to keep the bb geo is to use X as tethers.

      set vars  (sc1*(i_n-j) + sc2 *j)/Real(i_n)
      if(l_minimize) then
         unfix only oldfix  # restore
         if(l_bb) then
           set selftether a_// X  # more expensive way to keep the bb geo is to use X as tethers.
         else
           set selftether a_ only
         endif
         minimize "vw,14,to,hb,ts" TOOLS.tsWeight = 100.
         minimize "vw,14,to,hb,ts" TOOLS.tsWeight = 20.
         minimize "vw,14,to,hb,ts" TOOLS.tsWeight = 5.
         unfix V_// ; delete selftethers
      endif
      store conf
    endfor
  endfor
  unfix only oldfix  # restore
  store stack a_  # put the conformations inside back the object
  delete stack
endmacro

macro makeTrajectoryFromStack
  l_info=no
  if(Nof(conf)==0) return
  store conf # remember the current state
  for i=1,Nof(conf)-1
    load conf i
    store frame
  endfor
  store frame write  # close the file
#
  load conf Nof(conf) # restore
  delete conf Nof(conf)
endmacro

macro playObjectStack os_ r_from (10.) r_to (40.) s_options ("")
  l_info=no
  if( Nof(os_ stack)==0 | Nof( os_ & a_*.//DD ) == 0 ) return
  set object Obj( os_ )
  load stack a_
  makeTrajectoryFromStack
  display trajectory r_from r_to $s_options
  load frame 1  # to restore
endmacro

macro calcRoc R_scores I_labels l_keep_table (no)
 l_commands = no; l_info=no
 l_show_results=yes
 ntrial=1 # theoritical estimate is better 28.8/sqrt(Npositives)
 l_showresults = yes
  Y = R_scores
 L = I_labels
 ny = Integer(Sum(L))
 nt = Nof(Y)
 rnt=Real(nt)
 if(ny<=0) return error
 group table troc L "A" Iarray(L) "AR" Y "S" Rarray(Y) "R" Rarray(nt) "X" Rarray(nt) "N"
 RocR   = Rarray(ntrial)
 for itrial=1,ntrial
   sort troc.R
   troc.N=(100.*Integral(troc.AR))/Real(ny)
   troc.X=(100.*Integral(Iarray(nt,1)-troc.AR))/Real(nt-ny)
   auc = troc.X[1]*troc.N[1]
   for i= 2,nt
     xsp = troc.X[i]-troc.X[i-1]
     auc += xsp*troc.N[i]
   endfor
   auc /= 100.
 endfor
 rocrms = 28.8/Sqrt(ny)
 R_out[1] = auc
#Hanley and McNeil 1982
 tetta = auc/100  # we are keeping the notation of Hanley .. 1982.
 nA = nt-ny # nof of all - number_of_positives => nof_negatives
 nN = ny    # nof_positives
 Q1 = tetta/(2-tetta)
 Q2 = 2*tetta*tetta/(1+tetta)
 SE = 100*Power( (tetta*(1-tetta)+(nA-1)*(Q1-tetta*tetta)+(nA-1)*(Q2-tetta*tetta))/(nA*nN) , 1./2) # SE, %
 z = (auc - 50)/SE # z-score for gaussian
 if(z<0.0000001) then
   z=0.0000001; log_pAuc=0.
 elseif(z>9.9) then  # large z
   z=9.9; log_pAuc = -100.
 else
   log_pAuc = Log(Error(z))  # logPvalue, 1-tailed
 endif
 R_out =  R_out//Error(z)  # [2]
 R_out =  R_out//log_pAuc  # [3]

 if(l_show_results) printf " Info> roc=%.0f  rnd=50. Pvalue=%.1g logPvalue=%.1f (rndrms=%.1f)\n",auc,z,log_pAuc,rocrms
 if(l_keep_table) then
   add header troc auc rocrms Error(z),log_pAuc name={"auc","rms","pAuc","log_pAuc"}
   make plot troc "x=X;y=N;;element=polygon;xy=0,0,100,100;;title=ROC curve"
   if(l_showresults) printf " Info> 'troc' with .X and .N arrays and .auc .rms .pAuc and .log_pAuc values saved\n"
   keep troc
 endif
endmacro

macro calc3Rocs R_scores I_labels l_keep_table (no) s_color ("navy") auto
 l_commands = no ; l_info=no ; l_show_results = no

 nofPoints = Nof(R_scores)
 nofCorrect = Integer(Sum(I_labels))
 nofWrong = nofPoints - nofCorrect

 R_out = Rarray(5)
 if (nofCorrect == 0 | nofWrong == 0) return

 group table troc R_scores "Score" copy Rarray(I_labels) "correct" Rarray(nofPoints) "rateTP" Rarray(nofPoints) "rateFP" Rarray(nofPoints) "rateTN" Rarray(nofPoints) "rateFN" Rarray(nofPoints) "rateAll" Rarray(nofPoints) "sqrtRateAll" Rarray(nofPoints) "sens" Rarray(nofPoints) "spec" Rarray(nofPoints) "prec" Rarray(nofPoints) "accu" Rarray(nofPoints) "F1" Rarray(nofPoints) "matt" Rarray(nofPoints) "prob" Sarray(nofPoints,s_color) "color"
 sort troc.Score
 for i_tmp = 1, Nof(troc)
   if (i_tmp > Nof(troc)) break
   if (Nof(troc.Score==troc.Score[i_tmp])==1) continue
   i_noftmp = Nof(troc.Score==troc.Score[i_tmp])
   troc.correct[Index(troc.Score==troc.Score[i_tmp])] = Sum( troc.correct[Index(troc.Score==troc.Score[i_tmp])])/i_noftmp
   i_tmp = i_tmp+i_noftmp-1
 endfor
 troc.rateTP      = (100. * Integral(troc.correct))   / Real(nofCorrect)
 troc.rateFP      = (100. * Integral(1-troc.correct)) / Real(nofWrong)
 add column troc Count(Nof(troc)) name="idx"
 sort troc.idx reverse
 troc.rateTN      = (100. * Integral(1-troc.correct)) / Real(nofWrong)
 troc.rateFN      = (100. * Integral(troc.correct))   / Real(nofCorrect)
 sort troc.idx
 delete troc.idx
 troc.rateAll     = (100. * Count(nofPoints))         / Real(nofPoints)
 troc.sqrtRateAll =  100. * Sqrt(Count(nofPoints)     / Real(nofPoints))
 troc.sens        =  troc.rateTP
 troc.spec        =  troc.rateTN
 troc.prec        = (100. * Integral(troc.correct))   / Count(Nof(troc))
 troc.accu        =  (troc.sens *nofCorrect + troc.spec *nofWrong)/nofPoints
 troc.F1          =  (troc.sens*nofCorrect*2.)/(2.*troc.sens*nofCorrect+troc.rateFP*nofWrong+troc.rateFN*nofCorrect)
 troc.matt        =  (troc.rateTP*nofCorrect+troc.rateFP*nofWrong)* (troc.rateTP*nofCorrect+troc.rateFN*nofCorrect)\
 *(troc.rateTN*nofWrong+troc.rateFP*nofWrong)* (troc.rateTN*nofWrong+troc.rateFN*nofCorrect)
 troc.matt        =  Sqrt(Max(Rarray(Nof(troc) 1.) troc.matt))
 troc.matt        =  (troc.rateTP*nofCorrect*troc.rateTN*nofWrong-troc.rateFP*nofWrong*troc.rateFN*nofCorrect)/troc.matt
 troc.prob        = (troc.rateTP-troc.rateFP)/(troc.rateTP+troc.rateFP)

 ### R_out[1:3] contain areas under curve where TP are plotted against (1) FP; (2) total; (3) square root total; #2 and #3 normalized
 xIncrements = troc.rateFP   -  ({0.} // troc.rateFP[1:nofPoints-1])      ; R_out[1] = 0.01 * Sum(troc.rateTP * xIncrements)
 R_out[2] = Sum(troc.rateTP) / nofPoints
 xIncrements = troc.sqrtRateAll-({0.} // troc.sqrtRateAll[1:nofPoints-1]) ; R_out[3] = 0.01 * Sum(troc.rateTP * xIncrements)
 ### Normalized #2 and #3 are stored in #4 and #5
 idealAUC = Sum(Rarray(Count(nofCorrect)//Iarray(nofWrong, nofCorrect)) / (nofPoints * nofCorrect))
 R_out[4] = (R_out[2]-50.) / (idealAUC-0.5)              ### ideal 1.-0.5*nofCorrect/nofPoints ; random 0.5
 idealAUC = Sum(Rarray(Count(nofCorrect)//Iarray(nofWrong, nofCorrect)) * xIncrements / nofCorrect)
 R_out[5] = 100. * (R_out[3]-100./3) / (idealAUC-100./3) ### ideal calculated; random 100./3

 if l_show_results printf "*TP_FP_ROC_AUC = %.1f, TP_ALL_AUC = %.1f, TP_SQ_ALL = %.1f, N_TP_ALL_AUC = %.1f, *NSQ_AUC  = %.1f (R_out[1:5])\n" R_out[1] R_out[2] R_out[3] R_out[4] R_out[5]
 if l_keep_table then
   group table troc append 0.01 * Abs((100. - troc.rateTP) * nofCorrect + troc.rateFP * nofWrong) "errors" Iarray(Nof(troc)) "series"
   make plot troc "x=rateFP;y=rateTP;shape=circle;size=3;style=connected;series=series;color=color;;element=polygon;xy=0,0,0,100,100,100;;title=ROC curve"
   make plot troc "x=rateAll;y=rateTP;shape=circle;size=3;style=connected;series=series;color=color;;element=polygon;xy=0,0,"+String(100.*Real(nofCorrect)/nofPoints)+",100,100,100;;title=TP against all"
   polygonStr = Sum(Sarray((10.*Count(0,10))*Sqrt(Real(nofCorrect)/nofPoints)) + Sarray(11, ",") + Sarray(Count(0,10)*Count(0,10)), ",") + ",100,100,"
   polygonStr = polygonStr + Sum(Sarray(10*Count(10,0)) + Sarray(11, ",") + Sarray(Count(10,0)*Count(10,0)), ",")
   make plot troc "x=sqrtRateAll;y=rateTP;shape=circle;size=3;style=connected;series=series;color=color;;element=polygon;xy="+polygonStr+";;title=TP against Sqrt of all"
   add ROCs troc
   keep ROCs
 endif
endmacro
#
macro calcMCC I_1 I_2 l_silent (no) auto
  l_info = l_warn = l_commands = no
  if (Nof(I_1)==0) return "Please specify two iarray of equal length"
  if (Nof(I_2)==0) return "Please specify two iarray of equal length"
  if (Nof(I_1)!=Nof(I_2)) return "Please specify two iarray of equal length"
  I_tmp = Unique(Sort(I_1 // I_2))
  N = Nof(I_tmp)
  group table t_tmpmacro I_1 "A" I_2 "B"
  M_tmpmacro = Matrix(N N)
  for i = 1, N
    for j = 1, N
      M_tmpmacro [i,j] = Nof(t_tmpmacro.A == I_tmp[i]  & t_tmpmacro.B == I_tmp[j])
    endfor
  endfor
  r_1 = 0.
  r_2 = 0.
  r_3 = 0.
  for k = 1, N
    for l = 1, N
      for m = 1, N
        r_1 = r_1 + (M_tmpmacro[k,k]* M_tmpmacro[m,l]) - (M_tmpmacro[l,k]*M_tmpmacro[k,m])
      endfor
    endfor
  endfor
  for k = 1, N
    r_21 = 0.
    for l = 1, N
      r_21 = r_21 + M_tmpmacro[l,k]
    endfor
    r_22 = 0.
    for f = 1, N
      if (f == k) continue
      for g = 1, N
        r_22 = r_22 + M_tmpmacro[g,f]
      endfor
    endfor
    r_2 = r_2 + r_21 * r_22
  endfor
  if (r_2 <= 0. ) return "r_2 is less than 0, something isn't right"
  for k = 1, N
    r_31 = 0.
    for l = 1, N
      r_31 = r_31 + M_tmpmacro[k,l]
    endfor
    r_32 = 0.
    for f = 1, N
      if (f == k) continue
      for g = 1, N
        r_32 = r_32 + M_tmpmacro[f,g]
      endfor
    endfor
    r_3 = r_3 + r_31 * r_32
  endfor
  if (r_3 <= 0. ) return "r_3 is less than 0, something isn't right"
  r_out = r_1 / Sqrt(r_2) / Sqrt(r_3)
  if (!l_silent) print "Matthew's Corelation Coefficient:" r_out
  keep r_out
endmacro
#
macro calcNsa R_scores I_labels r_score_error (0.) l_linear_auc (no) l_keep_table (no) l_showresults (yes)
# Normalized Square-rank Area Under Curve
  ntrial=1; l_info=no
  Y = R_scores; L = I_labels; ny = Integer(Sum(L)); nt = Nof(Y); rnt=Real(nt)
  if(ny<=0) return error
  group table tnsa L "A" Y "S" Rarray(Y) "R" Rarray(nt) "X" Rarray(nt) "N"
  if(r_score_error>0.00001) ntrial=35

  Nosauc = Rarray(ntrial)
  Roc    = Rarray(ntrial)
  for itrial=1,ntrial
    if(itrial>1)tnsa.R = tnsa.S + Random(0.,r_score_error,nt,"gauss")
    sort tnsa.R
    tnsa.N=(100.*Integral(tnsa.A))/Real(ny)
    tnsa.X=Sqrt(100.*Rarray(Count(nt))/rnt)
    if(l_linear_auc) tnsa.X=(100.*Rarray(Count(nt))/rnt)
    auc = tnsa.X[1]*tnsa.N[1]
    pauc = tnsa.X[1]*100./Real(ny)
    for i= 2,nt
      xsp = tnsa.X[i]-tnsa.X[i-1]
      auc += xsp*tnsa.N[i]
      pauc+= xsp*100.*Min(i,ny)/Real(ny) # perfect
    endfor
    if(l_linear_auc) then
      auc /= 100.; pauc /= 100.; arand = 50.0    # linear
    else
      auc /=  10.; pauc /= 10.; arand = 33.3333  # sq
    endif
    Nosauc[itrial] = 100.*(auc-arand)/(pauc-arand)
  endfor
  rndrms = 13.3/Sqrt(ny)
  if(l_linear_auc) rndrms = 28.8/Sqrt(ny)

  nosauc     = Nosauc[1]
  nosauc_ave = Mean(Nosauc)
  nosauc_rms = Rmsd(Nosauc)
  nosauc_rndrms = 100.*rndrms*(Abs(auc-arand)+Abs(pauc-arand))/((pauc-arand)*(pauc-arand))  # correct here with the formula (auc-arand)/(pauc-arand)
  nosauc_nmr = 100.*Index(Sort(Iarray(tnsa.N)//50),50)/rnt
  R_out = nosauc//nosauc_ave//nosauc_rms//nosauc_rndrms//nosauc_nmr
  if(l_showresults) then
    if(ntrial==1) printf "  Info> nosauc= %.1f =100*(%.0f-%.0f)/(%.0f-%.0f) rndrms= %.1f nmr= %.1f . See R_out[1:5]\n",nosauc,auc,arand,pauc,arand,nosauc_rndrms,nosauc_nmr
    if(ntrial> 1) printf "  Info> nosauc= %.1f  nosauc_ave= %.1f nosauc_rms= %.1f rnd=0.+- %.1f nmr= %.1f . See R_out[1:5]\n",nosauc,nosauc_ave,nosauc_rms,nosauc_rndrms,nosauc_nmr
  endif
  # nosauc = (A -Arandom)/(Aperfect-Arandom)
  if(l_keep_table) then
    add header tnsa nosauc nosauc_ave nosauc_rms nosauc_rndrms nosauc_nmr String(l_linear_auc,"linear","sqrt") name={"nsa","nsamean","nsarms","rndrms","nmr","type"}
    make plot tnsa "x=X;y=N;;element=polygon;xy=0,0,100,100;;title=NSA curve"
    keep tnsa
  endif
endmacro

macro scanMutations rs_  S_mutations l_append (no)
   l_commands=l_info=l_warn=no
   l_minRedraw=no
   rs_ = Res( rs_ )
   if(Nof(rs_)==0| Nof(S_mutations)==0|Type(Obj(rs_)[1],2)!="ICM") return error
   if(!l_append) delete tmuts
   if(Type(tmuts)!="table") then
     group table tmuts Sarray(0),"res1",Sarray(0),"res2",Sarray(0),"muta",Rarray(0) "ener",Rarray(0) "enre"
     add header tmuts "as_graph=Res( %1 )" name={"doubleClick"}
   endif

   set object Obj(rs_)[1]
   for ires=1,Nof(rs_)
     sres= Label( rs_ [ires] )[1]  # A23

     copy Obj(rs_)[1] "mutant" delete
     sori= String( Select( rs_ [ires] a_mutant. ))    # a_mutant.a/^A23
     set object a_mutant.
     unfix only V_//S
     mutateResidue $sori Name( rs_ [ires] )[1]  # the goal is to 'regularize' the source residue to make it comparable
     minimize "vw,14,to,el,hb,ss,ts" v_//x* & $sori selftether= $sori TOOLS.tsWeight = 1.  # since it can be strained
     er0 = Energy( $sori simple)
     ey0 = Energy ( a_/A simple )

     for imut=1,Nof(S_mutations)
       smut=Trim(Tolower(S_mutations[imut]),all)
       add tmuts; ir = Nof(tmuts)
       tmuts.res1[ir]= String ( rs_ [ires]  )
       tmuts.res2[ir]=smut
       tmuts.muta[ir]=sres+Tr321(smut)

       copy Obj(rs_)[1] "mutant" delete

       rsn = Select( rs_ [ires] a_mutant. )
       srsn = String(rsn)
       set object a_mutant.
       unfix only V_//S
       mutateResidue Res(rsn) [ires] smut
       rsn = $srsn

       if(Index("arg,lys",smut)==0) ssearch v_//xi* & rsn   "vw,14,hb,to,ss,el" mute mncalls=100
       if(Index("arg,lys",smut)!=0) montecarlo v_//xi* & rsn "vw,14,hb,to,ss,el"  mute mncalls=100 mncallsMC=1000

       ey1=Energy(a_/A simple)
       er1=Energy(rsn simple)
       tmuts.ener[ir]=Sum(ey1-ey0)
       tmuts.enre[ir]=Sum(er1-er0)
     endfor
   endfor
   delete a_mutant.
   keep tmuts
endmacro

macro test_sdf ms_
  l_commands = l_warn = no
  l_info=no
  ms_ = Mol(ms_)
  for ip = 1,Nof( ms_ )
    ms1 = ms_ [ip]
    copy Obj( ms1 ) "tmp_"+Name(Obj(ms1))[1] delete
    smol = Name( ms1 )[1]
    set object a_tmp_*.
    l_cov_attached = Nof( Mol(Next( ms1 bond)) & !(ms1) ) > 0
    if l_cov_attached then
      delete a_tmp_*.
      continue
    endif
    delete a_!$smol | a_//AS
    set comment a_//* " "
    nat = Nof(a_tmp_*.//!v*,h*)
  # legitimate ligand tests: include covalent binding exclusion and zero occup.
    if( nat>3 & nat<60 & Nof( Res(a_tmp_*.*))==1 & Min(Occupancy(Atom(ms1)))>0.2 ) then
    if( Type(Obj( a_tmp_*. ) ,2 )!="ICM")  convertObject a_tmp_*. yes no yes no no no no ""

    cf1 = Sum(Charge(a_ formal)) # formal charge after conversion
    nh1 = Nof(a_//h* )
    smol = String(Chemical( a_ exact hydrogen ))
    read mol input=smol name="tmp1" delete          # formal charge after exact hydrogen
    cf2 = Sum(Charge(a_//* , formal))
    nh2 = Nof(a_//h* )
    if(cf1!=cf2 ) printf "\n FC mismatch in %s(%d):  %.1f %s  | %.1f %s\n",Field(Sarray(ms1)[1],1,"/"),nat,cf1,String(Formula( Chemical( a_ ) )),cf2,""
    if(nh1!=nh2 ) printf "\n nH mismatch in %s(%d):  %d %s  | %d %s\n",Field(Sarray(ms1)[1],1,"/"),nat,nh1,String(Formula( Chemical( a_ ) )),nh2,""
    endif
    delete a_tmp_*,tmp1. mute
  endfor
endmacro

macro colorGrobByProximity &g_ as_ (as_graph) s_rainbow ("#ffff00/#00aaaa") r_max (5.) i_NofSteps (10) l_colorPatchOnly (yes)
  l_commands = l_info = no
  GRAPHICS.l_redraw = no
  if(!l_colorPatchOnly) color g_ rgb=Color(1.,s_rainbow)
  for i=0,i_NofSteps
    dist = r_max - i * (r_max-1.5)/Real(i_NofSteps)
    color g_ as_ rgb=Color(dist/r_max,s_rainbow) GROB.atomSphereRadius=dist
  endfor
  GRAPHICS.l_redraw = yes
  display new
endmacro

macro molcolors auto as_ (a_*.*) s_rainbow ("")
HELP = """
  Set colors by molecule, chain or object.
  To see color names, type makeColorTable or from GUI: View/View Colors
  To color by chain, start color lists with word 'chain'
  Example:
  molcolors a_*.                             # by object
  molcolors a_*. 'chain seagreen plum pink'  # by chain
  molcolors a_*.* 'red white'                # by molecule
"""
  l_commands = l_info=no
  GRAPHICS.l_redraw = no
  s_rainbow = Trim( s_rainbow all)
  fd1 = Field(s_rainbow,1,"  //,,;;"); lefd1=Length(fd1)
  if(fd1=="chain"|fd1=="molecule"|fd1=="object") then
    if(lefd1< Length(s_rainbow)) s_rainbow = s_rainbow[lefd1+1:$]
    if(lefd1>=Length(s_rainbow)) s_rainbow = ""
    krby = fd1
  else
    krby = Type( as_ 1 ); if(krby=="atom") krby = "molecule"
  endif
  if(Length(s_rainbow) < 15) s_rainbow += " skyblue yellow green orange aquamarine brown darkorange gold pink navy seashell lightcoral lightyellow lightgreen sienna aliceblue maroon lightcyan hotpink1"
  s_rainbow = Replace(Trim(s_rainbow,all)," ","/")
print krby, s_rainbow
  color field as_ delete
  color field $krby store as_ GRAPHICS.discreteRainbow=s_rainbow
  GRAPHICS.l_redraw = yes
  display new
endmacro

macro molskins auto as_ ( a_//!h* ) l_grob (yes) l_colorByContact (yes) s_rainbow ("")
  l_commands = l_info = l_warn = no;  GRAPHICS.l_redraw = no
  l_colorByResidue = no
  if(s_rainbow=="residue") then; l_colorByResidue = yes; s_rainbow=""; endif
  s_rainorig = s_rainbow
  if(s_rainbow==""&GRAPHICS.discreteRainbow!="") s_rainbow=GRAPHICS.discreteRainbow
  if(s_rainbow==""&GRAPHICS.discreteRainbow=="") s_rainbow="maroon skyblue yellow green orange aquamarine brown darkorange gold pink navy seashell lightcoral lightyellow lightgreen sienna aliceblue maroon lightcyan palevioletred"
  show s_rainbow
  scolrs = Trim(Split(Tolower(s_rainbow),"  /\n"),all)
  scolrs = Sarray(scolrs[ $ ])//scolrs[1:$-1]   # permutation since Mod(1,N)+1 is 2
  ms_ = Mol( as_ )
  msoff = Select(ms_ off)
  set Atom( ms_ ) & ! as_ off
  nn = Nof(Atom(ms_))-Nof(Atom(as_)); if(nn>0) printf " Info> %d atoms outside selection temporarily hidden\n", nn
  as2_out = ms_ & a_*.!W
  display ms_ & a_*.M ball
  set xstick ms_ & a_*.M  0.3*(Radius(Atom(ms_ & a_*.M//!vt*)))
  display residue label ms_& a_*.M
  ms_ = Mol( ms_ & a_*.!W,M )
  delete field Atom(Obj(ms_)) name="contact"
  delete field Atom(Obj(ms_)) name="contact2"
  N = Nof( ms_ )
  delete MOL_SKINS l_warn=no
  add column MOL_SKINS Name( ms_ full ) Namex( ms_ ) Sarray(N)  Sarray(N) Type( ms_ all) Iarray(N) Rarray(N) Rarray(N) name="S"//"Info"//"G"//"C"//"T"//"nR"//"A"//"CA"
  if(l_grob) print bar "Making Surfaces"  N l_info = yes
  for i=1,N
    if(l_grob) print bar N l_info = yes
    as_out = ms_ [i]
    icol = 1 + Mod( i, Nof( scolrs ))
    s_mainColor = Color( Mol( as_out ) field )[1]
    scolr = (s_mainColor == "")?(scolrs[icol]):s_mainColor
    if(s_mainColor == "") color field store as_out & a_*.//c*,h* $scolr
    if(!(l_grob&l_colorByResidue)) then
      display xstick as_out
      display ribbon as_out $scolr
      color ribbon base as_out & a_*.N $scolr
      display residue label as_out $scolr
      color xstick a_*.*//c*,h* & as_out  $scolr
      display wire cpk as_out & a_*.//c* $scolr
      undisplay wire cpk as_out # & a_*.//c*,h*
      set label as_out & a_*.A//DD & (a_*.A/!asp,asn,gln,glu,arg,leu,val,pro/!c,o,h* | a_*.A/pro/cg | a_*.A/glu,asp,asn,gln,arg,leu,val/!c,o,h*,o*,n*,cd?,cg? ) & Res(a_*.//DD)
    endif
    if(l_grob) then
      s_out  = Replace(Name( as_out full )[1], ".","_"); s_out[1]='g'
      if(Type( $s_out )=="unknown") then; make grob skin as_out as_out; compress $s_out 0.3; endif
      color $s_out $scolr
#      color $s_out rgb=Color(r_dim, scolr + "/white" )  #  not enough colors for meaningful shading
      set property $s_out smooth
      MOL_SKINS.G[i] = s_out
    endif
    show surface area mute as_out as_out
    set field Res(as_out) Area( Res(as_out) ) name="area1"
    MOL_SKINS.A[i] = Sum(Field(Res(as_out),"area1"))
    show surface area mute as_out as2_out
    set field Res(as_out) Trim(Field(Res(as_out),"area1")-Area( Res(as_out)),0.,9999.) name="cntarea"
    MOL_SKINS.CA[i] = Sum(Field(Res(as_out),"cntarea"))
    MOL_SKINS.C[i] = scolr
    MOL_SKINS.nR[i] = Nof( Res( as_out ))
    MOL_SKINS.Info[i] = MOL_SKINS.Info[i] +  Name(as_out swiss)[1]
  endfor
  set format MOL_SKINS.C color="C"
  set format MOL_SKINS.A MOL_SKINS.CA "%.1f"
  if(l_grob) print bar N l_info = yes
  for i=1,N
    for j=1,N
      if(i==j | Obj( $MOL_SKINS.S[i] ) != Obj( $MOL_SKINS.S[j] )) continue
      if(l_grob & l_colorByContact) then
        color $MOL_SKINS.G[i] $MOL_SKINS.S[j] rgb = Color(0.9, MOL_SKINS.C[j]+"/"+MOL_SKINS.C[i] ) GROB.atomSphereRadius=2.8
        color $MOL_SKINS.G[i] $MOL_SKINS.S[j] rgb = Color(0.3, MOL_SKINS.C[j]+"/"+MOL_SKINS.C[i] ) GROB.atomSphereRadius=2.2
        color $MOL_SKINS.G[i] $MOL_SKINS.S[j] $MOL_SKINS.C[j] GROB.atomSphereRadius=1.6
      endif
      set label Sphere( $MOL_SKINS.S[i] $MOL_SKINS.S[j], -1.0 )
      set field Sphere( $MOL_SKINS.S[i] $MOL_SKINS.S[j], -1.0 ) name="contact"
      set field Sphere( $MOL_SKINS.S[i] $MOL_SKINS.S[j], -1.5 ) name="contact2"
    endfor
    if(l_grob) then
      display $MOL_SKINS.G[i]
      link $MOL_SKINS.G[i] Mol( ms_ [i] )
      if(!l_colorByContact) then
        GROB.atomSphereRadius =2.1
        set label $MOL_SKINS.S[i] & (a_*.A/!asp,asn,gln,glu,arg,leu,val,pro/!c,o,h* | a_*.A/pro/cg | a_*.A/glu,asp,asn,gln,arg,leu,val/!c,o,h*,o*,n*,cd?,cg? ) & Res(a_*.//DD)
#        color $MOL_SKINS.G[i] $MOL_SKINS.S[i] & a_*.//cb  green2 GROB.atomSphereRadius =2.0
#        color $MOL_SKINS.G[i] $MOL_SKINS.S[i] & a_*./ala/cb green
      endif
    endif
    if(l_grob & l_colorByResidue & Nof( a_*.A & $MOL_SKINS.S[i] )>0 ) then
       dsCustom $MOL_SKINS.S[i] & !( a_*.A,H/!ala,gly,pro/ca,ha,c,o,n,hn,cb,hb* | a_*.A,H/ala,pro/ca,ha,c,o,n,hn | a_*.A,H/gly/c,o,n,nh ) MOL_SKINS.G[i] "residue" yes
    endif
    color accessibility $MOL_SKINS.G[i] 0.8
  endfor
  undisplay xstick ms_ & ! Res(Select(a_*.// "contact2"))
  undisplay residue label ms_ & ! Res(Select(a_*.// "contact2"))
  as_out = Res(ms_ & Res(Select(a_*.// "contact2")) & a_*.A )
  if(Nof(as_out)>0) set xstick as_out Trim(GRAPHICS.stickRadius*(Sqrt(Field(as_out "cntarea")*0.022+1.)),0.1,1.0)

  set label ms_ & (a_*.A/!asp,asn,gln,glu,arg,leu,val,pro/!c,o,h* | a_*.A/pro/cg | a_*.A/glu,asp,asn,gln,arg,leu,val/!c,o,h*,o*,n*,cd?,cg? ) & Res(Select(a_*.// "contact2"))
  if(l_grob) print bar "End\n" l_info = yes
  if(l_grob) keep grob
  if(l_grob) keep MOL_SKINS global
  set Mol( as_ ) on ; set msoff off  # restore
  GRAPHICS.l_redraw = yes
  display new
endmacro

#macro actionOnIcbFile
#  LIGAND.receptor = String( a_1. simple)
#  LIGAND.selection = String( $LIGAND.selection simple )
#  LIGAND.box = Box( $LIGAND.selection 2. )
#  e3dSetReceptor $LIGAND.receptor yes no yes
#  keep m_gh m_ge m_gb m_gs m_gl m_gc
#  e3d_makePocketSurface 4.
#  keep g_recPocketSurface
#endmacro

#macro readIcbDirectory s_path
#  s_oldpath = Path()
#  set directory s_path
#  files=Split(Unix("ls *.icb"),"\n")
#  tnam = Name("dir_"+Name(s_path simple),unique)
#  add column $tnam files
#  add header $tnam "set property delete off "+tnam+ "\ndelete all\nread binary display %@.A[%#]\nactionOnIcbFile\nset property delete "+tnam+"\n" name="doubleClick"
#  set property delete $tnam
#  set directory s_oldpath
#  keep $tnam
#endmacro

#macro makeligrec
#  os_ = a_
#  e3dSetLigand a_H [Nof(a_H)]  yes
#  setLigandBoxSelection a_LIG.I os_ no 3.
#  e3dSetReceptor os_ yes no yes
#  makeLigandPocketSurface 3.5
#  GRAPHICS.hydrogenDisplay = 4
#  GRAPHICS.hbondMinStrength = 0.1
#  keep g_recPocketSurface
#endmacro

macro dsUnsatHbonds l_on (yes)
# ligand acceptors may find weak donors from aroma and even aliph protons, not the donors.
# weak acceptors: oxygens in sulfonamides
  l_commands = no
  l_info = no
  GRAPHICS.l_redraw = no
  if(l_on) then
    make hbond Sphere( a_LIG.I//E a_LIG,REC. 4.5 )  a_LIG,REC. name="tmphbonds" GRAPHICS.hbondMinStrength=0.1
    as_out = a_NONE.
    if(Type(tmphbonds)=="parray") as_out = Atom(tmphbonds)
    display ball cpk Sphere( a_LIG. ( a_CURREC,LIG.//E ) & !as_out 2.5 )

  #
    copy a_CURREC. "tmprec" delete
    show area surface a_tmprec.//E a_tmprec. mute surfaceAccuracy=5
    undisplay cpk Sphere( Select (a_tmprec.//E "a<3." ) a_CURREC,LIG.//E , 0.01 )  # buried in isolated

    copy a_LIG. "tmplig"
    show area surface a_tmplig.//E a_tmplig. mute surfaceAccuracy=5
    undisplay cpk Sphere( Select( a_tmplig.//E "a<3.") a_CURREC,LIG.//E , 0.01 )  # buried in isolated

    move a_tmplig. a_tmprec.
    show area surface a_tmprec.//E a_tmprec. mute surfaceAccuracy=5
    undisplay cpk Sphere( Select(a_tmprec.//E "a>=3." ) a_CURREC,LIG.//E , 0.01 )  # exposed in complex

    delete tmphbonds
    delete a_tmprec.
    l_dsUnsatHbonds= yes

  else
    undisplay a_CURREC,LIG.//E cpk
    l_dsUnsatHbonds= no

  endif
  keep l_dsUnsatHbonds
  GRAPHICS.l_redraw = yes
  display new
endmacro

#ifdef Docking
#
macro icmPocketFinder as_receptorMol r_threshold ( 4.6 ) l_displayPocket (yes) l_assignSites (no) l_link (yes) auto
  l_confirm = no
  l_warn=no
  l_info=no
  l_commands=no
  l_color = Index(Version( ),"ng")==0
  if(!l_color) print " Warning> non-graphics ICM version. Some functionality is disabled"
  if(Nof(color)==0) read color
  minVolume = 100.
  if Nof( a_ICM. & as_receptorMol )==0 return error "\nYou need to select an ICM object\n"
  set object Obj(a_ICM. & as_receptorMol )[1]
  as_receptorMol = as_receptorMol & a_
  show surface area as_receptorMol as_receptorMol # & a_A removed  R
  consS= Score( Acc(Res(as_receptorMol)),simple)  # accessible area
  if( Nof(consS)<=0 ) consS = {1.}
  meanConsS = Mean(consS) + 0.001
  print " Mean Surface Conservation is ", meanConsS
  tcav = Type( m_cav )
  tin  = Type( m_in )
  icMkMap = yes
  if Type(m_cav) =="map" & Type(m_in)=="map" then
     if Length(Box(as_receptorMol 1.)-Box(m_cav))<2. then
        if (Askg(" Warning> MAPS ALREADY EXIST. Ignore them?","Ignore/Use",simple)=="Use") icMkMap = no
     endif
  endif
 if(icMkMap) then
  make map potential simple as_receptorMol "gc" 1. Box ( as_receptorMol , 1.) # added simple
   m_in =  Bracket( m_gc , .6, 1.6 ) -.6
   for i=1,42
     m_in = Smooth( m_in  )
   endfor
   m_in = 10. * ( Bracket( m_in , 0.4, 0.5 ) -0.4 )
#
   m_cav = Bracket( m_gc , -3.5,  -0.8) + 0.8
   for i=1,10
     m_cav= Smooth( m_cav  )
  endfor
 endif
#  delete grob "g_pocket*"
  global make grob -r_threshold m_cav*m_in solid name="g_pocket"
  global group table POCKETS Iarray(0) "i" Rarray(0) "Volume" Rarray(0) "Hydrophobicity" Rarray(0) "Buriedness" Rarray(0) "Aromatic" Rarray(0) "DLID" Rarray(0) "Area" Rarray(0) "LoopFraction" Rarray(0) "dTSsc" Rarray(0) "relTSsc" Rarray(0) "Bfactor" Rarray(0) "relBfactor" Rarray(0) "Radius" Rarray(0) "Nonsphericity" Rarray(0) "Conservation" Rarray(0) "RelCons" Sarray(0) "Type"
  add header POCKETS "s_out=%@.Type[%#]\ndisplay smooth transparent $s_out color[%1+1]\ncenter $s_out only margin=5.\nas_graph=Sphere($s_out "+String(Mol( as_receptorMol ))+" 2.5)" name="doubleClick"

#  make plot POCKETS "x=Volume;y=Area;color=i;size=8;title=Volumes and areas;;element=rectangle;x1=150;y1=200;x2=550;y2=550;color=blue;fillStyle=BDiagPattern;label=Drugs;labelPos=center"

  read matrix name="voldist" input="""
8. 14. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
0. 60. 116. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
1. 2. 245. 308. 4. 0. 0. 0. 0. 0. 0. 0. 0. 0.
0. 0. 7. 334. 413. 11. 0. 0. 0. 0. 0. 0. 0. 0.
0. 0. 0. 13. 324. 432. 17. 0. 0. 0. 0. 0. 0. 0.
0. 0. 0. 0. 25. 308. 527. 47. 0. 0. 0. 0. 0. 0.
0. 0. 0. 0. 0. 18. 372. 486. 51. 0. 0. 0. 0. 0.
0. 0. 0. 0. 0. 1. 46. 306. 424. 56. 0. 0. 0. 0.
0. 0. 0. 0. 0. 0. 0. 58. 204. 273. 52. 0. 0. 0.
0. 0. 0. 0. 0. 0. 0. 8. 44. 104. 111. 23. 1. 0.
0. 0. 0. 0. 0. 2. 0. 0. 1. 19. 36. 58. 22. 1.
0. 0. 0. 0. 0. 0. 0. 0. 0. 2. 12. 16. 45. 25.
0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 2. 7. 11. 34.
0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 1. 11. 10.
"""

  read matrix name="DLIDVolOcc" input="""
0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
0.020833 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
0.031847 0.095238 0. 0. 0. 0. 0. 0. 0. 0. 0.
0.052063 0.048544 0.363636 0. 0. 0. 0. 0. 0. 0. 0.
0.071942 0.15814 0.229508 0.333333 0. 0. 0. 0. 0. 0. 0.
0.084158 0.252747 0.381295 0.591837 0.380952 0.571428 0. 0. 0. 0. 0.
0.103896 0.3625 0.46 0.633333 0.647059 0.761905 0.666667 0.5 0. 0. 0.
0.078125 0.519481 0.717391 0.642857 0.773585 0.652174 0.619048 0.75 0.636364 0.6 0.999999
0. 0.777778 0.71875 0.65625 0.652174 0.807692 0.666667 0.6 0.666667 0.714286 0.666666
0. 0. 1. 1. 0.833333 0.5 0. 0. 0. 0. 0.999999
"""
# Sqrt(NofFilled) * NofFilled/NofAll ; ligand-occupied fraction augmented by sqrt abs. frequency
  read matrix name="DLIDVolOccPop" input="""
0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
0.046585 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
0.142425 0.134687 0. 0. 0. 0. 0. 0. 0. 0. 0.
0.379023 0.108547 0.727273 0. 0. 0. 0. 0. 0. 0. 0.
0.557264 0.922104 0.858741 0.471404 0. 0. 0. 0. 0. 0. 0.
0.490724 2.099476 2.775869 3.187138 1.077496 1.142857 0. 0. 0. 0. 0.
0.508985 2.760718 3.821047 4.781562 3.71707 3.047619 1.885618 0.707107 0. 0. 0.
0.174693 3.285483 5.828115 4.312417 4.95336 3.572104 2.232008 2.25 1.68366 1.03923 0.999999
0. 2.910178 4.8748 3.007315 2.525859 3.701311 2.309401 1.469694 1.333333 1.597191 0.942809
0. 0. 1.73205 1.73205 1.86339 0.5 0. 0. 0. 0. 0.999999
"""
#  add header POCKETS Log(voldist+1) name="voldist"
#  add header POCKETS DLIDVolOcc name="DLIDVolOcc"
   add header POCKETS Log(Trim( DLIDVolOccPop 0.01 1000. ) 10.) + 2. DLIDVolOcc name="DLIDVolOcc"
#  make plot POCKETS "x=Volume;y=Area;color=i;size=8;title=Volumes and areas;;matrix=$$POCKETS.voldist;pos=0,0;step=50;rainbow=white/lightblue/royalblue;legend=no;depth=-1;;xStep=50;yStep=50"
  make plot POCKETS "x=Volume;y=DLID;color=i;size=8;title=Volumes and DLIDs;;matrix=$$POCKETS.DLIDVolOcc;pos=100,-2.5;rainbow=white/lightblue/royalblue;legend=no;depth=-1;step=100,0.5"

  split g_pocket 30. ; nPkGrobs = i_out   # 30 vertices min
  s_pocket_prefix = "g_pocket_" + Sum(Name(Obj(as_receptorMol)))
  show energy "en" as_receptorMol as_receptorMol
  Een0 = Energy("en")

  for i = 1,nPkGrobs
    s_fr = "g_pocket" + i
    s_ = Name( s_pocket_prefix  + i , unique )
    rename $s_fr s_
    #
    v = Volume( $s_ )
    if(v<0.) set $s_ reverse
    v=Abs(v)
    s = Area( $s_ )
    if( Abs(v) < minVolume ) then
      delete  $s_
      continue
    endif
    add POCKETS
    j = Nof(POCKETS)
# new: hydrophobicity
#    if l_displayPocket then
    if yes then
      if (Nof(color)==0) read color
      color $s_ black
      color $s_ as_receptorMol & a_//c* GROB.atomSphereRadius = 3.0 white
      color $s_ as_receptorMol & aHbDoAcSel  GROB.atomSphereRadius = 1.5 black
      h = Mean(Mean(Color( $s_ )))
      POCKETS.Hydrophobicity[j] = h
      color $s_ black
      color $s_ as_receptorMol & a_//!h* GROB.atomSphereRadius = 3.0 white
      b = Mean(Mean(Color( $s_ )))
      POCKETS.Buriedness[j] = b
#     aromatic ring contact
      color $s_ black
      color $s_ distance Xyz( Sphere( Xyz( $s_ ) as_receptorMol & a_//RA 3.5 ring ) ring ) GROB.atomSphereRadius = 3.0 white
      POCKETS.Aromatic[j] = Mean(Mean(Color( $s_ )))

# DLID: J. Chem. Inf. Model. 2010, 50, 20292040
      POCKETS.DLID[j] = -8.7 + 1.7*Log(v 10.) + 3.94*b + 2.27*h
    endif
    POCKETS.Bfactor[j] = Mean( Bfactor( Sphere( $s_ as_receptorMol & a_.//!h*,vt* 3. ) ))
    color $s_ color[i+3]
   # set $s_ reverse
    POCKETS.i     [j]= i
    POCKETS.Volume[j]= v
    POCKETS.Area  [j]= s
    rv              = Power(v*0.238732,1./3.)
    ra              = Sqrt (s*0.079577)
    POCKETS.Radius[j]= rv
    POCKETS.Nonsphericity[j] = s/(4.*Pi*rv*rv)
    cons = Score( Res(Sphere( $s_ as_receptorMol & !a_*.//ca,c,n,o,h* 2.5 )) simple )
    if(Nof(cons) >0) consmean = Mean(cons)
    if(Nof(cons)==0) consmean = 0.
    POCKETS.Conservation[j]  = consmean
    POCKETS.RelCons[j]  = consmean/meanConsS
    POCKETS.Type[j]  = s_
    if (l_link) link $s_ a_
    show energy as_receptorMol & !Sphere( $s_ as_receptorMol 2.5 ) as_receptorMol "en"
    POCKETS.dTSsc[j] = Energy("en" ) - Een0
    s_ss = Sstructure( Sphere( $s_ as_receptorMol & a_.//!h* 2.5) )
    POCKETS.LoopFraction  [j] = Nof( s_ss "_" )/Real(Length(s_ss))
  endfor
  delete g_pocket
  if(Nof(POCKETS)==0) then
    print "\n No pockets identified"
    delete POCKETS
    return
  else
    sort POCKETS.Volume reverse
  endif
  POCKETS.relTSsc    = POCKETS.dTSsc/POCKETS.Volume
  POCKETS.relBfactor = (POCKETS.Bfactor - Mean( Bfactor(  as_receptorMol & a_.//!h*,vt*   ) ))/Rmsd( Bfactor(  as_receptorMol & a_//!h*,vt*   ) )
#
  set format POCKETS.Volume         "%.4g" name="" color="rainbow='#FFBBBB/#FFFFFF/#33AAFF,100.:350.,pinwheel'"
  set format POCKETS.DLID           "%.3g" name="" color="rainbow='#FFBBBB/#FFFFFF/#33AAFF,-1.:.5,pinwheel'"
  set format POCKETS.Buriedness     "%.3g" name="" color="rainbow='#FFBBBB/#FFFFFF/#33AAFF,0.6:0.85,pinwheel'"
  set format POCKETS.Hydrophobicity "%.3g" name="" color="rainbow='#FFBBBB/#FFFFFF/#33AAFF,0.4:0.7,pinwheel'"
  set format POCKETS.LoopFraction   "%.3g" name="" color="rainbow='#33AAFF/#FFFFFF/#FFBBBB,0.7:1.1,pinwheel'"
  set format POCKETS.Aromatic       "%.3g" name="" color="rainbow='#FFBBBB/#FFFFFF/#33AAFF,-0.06:0.1,pinwheel'"
  set format POCKETS.relTSsc        "%.3g" name="" color="rainbow='#33AAFF/#FFFFFF/#FFBBBB,0.005:0.015,pinwheel'"
  set format POCKETS.relBfactor     "%.3g" name="" color="rainbow='#33AAFF/#FFFFFF/#FFBBBB,-1.:1.,pinwheel'"
#
  gNames = Name(grob)~(s_pocket_prefix+"*")
  nPock = Nof(gNames)
  if( nPock == 0 ) then
    print "\n No pockets identified"
  else
    if(l_assignSites)then
      for i=1,nPock
        gName = gNames[i]
        set site Res(Sphere( $gName , as_receptorMol & a_*.//!h* 2.5)) "Predicted binding site #" + i
      endfor
      if(l_color)display site as_receptorMol
    endif
    if(l_displayPocket) then
      gName = gNames[1]
      display transparent smooth $gName color[2]
      #as_graph = Sphere( $gName Mol( as_receptorMol ) 2.5 )
    else
      print "To select residues around g_pocket1, use Sphere( g_pocket1 a_/* ), etc."
    endif
    printf "\n\n Info> %d  pocket[s], %s .. %s found for  %d  selected or displayed residues.\n If you wanted the whole molecule, unselect and redo\n",nPock,gNames[1],gNames[nPock],Nof(Res(as_receptorMol))
  endif
  keep m_in m_cav
  keep grob global
endmacro
#
#endif
macro dsPropertySkin as_sel (a_) l_wire (no) l_biggestBlobOnly (no)

  l_commands = no
  l_info     = no
  l_warn = no
  l_confirm = no
  l_minRedraw = no

  if Nof(as_sel)==0      return error " Error_dsPropertySkin> empty selection"
  if Nof(Obj(as_sel))>1  return error " Error_dsPropertySkin> atoms in more than 1 object selected"
  if Type( Obj( as_sel )[1] 2 ) != "ICM" return error " Error_dsPropertySkin> this is a non-ICM object. Convert it to ICM"
  as_sel = as_sel & a_ICM.
  set object Obj( as_sel )
  ms_tmp = Mol( as_sel )
  boxtm = Box( as_sel 1.5 )
  make map potential "gs,gb" boxtm Atom( ms_tmp ) & boxtm  1.
  s_wire = "solid"
  if(l_wire) s_wire = "wire"
  gname = "g_bind_"+Name(Obj(as_sel))[1]+"_"+Name(Mol(as_sel))[1]
  if Replace((Version()[1:7]),".","") >= "30005" gname = Name(gname,unique)

  make grob skin $s_wire gname Sphere( as_sel ms_tmp 1.3)  ms_tmp
  if(l_biggestBlobOnly) then
    split $gname
    delete $gname
    ss = gname + "1"
    rename $ss $gname
  endif
  display $gname smooth solid transparent
  link $gname Obj(a_)
  color $gname white
  color $gname map -m_gs { 0,0,0,3,4,5 } { 0. 0.5  } green
  if(l_oldMaps)color $gname map $s_wire m_gb { 1,1,2,3,0,0,7,8,9 } { -.7 .7 } GRAPHICS.NtoCRainbow = "blue/white/red"
  # for new hb maps augment hydrogen field
  if(!l_oldMaps)color $gname map $s_wire m_gb { 1,2,3,0,0,0,7,8,9 } { -.7 .7 } GRAPHICS.NtoCRainbow = "blue/white/red"
  print " Color code:"
  print " Green - hydrophobic"
  print " Red   - hydrogen bond acceptor"
  print " Blue  - hydrogen bond donor"
  s_out = gname
  keep $gname
  keep map
endmacro
#
macro dsPropertySurface as_sel (a_) l_wire (no)

  l_commands = no
  l_info     = no
  l_warn = no
  l_confirm = no
  l_minRedraw = no

  if Nof(as_sel)==0      return error " Error_dsPropertySurface> empty selection"
  if Nof(Obj(as_sel))>1  return error " Error_dsPropertySurface> atoms in more than 1 object selected"
  if Type( Obj( as_sel )[1] 2 ) != "ICM" return error " Error_dsPropertySurface> this is a non-ICM object. Convert it to ICM"
  as_sel = as_sel & a_ICM.
  set object Obj( as_sel )
  ms_tmp = Mol( as_sel )
  boxtm = Box( as_sel 4.0 )
#  l_ecep=no
  make map potential "gc,gb" boxtm Atom( ms_tmp )  1. simple
#  l_ecep=yes
  m_hf =Smooth(Trim( m_gc, -1. 0. ),"expand")
  m_ac =Smooth(-Trim(m_gb,  0. 1. ),"expand")
  m_do =Smooth(Trim( m_gb, -1. 0. ),"expand")
  s_wire = "solid"
  if(l_wire) s_wire = "wire"
  gname = "g_bind_"+Name(Obj(as_sel))[1]+"_"

  make grob surface  $s_wire gname Sphere( as_sel ms_tmp 1.3) & a_//!P  ms_tmp & a_//!P
  display $gname smooth solid transparent
  color $gname white
  color $gname map $s_wire -m_hf { 0,0,0,0,2,4,5 } { 0. 1.0  } green
#  color $gname map $s_wire Smooth(Smooth(m_gb)) { 1,2,3,0,0,7,8,9 } { -.5 .5 }
  color $gname map $s_wire -m_ac { 0,0,0,0,2,4,5 } { 0. .5  } red
  color $gname map $s_wire -Smooth(Smooth(Smooth(m_do))) { 0,0,0,0,2,4,5 } { 0. .25  } blue
  print " Color code:"
  print " Green - hydrophobic"
  print " Red   - hydrogen bond acceptor"
  print " Blue  - hydrogen bond donor"
  s_out = gname
  keep $gname
  keep map
endmacro

macro calcMLR M_inputs R_outputs
if( Nof(R_outputs) != Nof(M_inputs) ) return error "Matrix of inputs and vector of outputs should have the same dimensions"
if( Length(M_inputs) <= Nof(M_inputs) )then
  R_out = R_outputs*M_inputs *Power(Transpose(M_inputs)*M_inputs, -1)
else
  print "Warning> Number of parameters is larger than number of data points"
  R_out = R_outputs*Power(M_inputs*Transpose(M_inputs), -1) *M_inputs
endif
print "Weights are stored in R_out, RMSD= " Rmsd(R_outputs-M_inputs*R_out)
endmacro

macro calcMLRW M_inputs R_outputs R_weights ( Rarray(0))
if( Nof(R_outputs) != Nof(M_inputs) ) return error "Matrix of inputs and vector of outputs should have the same dimensions"
if( Nof(R_weights)==0 ) R_weights = Rarray(Nof(R_outputs) 1. )
if( Length(M_inputs) <= Nof(M_inputs) )then
  if( Nof(R_weights)!=Nof(R_outputs)) return error "Vector of weights should have the same dimension as outputs"
  M_weights = Matrix(Nof(R_weights) R_weights*R_weights)
  R_out = R_outputs*M_weights*M_inputs *Power(Transpose(M_inputs)*M_weights*M_inputs, -1)
else
  print "Warning> Number of parameters is larger than number of data points"
  R_out = R_outputs*Power(M_inputs*Transpose(M_inputs), -1) *M_inputs
endif
print "Weights are stored in R_out, RMSD= " Rmsd((R_outputs-M_inputs*R_out)*R_weights )
endmacro

macro generalSearchFromGUI s_type s_searchWhat s_extra ("") l_append (no) i_maxHits (500) l_bg (no) l_advSearch (no) auto
  l_commands = no
  l_info = yes
  if (s_type == "PDB Search") then
    s_searchWhat = s_extra + s_searchWhat
    if (s_extra != "") l_advSearch = yes
    findPDB s_searchWhat "" "" "" "" 9.9 "" no l_append l_advSearch
  elseif (s_type == "NCBI BLAST") then
    findSequenceBlast s_searchWhat s_extra i_maxHits l_bg
  elseif (s_type == "Uniprot") then
    readUniprotCloud Sarray(s_searchWhat) Sarray(s_extra) no
  elseif (s_type == "PubChem") then
    findPubchem s_searchWhat l_append s_extra == "3d" i_maxHits
  elseif (s_type == "Crystallography Open DB") then
    if (s_searchWhat ~ "smiles:*") then
      s_searchWhat = s_searchWhat[8:$]
      read string "http://mars.molsoft.com/cgi-bin/codsearch.cgi?" + String(Collection("smi",s_searchWhat),html)
    else
      read string "http://mars.molsoft.com/cgi-bin/codsearch.cgi?" + String(Collection("kwd",s_searchWhat),html)
    endif
    if (Length(s_out)) then
      read table mol input=s_out name="result"
    else
      Askg( "No hits found" ,"",simple)
    endif
    if (Nof(result)) then
      add column result index=2 name="Act" Sarray(Nof(result),"Load Crystal Neighbours")
      set format result.Act """
  <!--icmscript name="1"
   if (Type( %@.L ) == "unknown") set property display %@
   dsChemTemp_new Name( variable %@ ) %# yes
   findSymNeighbors  a_ 14.00 no 2 yes yes
--><a href=#_>%1</a>
"""
    endif
  elseif (s_type == "PDB by Seq Pattern") then
    findSequence s_searchWhat "" no l_append
  elseif (s_type == "PDB Sequence Match") then
    findHomology s_searchWhat "protein" no no yes no
  elseif (s_type == "PDB Seq Homologs") then
    findHomology s_searchWhat "" no no no no
  elseif (s_type == "Ligand Code") then
    findPDB "ADVANCED SEARCH" "*" "*" "*" "*" 9.9 s_searchWhat no l_append
  elseif (s_type == "Historeceptomics") then
    historeceptomicsAPI s_searchWhat
  elseif (s_type == "Enamine Real DB") then
    l_info = no
    if (s_searchWhat ~ "smiles:*") s_searchWhat = s_searchWhat[8:$]
    c_out = Collection("smiles", s_searchWhat)
    c_out["timeout"] = 15
    c_out["fmt"] = "json"
    c_out["maxHits"] = 5000
    c_out["maxDist"] = 0.5

    c_params = Collection( s_extra, web )
    s_type = "sss"
    if (Exist(c_params,"type")) s_type = c_params["type"]
    if (s_type == "sim") c_out["timeout"] = 90
    s_resultTab = Exist(c_params,"resultName") ? c_params["resultName"] : "enamineHits"
    if (Exist(c_params,"maxHits"))  c_out["maxHits"] = c_params["maxHits"]
    if (Exist(c_params,"statdir"))  c_out["statdir"] = c_params["statdir"]
    if (Exist(c_params,"table"  ))  c_out["table"  ] = c_params["table"]
    if (Exist(c_params,"maxDist"  ))c_out["maxDist"  ] = c_params["maxDist"]
    c_out["type"] = s_type
    r_maxDist = c_out["maxDist"]

   # "http://mars.molsoft.com/cgi-bin/enaminesearch_deb.cgi?" + String(c_out html )
TOOLS.gigaSearchUrl + "?" + String(c_out html )
    read json TOOLS.gigaSearchUrl + "?" + String(c_out html ) name="c_out"

    show " Info> " + c_out["info"]
    delete $s_resultTab l_warn=no
    if Type(c_out["result"]) == "collection" then
      $s_resultTab = Table( c_out["result"] )
      if Nof( $s_resultTab ) keep global $s_resultTab
    endif

    if (c_out["nof_searched"] < c_out["nof_filter"]) then
      sprintf " The search returned %d hits and processed %.2f%% of potential search space\nDo you want to submit background job to get more hits?", Nof($s_resultTab), Real(c_out["nof_searched"])/c_out["nof_filter"]
      S_out = s_searchWhat//s_type//String(r_maxDist)
      i_out = Nof($s_resultTab)*5
      keep i_out global
      set foreground menu="SubmitEanamineSearchBG"
    elseif (Nof($s_resultTab)==0 & c_out["nof_searched"] >= c_out["nof_filter"]) then
      Askg("Warning> no hits found", "Ok", simple )
    endif

  elseif (s_type == "Drug Bank" | s_type == "Drug Central") then
    findDrugbank Sarray(s_searchWhat) s_extra l_append no
    #find molcart sstructure s_searchWhat table=TOOLS.defaultChemDB l_info=yes
  elseif (s_type == "FDA Drug Label") then
    fdaapi s_searchWhat s_extra 0 i_maxHits
    if (Type(FDAlabelhtml)!="unknown") keep FDAlabelhtml
  elseif (s_type == "ICB Index") then
    findICB s_searchWhat
  elseif (s_type == "Pocketome") then
    findPocketome s_searchWhat s_extra
  elseif (s_type == "ChEMBL") then
    #findChembl Sarray(s_searchWhat) Sarray(s_extra) l_append "new" no i_maxHits
    if (s_searchWhat ~ "smiles:*") then
      if (s_extra != "substructure" & s_extra != "similarity" & s_extra != "molecule") s_extra = "substructure"
#      s_searchWhat = s_searchWhat[8:$]
    endif
    chemblapi s_searchWhat s_extra i_maxHits
  elseif (s_type == "SureChEMBL") then
    findSurechembl s_searchWhat s_extra l_append no
  endif
  l_info = no
  keep table sequence
endmacro

macro visualizeNM as_ i_Nmodes (10)
#
  H = Matrix( a_.//ca & as_ energy)
  X = Eigen( H )
  A = R_out
#
  npt = Nof( a_.//ca & as_ )
  R_kr = Rarray( 6*npt)
  R_kr[6*Count(npt)-5] = 1.
  R_kr[6*Count(npt)] = 1.
  for i = 1, Min( i_Nmodes Nof(A)-6 )
    s_ = "g_NM" + i
    d = (0.1/A[Nof(A)-5-i])*X[?,Nof(A)-5-i]
    a =  Sqrt(Sum(Transpose( Matrix( d*d 3 ))))
    a = a/Max(a)
    $s_ = Grob( "line" Rarray(Xyz( a_.//ca & as_ )) + d )
    g_tm = Grob( "line" Rarray(Xyz( a_.//ca & as_ )) - d )
    color $s_ green
    color g_tm yellow
    $s_ = $s_ // g_tm
    g_tm = Grob( "lines" Rarray(Matrix( Rarray(Xyz( a_.//ca & as_ )) + d 3) // Matrix( Rarray(Xyz( a_.//ca & as_ )) - d 3) ))
#    color g_tm Matrix( R_kr 3)
    a =  Rarray( Transpose(Matrix( a // a Nof(a)) ))
    color g_tm  Transpose( Matrix( 2*a-a*a*a // (  0.5*(1-2*Abs(a-0.5)) ) // (1.-a) Nof(a) ) )
    $s_ = $s_ // g_tm
  endfor
  delete g_tm
  keep grob
endmacro

#macro mkNMstack as_ i_Nmodes (10) r_Amplitude (1.0) i_Steps (1) i_randomComb (0) l_gap (no) l_local (no) l_singleMode (no)
macro mkNMstack as_ i_Nmodes (10) r_Amplitude (1.0) i_Steps (1) l_randomize (no) l_gap (no) l_local (no) l_singleMode (no)
#
#  l_commands=yes
  set object Obj(as_)
  if(Type( a_ 2 )!="ICM") convertObject a_ no yes yes yes yes no no ""
# WARNING: currently breaks with Nof(as_ & a_*.H) > 0
  l_minRedraw = no
#
  as_local = ! a_.
  if(l_local)then
    as_local = Res( as_ )
    as_ = Obj( as_ )
  else
    as_ = Mol( as_ )
  endif
#
  s_NARF = "n3,o6,n6,c1',p" # ad hoc reference atoms in DNA/RNA
#
  ixrfht = Iarray(0)
  if(Nof( a_.H & as_ ) != 0)then
    group table TH Sarray( a_.H//!h*,vt* & as_ ) "atsel" header Distance( Xyz( a_.H//!h*,vt* & as_ )) "dimt" l_info=no
    make tree TH full "UPGMA" split="cl" label="%Name;" name="" distance="dimt" l_info=no
    ixrfht = Index( TH.cluster center 3.5 )
    T_rfht =  TH[ixrfht]
    print "Hetero groups represented by " + Nof(ixrfht) + " centers"
    delete TH
  endif
  if(Nof(a_.A & as_ )>0)then
    build string Replace( IcmSequence( Res( a_.A//ca & as_ )) {"asp" "glu" "lys" "arg" "his" "tyr" "phe" "trp" "ser" "thr" "asn" "gln" "cys" "val" "leu" "ile" "met" "ala" "gly" "pro" } Sarray(18 "alas") // "glys" // "pros" ) name="gapNM"
  endif
  if(Nof( a_.H,N,M & as_ ) != 0)then
    appendMol Mol( a_.H,N,M & as_ ) "gapNM"  # was copyMol and then move
    set object a_gapNM.
#    move a_tmphet. a_
    set tether a_H,N,M  a_.H,N,M & as_
  endif
  if(Nof(a_.A & as_ )>0) set tether a_A  a_.A//!h* & as_
  unfix V_!H,N,M
  minimize tether l_info=no
#
  H = Matrix( a_A//ca | ( a_H//!h*,vt* [ixrfht]) | a_N//$s_NARF | a_M//!vt*  energy)
  X = Eigen( H )
  A = R_out
  X = X[?,1:Nof(A)-6]  # last six are zero frequency translations/rotations
  A = A[1:Nof(A)-6]
  X = X * Matrix( Nof(A) 1./A ) # scale
#
  unfix only v_//S,V   # should it be V_//S,V ?
  Rmsd( a_ )
  delete tether a_
  fix v_//omg
  copy a_ "tztmp" strip
  delete a_tztmp. & !( a_tztmp.//ca |  (a_tztmp.H//!h*,vt* [ixrfht]) | a_tztmp.N//$s_NARF | a_tztmp.M )
  delete a_tztmp.//h*,vt*
#
  if(Nof(as_local & as_)!=0)then
    delete tether a_
    set tether as_local & as_ a_tztmp.
    D = Rarray(Nof(A))
    for i = 1,Nof(A)
      d = 0.1*X[?,i]
      set a_tztmp.//   Matrix( (Rarray(Xyz( a_.A//ca & as_ ))//Rarray(Xyz(( a_.H//!h*,vt* & as_ )[ixrfht] | (a_.N//$s_NARF & as_ ) | (a_.M//!vt* & as_ ) ))) + d 3)
      D[i] = Rmsd( as_local & as_ )
    endfor
    group table T D Count(Length(X))  Parray(Transpose(X)) "X"
    sort reverse T.D
    T[1:Min( i_Nmodes Nof(T) )]
#    if(i_randomComb!=0) delete T[i_Nmodes+1:Nof(T)]
    if(l_randomize) delete T[i_Nmodes+1:Nof(T)]
    qf = 1. # 0.5/T.D[1] this results in very aggressive movements
    sort T.D
    X = qf*Transpose(Matrix( T.X ))
    delete T
#  else
#    X = X[?,Length(X) - Min( i_Nmodes Length(X) )+1:Length(X)]
  endif
#
  if(Nof(a_.A & as_ )>0) set tether a_gapNM.A//ca a_tztmp.A//ca
  if(Nof( a_.H & as_ ) != 0) set tether a_gapNM.H// a_tztmp.H//*
  if(Nof( a_.N & as_ ) != 0) set tether a_gapNM.N//$s_NARF a_tztmp.N//$s_NARF
  if(Nof( a_.M & as_ ) != 0) set tether a_gapNM.M a_tztmp.M
  delete stack
  store conf 0.
  set vrestraint energy v_//!V , -1000. 0. 180.
#
#  if(i_randomComb>0) X = X * Matrix( Random( Length(X)*Length(X)*i_randomComb, -1., 1.) Length(X)*i_randomComb) /Sqrt(i_Nmodes)
  if(l_randomize) X = X * Matrix( Random( Length(X)*Length(X), -1., 1.) Length(X)) /Sqrt(i_Nmodes)
  iFirst=1
  if(l_singleMode)iFirst = Min( i_Nmodes Length(X) )
  for i = iFirst, Min( i_Nmodes Length(X) )
    d = r_Amplitude*0.2*X[?,Length(X)-i+1]/Real(2*i_Steps-1)
    for j = -2*i_Steps+1 2*i_Steps-1 2
      load conf 1
      set a_tztmp.//  Matrix( (Rarray(Xyz( a_.A//ca & as_ ))//Rarray(Xyz(( a_.H//!h*,vt* & as_ )[ixrfht] | (a_.N//$s_NARF & as_ ) | (a_.M//!vt* & as_ ) ))) + d*j 3)
      minimize 1000 "rs,tz"
      store conf 0.
    endfor
  endfor
  delete tether a_
  delete a_tztmp.
  store stack a_
  if(!l_gap)then
    set tether Mol( a_.A & as_ ) a_gapNM.//c,ca,n,o,cb
    if(Nof( a_.H,N,M & as_ ) != 0) set tether Mol( a_.H,N,M & as_ ) a_gapNM.H,N,M
    ncf = Nof(conf)
    delete stack
    set object Obj( as_ )
    store conf 0.
    for i = 2,ncf
      set object a_gapNM.
      load conf a_ i
      set object Obj( as_ )
      load conf 1
      set a_//c,ca,n,o,cb  tether tree # there is an oxt issue
      if(Nof( a_.H,N,M & as_ ) != 0) set a_H,N,M tether
      minimize v_//xi* 300 vwMethod="soft" "vw,14,hb,el,to,bb"
      store conf 0.
    endfor
    store stack a_
    delete tether a_
    delete a_gapNM.
  endif
  sort A
  keep A
  print " mkNMstack> Eigenvalues kept in rarray 'A'"
endmacro

#
macro flexrec auto as_lig rs_rec i_mode
# assumptions:
#   current object, contains ligand, the argument can be ligand copy elsewhere.
#
   l_commands = no;  l_info = no
   errorAction = "none"
   interruptAction = 1
   mslig = Mol( Sphere( as_lig a_ 0.001 ) )
   msrec = Mol( a_ ) & ! mslig
#
   nRefinementCycle = 2
   set term "vw,14,hb,to,ss,el,ts" only l_info=no
   vwMethod="soft"
   mcvar = ( v_//* & mslig ) | v_//x* & Res( Sphere( as_lig ( msrec & ! a_//ca,c,n,o,h* ) 7. ))
# display variable label mcvar
   mncalls = 50+2*Nof( a_/* )
   mncallsMC = Nof( mcvar ) * mncalls
   temperature = 600
   dielConst = 20.
   l_minRedraw = no
   electroMethod = "distance dependent"
   s_terms1 = "vw,14,hb,to,ss"
#
   delete stack
   show energy s_terms1 mute
   ener = Energy(s_terms1)
   print " Info> Total energy before refinement = ", ener

   if( ener > 0.)  then
      refineModel 3 no
      show energy s_terms1 mute ;  ener = Energy(s_terms1)
      print " Info> Energy after annealing = ", ener
   endif

   set vrestraint a_/*
   if     (i_mode==1) then
     optimizeH_zeroOcc mslig | Res(Sphere( mslig , msrec , -2. )) no no
     return
   elseif (i_mode==3) then
     ssearch residue fast v_//x* & Res(Sphere( mslig , msrec & ! a_*.//h*,ca,c,n,o , -3. )) & rs_rec "vw,14,hb,to,ss,el" vwCutoff=6.5 l_info=yes l_warn=yes
     return
   endif

   for i=1,nRefinementCycle
     if(i_mode >= 2 & i_mode <= 4 ) then
       minimize mcvar selftether =  mslig TOOLS.tsWeight = 0.2+10./Real(i*i)  l_showMinSteps = no l_info=no
     endif
     if(  i_mode == 4 ) then
       montecarlo fast reverse append mute mcvar selftether =  mslig selectMinGrad=1.5 l_info=yes l_warn=yes TOOLS.tsWeight = 0.2+10./Real(i*i);
     endif
     show energy s_terms1 mute ;  ener = Energy(s_terms1)
     printf " dockflex> Iteration %d. Total energy = %.1f\n", i, ener
   endfor

endmacro

macro makePlotMatrix auto M s_rainbow ("white/pink/blue") s_title ("") s_I ("I") s_J ("J")
 if(Exist(matrixplot)&Index(Name(matrixplot),"matrixplot.M")!=0) delete matrixplot.M
 add header matrixplot M name="M"
 make plot matrixplot "matrix=M;rainbow="+s_rainbow+";pos=-1;;title="+s_title+";xTitle="+s_I+";yTitle="+s_J+";"
 keep matrixplot
endmacro

macro plotVwR6exp r_A r_B r_C r_A1 (0.) r_B1 (0.) r_C1 (0.)
 delete VwR6expPlot
 if(r_A1!=0.)then
   r_A = Sqrt(r_A*r_A1)
   r_B = Sqrt(r_B*r_B1)
   r_C = 0.5*(r_C+r_C1)
 endif
 x = 1. + 7.*(Count( 101 )-1.)/100.
 E = -r_A/(x*x*x*x*x*x) + r_B*Exp(-r_C*x)
 group table VwR6expPlot x "R" E "E"
 make plot VwR6expPlot "x=R;y=E;"
 keep VwR6expPlot
endmacro

macro solveCubicEquation r_a r_b r_c
# roots: x1, xr + i*xi, xr - i*xi
# i_out contains number of roots
  a=r_a; b=r_b; c=r_c
  m = 2*a*a*a-9*a*b+27*c
  k = a*a-3*b
  n = m*m-4*k*k*k
  onethird = 1./3.
  s1 = Power(0.5*(m+Sqrt(n)),onethird)
  s2 = Power(0.5*(m-Sqrt(n)),onethird)
  R_cubic_roots = Rarray(0)//( -onethird * (a + s1 + s2))
  keep R_cubic_roots
endmacro

macro shiftResidueLabels2SidechainTips auto rs_ ( a_*.A )
 l_info=no
 set label rs_ & (a_*.A/!asp,asn,gln,glu,arg,leu,val,pro/!c,o,h* | a_*.A/pro/cg | a_*.A/glu,asp,asn,gln,arg,leu,val/!c,o,h*,o*,n*,cd?,cg? )
endmacro

macro alignTwoDnaSequences &seq_1 &seq_2 s_aliname ("dna_ali")
  l_info=no
  read comp_matrix s_icmhome+"dna"
  aliname = Name( s_aliname unique )
  $aliname = Align( seq_1 seq_2 )
  read comp_matrix s_icmhome+"icm"
  keep $aliname
endmacro

macro calcSeqIdent auto &ali_ l_sel (no)
HELP="""
  Calculate pairwise sequence identity for aligned sequences.
  Columns: row, Seq1, Seq2
    Ident    - sequence identity according to the provided alignment
    Ident2   - sequence identity if only these two sequences were realigned
    IdentSel - sequence identity in selected alignment columns/blocks (if l_sel is yes)
"""
  l_commands = l_info = no
  delete SeqIdent l_warn = no
  nseq = Nof (ali_)
  nams = Name(ali_)
  if (l_sel) then
    I_cols = Index( ali_ selection column )
    if (Nof(I_cols)==0) I_cols = Count( Length(ali_) )
  endif
  nrw = (nseq*(nseq-1))/2
  add column SeqIdent Count(nrw) Sarray(nrw) Sarray(nrw) Rarray(nrw) Rarray(nrw) name={"row","Seq1","Seq2","Ident","Ident2"}
  if(l_sel) add column SeqIdent Rarray(nrw) name={"IdentSel"}
  krw=0
  for i=1,nseq-1
    for j=i+1,nseq
      krw+=1
      SeqIdent.Seq1 [krw]= nams[i]
      SeqIdent.Seq2 [krw]= nams[j]
      SeqIdent.Ident [krw]= Real(Score( Align( ali_ i//j ) identity   ),2)
      SeqIdent.Ident2[krw]= Real(Score( Align( $nams[i] $nams[j] ) identity   ),2)
      if(l_sel) SeqIdent.IdentSel[krw]= Real(Score( Align( ali_ [I_cols] i//j ) identity   0 ),2)
    endfor
  endfor
  set format SeqIdent.Ident  color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:101.,pinwheel'" comment="Pairwise SeqId According to the Provided Alignment"
  set format SeqIdent.Ident2 color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:101.,pinwheel'" comment="Pairwise SeqId in Re-aligned Sequences"
  if(l_sel) set format SeqIdent.IdentSel color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:101.,pinwheel'" comment=" SeqId in Selected Alignment Columns/Blocks"
  keep SeqIdent
endmacro

macro makeSeqClusters
  if( Nof(sequence selection)==0) return error " Warning> sequences not selected"
  s_name = Name("SeqClusters",unique)
  add column $s_name Name(sequence selection)  name="Name"
  add header $s_name Distance(Parray(sequence selection)) name="dimt"
  make tree  $s_name full "UPGMC" split="cl" name="tree" distance="dimt"
  delete $s_name.dimt
#  add header $s_name name="onSelection" "select sequence  %@.Name [ Index( %@ selection )]"
  keep $s_name
endmacro

macro calcSeqSimilarity auto &ali_ s_seqName ("") i_seq (0) l_sel (no)
  l_commands = l_info = no
  delete SeqSimilarity l_warn = no
  nseq = Nof(ali_);
  nams = Name(ali_)
  if (l_sel) I_cols = Index( ali_ selection column )
  if (Nof(I_cols)==0) I_cols = Count( Length(ali_) )
  if(i_seq<=0|i_seq>nseq) then
    s_seq= Trim(s_seqName,all)
    if( s_seq=="" | Index(nams,s_seq)==0 ) then; i_seq=1; else; i_seq = Index(nams,s_seq); endif
  endif
  i=i_seq; if(i<1|i>nseq) return error " Error> sequence number in alignment outside range "
  add column SeqSimilarity Sarray(nseq,Name(ali_)[i]) Name(ali_) Rarray(nseq) Rarray(nseq) name={"Ref","Seq","Ident","Sim"}
  SeqSimilarity.Ident[i]= 100. ;  SeqSimilarity.Sim  [i]= 100.
  for j=1,nseq
    SeqSimilarity.Ident[j]= Real(Score( Align( ali_ i//j ) identity   ),2)
    SeqSimilarity.Sim  [j]= Real(Score( Align( ali_ i//j ) similarity ),2)
  endfor
  add column SeqSimilarity Count(nseq) name="row" index=1
  set format SeqSimilarity.Ident color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:101.,pinwheel'"
  if(l_sel) then
    add column SeqSimilarity  Rarray(nseq) Rarray(nseq) name={"IdentSel","SimSel"}
    ncol = Nof(Name(SeqSimilarity))
    add column SeqSimilarity  Table( ali_ I_cols label )
    delete SeqSimilarity.seq
    for j=1,nseq
      SeqSimilarity.IdentSel[j]= Real(Score( Align( ali_ [I_cols] i//j ) identity   0),2)
      SeqSimilarity.SimSel  [j]= Real(Score( Align( ali_ [I_cols] i//j ) similarity 0),2)
    endfor
    set format SeqSimilarity.IdentSel color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:101.,pinwheel'"
    namss = Name(SeqSimilarity)
    for j=ncol+1,Nof(namss)
      set format $namss[j] color='Icm::Color('+Extension(namss[j] dot)+' protein)'
    endfor
  else
    for j=1,Nof(SeqSimilarity)
      if(SeqSimilarity.Ref[i]==SeqSimilarity.Seq[i]) SeqSimilarity.Ref[i]=""
    endfor
    delete SeqSimilarity.Ref==""
  endif
  printf " Info> SeqSimilarity table contains identities and similarities for sequence '%s' in alignment\n",nams[i]
  keep SeqSimilarity
endmacro

macro torScanQM vs_1 r_step (10.) l_optPolar (no) l_reverse (yes) l_dontrun (yes) s_gamessPath ("/usr/local/gamess/rungms")
#
  torScan vs_1 r_step l_optPolar l_reverse
  s_obna = Name(Obj(Atom( vs_1 )))[1]
  rename torsionProfile torsionProfileQM
  add column torsionProfileQM Rarray( Nof( torsionProfileQM ) ND ) name="QM_Energy"
  add column torsionProfileQM Rarray( Nof( torsionProfileQM ) ND ) name="QM_dEnergy"
  add column torsionProfileQM Sarray( Nof( torsionProfileQM ) ) name="fname"
  add header torsionProfileQM Parray( a_ object ) name="OBJECT"
  torsionProfileQM.cursor = "if( Nof( a_"+s_obna+". )==0 )load object %@.OBJECT \n" + torsionProfileQM.cursor
  torsionProfileQM.cursor = "if( Nof( a_"+s_obna+". )!=0 )set object a_"+s_obna+". \n" + torsionProfileQM.cursor
  torsionProfileQM.cursor = "# b_Load_GAMESS_output (loadQMtorScanResult \"%@\")\n" + torsionProfileQM.cursor
#
  l_win = Version() ~ "*WIN*"
#
  if(l_dontrun) s_tempDir = Path()
  s_cmd = "cd " + s_tempDir
#
  if(Index(s_gamessPath "qsub")!=0)then
    s_rungms = Field( s_gamessPath Nof(Split(s_gamessPath)) " ")
    s_gamessPath = Replace( s_gamessPath " "+s_rungms " \""+s_rungms)
  endif
  s_options="level=1"
  i_level = Integer(Field(s_options "level=" 1 ))
  s_wrgmopt = ""
  if(i_level==2) s_wrgmopt = "type=\"MP2\""
  if(i_level==3) s_wrgmopt = "type=\"DFT\""
# create GAMESS input
  for i = 1 Nof( torsionProfileQM )
    fname_in  =  Name( system s_tempDir + "QMicmXXXX.inp" )
    fname_out = s_tempDir + Name( fname_in ) + ".log"
    fname_dat = s_tempDir + Name( fname_in ) + ".dat"
    load conf a_ i
    write gamess a_ fix = vs_1 fname_in $s_wrgmopt
    s_pref = ""
    if (l_win) s_pref = "call "
    s_cmd = s_cmd + ";" + Sum( (s_pref + s_gamessPath) // Name(fname_in) // " > " // fname_out )
    if (l_win) s_cmd += ";echo " + String(Integer(Ceil(Real(i)/Nof(torsionProfileQM)*100))) + "%% gamess 1>&2"   # progress
    if(Index(s_gamessPath "qsub")!=0)s_cmd = s_cmd + '"'
    delete system fname_dat
    torsionProfileQM.fname[i] = fname_in
  endfor
  if (l_win) then
    s_gmsdirs = ""
    s_gmsdirs += "GAMESSDIR=" + Path(s_gamessPath) + "\n"
    s_gmsdirs += "AUXDATADIR=" + Path(s_gamessPath) + "/auxdata\n"
    s_gmsdirs += "RESTARTDIR=" + s_tempDir + "\n"
    s_gmsdirs += "SCRATCHDIR=" + s_tempDir + "\n"
    write string delete Replace(s_gmsdirs,"/","\\") s_tempDir + "rungms.gms"

    write string delete Replace( s_cmd ";" "\n" ) s_tempDir + "gms_job.bat"
    s_com = "c:/Windows/System32/cmd.exe"
    if (Existenv("COMSPEC" )) s_com = Getenv("COMSPEC" )
    s_cmd = s_tempDir + "gms_job.bat"
    if (!l_dontrun) s_cmd = s_com + " /C " + '"' + s_cmd + '"'
    s_cmd
  endif
  if(l_dontrun)then
    print " Run this from UNIX command line:\n"
    print Replace( s_cmd ";" "\n" )
    print "\n After the jobs are finished,  press Load GAMESS Results in the table tools to load results"
  else
    make background s_cmd command="loadQMtorScanResult " + "'torsionProfileQM'" info="QM evaluation of conformers finished. Press OK to load the result"
    print " Info> GAMESS QM calculations started in background. You will be notified when the job is complete."
  endif
  make plot torsionProfileQM "x=torsion_angle;y=QM_dEnergy;size=3.;style=connected;;title=QM_"+ (Name(vs_1)[1]) +";xStep=90.;"
  set format torsionProfileQM.QM_dEnergy "%.4g" color="rainbow='#33AAFF/#FFFFFF/#FFBBBB'"

  keep torsionProfileQM
endmacro

macro loadQMtorScanResult s_torProf
  load object $s_torProf.OBJECT
  load stack a_
  for i = 1 Nof( $s_torProf )
    fname_in = $s_torProf.fname [i]
    fname_out= Replace( fname_in ".inp" ".log")
    fname_dat= Replace( fname_in ".inp" ".dat")
    s_grep = "\"TERMINATED NORMALLY\" " + fname_out
    read sys grep $s_grep
    if(s_out!="")then
      read gamess fname_out name="XYZ"
      $s_torProf.QM_Energy [i] = r_out
#      read mol $s_torProf.mol [i] name = "TMPQMOBJ"
      set a_//!vt* XYZ[Index(Name( a_//!vt* ) S_out index)]
#      $s_torProf.mol[i] = Chemical( a_ exact hydrogen )
      store conf i
#      delete system fname_in + " " + fname_dat + " " + fname_out
    else
      print " Error> QM calculations failed or didn't finish for row " + i
    endif
  endfor
  $s_torProf.QM_dEnergy = $s_torProf.QM_Energy - Min( $s_torProf.QM_Energy )
  store stack a_
  $s_torProf.OBJECT = Parray( a_ object )
endmacro

macro torScan vs_1 r_step (5.) l_optPolar (no) l_reverse (yes)
HELP = """
  calculates torsion profile using opimized MMFF force field at dielectric constant of 2.
  The procedure minimizes all variables except for the torsion scanned for 1000 iterations.
  Arguments and options:
    <vs_1>    the torsion angle selection to be scanned
    <r_step>  the angle increment
    <l_optPolar>  preoptimizes polar hydrogens before full minimization
  Output:
    table torsionProfile and associated plot
"""
  l_minRedraw = l_info = no
  set object Obj(Atom(vs_1))
  M = Nof(vs_1)
  vfree = v_
  ffMethod = "mmff"
  dielConst = 2.
  set symmetry v_//t* 1
  unfix V_
  N = Integer( 360./r_step)
  ffEnergy = Rarray(N+1)
  if (M==2) then
    l_reverse = no   # fix later
    torAngle  = Matrix((N+1)*(N+1),3)
    GRAPHICS.l_redraw = no
  else
    torAngle  = Rarray(N+1)
  endif
  delete stack a_
  k = 1
  print bar "Torsion scan" N l_info=yes
  for i0 = 0,N*(l_reverse?2:1)
    i = i0
    if(i0>N) i = 2*N - i0
    set vs_1 [1] i*(360./N)
    #
    if (M == 2) then
      for j0 = 0,N
        j = j0
        set vs_1 [2] j*(360./N)
        torAngle[k,1] = i*(360./N)
        torAngle[k,2] = j*(360./N)
       # print i,j, torAngle[k,1] torAngle[k,2] Value( vs_1 [1] )[1]  Value( vs_1 [2] )[1]
        if(l_optPolar) minimize v_//P & ! vs_1 "el" # try to pre-orient polar hydrogens
        minimize "vw,14,el,to,bb,bs,af" v_ & ! vs_1 1000
        if(i0<=N) torAngle[k,3] = Energy("ener")
        if(i0>N ) torAngle[k,3] = Min( torAngle[k,3] Energy("ener") )
        store conf a_
        k = k + 1
      endfor
    else
      torAngle[i+1] = i*(360./N)
      if(l_optPolar) minimize v_//P & ! vs_1 "el" # try to pre-orient polar hydrogens
      minimize "vw,14,el,to,bb,bs,af" v_ & ! vs_1 1000
      if(i0<=N) ffEnergy[i+1] = Energy("ener")
      if(i0>N)  ffEnergy[i+1] = Min( ffEnergy[i+1] Energy("ener") )
      store conf a_
    endif
    print bar N l_info=yes
  endfor
  print bar "End\n" l_info=yes

  if (M == 2) then
    group table torsionProfile Count(Nof(torAngle)) "ix" torAngle[?,1] "torsion_angle1"  torAngle[?,2] "torsion_angle2" torAngle[?,3] "MMFF_energy" header "load conf a_" + Name( a_ )[1] + ". %@.ix[%#]" "cursor"
    GRAPHICS.l_redraw = yes
    display new
  else
    group table torsionProfile Count(Nof(torAngle)) "ix" torAngle "torsion_angle" ffEnergy "MMFF_energy" header "load conf a_" + Name( a_ )[1] + ". %@.ix[%#]" "cursor"
    make plot torsionProfile "x=torsion_angle;y=MMFF_energy;size=3.;style=connected;;title="+ (Name(vs_1)[1]) +";xStep=90.;"
  endif
  torsionProfile.MMFF_energy = torsionProfile.MMFF_energy - Min( torsionProfile.MMFF_energy )
  set format torsionProfile.MMFF_energy "%.4g" color="rainbow='#33AAFF/#FFFFFF/#FFBBBB'"
  keep torsionProfile
  unfix only vfree
  l_info=no
endmacro

macro splitAlter as
  l_info = no
  os = Obj(as)[1]
  aa = Unique(Sort(Field(Name( Atom(os) full ),":",1)))
  if Nof(aa) > 2 & Nof( as & a_*.//A ) > 0 then
    for iob = 2,Nof(aa)
      obna = Name(os)[1] + "_" + aa[iob] # eg "2ins_a"
      copy os obna delete
      if l_warn print " Warning> object a_"+obna+". created "
      sch=":";
      if iob>2 then; sch += Sum(aa[2:iob-1]); endif
      if iob<Nof(aa) then; sch += Sum(aa[iob+1:9999]); endif
      delete a_$obna.//$sch
      set comment Atom(a_$obna.//A ) " "
    endfor
  else
    if l_warn print " Warning> no alternatives found"
  endif
endmacro

macro cluster_vars R_vars i_n r_vicinity (0.3)
# here vicinity is relative to the average distance. Row-vectors are clustered
  l_info=no
  m = Matrix(R_vars i_n); d = Distance(m); av = Mean(Mean(d))
  group table t Count(Nof(d)) Cluster(d, r_vicinity*av)
  sort t.B
  add column t Count(t.B identity)
  vindx = ( t.C == 1  & t.B != 0 ).A  # array of indeces of 1st members of nonsingleton clusters
  v2inx = ( t.B == 0 ).A  # singletons added
  vindx //= v2inx
  M_out = Matrix(Nof(vindx), i_n )
  for i=1,Nof(vindx)
    inx = vindx[i]
    M_out[i,?] = m [inx]
    icl = t[inx].B[1]; R_2out[i] = Max((t.B==icl).C)
  endfor
  printf " Reduced from %d to %d. Max cluster size %d members. nSingletons=%d. result in M_out\n", Nof(d), Nof(vindx), Max((t.B!=0).C), Nof(t.B==0)
  keep M_out R_2out
endmacro

macro set_icmff auto r_vwSoftMaxEnergy (4.)
  l_info=no
  LIBRARY.res = {"icmff"};  ffMethod = "icmff"
  vwSoftMaxEnergy = r_vwSoftMaxEnergy  # needs to be before read library to recompute A,B,C for icmff
  read library energy   # redefines, A,B,C with new maximum
  dielConst = 2. ;  electroMethod = "distance dependent"
  set type "atomic" { 0.0080,0.0220,-0.0900,-0.2240,-0.1760,-0.0630,-0.0350,-0.2240,-0.0960,-0.1160,-0.0120,-0.0510,0.0080,0.0080,-0.0630,-0.0900,-0.0900,-0.1760,-0.0900,0.0,0.0100,0.0100,0.0100,0.0100,0.0100}
  set term only "bb,vw,14,hb,el,to,cn,sf"
  vwMethod="soft"
# sfMethod ?  # sfWeight sfHbondBoost (??)
  flipStepPb=0.25
  temperature = 600.
  s_skipMessages = "[65][66][67]"
  keep electroMethod dielConst ffMethod visitsAction vwMethod vwSoftMaxEnergy flipStepPb s_skipMessages temperature
endmacro

macro dsReadSel s
  l_info=no
  if(Length(s)<2) return error "wrong selection string"
  if Nof( $s ) == 0 then
    if(s[1:2]!="a_") then
      obname=s; s="a_" + s + "."
    else
      obname = Field(s,"_",1,".")
    endif
    if Nof( a_$obname.  ) == 0 & Length(obname)==4 then  # reading section
      read binary object "http://ablab.ucsd.edu/xpdb/"+obname[2:3]+"/"+obname+".icb"
      if i_out > 0 set field a_ name="temp"
      if Nof( Select(a_*. "temp" )) > TOOLS.mnLoadedTempObjects  delete Select(a_*. "temp" )[1]
    endif
  endif
  dsLocal $s
endmacro

macro dsLocalwire as
  GRAPHICS.l_redraw = no
  if Nof( as ) == 0 return
  as_out = Res(Sphere( as Atom(Obj( as )) & ! as , -2.0 ))
  set label Sphere( as Atom(Obj( as )) & ! as , -2.0 ) l_warn=no
  set color wire gray as_out & a_*.//c*
  set color wire pink as_out & a_*.//o*
  set color wire darkblue as_out & a_*.//n*  # aliceblue ?
  set color wire brown as_out & a_*.//!c*,o*,n*
  set color wire as
  undisplay !Obj( as )
  display as | as_out
  display ribbon Select(Select (Res( as_out ) 6 ),margin,1)
  if Nof( Atom(( as )) ) < 200 then
    undisplay wire as & ! ( Next( as_out bond ) & Atom( as ) )
    display xstick as GRAPHICS.stickRadius=0.1
    display residue label ( as | as_out ) & a_*.!W
    show surface area mute as & a_*.!W//!h*  ( as | as_out  ) & a_*.!W//!h*
    color Select( Atom( as & a_*.//c* ), "a>5" ) xstick white
    color Select( Atom( as & a_*.//n* ), "a>5" ) xstick deepskyblue
    color Select( Atom( as & a_*.//o* ), "a>5" ) xstick indianred
  elseif Nof( Res( as ) ) < 16 then
    display residue label as & a_*.!W
  else
    if Nof( Atom( as )) > 300 then; undisplay wire as ; display as & a_*.H,M xstick ; set xstick as & a_*.M 0.4; display as & a_*.M atom label; endif
    display ribbon as  ribbonColorStyle=2
  endif
  display atom label ( as | as_out ) & a_*.//CM
  center as static
  GRAPHICS.l_redraw = yes
  display new
endmacro

macro dsLocal as
  GRAPHICS.l_redraw = no
  GRAPHICS.quality=10
  if Nof( as ) == 0 return
  as2_out = Sphere( as Atom(Obj( as )) & ! as , -2.0 ); as_out = Res(as2_out)
  set label Sphere( as Atom(Obj( as )) & ! as , -2.0 ) l_warn=no
  set color xstick gray as_out & a_*.//c*
  set color xstick pink as_out & a_*.//o* & a_*.!W
  set color xstick darkblue as_out & a_*.//n*  # aliceblue ?
  set color xstick brown as_out & a_*.//!c*,o*,n*
  set color xstick as
  set color xstick Obj(as) & a_*.W skyblue
  undisplay !Obj( as )
  undisplay cpk residue label Obj( as )
  set xstick Obj( as ) 0.
  set xstick as 0.15
  set xstick Obj( as ) & ! as 0.1
  display xstick as | as_out
  display ribbon Select(Select (Res( as_out ) 6 ),margin,1)
  if Nof( Atom(( as )) ) < 300 then
    display cpk as GRAPHICS.stickRadius=0.1
    display residue label ( as | as_out ) & a_*.!W,M
    set xstick ( as | as2_out ) & a_*.W 0.4; display ( as | as2_out ) & a_*.W xstick skyblue
    display as2_out & a_*.*//CM cpk
    show surface area mute as & a_*.!W//!h*  ( as | as_out  ) & a_*.!W//!h*
    color Select( Atom( as & a_*.//c* ), "a>5" ) xstick white
    color Select( Atom( as & a_*.//n* ), "a>5" ) xstick deepskyblue
    color Select( Atom( as & a_*.//o* ), "a>5" ) xstick indianred
    display atom label ( as | as_out ) & a_*.//CM
  elseif Nof( Res( as ) ) < 16 then
    display residue label as & a_*.!W
  else
    cool as
    if Nof( Res(as) ) < Nof( Res( Mol( as )) ) display residue label Res( as ) & a_*.!W,M
  endif
  center as static margin=5.
  GRAPHICS.l_redraw = yes
  display new
endmacro

macro makeSideConf rs_
# considers multiple stack confs in objects. generates sc confs around each of them for further analysis
# UNFINISHED R
 os = ( a_*. &  a_ICM.  )[1]
 if Nof(os) == 0 return " Error> icm objects not found"
 set object os ; rs_ = Res( rs_ & os )
 if Nof(rs_) == 0 return " Error> no residues selected"
 set vrestraint rs_
 store conf a_   # add current as last
 if Nof( a_ stack) > 0 load stack a_
 ncf = Nof(conf)
 for icf = 1,ncf
   load conf icf
   ssearch residue  fast v_//x* & rs_ "vw,14,hb,to,ss,el" vwCutoff=6.5 mute mncalls=100 mncallsMC=5000 electroMethod = "distance dependent"
 endfor
 store stack a_
endmacro

macro aquaFlood auto R_6box i_nconf ( 1 ) i_nw ( 0 ) l_progress (no)
#
  TOOLS.tsShape = 3
  TOOLS.tsShapeData = R_6box
  TOOLS.tsWeight=2.0
  set term only "vw,14,hb,el,to,ts"
  s_skipMessages = "[3908]"
#
  l_minRedraw = no
  surfaceAccuracy = 5
  ob = a_
  mxnw = 0
  if(i_nconf>0)delete stack
  for c = 1, i_nconf
    delete a_W
    for i = 1, 10 # arbitrary limit on number of iterations/layers
      if( i==1) vwExpand = 1.2
      if( i!=1) vwExpand = 1.45
      g = Grob( "dot" Rarray(Xyz( a_//!h* 2.8 surface )) )
      g1 = Trim( g R_6box )
      if(Nof( g1 )==0 ) break
      for j = 1, Nof( g1 )
        if(i_nw!=0 & Nof( a_W ) >= i_nw)break
        build string "se hoh" l_info=no
        set a_//vt1
        randomize v_//?vt2,?vt3 l_info=no
        translate a_ Xyz( g1 ) [j]
        move a_ ob
      endfor
      printf "Info_aquaFlood> Layer %d: %d waters added" i Nof( g1 )
      minimize v_W//?vt2,?vt3 | ( v_//P & ( a_ & R_6box )) "el" 1000
      minimize v_W//?vt2,?vt3 | ( v_//P & ( a_ & R_6box )) "vw,hb,el" 1000 vwMethod = "soft" vwSoftMaxEnergy = 4.0
    endfor
    minimize v_W | ( v_//P & ( a_ & R_6box )) 1000
    minimize v_W | ( v_//P & ( a_ & R_6box )) 1000
    minimize v_W | ( v_//P & ( a_ & R_6box )) 1000
    if(i_nconf>1)then
      if(mxnw < Nof( a_W )) mxnw = Nof( a_W )
      if( c==1 ) nw = Nof( a_W ) + 10 # spare waters
      if(Nof( a_W ) > nw ) delete a_W [nw+1:Nof( a_W )] # sacrifice some waters if not enough spares
      for j = 1, nw - Nof( a_W )
        build string "se hoh" l_info=no
        set a_ off l_info=no
        move a_ ob
      endfor
      store conf atom
    endif
    if(l_progress) printf "%d%% completed\n" (c*80)/i_nconf error
  endfor
  if(i_nconf>1)then
    minimize stack 1 v_W | ( v_//P & ( a_ & R_6box ))
    sort stack
    store stack a_
  endif
  if(mxnw!=0 & Nof( a_W ) > mxnw ) delete a_W [mxnw+1:Nof( a_W )] # remove unused spares
  if(i_nw!=0 & Nof( a_W ) > i_nw ) delete a_W [i_nw+1:Nof( a_W )]
endmacro
#
macro mrcStack as_mainObj (a_) os_otherObjects (a_*.) l_super (no) l_optimizeH (yes)
HELP = """
  macro to create a stack from multiple objects of the same protein in different conformations. The first selection does not need to be the full object, it can be only a part.
  Prerequisites: one master object with an empty pocket, necessary waters and co-factors, and number of other superimposable objects from which different conformations for the pocket can be borrowed.
  Outcome:  a stored stack in the converted main-object of the first selection that contain those conformations.
  Example with a Pocketome file:
  read binary object 'DRD3_HUMAN_1_400.icb'
  delete Select( a_*./ 'ligand' )
  mrcStack a_A !a_ no yes
"""
  l_commands = yes
  print "main object is"  Name(Obj((as_mainObj)))
  print "the conformations of the following objects" Name(Obj(os_otherObjects)) "will be added to the stack of " Name(Obj(as_mainObj)) "object"
  if (Nof(Obj(as_mainObj)) > 1 | Nof(as_mainObj) == 0) return error "Error> Select one main object"
  set object Obj(as_mainObj)
  if(Type( a_ 2 )!="ICM") convertObject a_ no yes yes yes yes no no ""
  if(Nof(a_ conf)==0)then
    store conf atom Obj(a_ ) 0.
    set comment a_ conf Nof(a_ conf) String(Name(Obj(a_)))
  endif
  os_otherObjects = Obj(os_otherObjects) & ! Obj( as_mainObj )
  for i= 1, Nof(os_otherObjects)
    load conf a_ 1
    set a_* on
    delete tether a_
    GRAPHICS.l_redraw = no
    if(Nof(a_A)) set tether a_A os_otherObjects [i] & a_.A align
    if(Nof(a_N)) set tether a_N os_otherObjects [i] & a_.N align
    if(Nof(a_M )>0 & Nof( os_otherObjects [i] & a_.M )>0) set tether a_M os_otherObjects [i] & a_.M
    if(l_super) superimpose a_A,N reverse
    set a_A,N,M tree
    set a_//!h*,vt* & a_//!T off
    as_Tamino = a_//T | ( a_//h* & Next(a_//T bond))
    delete tethers
# place cofactors
    if(Nof( a_H )>1) print " Warning> more than one cofactor. Make sure that the order of cofactors is correct."
    if(Nof( a_H )>0 & Nof( os_otherObjects [i] & a_.H )>0 ) set tether a_H Mol( os_otherObjects [$i] & a_.H )
    as_Tcofactor = a_//T | ( a_//h* & Next(a_//T bond))
    minimize tethers v_H
    delete tethers
# place waters
    if(Nof( a_W )>0 & Nof( os_otherObjects [i] & a_.W )>0 ) set tether a_W Mol( os_otherObjects [$i] & a_.W ) water
    as_Twater = a_//T | ( a_//h* & Next(a_//T bond))
    minimize tethers v_W
    delete tethers
# mask/unmask according to template
    set a_//!vt* off
    set as_Tamino | as_Tcofactor | as_Twater on
    if(l_optimizeH) optimizeHbonds a_ yes no
    store conf a_ 0.
    set comment a_ conf Nof(a_ conf) String(Name(Obj(os_otherObjects [i])))
    GRAPHICS.l_redraw = yes
  endfor
endmacro
#
macro tryMut ms_rec (a_1) s_mutStr ("") l_optVic (no)
  # tryMut a_a "W123ASDF"
  ### check input correctness
  if Nof(T_mutScore) > 0 then ; delete T_mutScore ; endif
  l_commands= no ; l_info = no ; s_error = ""; keep s_error
  if (Nof(ms_rec) == 0) then ; s_error = "Error> receptor not found" ; return s_error ; endif
  os_rec = Obj(ms_rec); if Nof(os_rec & a_ICM.) == 0 then ; s_error = "Error> the object must be converted into ICM first" ; return s_error ; endif
  os_rec = Obj(os_rec & a_ICM.)[1] ; ms_rec = Mol(ms_rec & os_rec)[1]
  s_mutStr = Match(s_mutStr, "[A-Z][0-9]+[a-zA-Z,]*")
  if s_mutStr == "" then ; s_error = "Error> please specify the mutation string in the format A234I,L or A234IL or A234ile,leu or simply A234 (to try all substutitions -pro,-gly)" ; return s_error ; endif
  obNm = Name(os_rec)[1]; molNm = obNm+"."+Name(ms_rec)[1]
  str = "^"+Match(s_mutStr, "[A-Z][0-9]+") ; if Nof(a_$molNm/$str)==0 | Nof(a_$molNm/* & !a_$molNm/$str)==0 then ; s_error = "Error> wrong residue selection" ; return s_error ; endif
  set field a_$obNm./* 0 name="mutenv" ; set field Res(Sphere(a_$molNm/$str/*, a_$obNm.//*, 4.)) 1 name="mutenv" ; set field a_$molNm/$str 2 name="mutenv"

  ### call _tryMut.icm
  inputDir=s_tempDir+"TMI/" ; if !Exist(inputDir) make directory inputDir ### tmi stands for try mut input - a temporary input icb file
  write binary Obj(os_rec) inputDir+obNm+".icb" delete
  s_cmd = Path(macro, s_icmhome + "_tryMutPos.icm", inputDir+obNm+".icb",  "-mol="+molNm,  "-m="+s_mutStr, String(l_optVic,"-flex","") )
  s_out = Unix(s_cmd) ; keep s_out

  ### analyze results
  print Sum(Split(s_out,"\n") ~ "Warning>*", "\n")
  if s_out !~ "*Error>*" then
    tryMutOu = s_tempDir+obNm+"_"+Replace(molNm, ".", "_")+"_"+s_mutStr+".icb"
    read binary tryMutOu name="T_mutScore"
    add column T_mutScore Field(T_mutScore.args, 2, " ") name="newRes" index=2 ; rename T_mutScore.args "oldRes"
    T_mutScore.oldRes[Count(Nof(T_mutScore))] = Replace(Tr123(s_mutStr[1])," ","")
    str = "^"+Match(s_mutStr, "[A-Z][0-9]+") ; if (Tr321(Name(ms_rec & a_*.A/$str)[1])==s_mutStr[1]) T_mutScore.oldRes[Count(Nof(T_mutScore))] = Name(ms_rec & a_*.A/$str)[1];
    ### group "base" lines if there's more than one
    sort T_mutScore.base ; T_mutScore.base[Index(T_mutScore.base=="")] = Sarray(Count(Nof(T_mutScore.base=="")))
    group T_mutScore.base T_mutScore.Score "min" all "refmin" ; T_mutScore.base[Index(T_mutScore.base!="X")]=""
    ### calculate substitution score
    add column T_mutScore T_mutScore.Score-T_mutScore.Score[Index(T_mutScore.base=="X")[1]] name="substScore" ;
    sort reverse T_mutScore.base T_mutScore.substScore
    ### define result table action
    str = "l_commands = no ; l_warn = no ; l_info = no\n"
    str = str + "if Nof(a_$mutObNm.)>0 then\n"
    str = str + "  if (Nof(a_env.)>0) delete a_env.\n"
    str = str + "  read binary tryMutOu name=\"env\"\n"
    str = str + "  if (Nof(a_mutRes.)>0) delete a_mutRes.\n"
    str = str + "  if (newRes != \"gly\") then\n"
    str = str + "    read binary tryMutOu name=newRes\n"
    str = str + "    rename a_$newRes. \"mutRes\"\n"
    str = str + "  endif\n"
    str = str + "  display wire Select(a_$mutObNm./*, \"mutenv>0\") only\n"
    str = str + "  center static\n"
    str = str + "  display xstick a_mutRes.\n"
    str = str + "  display wire Res(Sphere(a_$mutObNm.//ca & Select(a_$mutObNm./*, \"mutenv>0\"), a_env.//ca, 0.1))\n"
    str = str + "  display ribbon a_$mutObNm.\n"
    str = str + "endif\n"
    if (Type(mutScoreDoubleClick)!="unknown") delete mutScoreDoubleClick ; rename str "mutScoreDoubleClick" ; keep mutScoreDoubleClick
    group table T_mutScore header append "newRes=%@.newRes[%#]\ncall string mutScoreDoubleClick\n" "doubleClick"
    mutObNm = obNm
    print "...done, see T_mutScore for results; lines are double-clickable" ; keep T_mutScore, tryMutOu, mutObNm
  else ; s_error = s_out ; return s_error ; endif

endmacro

macro bindingScoreMut ms_rec ( a_1 ) ms_lig ( a_2 ) l_ligInternalHBond (no)
HELP="""
  Input: icm-converted objects with the default variable fixation
  Output: r_bindingScore variable contains the score and
          R_bindingScoreComponents contains score contributions:
           {Score, dE_ligstrain, dE_vw_steric, dE_conf_entropy_torsions,
            dE_electro_desolvation, dE_hbonds, dE_hydrophobic, dE_buried_hb}
"""
  l_info = no
  l_warn = no
  l_commands = no
  l_minRedraw=no
  ms_rec = Mol(ms_rec & Obj(ms_rec)[1])
  ms_lig = Mol(ms_lig & Obj(ms_lig)[1])

  l_chemical = (Nof(ms_lig & a_*.H) > 0)

  copy  Obj(ms_rec) "DOTMREC" delete
  delete a_DOTMREC.* & !Mol(Select(ms_rec a_DOTMREC.))
  s_recMol = Sum(Name(a_DOTMREC.*),",")
  s_recMol = "\\" + Replace(s_recMol, ",", ",\\")
  copy  Obj(ms_lig) "DOTMLIG" delete
  delete a_DOTMLIG.* & !Mol(Select(ms_lig a_DOTMLIG.))
  move a_DOTMLIG.* a_DOTMREC.
  s_ligMol= Sum(Name(a_DOTMREC.!$s_recMol), ",")
  s_ligMol = "\\" + Replace(s_ligMol, ",", ",\\")

  copy a_DOTMREC. "DOTMCPX" delete
  delete a_DOTMREC.$s_ligMol

  electroMethod = "distance dependent"
  vwMethod = "soft"
  vwSoftMaxEnergy = 1.

  if (Type(tmp) != "unknown") delete tmp
  tmp = Rarray(3)

  s_terms = "vw,14,to"
  if l_ligInternalHBond s_terms = "vw,14,hb,to"


  copy a_DOTMCPX. "DOTMLIG" delete
  delete a_DOTMLIG.$s_recMol
  set object a_DOTMLIG.
  unfix V_//V
  show energy "vw,14,hb,to" mute  # before
  r_ligVwHbToCur = Energy(s_terms)
#
  vold = Value(v_//* ) ; minimize "vw,14,hb,to" 100
  show energy "vw,14,hb,to" mute
  r_ligVwHbToMin = Energy(s_terms)  # after min
  set v_//* vold
#
  ligStrain = r_ligVwHbToCur - r_ligVwHbToMin
  if ligStrain < 0. then
    print "Ligand ground state has a higher energy than the bound state by " + String(Abs(ligStrain)) + "; resetting ligStrain to 0."
    ligStrain = 0.
  endif
  nVar = Nof( v_//!V,r* & v_//!M,T3,T43,T16,T15,T11,T48 ) # skip 'hard' torsions for entropy evaluation

### ELECTROSTATIC TERM, BORN APPROXIMATION ###

  for i = 1, 3
    obNm = {"DOTMREC", "DOTMLIG", "DOTMCPX"}[i]
    set object a_$obNm.
    tmpCharge = Charge(a_//*)
    if l_chemical then
      set type mmff
      set charge mmff
    endif
    make born electroMethod="generalized Born" surfaceAccuracy=5 vwCutoff=15.
    show energy "el" V_* electroMethod="generalized Born" surfaceAccuracy=5 vwCutoff=15. mute # to consider ALL part. charge pair
    tmp[i] = Energy("el")
    set charge a_//* tmpCharge
  endfor
  eyEl = tmp[3] - (tmp[1]+tmp[2])

#  print tmp[3] "electrostatic energy bound"
#  print tmp[1] "electrostatic energy receptor"
#  print tmp[2] "electrostatic energy ligand"

### HYDROPHOBIC TERM #########################

  for i = 1, 3
    obNm = {"DOTMREC", "DOTMLIG", "DOTMCPX"}[i]
    set object a_$obNm.
    show energy "sf" aHphobSel a_* surfaceMethod="constant tension" mute
    tmp[i] = Energy("sf")
  endfor
  eyHp = tmp[3] - (tmp[1]+tmp[2])

  delete tmp

### POLAR SURFACE TERM AND HYDROGEN BONDS ####

  polarAreaUnbound = Rarray(0)
  hbUnbound        = Rarray(0)

  for i = 1, 3
    obNm = {"DOTMREC", "DOTMLIG", "DOTMCPX"}[i]
    set object a_$obNm.
    set field a_//* 0.
#    if (Nof(a_$s_recMol) > 0) show hbond exact a_$s_recMol a_* mute
    if (Nof(a_$s_recMol) > 0) show hbond exact a_$s_recMol a_$s_recMol | ( aHbDoAcSel & a_$s_ligMol ) mute
    if (Nof(a_$s_ligMol) > 0) set field a_$s_ligMol//*  0.
    show area surface mute

    if (obNm !~ "*CPX") then
      hbUnbound        //= Field( aHbDoAcSel )
      polarAreaUnbound //= Area ( aHbDoAcSel )
    else
      hbBound            = Field( aHbDoAcSel )
      polarAreaBound     = Area ( aHbDoAcSel )
      hbMask =  1. - Sign(Trim(hbUnbound - 0.8, 0., 1.)) # donors and acceptors unsatisfied in the unbound state are marked with 1
      eySf   = -2. * Sum(hbMask * (polarAreaBound - polarAreaUnbound) / (polarAreaBound + polarAreaUnbound + 5.))
      eyHb   = -2. * Sum(Trim(hbBound - hbUnbound, 0., 10.) / (polarAreaUnbound/5. + 1.))
#      print Sum( polarAreaBound * hbMask )   "polar area bound"
#      print Sum( polarAreaUnbound * hbMask ) "polar area unbound"
#      group table t Count(Nof( aHbDoAcSel )) "cnt" Name( aHbDoAcSel ) polarAreaBound polarAreaUnbound hbMask copy
    endif
  endfor

### VAN DER WAALS ############################
  set object a_DOTMCPX.
  show energy "vw,hb" a_$s_recMol a_$s_ligMol mute
  eyVw= Energy("vw")

### COMBINED SCORE ###########################
  fisco = ligStrain + eyVw + 0.60*nVar + 0.66*eyEl + 2.53*eyHb + 0.67*eyHp + 0.75*eySf

  group table tmp Sarray(1, "bindingScoreMut") "macro" Sarray(1, String(ms_rec) + " / " + String(ms_lig)) "args"
  group table tmp append Rarray(1, r_ligVwHbToMin) "unbound"
  group table tmp append Rarray(1, r_ligVwHbToCur) "bound"
  group table tmp append Rarray(1, ligStrain) "strain"
  group table tmp append Iarray(1, nVar)      "nVar"
  group table tmp append Rarray(1, eyVw)      "vw"
  group table tmp append Rarray(1, eyEl)      "el"
  group table tmp append Rarray(1, eyHb)      "hb"
  group table tmp append Rarray(1, eyHp)      "hp"
  group table tmp append Rarray(1, eySf)      "sf"
  group table tmp append Rarray(1, fisco)     "Score"
  group table tmp append Sarray(1, Replace(String(Res(Select(Sphere(a_$s_ligMol, a_//*, 5.), "o<1."))), "DOTMCPX.", "")) "occupancy"

  if (Nof(T_bindingScore) > 0) then
    add T_bindingScore tmp
  else
    rename tmp "T_bindingScore"
  endif

  delete a_DOTM*.
  keep T_bindingScore
endmacro

macro findSelHitDisplay s_hits i_row
  if Type( $s_hits )!="table" return error " Error> hit table not found"
  if i_row > Nof( $s_hits ) return error " Error> row number out of range"
  if Type(  $s_hits.qob )!="sarray"  return error " Error> looking for .qob .tob .qre .tre and .rms columns in the hits table "
  qob = $s_hits.qob [i_row]
  tob = $s_hits.tob [i_row]
  qre = $s_hits.qre [i_row]
  tre = $s_hits.tre [i_row]
  delete Select(a_*. "temp")
  if Nof( $qob )== 0 read binary pdb qob[3:6]
  if Nof( $tob )== 0 read binary pdb tob[3:6]
  set field $tob name="temp"
  qob1=qob+"//ca,cb"
  tob1=tob+"//ca,cb"
  superimpose $qob $tob Iarray( $qob1 qre atom ) Iarray( $tob1 tre atom )    # option minimize?
  if Type( $s_hits.rms )=="rarray" $s_hits.rms [i_row] = r_out
  GRAPHICS.l_redraw = no
  center Res(as_out) static
  display wire Res(as_out) | Res(as2_out)
  display xstick (Res(as_out) | Res(as2_out)) & a_*.//ca,cb
  display residue label Res(as2_out) lightblue
  display ribbon Mol(as2_out) lightblue
  color Res(as2_out) & a_*.//c* xstick lightblue
  color as2_out xstick grey
  color Res(as2_out) & a_*.//n* xstick blue
  color Res(as2_out) & a_*.//o* xstick pink
  GRAPHICS.l_redraw = yes
  display new
endmacro

macro viz_apf
  m_tmpshape = Abs(m_g1)+ Abs(m_g2)+ Abs(m_g3)+ Abs(m_g4)+ Abs(m_g5)+ Abs(m_g6)+ Abs(m_g7)
  make grob m_tmpshape 0.2 exact name="g_shape"
  make grob wire  m_g1 exact 0.75 name="g_donor"
  make grob wire  m_g2 exact 0.75 name="g_accept"
  make grob wire  m_g6 exact 0.75 name="g_positive"
  make grob wire  m_g6 exact -0.75 name="g_negative"
  make grob wire  m_g4 * Trim( m_g3 0. 1. ) exact .5 name="g_aroma"
  make grob wire  m_g4 * (1.-Trim( m_g3 0. 1. )) exact .5 name="g_lipo"
  color g_donor blue
  color g_accept red
  color g_aroma white
  color g_lipo yellow
  color g_positive aquamarine
  color g_negative pink
  display g_donor g_accept g_aroma g_lipo g_positive g_negative  g_shape
  keep g_donor g_accept g_aroma g_lipo g_positive g_negative g_shape
endmacro

function Mqn_add T_table
  l_info=no

  T_ = T_table

  if Type( T_.mol ) != "parray" return error " Error> .mol column not found. Syntax: Mqn_add( <t_chem> ) # output: MQN_desc table"
  n = Nof( T_ )
  set charge formal auto T_.mol 7.0
  add column T_ function = "Nof_Fragments(mol '[#6]')"     name="nof_c"
  add column T_ function = "Nof_Fragments(mol '[#9]')"     name="nof_f"
  add column T_ function = "Nof_Fragments(mol '[#17]')"    name="nof_cl"
  add column T_ function = "Nof_Fragments(mol '[#35]')"    name="nof_br"
  add column T_ function = "Nof_Fragments(mol '[#53]')"    name="nof_I"
  add column T_ function = "Nof_Fragments(mol '[#16]')"    name="nof_s"
  add column T_ function = "Nof_Fragments(mol '[#15]')"    name="nof_p"
  add column T_ function = "Nof_Fragments(mol '[#7;R0]')"  name="nof_an"
  add column T_ function = "Nof_Fragments(mol '[#7;!R0]')" name="nof_cn"
  add column T_ function = "Nof_Fragments(mol '[#8;R0]')"  name="nof_ao"
  add column T_ function = "Nof_Fragments(mol '[#8;!R0]')" name="nof_co"
  add column T_ function = "Nof_Fragments(mol '[!H]')"     name="nof_hac"

#Polarity counts
  add column T_ name="nof_hbam" function="Nof_Fragments(mol '[#7X2,#7X3]') + 2*Nof_Fragments(mol '[#8X1,#8X2]')"
  add column T_ name="nof_hbdm" function="Nof_Fragments(mol '[#7,#8;H1]') + 2*Nof_Fragments(mol '[#7,#8;H2]') + 3*Nof_Fragments(mol '[#7,#8;H3]')"
  add column T_ function="Nof_HBD(mol)" name="nof_HBD"
  add column T_ function="Nof_HBA(mol)" name="nof_HBA"
  add column T_ name="nof_posCharge" function="Nof_Fragments(mol,'[*;+]')"
  add column T_ name="nof_negCharge" function="Nof_Fragments(mol,'[*;-]')"

#Bond counts
  add column T_ name="nof_asb" function="Nof_Fragments(mol '*-;!@*')"
  add column T_ name="nof_adb" function="Nof_Fragments(mol '*=;!@*')"
  add column T_ name="nof_atb" function="Nof_Fragments(mol '*#;!@*')"
  add column T_ name="nof_csb" function="Nof_Fragments(mol '*-;@*')"
  add column T_ name="nof_cdb" function="Nof_Fragments(mol '*=;@*')"
  add column T_ name="nof_ctb" function="Nof_Fragments(mol '*#;@*')"
  add column T_ function="Nof_RotB(mol)" name="nof_rbc"

#Topology counts
  add column T_ name="nof_asv" function="Nof_Fragments(mol '[*;R0;v1]')"
  add column T_ name="nof_adv" function="Nof_Fragments(mol '[*;R0;v2]')"
  add column T_ name="nof_atv" function="Nof_Fragments(mol '[*;R0;v3]')"
  add column T_ name="nof_aqv" function="Nof_Fragments(mol '[*;R0;v4]')"
  add column T_ name="nof_cdv" function="Nof_Fragments(mol '[*;!R0;v2]')"
  add column T_ name="nof_ctv" function="Nof_Fragments(mol '[*;!R0;v3]')"
  add column T_ name="nof_cqv" function="Nof_Fragments(mol '[*;!R0;v4]')"
  add column T_ function="Nof_Rings(mol,3)" name="nof_ring3"
  add column T_ function="Nof_Rings(mol,4)" name="nof_ring4"
  add column T_ function="Nof_Rings(mol,5)" name="nof_ring5"
  add column T_ function="Nof_Rings(mol,6)" name="nof_ring6"
  add column T_ function="Nof_Rings(mol,7)" name="nof_ring7"
  add column T_ function="Nof_Rings(mol,8)" name="nof_ring8"
  add column T_ function="Nof_Rings(mol,9)" name="nof_ring9"
  add column T_ function="Nof_Rings(mol,10,1000)" name="nof_ring10"
  add column T_ name="nof_afr" function="Nof_Fragments(mol '[*;R2]') +  Nof_Fragments(mol '[*;R3]')"
  add column T_ name="nof_bfr" function="Nof_Fragments(mol '[*;R2]~[*;R2]') + Nof_Fragments(mol '[*;R2]~[*;R3]') + Nof_Fragments(mol '[*;R3]~[*;R3]')"

  return T_

endmacro
#
function CovalentMechanisms P_chem l_addChem
  S_res     = Sarray(Nof(P_chem))
  S_comment = Sarray(Nof(P_chem))
  I_nof     = Iarray(Nof(P_chem))
  P_match   = Parray(iarray Nof(P_chem))
  P_chemRes = Chemical(Nof(P_chem))
  if (Type(Covalent_Mechanisms) != "table") read binary s_icmhome + "Covalent_Mechanisms.icb"

  for i=1,Nof(Covalent_Mechanisms)
    delete tmp_res l_warn = no
    make reaction Covalent_Mechanisms.rxn [i] P_chem name="tmp_res"
    for j=1,Nof(tmp_res)
      jj = tmp_res.rct1[j]
      I_nof[jj] = I_nof[jj] + 1
      P_match[jj] = P_match[jj] // i
      if (Length(S_res[jj])>0) S_res[jj] = S_res[jj] + "\n"
      S_res[jj]     = S_res[jj]     + Covalent_Mechanisms.Residue[i]
      S_comment[jj] = S_comment[jj] + Covalent_Mechanisms.Name[i] + "/" + Covalent_Mechanisms.Targets[i]
      if (Length(S_comment[jj])>0) S_comment[jj] = S_comment[jj] + "\n"
      if (l_addChem) P_chemRes[jj] = tmp_res.mol[j]
    endfor
  endfor
  res = Collection( "Nof_match" I_nof "Match_idx" P_match "Cov_Res" S_res "Cov_Comment" S_comment );
  if (l_addChem) res["Cov_Chem"] = P_chemRes;
  return res;
endfunction
#
function ToxScore P_chem l_addpenal (yes) l_addname (no)
 if (Type(T_toxscore) == "unknown") then
   if (Exist(s_icmhome+"T_toxscore.icb")) then
     read binary s_icmhome+"T_toxscore.icb"
   elseif Exist("T_toxscore.icb") then
     read binary "T_toxscore.icb"
   else
     return error "table T_toxscore not found"
   endif
 endif
 T_toxscore.mol = Chemical(T_toxscore.smarts)
 if (l_addpenal)  T_toxscore.toxscore[Index(T_toxscore.ID ~"CA*")] = Tostring(T_toxscore.tox_demerit[Index(T_toxscore.ID ~"CA*")])
 add column T_macrotmp P_chem
 toxnames = Find(T_macrotmp.mol T_toxscore.mol T_toxscore.ID);
 add column T_macrotmp toxnames name="toxname" index=2
 add column T_macrotmp T_macrotmp.toxname name="toxtmp"
 T_macrotmp.toxtmp = Replace(T_macrotmp.toxtmp T_toxscore.ID T_toxscore.toxscore)
 T_macrotmp.toxname = Replace(T_macrotmp.toxname "," ";")
 T_macrotmp.toxname = Replace(T_macrotmp.toxname T_toxscore.ID T_toxscore.commonname)
 add column T_macrotmp Rarray(Nof(T_macrotmp) 0.) name="toxscore" index=2
 for i_macro = 1, Nof(T_macrotmp)
   if (T_macrotmp.toxtmp[i_macro] == "") continue
   T_macrotmp.toxscore[i_macro] = Sum(Toreal(Split(T_macrotmp.toxtmp[i_macro] ",")))
   if (!l_addname) continue
   T_macrotmp.toxname[i_macro] = Replace(Sum(Trim(Unique(Sort(Split(T_macrotmp.toxname[i_macro] ";"))) all) ";") "^;" "")
 endfor
 l_toxclass = no
 if (Exist(s_icmhome+"models/toxclassnn.icb")) then
   l_toxclass = yes
   read binary s_icmhome+"models/toxclassnn.icb"
   predict toxclassnn T_macrotmp
   add column T_macrotmp Trim(Max(T_macrotmp.toxclassnn) 0. 7.)/7. name="toxclass"
   T_macrotmp.toxclass = Power(T_macrotmp.toxclass Log(0.5)/Log(0.714286))
   T_macrotmp.toxclass = Rarray(T_macrotmp.toxclass 2)
   T_macrotmp.toxclass [Index(T_macrotmp.mol == Chemical(""))] = 0.
#   predict toxclassnn T_macrotmp key
#   add column T_macrotmp Rarray(Nof(T_macrotmp)) name="toxclass"
#   for i_macro = 1, Nof(T_macrotmp)
#    T_macrotmp.toxclass[i_macro] = Sum(T_macrotmp.toxclassnnv[i_macro])/6.
#   endfor
#   T_macrotmp.toxclass = Power(T_macrotmp.toxclass Log(0.5)/Log(0.821375))
#   T_macrotmp.toxclass = Tointeger(T_macrotmp.toxclass*100.)/100.
 endif
 if (l_addname) then
   if (l_toxclass) then
     return Collection( "Tox_Score" T_macrotmp.toxscore "Tox_Names" T_macrotmp.toxname "Tox_Class" T_macrotmp.toxclass)
   else
     return Collection( "Tox_Score" T_macrotmp.toxscore "Tox_Names" T_macrotmp.toxname )
   endif
 else
   if (l_toxclass) then
     return Collection("Tox_Score" T_macrotmp.toxscore  "Tox_Class" T_macrotmp.toxclass)
   else
     return Collection("Tox_Score" T_macrotmp.toxscore )
   endif
 endif
endfunction
#
function DILIScore P_chem
  if (Type(DILIRegnn)=="unknown") then
    l_loaded = no
    if (!Exist(s_icmhome+"models/DILIRegnn.icb")) return
    read binary s_icmhome+"models/DILIRegnn.icb"
  else
    l_loaded = yes
  endif
  group table T_macrotmp P_chem "mol"
  modify T_macrotmp.mol delete salt
  modify T_macrotmp.mol delete salt simple
  delete hydrogen T_macrotmp.mol
  modify T_macrotmp.mol auto
  modify T_macrotmp.mol delete charge
  predict T_macrotmp DILIRegnn
  add column T_macrotmp Rarray(Nof(T_macrotmp) 0.) name="DILI1"
  add column T_macrotmp Rarray(Nof(T_macrotmp) 0.) name="DILI2"
  add column T_macrotmp Rarray(Nof(T_macrotmp) 0.) name="DILI3"
  add column T_macrotmp Rarray(Nof(T_macrotmp) 0.) name="DILI_Score"
  for i_cpd = 1, Nof(T_macrotmp)
    T_macrotmp.DILI1[i_cpd] = T_macrotmp.DILIRegnn[i_cpd][1]
    T_macrotmp.DILI2[i_cpd] = T_macrotmp.DILIRegnn[i_cpd][2]
    T_macrotmp.DILI3[i_cpd] = T_macrotmp.DILIRegnn[i_cpd][3]
    T_macrotmp.DILI_Score[i_cpd] = Trim((T_macrotmp.DILI1[i_cpd]/3. + T_macrotmp.DILI2[i_cpd]/8. + T_macrotmp.DILI3[i_cpd]/2.)/3. 0. 1.)
  endfor
  add column T_macrotmp Sarray(Nof(T_macrotmp) "No match") name="DILI_Label"
  add column T_macrotmp Tointeger(Trim(T_macrotmp.DILI2 0. 8.)) name="DILI_Severity"
  add column T_macrotmp Sarray(Nof(T_macrotmp) "No Concern") name="DILI_Concern"
  T_macrotmp.DILI_Label [Index(T_macrotmp.DILI1 >= 0.5)] = "Warnings\nPrecautions\nAdverse Reactions"
  T_macrotmp.DILI_Label [Index(T_macrotmp.DILI1 >= 1.5)] = "Box Warning"
  T_macrotmp.DILI_Label [Index(T_macrotmp.DILI1 >= 2.5)] = "Withdrawn\nDiscontinue"
  T_macrotmp.DILI_Concern [Index(T_macrotmp.DILI3 >= 0.5)] = "Ambiguous/Less Concern"
  T_macrotmp.DILI_Concern [Index(T_macrotmp.DILI3 >= 1.5)] = "Most Concern"
  if (!l_loaded) delete DILIRegnn l_warn=no
  return Collection("DILI_PredScore" T_macrotmp.DILI_Score "DILI_predLabel" T_macrotmp.DILI_Label "DILI_predSeverity" T_macrotmp.DILI_Severity "DILI_predConcern" T_macrotmp.DILI_Concern)
endfunction
#
function predictModelsCol P_chem s_mod
  if (Type($s_mod)!="unknown") then
    l_loaded = yes
  else
    l_loaded = no
    if Exist(s_icmhome+"models/"+s_mod+".icb") then
      read binary s_icmhome+"models/"+s_mod+".icb"
    elseif Exist(TOOLS.modelsDir+s_mod+".icb") then
      read binary TOOLS.modelsDir+s_mod+".icb"
    else
      l_continue = yes
      S_modelsDir = Split(TOOLS.modelsDir ";")
      for i_modelsDir = 1, Nof(S_modelsDir)
        if Exist(S_modelsDir[i_modelsDir]+s_mod+".icb") then
          read binary S_modelsDir[i_modelsDir]+s_mod+".icb"
          l_continue = no
          break
        endif
      endfor
      if (l_continue) return error "Prediction model" s_mod "not found"
    endif
  endif
  group table T_macrotmp P_chem "mol"
  predict T_macrotmp $s_mod
  s_comment = $s_mod["NAME"]
  s_comment = s_comment+"\n"+$s_mod["COMMENT"]
  if (s_mod[1:3]== "mcp") then
    if (Type($s_mod["SMILES"]) == "sarray") s_comment = s_comment+"\nModel trained on "+String(Nof($s_mod["SMILES"]))+" compounds"
    if (($s_mod["AUC"] != Toreal("ND"))& ($s_mod["AUC"] != 0.)) s_comment = s_comment+"\nAUC for external test set: "+String($s_mod["AUC"])
    if (($s_mod["Q2"] != Toreal("ND"))&($s_mod["Q2"] != 0.)) s_comment = s_comment+"\nQ2 for external test set: "+String($s_mod["Q2"])
  endif
  s_col = Replace(s_mod "^mcp" "Mol")
  rename T_macrotmp.$s_mod s_col
  set format T_macrotmp.$s_col "%.2f" name="" color=$s_mod["COLOR"] comment=s_comment
  if (s_mod == "mcpPGP") then
    rename T_macrotmp.PGP_inhibitor_mcpPGP "MolPGPinhibitor"
    rename T_macrotmp.PGP_substrate_mcpPGP "MolPGPsubstrate"
    set format T_macrotmp.MolPGPinhibitor "%.2f" name="" color=$s_mod["COLOR"] comment=Replace(s_comment "/substrate" "")
    set format T_macrotmp.MolPGPsubstrate "%.2f" name="" color=$s_mod["COLOR"] comment=Replace(s_comment "inhibitor/" "")
    C_final =  Collection (s_col Collection( "_", T_macrotmp.$s_col "FORMAT" Collection(T_macrotmp.$s_col format) ))
    C_final ["MolPGPinhibitor"] =  Collection( "_", T_macrotmp.MolPGPinhibitor "FORMAT" Collection(T_macrotmp.MolPGPinhibitor format))
    C_final ["MolPGPsubstrate"] =  Collection( "_", T_macrotmp.MolPGPsubstrate "FORMAT" Collection(T_macrotmp.MolPGPsubstrate format))
    if (!l_loaded) delete $s_mod
    return C_final
  elseif (s_mod == "mcpINFLAMMATION") then
    rename T_macrotmp.Antiinflammation_mcpINFLAMMATION "MolAntiInflammation"
    rename T_macrotmp.Proinflammation_mcpINFLAMMATION "MolProInflammation"
    set format T_macrotmp.MolAntiInflammation "%.2f" name="" color=$s_mod["COLOR"] comment=Replace(s_comment " or Pro-Inflammatory" "")
    set format T_macrotmp.MolProInflammation "%.2f" name="" color=$s_mod["COLOR"] comment=Replace(s_comment "Anti-Inflammatory or " "")
    C_final =  Collection (s_col Collection( "_", T_macrotmp.$s_col "FORMAT" Collection(T_macrotmp.$s_col format) ))
    C_final ["MolAntiInflammation"] =  Collection( "_", T_macrotmp.MolAntiInflammation "FORMAT" Collection(T_macrotmp.MolAntiInflammation format))
    C_final ["MolProInflammation"] =  Collection( "_", T_macrotmp.MolProInflammation "FORMAT" Collection(T_macrotmp.MolProInflammation format))
    if (!l_loaded) delete $s_mod
    return C_final
  elseif (s_mod == "mcpLogPERME") then
    s_comment = $s_mod["NAME"]
    set format T_macrotmp.$s_col "%.2f" name="" color=$s_mod["COLOR"] comment=s_comment+"\nLog Permeability of PAMPA\n>-5 Highly Permeable\n<-6 Poorly Permeable"
    rename T_macrotmp.CACO2_LogEffluxR_mcpLogPERME "MolEffluxRatioCACO2"
    T_macrotmp.MolEffluxRatioCACO2 = Power(10. T_macrotmp.MolEffluxRatioCACO2)
    rename T_macrotmp.CACO2_LogPappAB_mcpLogPERME "MolLogPERMECACO2"
    rename T_macrotmp.PAMPA_LogPapp_mcpLogPERME "MolLogPERMEPAMPA"
    set format T_macrotmp.MolEffluxRatioCACO2 "%.2f" name="" color="rainbow='#DCFFDC/#FFFFFF/#FFDCDC,0.:2.,pinwheel'" comment=s_comment+"\nCACO2 Efflux Ratio\n>2. indicates active efflux"
    set format T_macrotmp.MolLogPERMECACO2 "%.2f" name="" color=$s_mod["COLOR"] comment=s_comment+"\nLog Permeability of CACO2 A->B\n>-5 Highly Permeable\n<-6 Poorly Permeable"
    set format T_macrotmp.MolLogPERMEPAMPA "%.2f" name="" color=$s_mod["COLOR"] comment=s_comment+"\nLog Permeability of PAMPA\n>-5 Highly Permeable\n<-6 Poorly Permeable"
    C_final =  Collection (s_col Collection( "_", T_macrotmp.$s_col "FORMAT" Collection(T_macrotmp.$s_col format) ))
    C_final ["MolEffluxRatioCACO2"] =  Collection( "_", T_macrotmp.MolEffluxRatioCACO2 "FORMAT" Collection(T_macrotmp.MolEffluxRatioCACO2 format))
    C_final ["MolLogPERMECACO2"] =  Collection( "_", T_macrotmp.MolLogPERMECACO2 "FORMAT" Collection(T_macrotmp.MolLogPERMECACO2 format))
    if (!l_loaded) delete $s_mod
    return C_final
  elseif (s_mod == "mcpLogHALFLIFE") then
    s_comment = $s_mod["NAME"]
    set format T_macrotmp.$s_col "%.2f" name="" color=$s_mod["COLOR"] comment=s_comment+"\nLog10 Half life in Human Plasma\n0: 1 hour\n1: 10 hours\n<0.: < 1 hour"
    T_macrotmp.LogHalflifemicrosome_human_mcpLogHALFLIFE = Power(10. T_macrotmp.LogHalflifemicrosome_human_mcpLogHALFLIFE)
    T_macrotmp.LogHalflifeplasma_human_mcpLogHALFLIFE = Power(10. T_macrotmp.LogHalflifeplasma_human_mcpLogHALFLIFE)
    rename T_macrotmp.LogHalflifemicrosome_human_mcpLogHALFLIFE "msT1_2_HumanMicrosome_h"
    rename T_macrotmp.LogHalflifeplasma_human_mcpLogHALFLIFE "msT1_2_HumanPlasma_h"
    set format T_macrotmp.msT1_2_HumanMicrosome_h "%.2f" name="" color="rainbow='#FFDCDC/#FFFFFF/#DCFFDC,1.:10.,pinwheel'" comment="Human Microsome Half Life in hours"
    set format T_macrotmp.msT1_2_HumanPlasma_h "%.2f" name="" color="rainbow='#FFDCDC/#FFFFFF/#DCFFDC,1.:10.,pinwheel'" comment="Human Plasma Half Life in hours"
    C_final =  Collection (s_col Collection( "_", T_macrotmp.$s_col "FORMAT" Collection(T_macrotmp.$s_col format) ))
    C_final ["msT1_2_HumanMicrosome_h"] =  Collection( "_", T_macrotmp.msT1_2_HumanMicrosome_h "FORMAT" Collection(T_macrotmp.msT1_2_HumanMicrosome_h format))
    C_final ["msT1_2_HumanPlasma_h"] =  Collection( "_", T_macrotmp.msT1_2_HumanPlasma_h "FORMAT" Collection(T_macrotmp.msT1_2_HumanPlasma_h format))
    if (!l_loaded) delete $s_mod
    return C_final
  else
    if (!l_loaded) delete $s_mod
    return Collection (s_col Collection( "_", T_macrotmp.$s_col "FORMAT" Collection(T_macrotmp.$s_col format) ))
  endif
endfunction
#
function GetScheduledICBIndex
#ifdef WIN32
  read csv header name="jobs" unix schtasks /query /v /fo csv
  c = Collection()
  #
  c["RUN_DAILY"] = no
  c["RUN_TIME" ] = Date("0:00","%H:%M")
  c["DIRS" ] = Sarray()
  #
  jobs = jobs.TaskName ~ "mkicbindex_*"
  if (Nof(jobs) == 1) then
    S_dirs = Split( Replace(jobs.Task_To_Run[1],"'","\"") "(?q)\\s+" regexp )
    s_taskname = jobs.TaskName[1]
    for i=3,Nof(S_dirs)
      S_dirs[i] = String( S_dirs[i] string off )
    endfor
    c["DIRS"] = S_dirs[3:Nof(S_dirs)]
    c["RUN_DAILY"] = jobs.Scheduled_Type[1] ~ "Daily*"
    c["RUN_PASSWORD"] = String(String(Blob(s_taskname[Length("mkicbindex_")+1:Length(s_taskname)],"hex")),crypt)
  endif
#else
  S_out = Match(  Split( Unix("crontab -l"), "\n"), ".*?mkicbindex.*?" only )
  if Nof(S_out) == 0 then
    S_out = Sarray(6)
  else
    S_out = Split( S_out[1] "(?q)\\s+" regexp )
  endif
  #
  c = Collection()
  c["RUN_DAILY"] = S_out[2] != "*";
  c["RUN_TIME" ] = Date( (S_out[1] == "*" ? "0" : S_out[1]) + ":" + (S_out[2] == "*" ? "0" : S_out[2]), "%H:%M" )
  # S_out[5] - day of the week
  S_dirs = Sarray()
  for i=8,Nof(S_out)
    if (S_out[i] == "|" | S_out[i] == ">") break
    S_dirs //= S_out[i]
  endfor
  c["DIRS"] = S_dirs
#endif
  return c
endfunction
#
macro setScheduledICBIndex S_dirs l_saveToCron (yes) l_runNow (no) s_password ("") auto
  l_commands = l_info = no
  S_args = Sarray(1,s_icmhome + "mkicbindex.icm")
  S_args //= S_dirs
  s_cmd = Path( command, S_args ) # command -> single quote not double
#ifdef WIN32
  read csv header name="jobs" unix schtasks /query /v /fo csv
  #
  if Nof(jobs.TaskName ~ "mkicbindex*") == 1 then
    s_taskname = (jobs.TaskName ~ "mkicbindex*").TaskName[1]
    unix schtasks /Delete /tn $s_taskname /F
  endif
  #
  if (l_saveToCron) then
    s_taskname = "mkicbindex_" + String(Blob(String(s_password,crypt)),"hex")
    s_what = "/Create /sc DAILY"
    s_user = Name(user)
    unix schtasks $s_what /tn $s_taskname /ru $s_user /rp $s_password /tr $s_cmd
  endif
#else
  add column t Split( Unix("crontab -l"), "\n") name="X"
  delete t.X ~ "*mkicbindex*"
  if (l_saveToCron) then
    s_newLine = "\n0 0 * * * " + s_cmd + "\n"
    s_fileName = Name( system s_tempDir + "cronXXXX"  )
    write string Sum( t.X, "\n" ) + s_newLine s_fileName
    unix crontab $s_fileName
  endif
#endif
  if (l_runNow) then
    s_cmd = Path( macro, S_args )
    make background s_cmd command="" info="ICB indexing is completed"
  endif
endmacro
#
macro fill_box_with_water R_6box s_mol ("hoh") r_gridSize (3.1)
# options "hoh","o"
  wco = Xyz( R_6box , r_gridSize , grid)
  nw=   Nof( wco )  # volume of one water in ice
  build string Sum(Sarray(nw, s_mol + ";")) name='grid'
  set a_*//vt1 Xyz( a_*//o )
  translate a_ wco
#  TOOLS.tsShape = "box"
#  TOOLS.tsShapeData = R_6box
#  TOOLS.tsWeight=2.0
  set selftether a_*//o wco
  minimize a_ "ts" 1000
  delete selftether a_*//
# see also aquaFlood
endmacro

macro calc_noise_ab  R
  rfr = 0.01; rto = 0.30 # low R range of noise R for A,B derivation
  n = Nof(R); ifr = Integer(1+rfr*n); ito = Min(Max(ifr+4, Integer(n*rto)),n)
  R_out = R
  sort R_out
  M50 = (Mod(n,2)==1)?R_out[(n+1)/2]:(0.5*(R_out[(n)/2]+R_out[(n+1)/2]))
  R_2out = Count(n)/Real(n)
  R_out  = R_out  [ifr:ito]
  R_2out = R_2out [ifr:ito]
  R_2out = Log(R_2out)
  R_4p = LinearFit(R_out R_2out )
# generate easier evaluation
  R_out[1]=(0.5-R_4p[2])/R_4p[1] # median
  R_out[2]=(R_out[1]+(R_4p[2]/R_4p[1]))*4. #std
  R_out[3]=M50
  printf " Mu=%.1f (%.1f) Sig=%.1f . output in R_out\n", R_out[1], M50, R_out[2]
endmacro

function Left_noise( R )
# inverts the left 50% of the distribution.
  c = Collection()
  n=Nof(R); if(n<2) return c
  sort R
  c["M"]=(Mod(n,2)==1)?R[(n+1)/2]:(0.5*(R[(n)/2]+R[(n+1)/2]))
  R = R - c["M"];
  for i=1,n/2
    R[n-i+1] = -R[i]
  endfor
  c["S"]= Rmsd( R )
  c["A"]= 1./(c["S"]+1.e-18)
  c["B"]= -c["M"]/(c["S"]+1.e-18) # x_norm = AX+B (no flipping)
  return c
endfunction

function Left_exp_noise  R r_from (0.00) r_to (0.50)
   rfr = r_from; rto = r_to # low R range of noise R for A,B derivation
   n = Nof(R); ifr = Integer(1+rfr*n); ito = Min(Max(ifr+4, Integer(n*rto)),n)
   R1 = R
   sort R1
   M50 = (Mod(n,2)==1)?R1[(n+1)/2]:(0.5*(R1[(n)/2]+R1[1+n/2]))
   R2 = Count(n)/Real(n)
   R1  = R1  [ifr:ito]
   R2 = R2 [ifr:ito]
   R2 = Log(R2)
   R_4p = LinearFit( R1 R2 )  # returns A and B for A*R1 + B ~ R2
 # generate easier evaluation
   c["A"]=R_4p[1]
   c["B"]=R_4p[2]
   c = Collection()
   c["M"]=(0.5-R_4p[2])/R_4p[1]         # mean ?
   c["S"]=(c["M"]+(R_4p[2]/R_4p[1]))*4. #std
   c["median"]=M50
#   printf " Mu=%.1f (%.1f) Sig=%.1f . output in R_out\n", R_out[1], M50, R_out[2]
   return c
endfunction
#
function dockUnpackProject P_proj
  l_commands = l_warn = no

  s_proj = P_proj["PROJNAME"]

  $s_proj = Table( P_proj["TABLE"] header )

  s_projDir = s_tempDir + s_proj  + "/"
  if (!Exist(s_projDir)) make directory s_projDir

  write table $s_proj s_projDir + s_proj + ".dtb" delete

  S_maps = Name(  P_proj["MAPS"] )
  for i=1,Nof(S_maps)
    write map  P_proj["MAPS",S_maps[i]] s_projDir + S_maps[i] delete
  endfor

  S_objs = Name( P_proj["OBJS"])
  for i=1,Nof( S_objs )
    write object P_proj["OBJS",S_objs[i]] s_projDir + S_objs[i] delete
  endfor

  if (Exist(P_proj, "RXN")) then
    write Chemical( P_proj["RXN"] reaction ) s_projDir + $s_proj.s_covRxn delete
  endif

  return s_projDir + s_proj
endfunction
#
macro mk_model_tab
# it contains model info, benchmark params and results, a chemical table with seeds and benchmark actives.
# need different color schemes for bad and good.
  add header MODEL "","","",   0.,0.,"rainbow='#FF0000/#00AA00/#FFFFFF,-10.:-2.,pinwheel'", {0.},   "", {0.},Matrix(3), 0.,0.,0.,"",0,"",0,"",0,Date(),Date() \
   name={"name","desc","type","A","B","color","pkdw","srcf","ligInitPosition","templateTensor","bauc","bmas","bpkdr2","seedf","nseed","actf","nact","decf","ndec","date","date_last"}
  add column MODEL Chemical(0) Rarray(0) Iarray(0) Sarray(0) name={"mol","pkd","seed","src"}
  keep MODEL
endmacro

macro visualizeAPFm l_display_box (yes) l_header (no)  auto
# a version for grids derived from multiple ligands (drops option exact)
  l_commands = l_info = no
  s_opt = ""
  s_ds_opt = "transparent smooth"
  if (l_header) then
    s_opt += " header "
    s_ds_opt = "wire"
  endif
  make grob solid  m_g1 $s_opt 2. name="g_donor"
  make grob solid  m_g2 $s_opt 2. name="g_accept"
  make grob solid  m_g6 $s_opt 2. name="g_positive"
  make grob solid  m_g6 $s_opt , -2. name="g_negative"
  make grob solid  m_g4 * Trim( m_g3 0. 1. ) 2. name="g_aroma"
  make grob solid  m_g4 * (1.-Trim( m_g3 0. 1. )) 2. name="g_lipo"
  color g_donor blue
  color g_accept red
  color g_aroma white
  color g_lipo yellow
  color g_positive aquamarine
  color g_negative pink
  set property only g_donor g_accept g_aroma g_lipo g_positive g_negative $s_ds_opt
  set g_negative reverse  # otherwise it comes out black on some graph. cards
  display g_donor g_accept g_aroma g_lipo g_positive g_negative
  if (l_display_box) display box Box( m_g1 )
  keep global g_donor g_accept g_aroma g_lipo g_positive g_negative
endmacro

macro visualizeQSARatomType s_atomKind r_level
  if(s_atomKind=="Caliph")   apfVector = { -.5 ,-.5  ,-.5  ,1.   ,1.   ,0.   , 1.  }
  if(s_atomKind=="Caroma")   apfVector = { -.5 ,-.5  , 1.  ,0.5  ,0.5  ,0.   , 0.5 }
  if(s_atomKind=="N_pos")    apfVector = { -.5 ,-.5  ,1.   ,-1.  ,0.   ,1.5  , 0.  }
  if(s_atomKind=="Nsp2_pos") apfVector = { -.5 ,-.5  ,-.5  ,-1.  ,0.   ,1.5  , 0.  }
  if(s_atomKind=="O_neg")    apfVector = { -.5 ,1.5  ,1.   ,-1.  ,0.   ,-1.5 ,-1.  }
  if(s_atomKind=="H_pol")    apfVector = { 1.5 ,-.5  ,0.   ,-1.  ,-1.  ,0.   ,1.   }
  if(s_atomKind=="N_acc")    apfVector = { -.5 ,1.5  ,0.   ,-.5  ,0.   ,0.   ,-.5  }
  if(s_atomKind=="Nsp2_acc") apfVector = { -.5 ,1.5  ,1.   ,-.5  ,0.   ,0.   ,-.5  }
  if(s_atomKind=="Cl")       apfVector = { -.5 ,-.5  ,-.5  ,1.   ,1.   ,0.   ,-.5  }
  if(Type(apfVector)=="unknown") return error "Unrecognized atom kind"
  s_color = Replace( s_atomKind { "Caliph" "Caroma" "N_pos" "Nsp2_pos" "O_neg" "H_pol" "N_acc" "Nsp2_acc" "Cl" } { "yellow" "grey" "aquamarine" "aquamarine" "red" "blue" "magenta" "magenta" "orange" } )


  s_map  = "m_a" + s_atomKind
  s_grob = "g_a" + s_atomKind
  $s_map = -apfVector[1]*MolApfQsar[ "m_g1" ]
  for i = 2 7
    $s_map = $s_map - apfVector[i]*MolApfQsar[ "m_g" + i ]
  endfor
  make grob $s_map exact r_level header name = s_grob solid
  display $s_grob transparent $s_color
  keep $s_map $s_grob
endmacro

macro dataObjAtomAction as_at
#  undisplay atom label Obj( as_at )
  l_commands = no;  l_info = no
  display atom label as_at
  if(Nof(Field(as_at "i"))>=1) then
    i_row = Field( as_at "i" )[1]
    s_tab = Field( Obj(as_at), "table" )[1]
    if( Type(i_row)=="integer" & Type( $s_tab )=="table" ) then
       find table $s_tab select gui index = Index( $s_tab.ORD_ == i_row )
    endif
  endif
endmacro

macro dataObjAtomActionTable s_objnam i_row
  l_info=no
  as_graph = as_graph | Select( a_$s_objnam.//  "i==" + i_row )
  display atom label as_graph
  center as_graph margin=10.
endmacro

macro makeDataObj R_X R_Y R_Z R_kr ({0.}) R_rad ({0.}) S ({""}) s_tabname ("") s_rainbow ("indigo/blue/green/yellow/orange/red") auto
  l_commands = no
  n = Nof(R_X)
  m = Integer( Power( n, 1/3. ) ) + 2
  GRAPHICS.l_redraw = no
  fx = m/(Rmsd(R_X)+0.001); fx=Power(10.,Integer(Log(fx 10.) ))
  fy = m/(Rmsd(R_Y)+0.001); fy=Power(10.,Integer(Log(fy 10.) ))
  fz = m/(Rmsd(R_Z)+0.001); fz=Power(10.,Integer(Log(fz 10.) ))
  M = Matrix( (fx*(R_X))//(fy*(R_Y))//(fz*(R_Z)) ,n)
  s_objnam = Name( s_tabname==""?("d"+n):Name((Field(s_tabname,1)+Field(s_tabname,2)),simple) object unique )
  read mol split Chemical(Sum( Sarray(n "C"), "." ) + "|3D:" + Sum( Sarray( Rarray(Transpose( M ))),"," )) name=s_objnam TOOLS.smilesXyzSeparator = "|"
  set comment a_ s_tabname
  set field name="table" a_ s_tabname
  if (Nof(R_rad)==n) set ball a_//*  Normalize( R_rad, 0.3//1.0 )
#  if (Nof(R_rad)==n) set ball a_//*  R_rad
  if (Nof(R_kr )==n) then
     set color ball a_//* Trim( R_kr rainbow )+0.01
     GRAPHICS.NtoCRainbow = s_rainbow
  endif
  if(Nof(S)==n) set label atom a_// S
#  set label atom a_// Nof(S)>=n ? (S[1:n]+" ") : Sarray(Count(n))
  S_axes = (Nof(S)>=(n+3))?S[(n+1):(n+3)]:((Nof(S)>=3&Nof(S)<=5)?S[1:3]:{"X","Y","Z"})
  blocked = {'a' 'b' 'c' 'q' 'o' 'u' 'x' 'y' 'z'}; for i =1,3; if (Index(blocked Tolower(S_axes[i]))>0) S_axes[i]=S_axes[i]+" "; endfor
  set field a_// name=S_axes[1] Sarray(Rarray(R_X,2))
  set field a_// name=S_axes[2] Sarray(Rarray(R_Y,2))
  set field a_// name=S_axes[3] Sarray(Rarray(R_Z,2))
  set field a_// name="i" Count(n)

  set field a_// name="doubleClick" "dataObjAtomAction $1"

  if( Nof(R_kr )==n) set field a_// name=(Nof(S)>=n+4?S[n+4]:"color") Sarray(Rarray(R_kr,2))
  if( Nof(R_rad)==n) set field a_// name=(Nof(S)>=n+5?S[n+5]:"size")  Sarray(Rarray(R_rad,2))
  SCL=(fx==1.?"":("*"+String(fx))) // (fy==1.?"":("*"+String(fy))) // (fz==1.?"":("*"+String(fz)))
  S_axes = S_axes+SCL
  set color atom label a_//* black
  makeAxesObj Box( a_ 1. ) S_axes
  rename a_ s_objnam+"Axes"
  set color atom label a_//* black
  set object a_*. [$-1]
  if(Nof(S)>=n+5|(Nof(S)<n&Nof(S)>=5)) then
#    delete label
#    display " color ="+S[$-1]+"\n size="+S[$]
  endif
  GRAPHICS.l_redraw = yes
  display a_*. [$-1:$] xstick

  if (Type( $s_tabname ) == "table" ) then
    add column  $s_tabname Count( Nof($s_tabname) ) name="ORD_"
    set format show off $s_tabname.ORD_
    add header $s_tabname name="doubleClick" "dataObjAtomActionTable \""+s_objnam + "\" %@.ORD_[%#]"
     set field name="onSelectionChange" a_ "find table gui select "+s_tabname+" index=Iarray(Field( as_graph & Select( a_*. 'table') &  a_*.!X,Y,Z//c* 'i' ))"
  else
    if(l_warn)  print " Warning_makeDataObj> the source table " + s_tabname + " not found.\n   With the table namd, the object atoms and table rows could have been linked"
  endif

  keep GRAPHICS
endmacro

macro makeAxesObj auto R S ({"X"})
  l_commands = no
  imarg = 1
  if(Nof(R)!=6)  return error "box not provided"
  if(Nof(S)<1|S[1]=="") S   = {"X"}
  if(Nof(S)<2|S[2]=="") S //= {"Y"}
  if(Nof(S)<3|S[3]=="") S //= {"Z"}
  AXS = {"X","Y","Z"}
  RR = Rarray(Integer(R[1:3])-imarg)//Rarray(Integer(R[4:6])+imarg)

  for iax = 1,3
    f = RR[iax]; t = RR[iax+3]
    n = Abs(Integer ( t-f )) + 1
    M = Matrix(3,n)
    M[1,?]=Rarray(n,RR[1]); M[2,?]=Rarray(n,RR[2]); M[3,?]=Rarray(n,RR[3])
    M[iax,?]= Rarray(Count(n)-1) + f
    axmol = Chemical(Sum( Sarray(n "C"), "" ) + "|3D:" + Sum( Sarray( Rarray(Transpose(M))),"," ))
    read mol axmol name=Name( AXS[iax] object unique) TOOLS.smilesXyzSeparator = "|"
    rename a_1 AXS[iax]
    S_tics = Sarray(n-1)//S[iax]
    for i=1,Nof(S_tics)-1
      if(Remainder(M[iax,i],5.)!=0) then; S_tics[i]=" "; else; S_tics[i]=String(M[iax,i]); endif
    endfor
    set label atom a_1//* S_tics
    set comment a_1 S[iax]
    set field a_ name="axis"
    rename a_1//* [$] Tolower(AXS[iax])
    set label atom a_1//* [$-4:$-1] {" "," "," "," "}
  endfor
  read mol Chemical("[C;-4]") name="AXES" delete ; set a_//c1 Matrix(RR[4:6])
  move  Select( a_*. "axis" ) a_AXES.
  delete a_AXES.m
  set label atom a_//c1 " "
  set ball a_AXES. 0.05
endmacro

macro makeAlignmentFromSuper auto ms ( a_*.A )
HELP = """
  derive 3D alignment with 'align <ms1> <ms2>' and combine into multiple alignment
"""
 l_info=no
 ms = Mol(ms) & a_*.A
 make sequence ms & a_*.!Q  # make sure all molecules have linked sequences.
 seqna = Name( ms sequence )
 nseq  = Nof( ms );
 if nseq < 2 return error " makeAlignmentFromSuper> too few chains with linked sequences selected "
 alnatt = Name("al3d" unique)
# add column t Count(Nof(ms)) Name( ms full) # order by distance.

  ms1 = ms [1]; delete ali_out l_warn=no
  for i=2,nseq
     msi = ms [i]
     align ms1 msi
     S_out = Name(ali_out)
     ali_out = Align(Align( $S_out[1] $S_out[2] 0.5*Matrix( ali_out residue )+0.1 ),dash)

     $alnatt = (i==2)? ali_out : ( $alnatt // ali_out )
     delete ali_out
  endfor

  link $alnatt ms
  printf " %s alignment generated from %d chains\n", alnatt , nseq
  keep $alnatt
endmacro

macro align2seqres auto as l_skip_seqres (no)
  l_info=l_warn=no; clear error;
#  if (Date(version)<Date("2012-12-06")) return error " Error> align2seqres: need to use newer version of ICM"
  as = Mol( as & a_*.A,N & a_*.J3 )
  for i=1,Nof(as)
    as2_out = Mol(as [i])
    make sequence as2_out
    s_seqatom =s_out  # the name of ATOM seq
    if(!l_skip_seqres) then
      s_seqres  = "sr"+ ( Replace((Name( as2_out full )[1] ),".","_")[3:$] );
      s_seqresaa = Field( as2_out "_SEQ_")[1]
      if(Length(s_seqresaa)!=0) then
         if( Type( $s_seqres )!="sequence" | s_seqresaa != String( $s_seqres ) ) $s_seqres   = Sequence( s_seqresaa )
      else
        s_seqres   = ""
        print " Warning_align2seqres> SEQRES sequence not found ( ml fields _SEQ_ and _SEQRES_ ) "
      endif
    endif


    salnx = "alx"+s_seqatom
    sunina = Name(as2_out swiss)[1]
    if( sunina !="" & Type( $sunina ) !="sequence" )  then
      readUniprot Name(as2_out swiss)[1]
      if(!Error()) then
        if( Field(s_out 1)!="Info>" ) then
           sunina = s_out
           align $sunina $s_seqres $s_seqatom  name=salnx
        else
          printf " Warning_align2seqres> UNIPROT offline or ID '%s' incorrect (try searching Uniprot)\n",sunina
          sunina = ""
        endif
      endif
    endif
    if (Type( $salnx )!="alignment") then
      align $s_seqatom $sunina $s_seqres name=salnx
    endif
    if (Type( $salnx )=="alignment") link $salnx as2_out
  endfor
  keep sequence
  keep alignment
endmacro

macro calcResConservation rs_ l_color (no)
  l_info=no
  as2_out = Res( rs_ & a_*.A,N )
  tbnatm = Name("seq_id_sim_" + Name(Obj(rs_))[1]  unique)
  add column $tbnatm Name( as2_out full ) Score( as2_out simple ) Score( as2_out comp_matrix ) name={"Sel","ID","Sim"}
  add header $tbnatm Mean(Score( as2_out simple )) Mean(Score( as2_out comp_matrix )) name={"MeanID","MeanSim"}
  if(l_color) then  # may set field
    color as2_out $tbnatm.ID
  endif
  set format $tbnatm.Sel "<!--icmscript name=\"1\"\nresLinkFormatToggle %1\n--><a href=#_>%1</a>"
  printf " Conservation in '%s': identity = %.1f, similarity = %.1f\n", String(Sequence( as2_out )), $tbnatm.MeanID, $tbnatm.MeanSim
  keep $tbnatm
endmacro

macro resLinkFormatToggle rs_
  if( Nof( rs_ & as_graph )>0 ) then
    as_graph = a_NONE.//
    undisplay residue label rs_
  else
    as_graph = Atom( rs_ )
    display residue label rs_
    center rs_ static margin=5.
  endif
endmacro

function Dweight( r_dst )
  if (r_dst <0.) return 0.
  dnor = -1. + 2./(1.+Exp( - r_dst ))
  dsim = 1.-dnor
  return Power( dsim, 3 )
endfunction

function funcMolPSA( as )
  ms = Mol( as )
  R_PSA = Rarray( Nof( ms ) )
  for i=1,Nof( ms )
     set object Obj ( ms[i] )
     as1 = ms[i] & a_//n*,o*,p*,s*  # probably need specific types
     show surface area as1 | ( a_//h* & Next( as1 bond )) ms[i] mute vwExpand=0.
     R_PSA[i] = r_out
  endfor
  return R_PSA
endfunction

function funcLigStrain( P_chem )  # returns strain for a given 3D chemical
  vwMethod = "exact"
  dielConst = 2.
  read mol P_chem name="LIGSTRAIN"
  build hydrogen
  set type charge mmff
  convert auto
  minimize cartesian "mmff" mncalls=1
  newE = Energy("ener")
  minimize cartesian "mmff" 5000
  baseE = Energy("ener")
  r_ligandStrain = newE - baseE
  delete a_
  return r_ligandStrain
endfunction

function funcPubchemCidLookup( P_chem l_testedOnly )
  params = Collection()
  if (l_testedOnly) params["tested"] = yes
  params["format"] = "json"
  i_step = 1024
  result = Array()
  for i=1,Nof(P_chem),i_step
    params["smi"] = Smiles(P_chem[i:i+i_step-1])
    read json "http://mars.molsoft.com/cgi-bin/pubchemlookup.cgi " + String(params html ) name="js"
    result //=  js["cid"]
  endfor
  return result
endfunction

function funcPubchemLookup2 S_id s_typeFrom s_typeTo ("") s_lookupMolt ("")
HELP = """
  convert CID/SID/CAS/Synonim to smiles
  or
  smiles to CID
  Supported s_typeFrom : cid,sid,syn,smi
  Supported s_typeTo   : cid,sid,syn,smi
  Example:
    funcPubchemLookup2({'22407705','17517329'}, 'sid', '' )
"""
  if (Exist(s_lookupMolt)) then
    if (Tolower(s_typeFrom) == "sid") then
      if (s_typeTo == "") s_typeTo = "smi"
      s_col = "sid"
      s_res =  s_typeTo
      ID_col = Iarray(S_id)
      if (s_res == "syn") then
        query molcart """
           select min(t.id), tt.sid, t.cid, t.syn from
               pubchem_cid2sid as tt left join pubchem_cid2syn as t on (t.cid = tt.cid)
               where tt.sid in :ID_col group by t.cid
        """ name="T_tmp" filename=s_lookupMolt
      else
        query molcart """
           select tt.sid, t.cid, t.smi from
               pubchem_cid2sid as tt left join pubchem_lookup as t on (t.cid = tt.cid)
               where tt.sid in :ID_col and tt.rel=1
        """ name="T_tmp" filename=s_lookupMolt
      endif
    elseif (Tolower(s_typeFrom) == "cid") then
      if (s_typeTo == "") s_typeTo = "smi"
      s_col = "cid"
      s_res = s_typeTo
      ID_col = Iarray(S_id)
      if (s_res == "syn") then
        query molcart """
           select min(t.id),t.cid,t.syn from pubchem_cid2syn as t
           where cid in :ID_col
           group by cid
        """ name="T_tmp" filename=s_lookupMolt
      else
        query molcart """
           select t.cid, t.smi from
               pubchem_lookup as t
               where t.cid in :ID_col
        """ name="T_tmp" filename=s_lookupMolt
      endif
    elseif (Tolower(s_typeFrom) == "syn") then
      if (s_typeTo == "") s_typeTo = "smi"
      s_col = "syn"
      s_res = s_typeTo
      ID_col = Tolower(Sarray(S_id))
      query molcart """
         select tt.syn, t.cid, t.smi from
             pubchem_cid2syn as tt left join pubchem_lookup as t on (t.cid = tt.cid)
             where tt.syn in :ID_col
      """ name="T_tmp" filename=s_lookupMolt
      group T_tmp.syn T_tmp.cid "min,cid" all "refmin"  name="T_tmp"
    elseif (Tolower(s_typeFrom) == "smi") then
      if (s_typeTo == "") s_typeTo = "cid"
      s_col = "smi"
      s_res = s_typeTo
      ID_col = Sarray(S_id)
      ch = Chemical( S_id simple )
      delete hydrogen ch all
      modify ch delete charge
      ID_col = Smiles( ch unique )
      if (s_res == "cid") then
        query molcart """
           select t.cid, t.smi from
               pubchem_lookup as t
               where t.smi in :ID_col
        """ name="T_tmp" filename=s_lookupMolt
      group T_tmp.smi T_tmp.cid "min,cid"  name="T_tmp"
      elseif (s_res == "syn") then
        query molcart """
           select min(tt.id),tt.syn,t.smi
             from pubchem_lookup as t left join pubchem_cid2syn as tt on (t.cid = tt.cid)
               where t.smi in :ID_col
               group by tt.cid
        """ name="T_tmp" filename=s_lookupMolt
      elseif (s_res == "sid") then
        query molcart """
           select min(tt.sid) as sid,t.smi
             from pubchem_lookup as t left join pubchem_cid2sid as tt on (t.cid = tt.cid)
               where t.smi in :ID_col and tt.rel=1
               group by t.smi
        """ name="T_tmp" filename=s_lookupMolt
      endif
    else
      return error " Error> unknown ID type " + s_typeFrom
    endif
    group table T_id ID_col "ID"
    join T_id.ID T_tmp.$s_col left name="T_res"
    return T_res.$s_res
  else
    params = Collection()
    params["format"] = "json"
    params["out_type"] = s_typeFrom
    params["typeFrom"] = s_typeFrom
    params["typeTo"  ] = s_typeTo
    i_step = 1024*8
    s_outColumn = "Sarray"
    if (s_typeTo == "cid" | s_typeTo == "sid") s_outColumn = "Iarray"
    result = $s_outColumn (Nof(S_id))
    N = Max(Nof(S_id) / i_step,1)
    print bar "Fetching result" N l_info=yes
    for i=1,Nof(S_id),i_step
      i_to = Min( i+i_step-1, Nof(S_id) )
      params["input"] = Sum(S_id[i:i_to],"\t")
      read json "http://mars.molsoft.com/cgi-bin/pubchemlookup2.cgi " + String(params html ) name="js"
      result[i:i_to] = $s_outColumn ( js["result"] )
      print bar N l_info=yes
    endfor
    print bar "End\n" l_info=yes
    return result
  endif
endfunction

macro setBondType i_type as_1 as_2
  l_commands = l_info = l_warn = no
  hasHydrogen = Nof( Mol( as_1 ) & a_*.//h* ) > 0

  if (hasHydrogen) delete (Next( as_1 bond ) | Next( as_2 bond )) & a_*.//h*
  if (i_type == 0) then
    delete bond i_type as_1 as_2
  else
    set bond type i_type as_1 as_2
  endif
  if (hasHydrogen) build hydrogen as_1 | as_2
endmacro

macro convertPepToHet ms_ l_reverse
  l_commands = l_info = l_warn = no

  ms_ = Mol(ms_)[1]
  if (!l_reverse) then
    if ( Mol(Obj(ms_)) == Mol(ms_) ) then
      read mol Chemical( ms_ exact hydrogen ) name=Name(Obj(ms_))[1] delete
    else
      s_name = Name( ms_ )[1]
      s_obj = Sum(Name(Obj( ms_ )))
      set field Mol( Obj( ms_ )) number=1 Rarray(Count(Nof(Mol( Obj( ms_ ))),1,-1))

      read mol Chemical( ms_ exact hydrogen ) name="tmphetmol" delete
      rename a_1 s_name
      r_ord = Field( Mol( ms_ ) 1 )[1]
      delete Mol( ms_ )
      set field a_1 number=1 Real(r_ord)
      move a_ a_$s_obj.
      sort Mol( a_$s_obj. ) field=1
    endif
  else
    assign residue ms_
  endif

endmacro

macro replaceBy1Het auto as_ s_name_comment ("")
HELP = """
  take a selection from an uncoverted PDB-file and replace it by a single HET molecule.
May be a useful first step for further ligand-editing.
  Example:
   read pdb '2mc0'
   replaceBy1Het a_2,3  "nhep nosiheptide"
"""
# similar to previous macro. need to memorize cov. attachments to the ! as_  and restore.
   if(Nof(Obj(as_))!=1 ) return error " Error> empty selection"
   if(Type(Obj(as_), 2)=="ICM") return " Info> Can not merge in ICM Object. Strip it to 'Model'. Nothing to do"
   snam = Name(Mol(as_ ))[1]; os1 = Obj(as_); scom = Namex(Mol(as_ ))[1];
   delete a_TMPmth.
   read mol Chemical( as_ exact hydrogen object ) name="TMPmth"
   if(s_name_comment!="") then
     snam = Trim(Name(Field( s_name_comment, 1 ),simple),all)
     ixcom= Index(s_name_comment,"[ |\/,;]",regexp)
     if(ixcom>0) scom = Trim(s_name_comment[ixcom:$],all)
     if(snam=="") snam="lig"
   endif
   rename a_TMPmth.1 snam
   set comment a_TMPmth.1 scom
   if( Nof(a_TMPmth.)==1) then
     delete Atom( as_  )
     move a_TMPmth. os1
   endif
   printf " Info> selection replaced by one HET molecule '%s'\n",snam
   l_info=no
endmacro


macro buildGlycan as_attach s_type ("MAN9") l_optimize (yes) l_display (yes)
  LIBRARY.res = {"icmff"}
  set term "bb"
  dielConst = 2.
  s_glseq = "ml peptide\n"
  if( Name(Res(as_attach))[1] == "asn")then
   if(s_type == "NAG" ) then
    s_glseq+= "se asn\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 bnag\n"
    s_glseq+= "end\n"
   elseif(s_type == "NAGNAG" ) then
    s_glseq+= "se asn\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 bnag bnag\n"
    s_glseq+= "end\n"
   elseif(s_type == "NAGNAGMAN" ) then
    s_glseq+= "se asn\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 bnag bnag bman\n"
    s_glseq+= "end\n"
   elseif(s_type == "NAGNAGMAN4" ) then
    s_glseq+= "se asn\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 bnag bnag bman aman@o3 aman@o2 aman@o2\n"
    s_glseq+= "end\n"
   elseif(s_type == "NAGNAGMAN4MAN" ) then
    s_glseq+= "se asn\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 bnag bnag bman aman@o3 aman@o2 aman@o2\n"
    s_glseq+= "ml s1a@s1/3/o6\n"
    s_glseq+= "se 1 aman\n"
    s_glseq+= "end\n"
   elseif(s_type == "MAN9" ) then
    s_glseq+= "se asn\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 bnag bnag bman aman@o6 aman@o6 aman@o2\n"
    s_glseq+= "ml s1a@s1/3/o3\n"
    s_glseq+= "se 1 aman aman@o2 aman@o2\n"
    s_glseq+= "ml s1b@s1/4/o3\n"
    s_glseq+= "se aman aman@o2\n"
    s_glseq+= "end\n"
   elseif(s_type == "MAN6" ) then
    s_glseq+= "se asn\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 bnag bnag bman aman@o6 aman@o6\n"
    s_glseq+= "ml s1a@s1/3/o3\n"
    s_glseq+= "se 1 aman aman@o2\n"
    s_glseq+= "ml s1b@s1/4/o3\n"
    s_glseq+= "se aman\n"
    s_glseq+= "end\n"
   elseif(s_type == "A2F") then
    s_glseq+= "se asn\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 bnag bnag bman aman@o6 bnag@o2 bgal asia@o6\n"
    s_glseq+= "ml s1a@s1/3/o3\n"
    s_glseq+= "se 1 aman bnag@o2 bgal asia@o6\n"
    s_glseq+= "ml s1b@s1/1/o6\n"
    s_glseq+= "se afuc\n"
    s_glseq+= "end\n"
   elseif(s_type == "NGA4") then
    s_glseq+= "se asn\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 bnag bnag bman aman@o6 bnag@o2\n"
    s_glseq+= "ml s1a@s1/3/o3\n"
    s_glseq+= "se 1 aman bnag@o2\n"
    s_glseq+= "ml s1b@s1/4/o2\n"
    s_glseq+= "se 1 bnag\n"
    s_glseq+= "ml s1c@s1a/1/o4\n"
    s_glseq+= "se 1 bnag\n"
   elseif(s_type == "NA4") then
    s_glseq+= "se asn\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 bnag bnag bman aman@o6 bnag@o2 bgal\n"
    s_glseq+= "ml s1a@s1/3/o3\n"
    s_glseq+= "se 1 aman bnag@o2 bgal\n"
    s_glseq+= "ml s1b@s1/4/o2\n"
    s_glseq+= "se 1 bnag bgal\n"
    s_glseq+= "ml s1c@s1a/1/o4\n"
    s_glseq+= "se 1 bnag bgal\n"
   else
    s_glseq+= "se asn\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 bnag bnag bman aman@o6 bnag@o2 bgal\n"
    s_glseq+= "ml s1a@s1/3/o3\n"
    s_glseq+= "se 1 aman bnag@o2 bgal\n"
    s_glseq+= "ml s1b@s1/4/o6\n"
    s_glseq+= "se bnag bgal\n"
    s_glseq+= "ml s1c@s1a/1/o4\n"
    s_glseq+= "se bnag bgal\n"
    s_glseq+= "ml s1d@s1/1/o6\n"
    s_glseq+= "se afuc\n"
    s_glseq+= "end\n"
   endif
  elseif(Name(Res(as_attach))[1]=="ser" | Name(Res(as_attach))[1]=="thr")then
    s_glseq+= "se " + Name(Res(as_attach))[1] + "\n"
    s_glseq+= "ml s1@peptide/1\n"
    s_glseq+= "se 1 " + s_type + "\n"
    s_glseq+= "end\n"
  else
   print "Error: don't know how to attach to residue " Name(Res(as_attach))[1]
   return
  endif
  cuob = a_
  build string s_glseq name="TMPGL"
#
  fix v_//acs [1]
  set vrestraint a_S/
  set conf v_S//phi,psi?,omgl 1
  set v_/bnag/omg 180.
#
  set object Obj(as_attach)
  as_gl = a_TMPGL.S
  move a_TMPGL.S Res(as_attach) & a_//nd2,og*
  delete a_TMPGL.
  if(l_optimize)then
    set terms only "vw,14,hb,el,to"
    set vrestraint Res( as_gl )
    ssearch residue mncalls=1 mcBell =0.00001  v_//phi*,psi*,omg* & as_gl
  endif
  show energy V_ vwMethod="soft"
  minimize v_//phin,P & as_gl vwMethod="soft"
  minimize v_// & as_gl vwMethod="soft"
  if(l_display)then
    display xstick as_gl | Res(as_attach)
  endif
  set object cuob
endmacro

macro normSubset s_tabname s_realColName r_mean r_std r_fract (0.1) l_normal (yes)
HELP = """
  Selects an r_fract fraction of rows from the table.
  Formal distribution it finds a random subset of rows that have the parent distribution with N(r_mean,r_std) parameters.
  For uniform distribution r_mean becomes r_from  and r_std becomes r_to .
"""
  l_commands = no
  l_info = no
  if( Type( $s_tabname.$s_realColName ) != "rarray" ) return error " Warning> no real key-column if found. Nothing to do"
  group table T $s_tabname.$s_realColName + 0. "key" Count(Nof( $s_tabname )) "ix" Iarray(Nof( $s_tabname )) "ic"
  sort T.key
  n = Integer(Nof(T)*r_fract)
  if(l_normal)then
    for i = 1,n
      R = ( T.ic == 0 ) .key
      j = Index( R, Random(1, r_mean, r_std, "gauss" )[1])
      T.ic[j] = 1
    endfor
    c0=r_mean
    s0=r_std
    q0=3.0
    s_res = "norm_" + s_tabname
  else
    for i = 1,n
      R = ( T.ic == 0 ) .key
      j = Index( R, Random(r_mean r_std))
      T.ic[j] = 1
    endfor
    c0=(r_std+r_mean)*0.5
    s0=(r_std-r_mean)*Sqrt(1./12)
    q0=1.8
    s_res = "unif_"  + s_tabname
  endif
  $s_res = $s_tabname [ ( T.ic == 1 ) .ix ]
  c  = Mean( $s_res.$s_realColName )
  d  = $s_res.$s_realColName - c
  s  = Sqrt(Mean( d*d ))
  print "Subset of" n " entries from" Nof(T)
  print "Mean     =" c  " expect=" c0
  print "St.Dev.  =" s " expect=" s0
  print "Skewness =" Mean(d*d*d)/(s*s*s) " expect= 0."
  print "Kurtosis =" Mean(d*d*d*d)/(s*s*s*s) " expect=" q0
  keep $s_res
endmacro

function ArrayStats( R )
  c = Collection()
  if(Nof(R)<2) return c
  c["mean" ] = Mean(R)
  c["median" ] = Median(R)
  c["sigma"] = Rmsd(R)
  c["A"]     = -c["mean"]
  c["B"]     = 1./(c["sigma"] + 1.e-18)
  return c
endfunction

function Table2collection( T_tab )
  c = Collection()
# add the header part
  s_out = "columns"  # name of inner array
  c[ s_out ] = Array()
  c["header"] = Collection( T_tab header )
  for i=1,Nof( T_tab )
    c[ s_out ,i] = Collection( T_tab[i] )
  endfor
  return c
endfunction

# NOT USED ???
# function ChemicalID( T_tab )
#   l_commands = yes
#   l_info = yes
#   X = T_tab.mol
# # allow multiple molecules and salts, do not standardize C(=O)O-  etc.
#   delete hydrogen X
#   modify X delete query
#   return Sarray( Smiles( X unique cistrans )  32 hash)
# endfunction

macro genAltChargeStates T_chem I_idx r_pH (7.) r_delta (1.)
  s_t = "qStates_" + Name( T_chem table )
  for i = 1,Nof( I_idx )
    read mol input = String( T_chem.mol[I_idx[i]] ) l_neutralAcids=yes
    build hydrogen
    group table "CHARGEABLE" Count(Nof( a_//!vt*,h* )) "IX" Rarray(Predict( Chemical( a_ ) MolpKaBase )) "B"  Rarray(Predict( Chemical( a_ ) MolpKaAcid)) "A"
    delete CHARGEABLE.A == 0. & CHARGEABLE.B == 0.
    set charge formal auto a_ r_pH
    s_t = "qStates_" + Name( a_ )[1]
    if(i==1) group table "qStates" Chemical( a_ ) "mol"
    if(i!=1) add qStates 0
    if(i!=1) qStates.mol [Nof(qStates)] = Chemical( a_ )
    for ic = -1,1,2
      for ia = 1, Nof(CHARGEABLE)
        dE = Rarray(Nof( a_//!vt*,h* ))
        dE[CHARGEABLE.IX[ia]] = ic*(0.6*2.3)*r_delta
        set field a_//* 0.
        set area a_//* 0.
        set field a_//!vt*,h* dE
        set charge formal auto field a_ r_pH
        add qStates 0
        qStates.mol [Nof(qStates)] = Chemical( a_ )
      endfor
    endfor
    delete CHARGEABLE
    delete a_
  endfor
  group qStates.mol all "first" name = s_t
  keep $s_t
endmacro

function TabUniqueRows( T )
  add column T Sarray(Nof(T)) name="TMPHASH"
  for i=1,Nof(T)
    T.TMPHASH[i] = String(String(Collection(T[i] )) hash)
  endfor
  group T.TMPHASH all "first"  name="TUNIQROWS"
  delete TUNIQROWS.TMPHASH
  return TUNIQROWS
endfunction

macro buildwiki s_com
  l_info=no; l_warn =no
  read string name='s' "http://en.wikipedia.org/w/api.php?action=query&rvprop=content&prop=revisions&format=xml&titles="+s_com
  sp=Split(s, '|', exact)
  smile = String(Replace(sp~ '*[sS][mM][iI][lL][eE][sS]*=*', "*[sS][mM][iI][lL][eE][sS]*= ",""))
  if(smile=="") return " Error_buildwiki> query not found"
  build smiles smile name=s_com
  convert2Dto3D a_ yes yes yes yes
  for i=1,4
    minimize cartesian a_
  endfor
  display only xstick a_ center
endmacro

macro findPharmacophore as_pharm s_file l_group (no) r_maxRmsd (0.5) i_maxHits (2000) auto
  l_commands = l_info = no
  if Extension(s_file) == ".molt" then

    molt_info = Info( s_file filename )

    if (!molt_info["result"]) return error " Error> file " + s_file + " not found"

    if (!molt_info["conf"]) return error " Error> file " + s_file + " doesn't contain 3D conformations"

    connect molcart filename=s_file
    if (molt_info["ride"]) then
      superimpose pharmacophore molcart Chemical( as_pharm exact object ) name="ph4hits" number=i_maxHits  limit=r_maxRmsd nProc=0 l_info=yes
    else
      s_resTable = Name(s_file) + "_hits"
      delete $s_resTable l_warn=no
      find molcart pharmacophore as_pharm table=Name(molcart table Name(s_file))[1] name=s_resTable (!l_group? : group) r_maxRmsd number=i_maxHits l_info=yes
    endif
    connect molcart off
    keep table global
  elseif  Extension(s_file) == ".sdf" then
    s_resTable = Name(s_file) + "_hits"
    delete $s_resTable l_warn=no
    nProc = Max(Nof(fork)/2,1)
    while (yes)
      read table mol keep s_file limit=10240 name="tmp_ph4"
      if (l_out) break
      delete tres l_warn=no
      find pharmacophore as_pharm tmp_ph4 name="tres" r_maxRmsd
      if (Nof(tres)>0) add $s_resTable tres
    endwhile
    if (l_group) group $s_resTable.mol $s_resTable.rmsd "min,rmsd"  all "refmin"  name=s_resTable
    set property display $s_resTable
    keep table global
  else
    return error "Unrecognized file extension " + Extension(s_file)
  endif
endmacro

macro calcElectroProfile os_ os_ax
# makes table EP_objname. needs ICM object source and axis Sampling points. some bias for huge connexin cx objects.
  l_commands = yes
  set object Obj( os_ ) [1]
  stabname = "EP_" + Name(a_)[1]
  as_out = os_ax & a_*.//c*
  if(Type( a_ 2 )!= "ICM") return error " Error> can not calculate potential from an unconverted source object"
  delete field as_out name="e"
  TOOLS.rebelPatchSize = 0.5    # experiment
  electroMethod = "boundary element"
  delete boundary
  show energy "el"
#  delete ATOMCHRS l_warn = no
#  add column ATOMCHRS Name( a_//!vt* full) Field( a_//!vt* )  Charge( a_//!vt*) Field( a_//!vt* )-Charge( a_//!vt*)
#  show skin area a_ a_ ; RSK = Area(a_//!vt*)
#  show surface area a_ a_ ; RSF = Area(a_//!vt*)
#  add column ATOMCHRS RSK RSF name="skinarea"//"sfarea"
#
  make boundary
  set field name="e" as_out Potential(as_out a_ )

  n = Nof(as_out)
  delete $stabname l_warn = no
  add column $stabname Name(as_out full) Field(as_out "e") Xyz( as_out )[?,3] Count(n) name="probe"//"EP"//"Z"//"i"
  keep $stabname
#  keep  ATOMCHRS
endmacro

macro calc_short_distance_table auto as_  r_max_dist (0.9)
  l_info = no
  set object Obj( as_ ) [1]
  make distance a_//!vt* & as_ a_//!vt* & as_ r_max_dist name="CLASH_"+Name(a_)[1]
  if( i_out > 0 ) then
    delete CLASHES l_warn = yes
    CLASHES = Table( $s_out distance )
    sort CLASHES.dist
    set format CLASHES.dist color="rainbow='#8888FF/#FF8888/#FFFFFF,0.:4.,pinwheel'"
    delete CLASHES.label CLASHES.color
    keep CLASHES
  else
    print " No distances below threshold detected"
  endif
endmacro

macro make_axis_atoms auto i_fr (0) i_to (20) i_ax (3)
  n = i_to-i_fr+1
  if(i_ax>=1 & i_ax <=3) then
    objname = "XYZ"[i_ax]
    delete a_$objname.
    build smiles String("C",n) name=objname
    strip a_ virtual
    delete a_//h*
#
    mxyz = Matrix(n,3) # x,y,z matrix initiallized
    for i=1,n
      mxyz[i,i_ax]= Real(i_fr + i) - 1.
    endfor
#
    set a_// mxyz  # assign coordinates
  endif
endmacro

macro make_ssbonds_by_distance auto as_ ( a_ ) r_max_dist (2.4)
  l_info=no
  set object Obj( as_ )[1]
  if(Type( a_ 2)!= "ICM") return error " Error> wrong object Hint: convert the object"
  make distance r_max_dist as_ & a_A/cys/sg as_ & a_A/cys/sg name="temp_distss"
  if(i_out==0) return " No proximal cys/sg found "
  tempdistss = Table(temp_distss distance)
  for i=1,Nof(tempdistss)
    make disulfide bond $tempdistss.atom1[i] $tempdistss.atom2[i]
  endfor
  minimize v_/cyss/x* & Res( as_ )
endmacro

macro diffPocketShape as_lig1 as_lig2 l_super (yes) s_tag ("")
#
  if ( s_tag=="" | s_tag=="ligand" ) then
    as_site1 = Sphere( as_lig1 & a_.//!h* a_.A & Obj( as_lig1 ) & ! as_lig1 7.5 )
    as_site2 = Sphere( as_lig2 & a_.//!h* a_.A & Obj( as_lig2 ) & ! as_lig2 7.5 )
  elseif s_tag=="exact" then
    as_site1 = as_lig1
    as_site2 = as_lig2
  else
    as_site1 = Select( Atom(as_lig1) s_tag )
    as_site2 = Select( Atom(as_lig2) s_tag )
  endif
  if Nof( as_site1 ) * Nof( as_site2 ) == 0  return error " One or both selections are empty "
#
  if(l_super)then
    siteSuperAPF as_site1 as_site2 "exact"
  endif
#
  R_box = Box( as_site1 | as_site2 3.)
  make map potential "gc" simple Mol(as_site1) & R_box R_box
  m_vw1 = Trim( m_gc 0. 1. )
  make map potential "gc" simple Mol(as_site2) & R_box R_box
  m_vw2 = Trim( m_gc 0. 1. )
  m_diff = m_vw1 - m_vw2
  for i = 1,10
    m_diff = Smooth( m_diff )
  endfor
  s_solid = "solid"
  make grob $s_solid m_diff exact -0.5 "g_diffBnotA"
  make grob $s_solid m_diff exact  0.5 "g_diffAnotB"
  make grob  m_vw1 + m_vw2 exact 1.5 "g_diffAandB"
  make grob  m_vw1 + m_vw2 exact 0.5 "g_diffAorB"
  if(s_solid == "solid") s_solid = "solid smooth transparent"
  display g_diffAnotB $s_solid reverse magenta
  color ribbon Obj( as_site1 ) magenta
  display g_diffBnotA $s_solid yellow
  color ribbon Obj( as_site2 ) yellow
  display g_diffAandB green
  keep g_diffAnotB g_diffBnotA g_diffAandB g_diffAorB
endmacro

macro symAxis os_in ( a_ ) i_nChain (1) l_display (yes) l_align (yes)
  os_in = Obj(os_in)
  if(Nof(os_in)!=1 | Nof(Mol(os_in))<=1) return error " Error> expecting single object selection"
  copy os_in "TMPOBJ" strip
  nA = Nof( a_TMPOBJ.A )
  for i = 1 i_nChain
    move a_TMPOBJ.A [1] a_TMPOBJ.A [nA]
  endfor
  if( l_align)then
    rms = Rmsd( a_.A & os_in a_TMPOBJ.A align)
  else
    rms = Rmsd( a_.A & os_in a_TMPOBJ.A )
  endif
  M_trans = Matrix(R_out//0.//0.//0.//1. 4)
  M_rot =  M_trans [1:3,1:3]
  if(l_info) print "Self-RMSD= ", rms, " for " i_out " atoms"
  delete a_TMPOBJ.
  A = Eigen(M_rot + Transpose(M_rot))[?,1]
  A = A/Length(A)
  B = M_trans [1:3,4]
  C = Rot(A 90.)*B
  if(Sum(B*M_rot*C)>0) C = Rot(A,-90.)*B
  alpha = Acos(Trim(Sum(B*M_rot*B)/Sum(B*B) ,-1. 1.))
  if(l_info) print "Fold= " 360./alpha
  R_point = 0.5*(B + (1./Tan(alpha/2 ))*C)
  if(l_display)then
    GROB.arrowRadius = 0.5
    amin = Min( Xyz(os_in)*A)
    amax = Max( Xyz(os_in)*A)
    s_gname = "axis_" + Name(os_in)[1]
    $s_gname = Grob( "ARROW" (R_point + amin*A) // (R_point + amax*A) )
    display $s_gname  white
    keep $s_gname
  endif
  R_axis = A
  R_out = rms // alpha
  if(l_info) print " Axis unit vector and point kept in R_axis R_point"
  keep R_axis R_point R_out
endmacro

macro selchain auto os_ ( a_ ) s_keep ("")
  os_ = Obj( os_ ) [1]
  s_keep = Name(Trim(s_keep,all),simple)
  if(s_keep!="") then
    a= (Split(s_keep,"")!="_")
    sch = Sum(Sarray(Nof(a),"C") + a, ",")
  else
    nbio = Nof(os_ "bio")  # just for information, the first chain is picked.
    if(nbio>0) print " Biomolecule chains:",Sum(Name( Select( os_ "bio" 1) & a_*.!W  full ),"|")
    sch = Name( Mol( os_ ) )[1]; sch = sch==" "?"_":sch
    sch = "C"+sch;
  endif
  sch = (sch=="")?"C_":sch
  show sch
  as_graph = os_ & a_*.$sch
  l_info = no
endmacro

macro compareSDFiles s_file1 s_file2 s_resultFile s_overlapType ("A")
HELP="""
  s_overlapType :
    A  : returns entries that are in file1.sdf but not in file2.sdf
    B  : returns entries that are in file2.sdf but not in file1.sdf
    AB : returns overlap (show entries from file1.sdf)
    BA : returns overlap (show entries from file2.sdf)
"""
  l_info = l_commands = no

  if (s_overlapType != "A" & s_overlapType != "B" & s_overlapType != "AB" & s_overlapType != "BA") return error HELP

  files = s_file1 // s_file2
  #
  S_smi1 = Sarray()
  while yes
    read table mol files[1] keep name="t" limit=1024
    if (l_out) break
    S_smi1 //= Smiles(t.mol unique)
  endwhile
  #
  S_smi2 = Sarray()
  while yes
    read table mol files[2] keep name="t" limit=1024
    if (l_out) break
    S_smi2 //= Smiles(t.mol unique)
  endwhile
  #
  cc = Index( S_smi1, S_smi2 compare )
  #
  idx = Sort(cc[s_overlapType])
  i_mainFile = (s_overlapType == "A" | s_overlapType == "AB") ? 1 : 2
  #
  if (s_resultFile != "-") delete system s_resultFile l_warn = no
  #
  i_ofs = 1
  n = 0
  while yes
    read table mol files[i_mainFile] keep name="t" limit=1024*10
    if (l_out) break
    idx2 = Count(i_ofs,i_ofs+Nof(t)-1)
    tt = t[Index(idx2,idx,compare)["AB"]]
    if (Nof(tt) != 0) then
      if (s_resultFile == "-") then
        write binary frame tt
      else
        write table mol append tt s_resultFile
      endif
    endif
    n += Nof(tt)
    i_ofs += Nof(t)
  endwhile
  #
  if (s_resultFile != "-") printf " Info> %d entries saved into %s\n" n, s_resultFile
endmacro

macro readModelPanel l_updatefile (no) l_loadcustompanel (no) s_panelname ("") auto
  l_commands = l_info = l_warn= no
  s_defaultCustomPanel = s_userDir+"models/CustomPanel.icb"
  keep s_defaultCustomPanel
  S_modelpanel = {"AllTargets","ApprovedDrugTargets","NeuralNet"}
  S_modelpanel2 = {"All_Models_kcc","All_Models_dfa","All_Models_dfz","All_Models_dpc","ADMET_properties"}
  S_modelsDir = Split(TOOLS.modelsDir ";")
  for i_modelsDir = 1, Nof(S_modelsDir)
    if (!Exist(S_modelsDir[i_modelsDir])) make directory S_modelsDir[i_modelsDir]
  endfor
  read binary s_icmhome+"models/catkcc.icb";s_cursor = catkcc.toolsPanel;delete catkcc
 if (s_panelname=="") then
  delete catkcc catncc cateca catdfz catdfa catdpc catmcp l_warn = no
  if (l_updatefile) then
    read binary s_icmhome+"models/catkcc.icb"; read binary s_icmhome+"models/catncc.icb"; read binary s_icmhome+"models/cateca.icb"; read binary s_icmhome+"models/catdfz.icb"; read binary s_icmhome+"models/catdfa.icb"; read binary s_icmhome+"models/catdpc.icb"; read binary s_icmhome+"models/catmcp.icb"
  else
    if Exist(s_userDir+"inx/catkcc.icb") then;read binary s_userDir+"inx/catkcc.icb";else;read binary s_icmhome + "models/catkcc.icb";endif
    if Exist(s_userDir+"inx/catncc.icb") then;read binary s_userDir+"inx/catncc.icb";else;read binary s_icmhome + "models/catncc.icb";endif
#    if Exist(s_userDir+"inx/cateca.icb") then;read binary s_userDir+"inx/cateca.icb";else;read binary s_icmhome + "models/cateca.icb";endif
    if Exist(s_userDir+"inx/catdfz.icb") then;read binary s_userDir+"inx/catdfz.icb";else;read binary s_icmhome + "models/catdfz.icb";endif
    if Exist(s_userDir+"inx/catdfa.icb") then;read binary s_userDir+"inx/catdfa.icb";else;read binary s_icmhome + "models/catdfa.icb";endif
    if Exist(s_userDir+"inx/catdpc.icb") then;read binary s_userDir+"inx/catdpc.icb";else;read binary s_icmhome + "models/catdpc.icb";endif
    if Exist(s_userDir+"inx/catmcp.icb") then;read binary s_userDir+"inx/catmcp.icb";else;read binary s_icmhome + "models/catmcp.icb";endif
  endif
#  if (l_updatefile) then; delete catkcc[1:$]; delete catncc[1:$]; delete cateca[1:$]; delete catdfz[1:$];  delete catdfa[1:$]; delete catdpc[1:$]; delete catmcp[1:$]; endif

#  for i=1,Nof(catkcc)
#    set label catkcc index=i Exist( s_icmhome + "models/" + catkcc.model[i] + ".icb") ? 3:1
#  endfor
#  for i=1,Nof(catdfz)
#    set label catdfz index=i Exist( s_icmhome + "models/" + catdfz.model[i] + ".icb") ? 3:1
#  endfor
#  for i=1,Nof(catdfa)
#    set label catdfa index=i Exist( s_icmhome + "models/" + catdfa.model[i] + ".icb") ? 3:1
#  endfor
#  set property catkcc catdfz catdfa write off
  delete ADMET_properties All_Models_kcc All_Models_ncc All_Models_eca All_Models_dfa All_Models_dpc All_Models_dfz l_warn=no
#  delete indexkcc indexdfz indexdfa indexmcp l_warn = no
  S_modelpref = {"kcc","ncc","dfz","dfa","dpc","mcp"}
  S_modelloc = Sarray(1 s_icmhome+"models/")
  S_modelloc //= Split(TOOLS.modelsDir ";")	#s_icmhome+"models/" has to be the first one
  for i_pref = 1, Nof(S_modelpref)
    s_pref = S_modelpref[i_pref]
    s_catsource = "cat"+s_pref
    rename $s_catsource "T_tmpfile"
     if (Type(T_tmpfile.location)=="unknown") add column T_tmpfile Sarray(Nof(T_tmpfile) "") name="location"
#    if (Type(T_tmpfile.location)=="unknown") add column T_tmpfile Sarray(Nof(T_tmpfile) s_icmhome+"models/")+T_tmpfile.model+Sarray(Nof(T_tmpfile) ".icb") name="location"
    for i = 1, Nof(T_tmpfile)
      if (i>Nof(T_tmpfile)) continue
      if Exist(s_icmhome+"models/"+T_tmpfile.model[i]+".icb") then
        T_tmpfile.location[i]=s_icmhome+"models/"+T_tmpfile.model[i]+".icb"
      else
        l_continue = yes
        for i_modelsDir = 1, Nof(S_modelsDir)
          if Exist(S_modelsDir[i_modelsDir]+T_tmpfile.model[i]+".icb") then
            T_tmpfile.location[i]=S_modelsDir[i_modelsDir]+T_tmpfile.model[i]+".icb"
            l_continue = no
            break
          endif
        endfor
        if (l_continue) then
          delete T_tmpfile[i]
          i=i-1
        endif
      endif
    endfor
    for i_loc = 1, Nof(S_modelloc)
      S_tmplist = Replace(Sarray( S_modelloc[i_loc]+s_pref+"*.icb" directory ) "\\" "/")
      N=Nof(S_tmplist); print bar N " Indexing " + s_pref + " models at " + S_modelloc[i_loc] l_info=yes
      for i = 1, Nof(S_tmplist)
        if Index(T_tmpfile.location S_tmplist[i])!=0 continue
        if Index(T_tmpfile.model Name(S_tmplist[i]))!=0 continue
        s_mod = Name(S_tmplist[i])
        l_loaded = no
        if (Type($s_mod)!="unknown") then
          l_loaded = yes
        else
          read binary S_tmplist[i]
#          s_tmplist = Name(S_tmplist[i])
#          $s_tmplist.cursor = s_cursor
        endif
        if (Type($s_mod)!="parray") then
          if (!l_loaded) delete $s_mod
          continue
        endif
        add T_tmpfile
        T_tmpfile.model[Nof(T_tmpfile)] = s_mod
        for j = 2, Nof(Name(T_tmpfile))-2
          s_col = Name(T_tmpfile)[j]
          s_field = Field(s_col 2 ".")
#          if ($s_mod[s_field] != Toreal("ND")) $s_col[Nof(T_tmpfile)] = $s_mod[s_field]
          if (Exist($s_mod s_field) & Type($s_mod[s_field])==Type($s_col[Nof(T_tmpfile)])) $s_col[Nof(T_tmpfile)] = $s_mod[s_field]
        endfor
        T_tmpfile.location[Nof(T_tmpfile)] =  S_tmplist[i]
        if !l_loaded delete $s_mod
        print bar N l_info=yes
      endfor
      print bar "End\n" l_info=yes
    endfor
    sort T_tmpfile.model
    T_tmpfile = Unique(T_tmpfile "model")
    if (Type(T_tmpfile.toolsPanel)=="unknown") then
      add header T_tmpfile "" name="toolsPanel"
      T_tmpfile.toolsPanel = T_tmpfile.cursor
      delete T_tmpfile.cursor l_warn=no
    endif
    if (T_tmpfile.toolsPanel != s_cursor) T_tmpfile.toolsPanel = s_cursor
    T_tmpfile.toolsPanel = Replace(T_tmpfile.toolsPanel "@.model" "@.location")
    if ((l_updatefile)|!Exist(s_userDir+"inx"+s_catsource+".icb")) then
      if (!Exist(s_userDir+"inx")) make directory s_userDir+"inx"
      $s_catsource = T_tmpfile
      write binary $s_catsource s_userDir+"inx/"+s_catsource+".icb" delete
      delete $s_catsource
    endif
#    set format T_tmpfile.location show off
#    s_indexfile = "index"+s_pref
#    rename T_tmpfile s_indexfile
    if (s_pref=="mcp") rename T_tmpfile "ADMET_properties"
    if (s_pref=="kcc") rename T_tmpfile "All_Models_kcc"
    if (s_pref=="ncc") rename T_tmpfile "All_Models_ncc"
#    if (s_pref=="eca") rename T_tmpfile "All_Models_eca"
    if (s_pref=="dfa") rename T_tmpfile "All_Models_dfa"
    if (s_pref=="dfz") rename T_tmpfile "All_Models_dfz"
    if (s_pref=="dpc") rename T_tmpfile "All_Models_dpc"
  endfor
#  keep global catkcc catdfz catdfa
  for i_modelsDir = 1, Nof(S_modelsDir)
    if (!Exist(S_modelsDir[i_modelsDir])) make directory S_modelsDir[i_modelsDir]
  endfor
  set property ADMET_properties All_Models_kcc All_Models_ncc All_Models_dfa All_Models_dfz All_Models_dpc field off
  keep global ADMET_properties All_Models_kcc All_Models_ncc All_Models_dfa All_Models_dfz All_Models_dpc
 endif
  if ((l_loadcustompanel)|(s_panelname!="")) then
    S_missmodel = Sarray()
    for i_modelsDir = 1, Nof(S_modelsDir)
      S_modelpanel //= Name(Sarray(S_modelsDir[i_modelsDir]+"*.icb" directory ))
    endfor
    S_modelpanel = Replace(S_modelpanel "\\" "/")
    if (s_panelname!="") S_modelpanel = Sarray(1 s_panelname)
    for i_modelpanel = 1, Nof(S_modelpanel)
      s_modelpanel = Field(S_modelpanel[i_modelpanel] 1 ".")
      if (s_modelpanel[1:3]=="kcc"|s_modelpanel[1:3]=="ncc"|s_modelpanel[1:3]=="eca"|s_modelpanel[1:3]=="dfz"|s_modelpanel[1:3]=="dfa"|s_modelpanel[1:3]=="dpc"|s_modelpanel[1:3]=="mcp"|s_modelpanel[1:3]=="kca"|s_modelpanel[1:3]=="cat"|s_modelpanel[1:7]=="summary") continue
      if (Index(S_modelpanel2 s_modelpanel)==0) then
        if (Exist(s_icmhome+"models/"+s_modelpanel+".icb")) then
          read binary s_icmhome+"models/"+s_modelpanel+".icb"
#          $s_modelpanel.cursor = s_cursor
        else
          l_continue = yes
          for i_modelsDir = 1, Nof(S_modelsDir)
            if (Exist(S_modelsDir[i_modelsDir]+s_modelpanel+".icb")) then
              read binary S_modelsDir[i_modelsDir]+s_modelpanel+".icb"
#              $s_modelpanel.cursor = s_cursor
              l_continue = no
              break
            endif
          endfor
          if (l_continue) return "Model panel not found"
        endif
      else
        if (Index(S_modelpanel2 s_modelpanel)<=4) then
          s_catfile = "cat"+s_modelpanel[$-2:$]
        else
          s_catfile = "catmcp"
        endif
        if Exist(s_userDir+"inx/"+s_catfile+".icb") then
          read binary s_userDir+"inx/"+s_catfile+".icb"
#          $s_catfile.cursor = s_cursor
        elseif Exist(s_icmhome+"models/"+s_catfile+".icb") then
          read binary s_icmhome+"models/"+s_catfile+".icb"
#          $s_catfile.cursor = s_cursor
        else
          return "Custom panel not found"
        endif
        delete $s_modelpanel l_warn=no
        rename $s_catfile s_modelpanel
      endif
      if (Type($s_modelpanel)!="table") then
        delete $s_modelpanel; continue
      endif
      rename $s_modelpanel "T_tmpfile"
      if (Type(T_tmpfile.toolsPanel)=="unknown") then
        delete T_tmpfile; continue
      endif
      if (Type(T_tmpfile.toolsPanel)=="unknown") then
        add header T_tmpfile "" name="toolsPanel"
        T_tmpfile.toolsPanel = T_tmpfile.cursor
        delete T_tmpfile.cursor l_warn=no
      endif
      if (T_tmpfile.toolsPanel != s_cursor) T_tmpfile.toolsPanel = s_cursor
      T_tmpfile.toolsPanel = Replace(T_tmpfile.toolsPanel "@.model" "@.location")
      if (Type(T_tmpfile.location)=="unknown") add column T_tmpfile Sarray(Nof(T_tmpfile) "") name="location"
      for i_mod = 1, Nof(T_tmpfile)
        if (i_mod > Nof(T_tmpfile)) break
        if (T_tmpfile.location[i_mod]!="") then
          if (Exist(T_tmpfile.location[i_mod])) continue
        endif
        if Exist(s_icmhome+"models/"+T_tmpfile.model[i_mod]+".icb") then
          T_tmpfile.location[i_mod] = s_icmhome+"models/"+T_tmpfile.model[i_mod]+".icb"
        else
          l_continue = yes
          for i_modelsDir = 1, Nof(S_modelsDir)
            if Exist(S_modelsDir[i_modelsDir]+T_tmpfile.model[i_mod]+".icb") then
              T_tmpfile.location[i_mod] = S_modelsDir[i_modelsDir]+T_tmpfile.model[i_mod]+".icb"
              l_continue = no
              break
            endif
          endfor
          if (l_continue) then
            S_missmodel //=T_tmpfile.model[i_mod]
            delete T_tmpfile[i_mod]; i_mod = i_mod-1
          endif
        endif
      endfor
      rename T_tmpfile s_modelpanel
      set property $s_modelpanel field off
      keep $s_modelpanel
      set foregound $s_modelpanel
    endfor
    if (Nof(S_missmodel)!=0) print "The following models in the custom model panels are missing, please download from Molsoft if you want to use them:\n" Sum(Unique(Sort(S_missmodel)) ",")
  endif
endmacro
#
macro msupdatetoolspanel s_tab ("") auto
  l_info = l_commands = l_warn=no
  s_tab = Trim(s_tab all)
  if (s_tab == "") return "Please specify table name"
  if (Type($s_tab)!="table") return "Name specified is not a table"
  T_tmpfile = $s_tab
  if (Type(T_tmpfile.toolsPanel)=="unknown") add header T_tmpfile "" name="toolsPanel"
  if (Type(T_tmpfile.cursor)!="unknown") delete T_tmpfile.cursor l_warn=no
  if ((Type(T_tmpfile.S_tags)=="unknown") & (Type(T_tmpfile.S_tag)=="sarray")) rename T_tmpfile.S_tag "S_tags"
  if (Type(T_tmpfile.chk)!="iarray") then
    delete T_tmpfile.chk l_warn=no
    add column T_tmpfile Iarray(Nof(T_tmpfile) 0) name="chk" index=1
    set property T_tmpfile.chk logical
  endif
  s_comment = """
Model name consists of three letter code for model type, plus the target name
Three letter code:
  dfa: Docking to Chemical Field Classifier/Activity: Use clusters of 3D alignment of ligands to predict binder/non-binder class and activity (pKd, pKi, pIC50, pEC50, etc)
  dfz: Docking to Chemical Field Z-Score: Use clusters of 3D alignment of ligands to predict Z-Score relative to random noise
  dpc: Docking to Receptor Pocket Classifier/Activity: Use 4D pocket of receptors to predict ligand pose and binder/non-binder class, and 3D alignment of ligand to predict activity (pKd, pKi, pIC50, pEC50, etc)
  kcc: Kernel Chemical Classifier/Activity: Use extended chemical fingerprint (ECFP) to predict binder/non-binder class and activity (pKd, pKi, pIC50, pEC50, etc)
  mcp: Miscellaneous Chemical Property: Use extended chemical fingerprint (ECFP) to predict ADMET properties, mostly using neural network or random forest methods
  ncc: Neural Network Chemical Classifier: Use fully connected neural network method and extended chemical fingerprint (ECFP) to predict binder/non-binder class
Target name:
  dfa/dfz/dpc/kcc: Uniprot prefix of the target, not the gene name, e.g. dpcVGFR2 not dpcKDR
  mcp: Short description of the property predicted, see NAME column for full description
  ncc: Family name of the targets included in each model
"""
  set format T_tmpfile.model comment=s_comment
  if ((Type(T_tmpfile.tags)=="unknown") & (Type(T_tmpfile.tag)=="sarray")) rename T_tmpfile.tag "tags"
  set format T_tmpfile.tags comment="; or \\n separated tags\nUse msupdatetags <s_panelname> to update the panel if user tags are added"
  if ((Type(T_tmpfile.nLigands)=="unknown") & (Type(T_tmpfile.nLigand)=="iarray")) rename T_tmpfile.nLigand "nLigands"
  if (Type(T_tmpfile.nLigands)=="iarray") set format T_tmpfile.nLigands comment="Number of training set ligands\nFor most models, number of external test set ligands is 1/3 of training set"
  if ((Type(T_tmpfile.nTargets)=="unknown") & (Type(T_tmpfile.nTarget)=="iarray")) rename T_tmpfile.nTarget "nTargets"
  if (Type(T_tmpfile.nTargets)=="iarray") then
    set format T_tmpfile.nTargets comment="For neural network type (ncc) models: the number of output predicted\nOther model types predict only one target"
    T_tmpfile.nTargets[Index(T_tmpfile.nTargets==0)] = 1
  endif
  if ((Type(T_tmpfile.nClusters)=="unknown") & (Type(T_tmpfile.nCluster)=="iarray")) rename T_tmpfile.nCluster "nClusters"
  if (Type(T_tmpfile.nClusters)=="iarray") then
    set format T_tmpfile.nClusters comment="For kcc, dfa and dfz models: the number of ligand clusters used as template in training"
    T_tmpfile.nClusters[Index(T_tmpfile.nClusters==0)] = 1
  endif

  if (Type(T_tmpfile.AUC)=="rarray") then
    set format T_tmpfile.AUC "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,50.:90.,pinwheel'"
    s_comment="""
Area under curve of the Receiver operating characteristic (ROC) plot: True positive rate vs False positive rate
Range: 0-100
Good model: 80-100
Random prediction: 50
For kcc and dpc model: performance of the classifier score in predicting binder/non-binder
For dfa model: performance of the predicted pKd in predicting binder/non-binder
For dfz model: performance of the Z-score predicting in predicting binder/non-binder
For other models: performance of the classifier
"""
    set format T_tmpfile.AUC comment=s_comment
  endif
  if (Type(T_tmpfile.pKdAUC)=="rarray") then
    set format T_tmpfile.pKdAUC "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,50.:90.,pinwheel'"
    s_comment="""
Area under curve of the Receiver operating characteristic (ROC) plot: True positive rate vs False positive rate
Range: 0-100
Good model: 80-100
Random prediction: 50
Only used for kcc and dpc model: performance of the predicted pKd in predicting binder/non-binder
"""
    set format T_tmpfile.pKdAUC comment=s_comment
    set format T_tmpfile.pKdAUC show off
  endif
  if (Type(T_tmpfile.ClassAUC)=="rarray") then
    set format T_tmpfile.ClassAUC "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,50.:90.,pinwheel'"
    s_comment="""
Area under curve of the Receiver operating characteristic (ROC) plot: True positive rate vs False positive rate
Range: 0-100
Good model: 80-100
Random prediction: 50
Only used for dfa model: performance of the classifier score in predicting binder/non-binder
"""
    set format T_tmpfile.ClassAUC comment=s_comment
    set format T_tmpfile.ClassAUC show off
  endif

  if (Type(T_tmpfile.Q2)=="rarray") then
    set format T_tmpfile.Q2 "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,0.1:0.6,pinwheel'"
    s_comment="""
Correlation Q2 of the external test set prediction vs experimental value
Range: 0-1
Good model: 0.4-1.
Random prediction: 0-0.1
Only used for regression type model
For kcc, dfa, dpc model: performance of the predicted pKd (pKi, pIC50, pEC50, etc) of the external test set
For mcp model: performance of the predicted value in regression type model
"""
    set format T_tmpfile.Q2 comment=s_comment
  endif
  if (Type(T_tmpfile.R2pkd)=="rarray") then
    set format T_tmpfile.R2pkd "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,0.1:0.6,pinwheel'"
    s_comment="""
Correlation R2 of the internal training set prediction vs experimental value
Range: 0-1
Good model: 0.4-1.
Random prediction: 0-0.1
Only used for dfa and some mcp models
For dfa model: performance of the predicted pKd (pKi, pIC50, pEC50, etc) of the internal training set
For mcp model: performance of the predicted value in regression type model of the internal training set
"""
    set format T_tmpfile.R2pkd comment=s_comment
    set format T_tmpfile.R2pkd show off
  endif

  if (Type(T_tmpfile.RMSE)=="rarray") then
    set format T_tmpfile.RMSE "%.1f" name="" color="rainbow='#DCFFDC/#FFFFDC/#FFDCDC,1.:2.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
    s_comment="""
Root Mean Square Error of the predicted value of the external test set vs experimental value
Range: 0-infinity
Good model: 0-1.
Random prediction: >2
Note that ChEMBL experimental data can have intrinsic error of around 1 Log unit!
Only used for regression type models
For kcc, dfa, dpc model: performance of the predicted pKd (pKi, pIC50, pEC50, etc) of the external test set
For mcp model: performance of the predicted value in regression type model
"""
    set format T_tmpfile.RMSE comment=s_comment
  endif
  if (Type(T_tmpfile.uniprot)!="unknown") set format T_tmpfile.uniprot show off
  if (Type(T_tmpfile.Drug_Mechanism)=="sarray") set format T_tmpfile.Drug_Mechanism "(.*?):(.*?);;<span style=\"color:#d15b0e\">\\1</span>&nbsp;<span>:\\2</span>"
# if (Type(T_tmpfile.Drug_Mechanism)=="sarray") set format T_tmpfile.Drug_Mechanism "%J"

  T_tmpfile.toolsPanel = """
# X_Chemical_Table:tab (*) [VISIBLE:(!$batjob)]
# l_Auto_pKa_Charge:char (yes)
# l_Remove_Inactives:rminact (no)
# b_Run_MolScreen_on_Selected_Models (msSettings| predictModels Name( variable $tab ) %@.model [ Index( %@.chk==1 ) ] yes no no yes yes "" $rminact $char P_mspara | set foreground $tab ) [OPTN:$tab,BEGINFRAME:Current Session]
# txt_Hints (Select models by checking the chk box and press Run<br>Output:<br> Original Table: Up to 100 target columns will be appended<br> msLigandModel table of all ligand/model activity rows will be generated)
# i_Display_Models:tagsonly (1@All|2@by_tags|3@GO_Cellular|4@GO_Process|5@GO_Function) [RDONLY]
# s_Tags:tags ($%@.S_tags) [RDONLY,VISIBLE:$tagsonly==2]
# s_GO_Cellular:gocellular ($%@.S_GOCellular) [VISIBLE:$tagsonly==3]
# s_GO_Process:goprocess ($%@.S_GOProcess) [VISIBLE:$tagsonly==4]
# s_GO_Function:gofunction ($%@.S_GOFunction) [VISIBLE:$tagsonly==5]
# b_Display_All_Rows (msfilterGO Name(variable %@)) [VISIBLE:$tagsonly==1]
# b_Display_by_tags (msfilterGO Name(variable %@) "tags" Field($tags 1 ";")) [VISIBLE:$tagsonly==2]
# b_Display_by_GO_Cellular (msfilterGO Name(variable %@) "GO_Cellular" Field($gocellular 1 ";")) [RDONLY,VISIBLE:$tagsonly==3]
# b_Display_by_GO_Process (msfilterGO Name(variable %@) "GO_Process" Field($goprocess 1 ";")) [RDONLY,VISIBLE:$tagsonly==4]
# b_Display_by_GO_Function (msfilterGO Name(variable %@) "GO_Function" Field($gofunction 1 ";")) [RDONLY,VISIBLE:$tagsonly==5]
# b_Check_Selected_Models_Performance (checkPredictionModels %@.model [ Index( %@.chk==1 )])
# b_Unpack_Selected_Models_Objects (msunpackModels %@.model [ Index( %@.chk==1 )])
# b_Predict_Potential_Covalent_Groups (predCov  Name( variable $tab ))
# b_Predict_ADMET_Properties (predmcp Name( variable $tab )) [ENDFRAME]
# l_Background_Job:bgjob (no)
# i_Number_of_Processor:nofproc (4) [VISIBLE:$bgjob,BEGINFRAME:Background Job]
# b_Submit_Background_Job (msSettings| predictModelsBG Name( variable $tab ) %@.model [ Index( %@.chk==1 ) ] $nofproc $rminact $char P_mspara) [VISIBLE:$bgjob]
# txt_Output (msLigandModel table will be loaded once background job is finished<br>Multiprocessor only effective for Linux and Mac) [VISIBLE:$bgjob,ENDFRAME]
# l_Cluster_Job:batjob (no)
# i_Input_table:tabtype (1@Loaded ICM Table|2@FILE: SDF/Indexed database/ICM Binary/Molsoft Local database|3@Molcart) [RDONLY,VISIBLE:$batjob,BEGINFRAME:Cluster Job]
# X_Chemical_Table_Input:tab1 (*) [VISIBLE:(($batjob)&($tabtype==1))]
# f_Chemical_File_Input|*.sdf;*.inx;*.icb;*.molt:tab2 ("") [VISIBLE:(($batjob)&($tabtype==2))]
# s_Molcart_server:tab3a ("mars") [VISIBLE:(($batjob)&($tabtype==3))]
# s_User_Name:tab3b ("molcart") [VISIBLE:(($batjob)&($tabtype==3))]
# s_Password:tab3c () [PASSWORD,VISIBLE:(($batjob)&($tabtype==3))]
# s_Database:tab3d ("screenpub") [VISIBLE:(($batjob)&($tabtype==3))]
# s_Molcart_table:tab3e ("") [VISIBLE:(($batjob)&($tabtype==3))]
# i_Beginning_Compound:stlig (0) [VISIBLE:$batjob]
# i_Ending_Compound:edlig (0) [VISIBLE:$batjob]
# i_Nof_Ligands_per_Job:noflig (1000) [VISIBLE:$batjob]
# txt_Ligand_Hint (To screen the whole table, choose 0 as starting compound<br>To screen a single molecule, choose 0 as ending compound) [VISIBLE:$batjob]
# i_Submit_via:mode (2@qsub or sbatch to cluster|3@ssh to cluster|4@ssh to remote cluster|1@Local Batch|0@Testing Directories) [RDONLY,VISIBLE:$batjob]
# i_Queue_system:queuemode (1@SGE|2@SLURM) [RDONLY,VISIBLE:$batjob]
# d_Work_Folder:folder [VISIBLE:$batjob,RESIZE]
# s_qsub_or_sbatch_argument:qsub ("-q all.q") [VISIBLE:(($batjob)&($mode>=2))]
# s_ssh_command:ssh ("ssh user at cluster") [VISIBLE:(($batjob)&($mode>=3))]
# s_Remote_Directory:remotefolder ("") [VISIBLE:(($batjob)&($mode>=4))]
# s_Remote_ICM_Directory:remoteicmfolder ("") [VISIBLE:(($batjob)&($mode>=4))]
# s_Remote_Model_Directory:remotemodfolder ("") [VISIBLE:(($batjob)&($mode>=4))]
# l_Short_CSV_Output_Only:shortoutput (no) [VISIBLE:$batjob]
# b_Submit_Job_to_Cluster (msSettings| predictModelsCluster Name( variable $tab1 )  %@.model [ Index( %@.chk==1 ) ] $folder $ssh $qsub $remotefolder $remoteicmfolder $remotemodfolder $mode $rminact $char $noflig $shortoutput P_mspara $stlig $edlig $queuemode) [VISIBLE:(($batjob)&($tabtype==1))]
# b_Submit_Job_to_Cluster (msSettings| predictModelsCluster $tab2   %@.model [ Index( %@.chk==1 ) ] $folder $ssh $qsub $remotefolder $remoteicmfolder $remotemodfolder $mode $rminact $char $noflig $shortoutput P_mspara $stlig $edlig $queuemode) [VISIBLE:(($batjob)&($tabtype==2))]
# b_Submit_Job_to_Cluster (msSettings| predictModelsCluster $tab3a +" "+ $tab3b +" "+ $tab3c +" "+ $tab3d +" "+ $tab3e %@.model [ Index( %@.chk==1 ) ] $folder $ssh $qsub $remotefolder $remoteicmfolder $remotemodfolder $mode $rminact $char $noflig $shortoutput P_mspara $stlig $edlig $queuemode) [VISIBLE:(($batjob)&($tabtype==3))]
# txt_Hint (Remote Directory etc only needed<br>if local files are not mounted on cluster<br>Use ssh key to enable passwordless ssh & rsync) [VISIBLE:(($batjob)&($mode>=4)),ENDFRAME]
# txt_Output (Subdirectories will be created<br>msLigandModel tables will be generated in subdirectories) [VISIBLE:$batjob]
# b_Retrieve_Results_as_MolResult_index_Table (predictModelsResult $folder $ssh $remotefolder $stlig $edlig) [VISIBLE:$batjob]
# txt_Info (MolResult can be used to extract Ligand/Model Pairwise tables<br>Might take a while) [VISIBLE:$batjob]
# S_Sort_by_Columns:Scol ({"MolScore","MolpKd"}) [VISIBLE:$batjob]
# b_Retrieve_All_Results_as_Plain_Text_Table (predictModelsHit $folder $ssh $remotefolder $ihit $Scol yes $stlig $edlig) [VISIBLE:$batjob]
# i_Max_Nof_Hits:ihit (1000) [VISIBLE:$batjob]
# b_Retrieve_Top_Hits_as_Interactive_Hitlist_Table (predictModelsHit $folder $ssh $remotefolder $ihit $Scol no $stlig $edlig) [VISIBLE:$batjob]
# ff_Output_Panel_Location:panelloc ($s_defaultCustomPanel) [BEGINFRAME:Make Custom Panel]
# b_Make_Custom_Panel_from_Selected_Models (if Type(%@.location)!="unknown" then; makeModelPanel $panelloc "" "" Name(variable %@) ;endif) [ENDFRAME]
# b_Add/Update_GO_Terms (msaddGO Name(variable %@)) [ONCHANGE:REFRESH]
# b_Update_Tags (msupdatetags  Name(variable %@)) [ONCHANGE:REFRESH]
# txt_Hints (If user tags has been added to the tags column,<br>press the Update tags button and then save the selected models as a custom panel)
"""
  msaddGO "T_tmpfile"
#  if (Type(T_tmpfile.chk)!="iarray") then
#    delete T_tmpfile.chk l_warn=no
#    add column T_tmpfile Iarray(Nof(T_tmpfile) 0) name="chk" index=1
#  endif
#  set property T_tmpfile.chk logical
  delete $s_tab l_warn=no
  rename T_tmpfile s_tab
  keep $s_tab
endmacro
#
macro msupdatetags s_tab ()
  l_info = l_commands = l_warn=no
  s_tab = Trim(s_tab all)
  if (s_tab == "") return "Please specify table name"
  if (Type($s_tab)!="table") return "Name specified is not a table"
  T_tmpfile = $s_tab
  if ((Type(T_tmpfile.tags)=="unknown") & (Type(T_tmpfile.tag)=="sarray")) rename T_tmpfile.tag "tags"
  if (Type(T_tmpfile.tags)!="sarray") then
    delete T_tmpfile.tags l_warn=no
    add column T_tmpfile Sarray(Nof(T_tmpfile) "") name="tags"
  endif
  set format T_tmpfile.tags comment="; or \\n separated tags\nUse msupdatetags <s_panelname> to update the panel if user tags are added"
  T_tmpfile.tags[Index(T_tmpfile.model ~"kcc*")] = T_tmpfile.tags[Index(T_tmpfile.model ~"kcc*")] +"\nType: Kernel Chemical Classifier/pKd"
  T_tmpfile.tags[Index(T_tmpfile.model ~"ncc*")] = T_tmpfile.tags[Index(T_tmpfile.model ~"ncc*")] +"\nType: Neural Network Classifier/pKd"
  T_tmpfile.tags[Index(T_tmpfile.model ~"dfa*")] = T_tmpfile.tags[Index(T_tmpfile.model ~"dfa*")] +"\nType: Docking to Atomic Property Field Classifier/pKd"
  T_tmpfile.tags[Index(T_tmpfile.model ~"dpc*")] = T_tmpfile.tags[Index(T_tmpfile.model ~"dpc*")] +"\nType: Docking to Protein Receptor Classifier/pKd"
  T_tmpfile.tags[Index(T_tmpfile.model ~"mcp*")] = T_tmpfile.tags[Index(T_tmpfile.model ~"mcp*")] +"\nType: Miscellaneous Chemical Property"
  T_tmpfile.tags[Index(T_tmpfile.model ~"dfz*")] = T_tmpfile.tags[Index(T_tmpfile.model ~"dfz*")] +"\nType: Docking to Atomic Property Field Z-Score"
  T_tmpfile.tags[Index(T_tmpfile.model !~"dfz*")] = T_tmpfile.tags[Index(T_tmpfile.model !~"dfz*")] +"\nAllTargets"
  if (Type(T_tmpfile.Category)=="sarray") then
    read binary s_icmhome+"models/TargetUniprot.icb"
    add column T_tmpfile Replace(Replace(Replace(Replace(Replace(Replace(T_tmpfile.model "kcc" "")"ncc" "")"dfa" "")"dpc" "")"dfz" "")"mcp" "") name="tmpcol"
    delete T_join l_warn=no
    join left T_tmpfile.tmpcol TargetUniprot.Uniprot
    T_tmpfile.Category[Index(T_tmpfile.model!~"ncc*" & T_tmpfile.model!~"mcp*" & T_tmpfile.Category!~"*PROTEIN*")] = T_join.Protein_family[Index(T_tmpfile.model!~"ncc*" & T_tmpfile.model!~"mcp*" &  T_tmpfile.Category!~"*PROTEIN*")]
    delete T_tmpfile.tmpcol T_join TargetUniprot l_warn=no
    I_tmp = Index(T_tmpfile.Category ~"G-protein coupled receptor*")
    T_tmpfile.tags[I_tmp] = T_tmpfile.tags[I_tmp] +"\nFamily: G-protein coupled receptor"
    I_tmp = Index(T_tmpfile.Category ~"*[Kk]inase*")
    T_tmpfile.tags[I_tmp] = T_tmpfile.tags[I_tmp] +"\nFamily: kinase"
#    I_tmp = Index(T_tmpfile.Category ~"*[Pp]eptidase*")
#    T_tmpfile.tags[I_tmp] = T_tmpfile.tags[I_tmp] +"\nFamily: peptidase"
    I_tmp = Index(T_tmpfile.Category ~"*[Cc]ytochrome*")
    T_tmpfile.tags[I_tmp] = T_tmpfile.tags[I_tmp] +"\nFamily: cytochrome P450"
    I_tmp = Index(T_tmpfile.Category ~"*[Nn]uclear hormone receptor*")
    T_tmpfile.tags[I_tmp] = T_tmpfile.tags[I_tmp] +"\nFamily: nuclear hormone receptor"
    I_tmp = Index(T_tmpfile.Category ~"*[Cc]hannel*")
    T_tmpfile.tags[I_tmp] = T_tmpfile.tags[I_tmp] +"\nFamily: ion channel"
    I_tmp = Index(T_tmpfile.Category ~"*[Tt]ransporter*")
    T_tmpfile.tags[I_tmp] = T_tmpfile.tags[I_tmp] +"\nFamily: transporter"
    for i_entry = 1, Nof(T_tmpfile)
      S_tmp = Split(T_tmpfile.Category[i_entry] " ")
      S_tmp = S_tmp~"*ase"
      if (Nof(S_tmp)!=0) T_tmpfile.tags[i_entry] = T_tmpfile.tags[i_entry]+"\n"+Sum(Sarray(Nof(S_tmp) "Family: ")+S_tmp "\n")
    endfor
  endif
  if (Type(T_tmpfile.Drug_Mechanism)=="sarray") then
    T_tmpfile.tags[Index(T_tmpfile.Drug_Mechanism !="")] = T_tmpfile.tags[Index(T_tmpfile.Drug_Mechanism !="")] +"\nApprovedDrugTargets"
  endif
  for i_entry = 1, Nof(T_tmpfile)
    if (Trim(T_tmpfile.tags[i_entry] all)=="") then
      T_tmpfile.tags[i_entry]=""; continue
    endif
    S_tmp = Unique(Sort(Trim(Split(T_tmpfile.tags[i_entry] "[\n;]") all)!=""))
    T_tmpfile.tags[i_entry]=Sum(S_tmp "\n")
  endfor
  S_tmp = Split(Sum(T_tmpfile.tags "\n") "\n")
  group table t_tmpfile S_tmp "A"
  group t_tmpfile.A t_tmpfile.A 'count,count' name='t_tmpfile_A_freq'
  sort t_tmpfile_A_freq.A; sort reverse t_tmpfile_A_freq.count
  S_tags = t_tmpfile_A_freq.A+Sarray(Nof(t_tmpfile_A_freq) "; ")+Tostring(t_tmpfile_A_freq.count)
  delete T_tmpfile.S_tags l_warn=no
  add header T_tmpfile S_tags name="S_tags"
  delete $s_tab l_warn=no
  rename T_tmpfile s_tab
  keep $s_tab
endmacro
#
macro readModelIndication s_Indication ("") auto
  l_info = l_commands = l_warn = no
  s_Indication = Field(Trim(s_Indication all) 1 ";")
  if (s_Indication == "") return "Please specify a valid indication"
  if (Type(ChEMBLIndication)=="unknown") read binary s_icmhome+"models/ChEMBLIndication.icb"
  i_indication = Index(ChEMBLIndication.Indication s_Indication)
  if (i_indication == 0) return "Cannont find targets related to the specified indication"
  S_uniprot = Split(ChEMBLIndication.Uniprot[i_indication] "\n")
  if (Nof(S_uniprot) == 0) return "Cannont find targets related to the specified indication"
  if (Type(AllTargets)!="table") then
    USER_panels = readPredictionModels("panel",no)
    readModelPanel "AllTargets"
  endif
  I_keep = Iarray(0)
  for i_uniprot = 1, Nof(S_uniprot)
    I_keep //= Index(AllTargets.model~"[dkmn][cfp][acp]"+S_uniprot[i_uniprot])
  endfor
  I_keep = Unique(Sort(I_keep))
  s_panelname = Name(s_Indication unique)
  $s_panelname = AllTargets[I_keep]
  keep $s_panelname
endmacro
#
macro makeModelPanel s_panel ("") s_modelname ("") s_keyword ("") s_origpanel ("") auto
  l_info = no; l_warn = no
  s_origpanel = Trim(s_origpanel all)
  if ((s_origpanel=="") & (s_modelname=="") & (s_keyword=="")) return "Please either specify model name, keyword, or original panel name"
  if (s_origpanel != "") then
    if (Type($s_origpanel)!="table") return "Please specify a valid molscreen panel name"
  endif
  s_userDirmodels = s_userDir+"models/"
  if !Exist(s_userDirmodels) make directory s_userDirmodels
  S_modelsDir = Split(TOOLS.modelsDir ";")
  if (Index(S_modelsDir s_userDirmodels )==0) then
    S_modelsDir //= s_userDirmodels
    TOOLS.modelsDir = Sum(S_modelsDir ";")
    write system preference
  endif
  s_panel = Trim(s_panel all)
  if (Path(s_panel)=="") then
    s_panelpath = s_userDirmodels
  else
    s_panelpath = Path(s_panel)
    s_panel = Name(s_panel)
  endif
  if (!Exist(s_panelpath)) make directory s_panelpath
  if (s_panel=="") return "Panel name not specified"
  if (Index(S_modelsDir s_panelpath )==0) then
    S_modelsDir //= s_panelpath
    TOOLS.modelsDir = Sum(S_modelsDir ";")
    write system preference
  endif
  l_oldpanel = no
  if (l_oldpanel) then
    if ((s_modelname=="")&(s_keyword=="")) return "Either Uniprot name or keyword needed"
    if (s_panel[1:3]=="kcc"|s_panel[1:3]=="eca"|s_panel[1:3]=="dfz"|s_panel[1:3]=="dfa"|s_panel[1:3]=="dpc"|s_panel[1:3]=="mcp") return "Please refrain from using kcc|eca|dfz|dfa|dpc|mcp as panel prefix"
    S_modelprefix = {"kcc","dfz","dfa","dpc","mcp","ncc"}
    for i_modelprefix = 1, Nof(S_modelprefix)
      if (!Exist(s_userDir+"inx/cat"+S_modelprefix[i_modelprefix]+".icb")) then
        print "Models were not indexed, indexing, please wait"
        readModelPanel yes no ""
        break
      endif
    endfor
    read binary s_userDir+"inx/catkcc.icb"
    delete tmppanel l_warn=no; rename catkcc "tmppanel"
    read binary s_userDir+"inx/catdfa.icb"
    add column tmppanel Toreal(Sarray(Nof(tmppanel) "ND")) name="ClassAUC" index=6
    add column tmppanel Toreal(Sarray(Nof(tmppanel) "ND")) name="R2pkd" index=9
    set format tmppanel.ClassAUC  "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,50.:90.'"
    set format tmppanel.R2pkd  "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,0.1:0.6'"
    add tmppanel catdfa; delete catdfa
    read binary s_userDir+"inx/catdfz.icb"
    add tmppanel catdfz; delete catdfz
    read binary s_userDir+"inx/catdpc.icb"
    add tmppanel catdpc; delete catdpc
    read binary s_userDir+"inx/catmcp.icb"
    add tmppanel catmcp; delete catmcp
    read binary s_icmhome+"models/tag.icb"
    for i_tag = 1, Nof(tag)
      I_tag = Index(Index(tmppanel.model "..."+tag.Uniprot[1] regexp) 1 all)
      if (Nof(I_tag)!=0) tmppanel.tag[I_tag] = tag.tag[i_tag]
    endfor
    delete tag
  else
    delete tmppanel l_warn=no
    if (s_origpanel!="") then
      tmppanel = $s_origpanel
    else
      if (Type(AllTargets)!="table") then
        readModelPanel "AllTargets"
      endif
      tmppanel = AllTargets
    endif
  endif
  I_tmpmacro = Iarray(Nof(tmppanel) 0)
  if (s_origpanel != "") then
    I_tmpmacro[Index(tmppanel.chk==1)]=1
  else
    if (s_modelname!="") then
      I_tmpmacro = I_tmpmacro+Index(tmppanel.model s_modelname simple)
    endif
    if (s_keyword!="") then
      I_tmpmacro = I_tmpmacro+Index(tmppanel.model s_keyword simple)
      I_tmpmacro = I_tmpmacro+Index(tmppanel.NAME s_keyword simple)
      if (Type(tmppanel.tags)=="sarray") I_tmpmacro = I_tmpmacro+Index(tmppanel.tags s_keyword simple)
      I_tmpmacro = I_tmpmacro+Index(tmppanel.Species s_keyword simple)
      I_tmpmacro = I_tmpmacro+Index(tmppanel.Tissue s_keyword simple)
      I_tmpmacro = I_tmpmacro+Index(tmppanel.ADR s_keyword simple)
      I_tmpmacro = I_tmpmacro+Index(tmppanel.Category s_keyword simple)
      I_tmpmacro = I_tmpmacro+Index(tmppanel.Disease s_keyword simple)
      I_tmpmacro = I_tmpmacro+Index(tmppanel.Function s_keyword simple)
      I_tmpmacro = I_tmpmacro+Index(tmppanel.Drug_Mechanism s_keyword simple)
      if (Type(tmppanel.GO_Cellular)=="sarray") I_tmpmacro = I_tmpmacro+Index(tmppanel.GO_Cellular s_keyword simple)
      if (Type(tmppanel.GO_Process)=="sarray") I_tmpmacro = I_tmpmacro+Index(tmppanel.GO_Process s_keyword simple)
      if (Type(tmppanel.GO_Function)=="sarray") I_tmpmacro = I_tmpmacro+Index(tmppanel.GO_Function s_keyword simple)
    endif
  endif
  group table T_tmpmacro Count(Nof(I_tmpmacro)) "A" I_tmpmacro "B"
  T_tmpmacro = T_tmpmacro.B!=0
  I_tmpmacro = T_tmpmacro.A; delete T_tmpmacro
  I_tmpmacro = Unique(Sort(I_tmpmacro))
  tmppanel2 = tmppanel[I_tmpmacro]
  sort tmppanel2.model
  tmppanel2 = Unique(tmppanel2 "model")
  if (Type($s_panel)!="unknown") then
    add $s_panel tmppanel2
    delete tmppanel2
    sort $s_panel.model
    if Nof(Unique($s_panel.model))!=Nof($s_panel) then
      tmppanel2 = Unique($s_panel "model")
      delete $s_panel
      rename tmppanel2 s_panel
    endif
  else
    rename tmppanel2 s_panel
  endif
  S_missmodel = Sarray()
  for i_model = 1, Nof($s_panel)
    if (!Exist(s_icmhome+"models/"+($s_panel).model[i_model]+".icb")) then
      l_continue = yes
      for i_modelsDir = 1, Nof(S_modelsDir)
        if (Exist(S_modelsDir[i_modelsDir]+($s_panel).model[i_model]+".icb")) l_continue = no
      endfor
      if (l_continue) S_missmodel//=($s_panel).model[i_model]
    endif
  endfor
  if (Nof(S_missmodel)!=0) print "The following models in the custom model panel: \""+s_panel+"\" are missing, please download from Molsoft if you want to use them:\n" Sum(Unique(Sort(S_missmodel)) ",")
  USER_panels = readPredictionModels("panel", no)
  keep $s_panel
  if (Nof(I_tmpmacro)!=0) then
    print " Info> Saving panel as binary file in:" s_panelpath+s_panel+".icb"
    write binary $s_panel s_panelpath+s_panel+".icb" delete
    s_defaultCustomPanel = s_panelpath+s_panel+".icb"; keep s_defaultCustomPanel
    print " Info> You can add additional entries from other panels to this custom panel"
    print " Info> Please save the final panel as binary file:" s_panelpath+s_panel+".icb" "if modifications are made"
  else
    print " Warning> Cannot find relevant entries; please try with other model name or keywords"
  endif
endmacro

macro makeModelPanelList s_panel ("CustomPanel") S_modelfullpath (Sarray(0)) s_modelexp ("") auto
HELP = """
  Generate custom model panel and save it in the
    s_userDir/models directory if full path of s_panel is not specified
  Either Specify the list of all the models in S_modelfullpath
    e.g. makeModelPanelList 'custompanel' {'/data/model/kccESR1.icb','/data/model/kccESR2.icb'}
         makeModelPanelList 'custompanel' {'kccESR1','kccESR2'}
  OR specify the expression in s_modelexp, s_modelexp can be a folder location:
    e.g. makeModelPanelList 'custompanel' '/data/model/'
         makeModelPanelList 'custompanel' '/data/*/kcc*.icb'
  If the path is not specified in S_modelfullpath or s_modelexp, it will attempt to search for models in s_icmhome/models/ and TOOLS.modelsDir
"""
  l_info = no; l_warn = no
  s_userDirmodels = s_userDir+"models/"
  if !Exist(s_userDirmodels) make directory s_userDirmodels
  S_modelsDir = Split(TOOLS.modelsDir ";")
  if (Index(S_modelsDir s_userDirmodels )==0) then
    S_modelsDir //= s_userDirmodels
    TOOLS.modelsDir = Sum(S_modelsDir ";")
    write system preference
  endif
  s_panel = Trim(s_panel all)
  if (Path(s_panel)=="") then
    s_panelpath = s_userDirmodels
  else
    s_panelpath = Path(s_panel)
    s_panel = Name(s_panel)
  endif
  if (!Exist(s_panelpath)) make directory s_panelpath
  if (s_panel=="") return "Panel name not specified"
  if (s_panel[1:3]=="kcc"|s_panel[1:3]=="eca"|s_panel[1:3]=="dfz"|s_panel[1:3]=="dfa"|s_panel[1:3]=="dpc"|s_panel[1:3]=="mcp") return "Please refrain from using kcc|eca|dfz|dfa|dpc|mcp as panel prefix"
  if (Index(S_modelsDir s_panelpath )==0) then
    S_modelsDir //= s_panelpath
    TOOLS.modelsDir = Sum(S_modelsDir ";")
    write system preference
  endif
#  if (S_modelfullpath == Sarray(0)) then
#    if (Path(s_modelexp) == "") s_modelexp = Path()+s_modelexp
#    if (Extension(s_modelexp)=="") then
#      S_modelfullpath = Sarray(s_modelexp+"/*.icb" directory)
#    else
#      S_modelfullpath = Sarray(s_modelexp directory)
#    endif
#  endif
  if (S_modelfullpath == Sarray(0)) then
    if (Extension(s_modelexp)=="") s_modelexp=s_modelexp+"/*.icb"
    if (Path(s_modelexp) != "") then
      S_modelfullpath = Sarray(s_modelexp directory)
    else
      S_modelfullpath = Sarray(s_icmhome+"models/"+s_modelexp directory)
      for i_modelsDir = 1, Nof(S_modelsDir)
        S_modelfullpath //= Sarray(S_modelsDir[i_modelsDir]+s_modelexp directory)
      endfor
      group table T_tmpmacro Name(S_modelfullpath) "model" S_modelfullpath "location"
      sort T_tmpmacro.model
      T_tmpmacro = Unique(T_tmpmacro "model")
      S_modelfullpath = T_tmpmacro.location
      delete T_tmpmacro
    endif
  endif
  if (S_modelfullpath == Sarray(0)) return "Please specify a sarray of model full path"
  l_old = no
  read binary s_icmhome+"models/catkcc.icb"
  delete tmppanel l_warn=no; rename catkcc "tmppanel"
  add column tmppanel Toreal(Sarray(Nof(tmppanel) "ND")) name="ClassAUC" index=6
  add column tmppanel Toreal(Sarray(Nof(tmppanel) "ND")) name="R2pkd" index=9
  set format tmppanel.ClassAUC  "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,50.:90.'"
  set format tmppanel.R2pkd  "%.2f" name="" color="rainbow='#FFDCDC/#FFFFDC/#DCFFDC,0.1:0.6'"
  add column tmppanel Sarray(Nof(tmppanel) "") name="location"
  delete tmppanel[1:$]
  N=Nof(S_modelfullpath); print bar N " Reading models... " l_info=yes
  for i_modelfullpath = 1, Nof(S_modelfullpath)
    s_modelfullpath = S_modelfullpath[i_modelfullpath]
    if (Extension(s_modelfullpath)!=".icb") s_modelfullpath = s_modelfullpath+".icb"
    if (Path(s_modelfullpath)=="") then
      if Exist(s_icmhome+"models/"+s_modelfullpath) then
        s_modelfullpath = s_icmhome+"models/"+s_modelfullpath
      else
        for i_modelsDir = 1, Nof(S_modelsDir)
          if Exist(S_modelsDir[i_modelsDir]+s_modelfullpath) then
            s_modelfullpath = S_modelsDir[i_modelsDir]+s_modelfullpath
            break
          endif
        endfor
      endif
      if (Path(s_modelfullpath)=="") continue
    endif
    if (!Exist(s_modelfullpath)) continue
    if (Extension(s_modelfullpath)!=".icb") continue
    s_modelname = Name(s_modelfullpath)
    if (s_modelname[1:3]!="kcc"&s_modelname[1:3]!="eca"&s_modelname[1:3]!="dfa"&s_modelname[1:3]!="dfz"&s_modelname[1:3]!="dpc"&s_modelname[1:3]!="mcp") continue
    read binary s_modelfullpath
    if (Type($s_modelname)=="unknown") continue
    add tmppanel
    tmppanel.model[$] = s_modelname
    if (Path(s_modelfullpath)!="") then
      tmppanel.location[$] = s_modelfullpath
    else
      tmppanel.location[$] = Path()+s_modelfullpath
    endif
    for i_field = 2, Index(Name(tmppanel) "tmppanel.location")-1
      s_col = Name(tmppanel)[i_field]
      s_field = Field(s_col 2 ".")
      if (!Exist($s_modelname s_field)) continue
      if (Type($s_col[$])!=Type($s_modelname[s_field])) continue
      $s_col[$]=$s_modelname[s_field]
    endfor
    delete $s_modelname
    print bar N l_info=yes
  endfor
  print bar "End\n" l_info=yes
  if (Nof(tmppanel)==0) return "No valid MolScreen models found"
  read binary s_icmhome+"models/tag.icb"
  for i_tag = 1, Nof(tag)
    I_tag = Index(Index(tmppanel.model "..."+tag.Uniprot[1] regexp) 1 all)
    if (Nof(I_tag)!=0) tmppanel.tag[I_tag] = tag.tag[i_tag]
  endfor
  delete tag
  if (Type($s_panel)!="unknown") then
    add $s_panel tmppanel
    delete tmppanel
    sort $s_panel.model
    if Nof(Unique($s_panel.model))!=Nof($s_panel) then
      tmppanel = Unique($s_panel "model")
      delete $s_panel
      rename tmppanel s_panel
    endif
  else
    rename tmppanel s_panel
  endif
  keep $s_panel
  print "Saving panel as binary file in:" s_panelpath+s_panel+".icb"
  write binary $s_panel s_panelpath+s_panel+".icb" delete
  s_defaultCustomPanel = s_panelpath+s_panel+".icb"; keep s_defaultCustomPanel
  print "You can add additional entries from other panels to this custom panel"
  print "Please save the final panel as binary file:" s_panelpath+s_panel+".icb" "if modifications are made"
endmacro
#
macro annotatemodels  S_modelfullpath (Sarray(0)) s_modelexp ("") S_modeluniprot (Sarray(0)) auto
HELP = """
  Annotate custom models and save it in original directory
  Please make sure the original directory is user writable
  Either Specify the list of all the models in S_modelfullpath
    e.g. annotatemodels {'/data/model/kccESR1.icb','/data/model/kccESR2.icb'}
         annotatemodels {'kccESR1','kccESR2'}
  OR specify the expression in s_modelexp, s_modelexp can be a folder location:
    e.g. annotatemodels '/data/model/'
         annotatemodels '/data/*/kcc*.icb'
  The name of the model will be used to guess the Uniprot ID:
  i.e. kccESR1 -> ESR1_HUMAN
       kccESR1_RAT -> ESR1_RAT
  Alternatively, an sarray of Uniprot name can be provided to override the guess, provided that the number of uniprot name equals to the number of list of al
l the models in S_modelfullpath
    e.g. annotatemodels {'/data/model/kccESR1.icb','/data/model/kccESR2.icb'} {'ESR1_RAT','ESR2_MOUSE'}
  If the path is not specified in S_modelfullpath or s_modelexp, it will attempt to search for models in s_icmhome/models/ and TOOLS.modelsDir
  If no argument is provided, it will search for models in the current directory
"""
  l_info = no; l_warn = no
  S_fields = {"NAME","tag","Species","Tissue","ADR","Category","Disease","Function","Drug_Mechanism"}
  s_userDirmodels = s_userDir+"models/"
  if !Exist(s_userDirmodels) make directory s_userDirmodels
  S_modelsDir = Split(TOOLS.modelsDir ";")
  if (Index(S_modelsDir s_userDirmodels )==0) then
    S_modelsDir //= s_userDirmodels
    TOOLS.modelsDir = Sum(S_modelsDir ";")
    write system preference
  endif
  if (S_modelfullpath == Sarray(0)) then
    if (Extension(s_modelexp)=="") s_modelexp=s_modelexp+"/*.icb"
    if (Path(s_modelexp) != "") then
      S_modelfullpath = Sarray(s_modelexp directory)
    else
      S_modelfullpath = Sarray(s_icmhome+"models/"+s_modelexp directory)
      for i_modelsDir = 1, Nof(S_modelsDir)
        S_modelfullpath //= Sarray(S_modelsDir[i_modelsDir]+s_modelexp directory)
      endfor
      group table T_tmpmacro Name(S_modelfullpath) "model" S_modelfullpath "location"
      sort T_tmpmacro.model
      T_tmpmacro = Unique(T_tmpmacro "model")
      S_modelfullpath = T_tmpmacro.location
      delete T_tmpmacro
    endif
  endif
  if (S_modelfullpath == Sarray(0)) return "Please specify a sarray of model full path"
  N=Nof(S_modelfullpath); print bar N " Reading models... " l_info=yes
  for i_modelfullpath = 1, Nof(S_modelfullpath)
    s_modelfullpath = S_modelfullpath[i_modelfullpath]
    if (Extension(s_modelfullpath)!=".icb") s_modelfullpath = s_modelfullpath+".icb"
    if (Path(s_modelfullpath)=="") then
      if Exist(s_icmhome+"models/"+s_modelfullpath) then
        s_modelfullpath = s_icmhome+"models/"+s_modelfullpath
      else
        for i_modelsDir = 1, Nof(S_modelsDir)
          if Exist(S_modelsDir[i_modelsDir]+s_modelfullpath) then
            s_modelfullpath = S_modelsDir[i_modelsDir]+s_modelfullpath
            break
          endif
        endfor
      endif
      if (Path(s_modelfullpath)=="") continue
    endif
    if (!Exist(s_modelfullpath)) continue
    if (Extension(s_modelfullpath)!=".icb") continue
    s_modelname = Name(s_modelfullpath)
    if (s_modelname[1:3]!="kcc"&s_modelname[1:3]!="eca"&s_modelname[1:3]!="dfa"&s_modelname[1:3]!="dfz"&s_modelname[1:3]!="dpc"&s_modelname[1:3]!="mcp") continue
    read binary s_modelfullpath
    if (Type($s_modelname)=="unknown") continue
    $s_modelname["model"] = $s_modelname
    set name $s_modelname s_modelname
    $s_modelname["PARAMETERS"] = {"dock.*", "l_*"}
    S_tmpmacro = Sarray(0)
    if (Type($s_modelname["PARAMETERS"])=="sarray") S_tmpmacro = $s_modelname["PARAMETERS"]
    S_tmpmacro //= S_fields
    $s_modelname["PARAMETERS"] = Unique(Sort(S_tmpmacro ) )
    if (Nof(S_modeluniprot) == Nof(S_modelfullpath)) then
      s_modeluniprot = S_modeluniprot[i_modelfullpath]
    else
      if (Nof(s_modelname "_") > 0) then
        s_modeluniprot = Field(s_modelname 1 "_")[4:$]+"_"+Field(s_modelname 2 "_")
      else
        s_modeluniprot = s_modelname[4:$]
      endif
    endif
    if (Type(Uniprot_result)!="unknown") delete Uniprot_result l_warn=no
    l_mammalian = no
    if (Nof(s_modeluniprot "_")==0) then
      s_modeluniprot = s_modeluniprot+"_HUMAN"
      l_mammalian = yes
    endif
    if (Nof(s_modeluniprot "_")==1) then
      s_resulttab = "uniprot_"+s_modeluniprot
      Error()
      generalSearchFromGUI "Uniprot" s_modeluniprot "protein"
      if Error() return "Error searching Uniprot"
      if (Type($s_resulttab)!="unknown") rename $s_resulttab "Uniprot_result"
    endif
    if (Type(Uniprot_result)=="unknown") then
      if (Toupper(Field(s_modeluniprot 2 "_"))=="HUMAN") then
        print "Cannot find uniprot entry" s_modeluniprot "for model:" s_modelname
        delete $s_modelname
        continue
      endif
      s_modeluniprot = Field(s_modeluniprot 1 "_")+"_HUMAN"
      s_resulttab = "uniprot_"+s_modeluniprot
      Error()
      generalSearchFromGUI "Uniprot" s_modeluniprot "protein"
      if Error() return "Error searching Uniprot"
      if (Type($s_resulttab)!="unknown") rename $s_resulttab "Uniprot_result"
    endif
    if (Type(Uniprot_result)=="unknown") then
      print "Cannot find uniprot entry" s_modeluniprot "for model:" s_modelname
      delete $s_modelname
      continue
    endif
    Uniprot_result = Uniprot_result.Uniprot_ID == s_modeluniprot
    if (Nof(Uniprot_result)!=1) then
      print "Error in Uniprot:" s_modeluniprot "for model:" s_modelname
    endif
    $s_modelname["NAME"] = Uniprot_result.Fullname[1]
    if (l_mammalian) then
      if ((!Exist($s_modelname "Species"))|($s_modelname["Species"]=="")) $s_modelname["Species"] = "Mammalian"
    else
      if ((!Exist($s_modelname "Species"))|($s_modelname["Species"]=="")) $s_modelname["Species"] = Uniprot_result.Organism[1]
    endif
    if ((Uniprot_result.Tissue[1]!="")&((!Exist($s_modelname "Tissue"))|($s_modelname["Tissue"]==""))) $s_modelname["Tissue"] = Uniprot_result.Tissue[1]
    if ((Uniprot_result.Protein_family[1]!="")&((!Exist($s_modelname "Category"))|($s_modelname["Category"]==""))) $s_modelname["Category"] = Uniprot_result.Protein_family[1]
    if ((Uniprot_result.Disease[1]!="")&((!Exist($s_modelname "Disease"))|($s_modelname["Disease"]==""))) $s_modelname["Disease"] = Uniprot_result.Disease[1]
    if ((Uniprot_result.Function[1]!="")&((!Exist($s_modelname "Function"))|($s_modelname["Function"]==""))) $s_modelname["Function"] = Uniprot_result.Function[1]
    delete Uniprot_result l_warn=no
    if Exist(s_icmhome+"models/tag.icb") then
      if (Type(tag)=="unknown") read binary s_icmhome+"models/tag.icb"
      if ((!Exist($s_modelname "tag"))|($s_modelname["tag"]=="")) then
        if (Nof(Index(tag.Uniprot==Field(s_modeluniprot 1 "_")))==1) $s_modelname["tag"] = tag.tag[Index(tag.Uniprot==Field(s_modeluniprot 1 "_"))[1]]
      endif
    endif

    if ((!Exist($s_modelname "Drug_Mechanism"))|($s_modelname["Drug_Mechanism"]=="")) then
      delete  drugbankResult drugbankSummary  l_warn=no
      Error()
      findDrugbank Sarray(1 s_modeluniprot) "uniprot_id" no no
      if Error() return "Error Searching Drugbank"
      s_drugbanktab = "DB_"+s_modeluniprot
      if (Type($s_drugbanktab)!="unknown") then
        drugbankResult = $s_drugbanktab
        delete $s_drugbanktab
      endif
      if (Type(drugbankResult)!="unknown") then
        drugbankResult = drugbankResult.status~"*[Aa]pproved*"
        if (Nof(drugbankResult)!=0) then
          delete drugbankResult_target l_warn=no
          findDrugbankTarget "drugbankResult"
          delete drugbankResult l_warn=no
          rename drugbankResult_target "drugbankResult"
          S_tmp = Unique(Sort(Trim(Split(Sum(drugbankResult.action "|" ) ";|") all)))
          s_drugbank = ""
          for i_tmp = 1, Nof(S_tmp)
            s_tmp = S_tmp[i_tmp]
            I_tmp = Iarray()
            I_tmp//=Index(drugbankResult.action~s_tmp)//Index(drugbankResult.action~"*[;|] "+s_tmp)//Index(drugbankResult.action~s_tmp+"[;|]*")\
            //Index(drugbankResult.action~"*[;|] "+s_tmp+"[;|]*")
            if (i_tmp == 1) then
              s_drugbank = drugbankResult.fullname[1]+" "+S_tmp[i_tmp]+": "\
              +Sum(Unique(Sort(drugbankResult.name[I_tmp])) ", ")
            else
              s_drugbank = s_drugbank+"\n"+drugbankResult.fullname[1]+" "+S_tmp[i_tmp]+": "\
              +Sum(Unique(Sort(drugbankResult.name[I_tmp])) ", ")
            endif
          endfor
          $s_modelname["Drug_Mechanism"] = s_drugbank
        endif
        delete drugbankResult l_warn=no
      endif
    endif

    write binary $s_modelname s_modelfullpath delete
    delete $s_modelname
    print bar N l_info=yes
  endfor
  print bar "End\n" l_info=yes

endmacro
#
macro make_globalkccBG  s_target s_table ("LIG") s_activityColumn ("pkd") l_localtable (yes) s_unit ("pKd") l_charge (yes) auto
  l_info = l_warn = no
  s_target = Trim(s_target all)
  if (s_target=="") return "Please specify the model name"
  if (s_target[1:3]=="kcc") s_target = Replace(s_target "kcc" "")
  s_table = Trim(s_table all)
  if (s_table=="") return "Please specify the chemical table name"
  if (Type($s_table)=="unknown") return "Table " s_table "not found"
  delete T_tmplig l_warn=no; T_tmplig = $s_table
  s_activityColumn = Trim(s_activityColumn all)
  if (s_activityColumn == "") return "Please specify activity column name"
  if (Type(T_tmplig.$s_activityColumn)=="unknown") return "Activity column " s_activityColumn "not found"
  if (l_localtable) then
    if (s_unit == "pKd") then
      add column T_tmplig T_tmplig.$s_activityColumn name="value"
    elseif (s_unit == "mM") then
      add column T_tmplig  3.-Log(Abs(T_tmplig.$s_activityColumn) 10) name="value"
    elseif (s_unit == "uM") then
      add column T_tmplig  6.-Log(Abs(T_tmplig.$s_activityColumn) 10) name="value"
    elseif (s_unit == "nM") then
      add column T_tmplig  9.-Log(Abs(T_tmplig.$s_activityColumn) 10) name="value"
    endif
    sort T_tmplig.mol
#    add column T_tmplig function="MolWeight(mol)" index=2 name="molWeight" append format="%.3f"
#    add column T_tmplig function="Nof_RotB(mol)" index=2 name="nof_RotB" append
#    T_tmplig = T_tmplig.molWeight <= 700. & T_tmplig.nof_RotB <= 15
#    if (Nof(T_tmplig)==0) return "No ChEMBL data found after filtering off MW>700 & nof_RotB>15 for target" s_target
    if (l_charge) set charge formal auto T_tmplig.mol 7.0
    if (s_table == "LIG") then; delete T_LIGtmp; rename LIG "T_LIGtmp";endif
    group T_tmplig.mol T_tmplig.value "count,count" T_tmplig.value "min,min" T_tmplig.value "max,max" T_tmplig.value "mean,mean" T_tmplig.value "rmsd,rmsd" name="LIG"
    add column LIG Rarray(Nof(LIG)) name="value"
    for i_macro = 1, Nof(LIG)
      tmp = T_tmplig.mol == LIG.mol [i_macro]
      sort tmp.value reverse
      LIG.value [i_macro] = tmp.value [Integer(Ceil(Nof(tmp) * 0.2))]
      delete tmp
    endfor
    rename LIG.value "pkd"; delete T_tmplig
  endif
  s_tmpfolder = s_tempDir+s_target
  if Exist(s_tmpfolder) then
    if (Match(Version() "/Win")!="") then
      s_cmd = "rmdir /s /q \""+s_tmpfolder+"\""; Unix(s_cmd)
    else
      sys rm -r $s_tmpfolder
    endif
  endif
#  s_cmd = "mkdir \""+s_tmpfolder+"\""; Unix(s_cmd)
  make directory s_tmpfolder
#  fname_in = Name(system s_tempDir+s_target+"/LIG.sdf")
  fname_in = s_tempDir+s_target+"/LIG.sdf"
  fname_out = s_tempDir+s_target+"/kcc"+s_target+".icb"
  write table mol LIG fname_in delete
  if (Type(T_LIGtmp)!="unknown") then; rename LIG Name("LIG" unique); rename T_LIGtmp LIG; endif
  s_dirold = Path()
  set directory s_tmpfolder
  s_cmd = Path(macro, "-P"+s_icmhome, s_icmhome+"models/make_globalkcc.icm","pkd="+fname_in)
  make background s_cmd info="kcc model building finished for table "+s_table+", please save the model to "+Split(TOOLS.modelsDir ";")[$]+" directory" command="read binary " + String(fname_out string)
  print " Info> kcc model building started in background. You will be notified when the model appears under Workspace/models."
  set directory s_dirold
endmacro
#
macro make_localdfaBG  s_target s_table ("LIG") s_activityColumn ("pkd") s_proj ("") os_obj (as_graph) l_localtable (yes) s_unit ("pKd") l_charge (yes) l_fromproject (yes) auto
  l_info = l_warn = no
  s_target = Trim(s_target all)
  if (s_target=="") return "Please specify the model name"
  if (s_target[1:3]=="dfa") s_target=Replace(s_target "dfa" "")
  s_table = Trim(s_table all)
  if (s_table=="") return "Please specify the chemical table name"
  if (Type($s_table)=="unknown") return "Table " s_table "not found"
  delete T_tmplig l_warn=no; T_tmplig = $s_table
  s_activityColumn = Trim(s_activityColumn all)
  if (s_activityColumn == "") return "Please specify activity column name"
  if (Type(T_tmplig.$s_activityColumn)=="unknown") return "Activity column " s_activityColumn "not found"
  s_proj = Trim(s_proj all)
  if (l_fromproject) then
    if (s_proj == "") return "Please specify either docking project/pocketome entry name"
  else
    if (Nof(os_obj)>0) os_obj = Obj(os_obj)
#    if (Nof(os_obj)==0) return "Please specify valid receptor object as input for docking"
  endif
  if (l_localtable) then
    if (Type(T_tmplig.mol 2 )=="2D") then
      l_3D=no
    else
      l_3D=yes
    endif
    if (s_unit == "pKd") then
      add column T_tmplig T_tmplig.$s_activityColumn name="value"
    elseif (s_unit == "mM") then
      add column T_tmplig  3.-Log(Abs(T_tmplig.$s_activityColumn) 10) name="value"
    elseif (s_unit == "uM") then
      add column T_tmplig  6.-Log(Abs(T_tmplig.$s_activityColumn) 10) name="value"
    elseif (s_unit == "nM") then
      add column T_tmplig  9.-Log(Abs(T_tmplig.$s_activityColumn) 10) name="value"
    endif
    sort T_tmplig.mol
    add column T_tmplig function="MolWeight(mol)" index=2 name="molWeight" append format="%.3f"
    add column T_tmplig function="Nof_RotB(mol)" index=2 name="nof_RotB" append
    T_tmplig = T_tmplig.molWeight <= 700. & T_tmplig.nof_RotB <= 15
    if (Nof(T_tmplig)==0) return "No data found after filtering off MW>700 & nof_RotB>15 for target" s_target
    if ((!l_3D)&(l_charge)) set charge formal auto T_tmplig.mol 7.0
    if (s_table == "LIG") then; delete T_LIGtmp l_warn=no; rename LIG "T_LIGtmp";endif
    if (Type(T_tmplig.Score)!="unknown") then
      group T_tmplig.mol T_tmplig.Score "min,Score" T_tmplig.value "count,count" T_tmplig.value "min,min" T_tmplig.value "max,max" T_tmplig.value "mean,mean" T_tmplig.value "rmsd,rmsd" name="LIG"
    else
      group T_tmplig.mol T_tmplig.value "count,count" T_tmplig.value "min,min" T_tmplig.value "max,max" T_tmplig.value "mean,mean" T_tmplig.value "rmsd,rmsd" name="LIG"
    endif
    add column LIG Rarray(Nof(LIG)) name="value"
#    if (Type(T_tmplig.Score)!="unknown") add column LIG T_tmplig.Score name="Score" index=2
    for i_macro = 1, Nof(LIG)
      tmp = T_tmplig.mol == LIG.mol [i_macro]
      sort tmp.value reverse
      LIG.value [i_macro] = tmp.value [Integer(Ceil(Nof(tmp) * 0.2))]
      delete tmp
    endfor
    rename LIG.value "pkd"; delete T_tmplig
  endif
  s_tmpfolder = s_tempDir+s_target
  if Exist(s_tmpfolder) then
    if (Match(Version() "/Win")!="") then
      s_cmd = "rmdir /s /q \""+s_tmpfolder+"\""; Unix(s_cmd)
    else
      sys rm -r $s_tmpfolder
    endif
  endif
#  s_cmd = "mkdir \""+s_tmpfolder+"\""; Unix(s_cmd)
  make directory s_tmpfolder
#  fname_in = Name(system s_tempDir+s_target+"/LIG.sdf")
  fname_in = s_tempDir+s_target+"/LIG.sdf"
  fname_out = s_tempDir+s_target+"/dfa"+s_target+".icb"
  write table mol LIG fname_in delete
  if (Type(T_LIGtmp)!="unknown") then; rename LIG Name("LIG" unique); rename T_LIGtmp LIG; endif
#  s_dirold = Path()
#  set directory s_tmpfolder
  S_arg = Sarray(1 "pkd="+fname_in)
  S_arg //="output="+fname_out
  S_arg //="mod="+"dfa"+s_target
  if (s_proj!="") then
    S_arg //="proj="+s_proj
  endif
  if (Nof(os_obj)>0) then
    fname_ob = s_tempDir+s_target+"/input.ob"
    write object os_obj fname_ob
    S_arg //= "obj="+fname_ob
  endif
  if (!l_charge) S_arg //= "-nocharge"
  s_cmd = Path(macro, "-P"+s_icmhome, s_icmhome+"models/make_localdfa.icm", S_arg)
  make background s_cmd info="local (4D/2D) dfa model generation finished for table "+s_table+", please save the model to "+Split(TOOLS.modelsDir ";")[$]+" directory" command="read binary " + String(fname_out string)
  print " Info> local (4D/2D) dfa model generation started in background. You will be notified when the job is complete (check Workspace/models)"
#  set directory s_dirold
endmacro
#
function pred_kcc P_mol
    group table T_tmpmacro P_mol "mol"
    modify T_tmpmacro.mol delete salt
    modify T_tmpmacro.mol delete salt simple
    delete hydrogen T_tmpmacro.mol
    modify T_tmpmacro.mol auto
    modify T_tmpmacro.mol delete charge
    c_map = @["c_map"]
    if (c_map == Collection()) then
      D_descmacro = Descriptor(T_tmpmacro.mol)
    else
      D_descmacro = Descriptor(T_tmpmacro.mol c_map)
    endif
    add column T_tmpmacro Rarray(Nof(T_tmpmacro) 999.) name="Score"
    add column T_tmpmacro Rarray(Nof(T_tmpmacro) 999.) name="Scoretmp"
    add column T_tmpmacro Iarray(Nof(T_tmpmacro) 0) name="cl"
    add column T_tmpmacro Toreal(Sarray(Nof(T_tmpmacro) "0.")) name="pkdpred"
    add column T_tmpmacro Count(Nof(T_tmpmacro)) name="idx"
    for i_macro = 1, Nof(@["R_distscale"])
      T_tmpmacro.Scoretmp = Min(Distance(@["DESCRIPTOR"][i_macro] D_descmacro))/@["R_distscale"][i_macro]
      T_tmpmacro.Score = Min(T_tmpmacro.Score T_tmpmacro.Scoretmp)
      if (Exist(@["kr1"])) T_tmpmacro.cl[Index(T_tmpmacro.Score == T_tmpmacro.Scoretmp)] = i_macro
    endfor
    if (@["l_predpkd"] == yes) then
      if (Exist(@["kr1"])) then
        for i_macro = 1, Nof(@["R_distscale"])
          if (Nof(T_tmpmacro.cl==i_macro & T_tmpmacro.Score<=@["r_krdistcutoff"])==0) continue
          T_tmpmacro2 = T_tmpmacro.cl==i_macro & T_tmpmacro.Score<=@["r_krdistcutoff"]
          if (Type(kr)!="unknown") delete kr
          s_krmod = "kr"+String(i_macro)
          if Exist(@[s_krmod]) then
            kr = @[s_krmod]
            predict kr T_tmpmacro2
            T_tmpmacro.pkdpred[T_tmpmacro2.idx] = T_tmpmacro2.kr
            delete kr
          endif
          delete T_tmpmacro2
        endfor
      endif
      if (Exist(@["krrf"])) then
        T_tmpmacro2 = T_tmpmacro.Score<=@["r_krdistcutoff"]
        if (Type(kr)!="unknown") delete kr
        kr = @["krrf"]
        predict kr T_tmpmacro2
        if (Nof(T_tmpmacro2.idx)!=0) T_tmpmacro.pkdpred[T_tmpmacro2.idx] = Max( T_tmpmacro.pkdpred[T_tmpmacro2.idx]  T_tmpmacro2.kr)
        delete kr; delete T_tmpmacro2
      endif
      if (Exist(@["krpls"])) then
        T_tmpmacro2 = T_tmpmacro.Score<=@["r_krdistcutoff"]
        if (Type(kr)!="unknown") delete kr
        kr = @["krpls"]
        predict kr T_tmpmacro2
        if (Nof(T_tmpmacro2.idx)!=0) T_tmpmacro.pkdpred[T_tmpmacro2.idx] = Max( T_tmpmacro.pkdpred[T_tmpmacro2.idx]  T_tmpmacro2.kr)
        delete kr; delete T_tmpmacro2
      endif
      if ((@["l_kr"]==yes) & (Exist(@["kr0"]))) then
        T_tmpmacro2 = T_tmpmacro
        kr = @["kr0"]
        predict kr T_tmpmacro2
#        T_tmpmacro.pkdpred = Max(T_tmpmacro.pkdpred T_tmpmacro2.kr)
        T_tmpmacro.pkdpred[Index(T_tmpmacro.pkdpred==Toreal("0."))] = T_tmpmacro2.kr[Index(T_tmpmacro.pkdpred==Toreal("0."))]
        delete kr; delete T_tmpmacro2
      endif
      T_tmpmacro.pkdpred = Trim(T_tmpmacro.pkdpred 0. 15.)
      T_tmpmacro.pkdpred[Index(T_tmpmacro.pkdpred==15.)] = Toreal("ND")
      T_tmpmacro.pkdpred[Index(T_tmpmacro.pkdpred==0.)] = Toreal("ND")
    endif

    i_chemicalFingerprintType = TOOLS.chemicalFingerprintType
    TOOLS.chemicalFingerprintType = 1
    s_simcol = Replace(@["model"] "kcc" "")+"_kcc_TANIsim"
    if (c_map != Collection()) D_descmacro = Descriptor(T_tmpmacro.mol)
    M_distmacro = Distance(@["FP"] D_descmacro)
    add column T_tmpmacro Min(M_distmacro) name="mindist"
    if (@["l_pose"]==yes) then
      s_nearestcol =  Replace(@["model"] "kcc" "")+"_kcc_nearest"
      I_tmpmacro = Min(index Transpose(M_distmacro))
      add column T_tmpmacro @["MOL"][I_tmpmacro] name="nn"
      add column T_tmpmacro Toreal(@["PKD"])[I_tmpmacro] name="nnpkd"
    endif
    TOOLS.chemicalFingerprintType = i_chemicalFingerprintType
#    T_tmpmacro.Score = T_tmpmacro.Score * @["A"]+@["B"]
    R_postmp = -(T_tmpmacro.Score-@["r_posmean"] )/@["r_posrmsd"]
    R_negtmp = -(T_tmpmacro.Score-@["r_negmean"] )/@["r_negrmsd"]
    R_posabs = Max(Abs(R_postmp) Rarray(Nof(R_postmp) 0.000001))
    R_negabs = Max(Abs(R_negtmp) Rarray(Nof(R_negtmp) 0.000001))
    R_possign = Sign(R_postmp)
    R_negsign = Sign(R_negtmp)
    R_postmp = 0.5-0.5*R_possign+R_possign*((1.-Exp(-1.422*R_posabs))*Exp(-Power(R_posabs 2)/2.))/1.135/Sqrt(2.*Pi())/R_posabs
    R_negtmp = 0.5-0.5*R_negsign+R_negsign*((1.-Exp(-1.422*R_negabs))*Exp(-Power(R_negabs 2)/2.))/1.135/Sqrt(2.*Pi())/R_negabs
    T_tmpmacro.Score = (@["r_posprior"]*R_postmp)/(@["r_posprior"]*R_postmp+(1.-@["r_posprior"])*R_negtmp)

    if (@["l_predpkd"] == yes) then
      s_pkdcol = Replace(@["model"] "kcc" "")+"_kca"
      if (@["l_pose"]==yes) then
        return Collection("0" T_tmpmacro.Score s_pkdcol T_tmpmacro.pkdpred s_simcol 1.-T_tmpmacro.mindist s_nearestcol T_tmpmacro.nn)
      else
        return Collection("0" T_tmpmacro.Score s_pkdcol T_tmpmacro.pkdpred s_simcol 1.-T_tmpmacro.mindist)
      endif
    else
      if (@["l_pose"]==yes) then
        return Collection("0" T_tmpmacro.Score s_simcol 1.-T_tmpmacro.mindist s_nearestcol T_tmpmacro.nn)
      else
        return Collection("0" T_tmpmacro.Score s_simcol 1.-T_tmpmacro.mindist)
      endif
    endif
endfunction
#
function pred_ncc P_mol
  l_info = l_commands = l_warn = no
  group table T_tmpmacro P_mol "mol"
  modify T_tmpmacro.mol delete salt
  modify T_tmpmacro.mol delete salt simple
  delete hydrogen T_tmpmacro.mol
  modify T_tmpmacro.mol auto
  modify T_tmpmacro.mol delete charge

  add column T_tmpmacro Rarray(Nof(T_tmpmacro) 0.) name="Score"
  add column T_tmpmacro Rarray(Nof(T_tmpmacro) 0.) name="Scoretmp"
  add column T_tmpmacro Count(Nof(T_tmpmacro)) name="idx"

  s_model = @["model"]
  if Exist(classmodeltmp) delete classmodeltmp l_warn=no
  classmodeltmp = @["classmodel"]
  predict T_tmpmacro classmodeltmp key
  S_targetlist = @["S_targetlist"]
  I_used = Tointeger(@["I_used"])
  R_midpoint = Toreal(@["R_midpoint"])
  R_maxpoint = Toreal(@["R_maxpoint"])
  R_minpoint = Toreal(@["R_minpoint"])
  R_pPvalueA = Toreal(@["R_pPvalueA"])
  R_pPvalueB = Toreal(@["R_pPvalueB"])
  R_pPvalueC = Toreal(@["R_pPvalueC"])
  R_posmean = Toreal(@["R_posmean"])
  R_posrmsd = Toreal(@["R_posrmsd"])
  R_negmean = Toreal(@["R_negmean"])
  R_negrmsd = Toreal(@["R_negrmsd"])
  R_NSA_train = Trim(Toreal(@["R_NSA_train"])/100. 0.01 1.)
  r_posprior = Toreal(@["r_posprior"])

  if (@["l_pose"]==yes) then
    i_chemicalFingerprintType = TOOLS.chemicalFingerprintType
    TOOLS.chemicalFingerprintType = 1
    s_simcol = Replace(s_model "ncc" "")+"_ncc_TANIsim"
    D_descmacro = Descriptor(T_tmpmacro.mol)
    M_distmacro = Distance(@["FP"] D_descmacro)
    add column T_tmpmacro Min(M_distmacro) name="mindist"
    s_nearestcol =  Replace(s_model "ncc" "")+"_ncc_nearest"
    I_tmpmacro = Min(index Transpose(M_distmacro))
    add column T_tmpmacro @["SMILES"][I_tmpmacro] name="nnsmiles"
    add column T_tmpmacro Chemical(T_tmpmacro.nnsmiles) name="nn"
    TOOLS.chemicalFingerprintType = i_chemicalFingerprintType
  endif

#  R_midnorm = (R_midpoint - R_minpoint)/(R_maxpoint - R_minpoint)

  M_tmpmacro2 = Matrix(Nof(T_tmpmacro) Nof(S_targetlist))
  for i_cpd = 1, Nof(T_tmpmacro)
    R_tmpmacro2 = T_tmpmacro.classmodeltmpv[i_cpd]/R_midpoint
#    M_tmpmacro2[i_cpd,?] = Trim(R_pPvalueC+(100.-R_pPvalueC)*(1./(1.+Exp(-R_pPvalueA*( R_tmpmacro2 - R_pPvalueB)))) 0. 100.)*0.01
    M_tmpmacro2[i_cpd,?] = -Log((100.-Trim(R_pPvalueC+(100.-R_pPvalueC)*(1./(1.+Exp(-R_pPvalueA*( R_tmpmacro2 - R_pPvalueB)))) 0. 99.99999999))/100. 10.)
  endfor

  M_tmpmacro3 = Matrix(Nof(T_tmpmacro) Nof(S_targetlist))
  for i_cpd = 1, Nof(T_tmpmacro)
    R_postmp = (T_tmpmacro.classmodeltmpv[i_cpd]-R_posmean )/R_posrmsd
    R_negtmp = (T_tmpmacro.classmodeltmpv[i_cpd]-R_negmean )/R_negrmsd
    R_posabs = Max(Abs(R_postmp) Rarray(Nof(R_postmp) 0.000001))
    R_negabs = Max(Abs(R_negtmp) Rarray(Nof(R_negtmp) 0.000001))
    R_possign = Sign(R_postmp)
    R_negsign = Sign(R_negtmp)

    R_posabs = Min(R_posabs Rarray(Nof(R_posabs) 8.))

    R_postmp = 0.5+0.5*R_possign-R_possign*((1.-Exp(-1.422*R_posabs))*Exp(-Power(R_posabs 2)/2.))/1.135/Sqrt(2.*Pi())/R_posabs
    R_negtmp = 0.5+0.5*R_negsign-R_negsign*((1.-Exp(-1.422*R_negabs))*Exp(-Power(R_negabs 2)/2.))/1.135/Sqrt(2.*Pi())/R_negabs
#    M_tmpmacro3[i_cpd,?] = (r_posprior*R_postmp)/(r_posprior*R_postmp+(1.-r_posprior)*(1.-R_negtmp))
#    M_tmpmacro3[i_cpd,?] = (r_posprior * R_postmp * R_NSA_train)/((r_posprior * R_postmp * R_NSA_train)+(1.-r_posprior)*(1.-R_negtmp))
    R_postmp = 1.-R_postmp
    R_negtmp = 1.-R_negtmp

#    R_postmp = Max(Abs(R_postmp) Rarray(Nof(R_postmp) 0.000000000001))

    M_tmpmacro3[i_cpd,?] = (r_posprior * R_postmp)/((r_posprior * R_postmp)+(1.-r_posprior)*R_negtmp)
#    M_tmpmacro3[i_cpd,?] = (r_posprior * R_postmp * R_NSA_train)/((r_posprior * R_postmp * R_NSA_train)+(1.-r_posprior*R_NSA_train)*(1.-R_negtmp))
  endfor

  M_tmpmacro = M_tmpmacro2
  if (@["l_probabilityscore"]) M_tmpmacro = M_tmpmacro3

  S_finalcol = Sarray(0)
  C_final = Collection()
  C_final["0"] = T_tmpmacro.Score
  s_topcol =  "0"+s_model+"_tophit"
  C_final[s_topcol] = Sarray(Nof(T_tmpmacro))
  if (@["l_pose"]==yes) then
    C_final[s_simcol] = 1.-T_tmpmacro.mindist
    C_final[s_nearestcol] = T_tmpmacro.nn
  endif
  for i_target = 1, Nof(S_targetlist)
    if (I_used[i_target] == 0) continue
    s_col = S_targetlist[i_target]+"_"+s_model
    S_finalcol //= s_col
    C_final[s_col] = M_tmpmacro[?, i_target]
  endfor
  S_tmpmacro =  Sarray(Nof(T_tmpmacro))
  for i_cpd = 1, Nof(T_tmpmacro)
    delete T_tmpmacro2 l_warn=no
    group table T_tmpmacro2 M_tmpmacro[i_cpd,?] "A"
    add column T_tmpmacro2 S_targetlist name="B"
    add column T_tmpmacro2 I_used name="C"
    T_tmpmacro2 = T_tmpmacro2.C != 0
    sort reverse T_tmpmacro2.A
    if (@["l_probabilityscore"]) then
      I_tmpmacro = Index(T_tmpmacro2.A > 0.1)
      if (Nof(I_tmpmacro)>999) I_tmpmacro = I_tmpmacro[1:999]
    else
      I_tmpmacro = Index(T_tmpmacro2.A > 2.)
      if (Nof(I_tmpmacro)>999) I_tmpmacro = I_tmpmacro[1:999]
    endif
    if (Nof(T_tmpmacro)>0) S_tmpmacro[i_cpd] = Sum((T_tmpmacro2.B + ": "+Tointeger(T_tmpmacro2.A*100.)/100.)[I_tmpmacro] "\n")
    T_tmpmacro.Score[i_cpd] = T_tmpmacro2.A[Max(Nof(T_tmpmacro2)/10,1)]
    delete T_tmpmacro2 l_warn=no
#    T_tmpmacro.Score[i_cpd] = Median(M_tmpmacro[i_cpd,?])
  endfor
  C_final["0"] = T_tmpmacro.Score
  C_final[s_topcol] = S_tmpmacro
  return C_final
endfunction
#
function pred_eca P_mol
  group table T_tmpmacro P_mol "mol"
  add column T_tmpmacro Toreal(Sarray(Nof(T_tmpmacro) "ND")) name="pkdpred"
  add column T_tmpmacro Count(Nof(T_tmpmacro)) name="idx"
  group table T_tmpmacro2 @["MODELMOL"] "mol" Toreal(@["MODELPKD"]) "pkd" Tointeger(@["MODELGROUP"]) "group" Tointeger(@["MODELiTARGET"]) "iTarget"
  group table T_tmpmacro3 Toreal(@["MODELCUTOFF"]) "cutoff" Toreal(@["MODELWEIGHT"]) "weight" Toreal(@["MODELCENTER"]) "center" Toreal(@["MODELSTEEP"]) "steep" Toreal(@["MODELSTEEP2"]) "steep2"
  add column T_tmpmacro3 Count(Nof(T_tmpmacro3)) name="iTarget" index=1
  join left T_tmpmacro2.iTarget T_tmpmacro3.iTarget name="T_tmpmacro4"
  delete T_tmpmacro2 T_tmpmacro3 l_warn=no
  add column T_tmpmacro4 T_tmpmacro4.pkd-Toreal(@["MODELPKDBASE"]) name="pkd0"
  if (@["l_excludetest"] == yes) T_tmpmacro4 = T_tmpmacro4.group!=Max(T_tmpmacro4.group)
  if (@["l_excludeself"] == yes) T_tmpmacro4 = T_tmpmacro4.group == 0
  if (@["l_excludeothers"] == yes) T_tmpmacro4 = T_tmpmacro4.group != 0
  if (Nof(T_tmpmacro4)==0) return "No training data left for prediction"
  i_chemicalFingerprintType = TOOLS.chemicalFingerprintType
  TOOLS.chemicalFingerprintType = 1
  M_distmacro = Distance(T_tmpmacro4.mol T_tmpmacro.mol)
  add column T_tmpmacro Min(M_distmacro) name="tmpdist"

  for i_cpd = 1, Nof(T_tmpmacro)
    if (T_tmpmacro.tmpdist[i_cpd]>1.-Min(T_tmpmacro4.cutoff )) continue
    add column T_tmpmacro4  1.-M_distmacro [?,i_cpd] name="sim"
    add column T_tmpmacro4 T_tmpmacro4.sim-T_tmpmacro4.cutoff name="simcutoff"
    I_tmpmacro = Index(T_tmpmacro4.simcutoff>=0.)
    if (Nof(I_tmpmacro)==0) continue
    T_tmpmacro2 = T_tmpmacro4[I_tmpmacro]
    if ((@["l_corr"] == no) &  (Nof(T_tmpmacro2.iTarget ==1)>Nof(T_tmpmacro2.iTarget !=1)*2)) T_tmpmacro2 = T_tmpmacro2.iTarget == 1
    add column T_tmpmacro2  T_tmpmacro2.weight/(1.+Exp(-T_tmpmacro2.steep*(T_tmpmacro2.sim-T_tmpmacro2.center))) name="weight2"
    add column T_tmpmacro2  T_tmpmacro2.weight/(1.+Exp(-T_tmpmacro2.steep2*(T_tmpmacro2.sim-T_tmpmacro2.center))) name="weight3"
    if ((Sum(T_tmpmacro2.weight3 )+Toreal(@["MODELSTEEPBASE"]))==0.) continue
    T_tmpmacro.pkdpred [i_cpd] = Toreal(@["MODELPKDBASE"])+Sum(T_tmpmacro2.pkd0*T_tmpmacro2.weight2 )/(Sum(T_tmpmacro2.weight3 )+Toreal(@["MODELSTEEPBASE"]))
    delete T_tmpmacro2 l_warn=no
  endfor

  if (@["l_corr"] == yes) then
    R_corr = Rarray(Nof(T_tmpmacro) 0.)
    I_corr = Iarray(Nof(T_tmpmacro) 0)
    for i_mod = 2,  Max(T_tmpmacro4.iTarget)
      s_modcorr = "modcorr"+String(i_mod)
      if (!Exist(@ s_modcorr)) continue
      $s_modcorr = @[s_modcorr]
      predict T_tmpmacro $s_modcorr
      s_modcorrcol = "T_tmpmacro."+s_modcorr
      R_corr[Index($s_modcorrcol!=Toreal("ND" ))] = R_corr[Index($s_modcorrcol!=Toreal("ND" ))] + $s_modcorrcol[Index($s_modcorrcol!=Toreal("ND" ))]
      I_corr[Index($s_modcorrcol!=Toreal("ND" ))] = I_corr[Index($s_modcorrcol!=Toreal("ND" ))] + 1
      delete $s_modcorr l_warn=no
    endfor
    for i_cpd = 1, Nof(T_tmpmacro)
      if (T_tmpmacro.pkdpred[i_cpd] == Toreal("ND")) continue
      if (I_corr[i_cpd]==0) continue
      T_tmpmacro.pkdpred[i_cpd] = T_tmpmacro.pkdpred[i_cpd] + R_corr[i_cpd]/Toreal(I_corr[i_cpd])
    endfor
  endif

  s_simcol = Replace(@["model"] "eca" "")+"_eca_TANIsim"
  add column T_tmpmacro Min(M_distmacro) name="mindist"
  if (@["l_pose"]==yes) then
    s_nearestcol =  Replace(@["model"] "eca" "")+"_eca_nearest"
    I_tmpmacro = Min(index Transpose(M_distmacro))
    add column T_tmpmacro T_tmpmacro4.mol[I_tmpmacro] name="nn"
    add column T_tmpmacro T_tmpmacro4.pkd[I_tmpmacro] name="nnpkd"
  endif
  TOOLS.chemicalFingerprintType = i_chemicalFingerprintType

  if (@["l_pose"]==yes) then
    return Collection("0" T_tmpmacro.pkdpred s_simcol 1.-T_tmpmacro.mindist s_nearestcol T_tmpmacro.nn)
  else
    return Collection("0" T_tmpmacro.pkdpred s_simcol 1.-T_tmpmacro.mindist)
  endif
endfunction
#
function pred_dfa P_mol
    R_res = Rarray(Sarray(Nof(P_mol),"ND"))
    R_restmp = Rarray(Nof(P_mol),0.)
    P_mol2 = P_mol
    if (!Exist(@,"ob1")) return R_res
    if (!Exist(@,"NORM")) return R_res
    s_obfile = "T_ob"+String(Iproc())+".ob"
    s_infile = "T_in"+String(Iproc())+".sdf"
    s_oufile = "T_ou"+String(Iproc())+".icb"
    s_dir = Path()
    s_dockdir = Name(system "tmpdockXXXXX")
    make directory s_dockdir

    set directory s_dir+s_dockdir
    i_noftmplcl = Nof(@["NORM"])
    group table T_tmp P_mol "mol"
    add column T_tmp Count(Nof(T_tmp)) name="idxtmp"
    write table mol T_tmp s_dir+s_infile delete
    if Exist(@ "effort") then
      S_cmdargs = Sarray(1 "effort="+Tostring(@["effort"]))
    else
      S_cmdargs = Sarray(1 "effort=2.")
    endif
    S_cmdargs = S_cmdargs // "-r" // "-S" // "-e" // "-z"
    if (@["l_charge"]==yes) S_cmdargs //= "-c"
    if (Exist(@ "n_parallel") & (@["n_parallel"] != 1)) S_cmdargs //= "proc="+String(@["n_parallel"])
    if (@["l_progress"]) then
      sprintf " Info> screening %d chemicals vs model: '%s'",Nof(R_res),@["model"]
      print bar s_out i_noftmplcl l_info=yes
    endif
    for i_tmplcl = 1, i_noftmplcl
      s_ob = "ob"+String(i_tmplcl)
      write object @[s_ob] s_dir+s_obfile delete
#      s_cmd = Path(origin, "-s", s_icmhome + "_chemSuper", s_dir + s_obfile, s_dir + s_infile, s_dir +  s_oufile, "thoroughness=2. -r -S -e -c" )
      s_cmd = Path(macro, "-s", s_icmhome + "_chemSuper", s_dir + s_obfile, s_dir + s_infile, s_dir +  s_oufile, S_cmdargs )
      s_out = Unix(s_cmd)

      if ((Field(Version() 2 "/")~"Win*") & Exist(@ "n_parallel") & (@["n_parallel"] != 1)) then
        S_tmpfile = Sarray(s_tempDir+Name(s_oufile)+"*.sdf" directory)
        delete LIGANDS l_warn=no
        for i_tmpfile = 1, Nof(S_tmpfile)
          s_tmpfile = S_tmpfile[i_tmpfile]
          read table mol s_tmpfile name="t_tmpfile"
          if (Type(LIGANDS)=="unknown") then
            rename t_tmpfile "LIGANDS"
          else
            add LIGANDS t_tmpfile; delete t_tmpfile
          endif
          delete system s_tmpfile
        endfor
        sort LIGANDS.IX
      elseif (Exist(s_dir+s_oufile)) then
        read binary s_dir +s_oufile
        sort LIGANDS.idxtmp
        delete system s_dir + s_oufile
      endif
      if (Type(LIGANDS) == "unknown") continue
      if (@["l_apfscore"]) R_restmp = -1.+(@["NORM"][i_tmplcl]-LIGANDS.Score)/@["NORM"][i_tmplcl]
      if (@["l_apfdist"]) then
        group table T_apfdist Chemical(@[s_ob] exact hydrogen) "mol"
        if(Nof(pmf)==0)read pmf s_icmhome+"APF"
        M_tmpl = Score(T_apfdist.mol field)
        r_tmpl = Sum(Sum(M_tmpl))/Nof(M_tmpl)/Nof(M_tmpl)
        for i_cpdmacro = 1, Nof(LIGANDS)
          add T_apfdist LIGANDS[i_cpdmacro]
          M_cross = Score(T_apfdist.mol field)
          LIGANDS.Score[i_cpdmacro] =  -Sqrt(Abs(2.*Mean(M_cross [Nof(M_cross)][1:Nof(M_cross)-1]) / (r_tmpl +  M_cross [Nof(M_cross), Nof(M_cross)])))
          delete T_apfdist[Nof(T_apfdist)]
        endfor
        if (@["l_apfscore"]) then
          R_restmp = R_restmp*-LIGANDS.Score
        else
          R_restmp = LIGANDS.Score
        endif
        delete T_apfdist
      endif
      if (Type(T_tmpmacro) == "unknown") then
        group table T_tmpmacro LIGANDS.mol "mol" R_restmp "min" Iarray(Nof(LIGANDS) 1) "tmpl" Rarray(Nof(LIGANDS) 0.) "tmp" Rarray(Nof(LIGANDS) 0.) "val"
        add column T_tmpmacro Parray(rarray Nof(T_tmpmacro)) name="ATOM_CONTRIB"
      else
        T_tmpmacro.tmp = R_restmp
        T_tmpmacro.min = Min(T_tmpmacro.min T_tmpmacro.tmp)
        T_tmpmacro.tmpl[Index(T_tmpmacro.min == T_tmpmacro.tmp)] = i_tmplcl
        T_tmpmacro.mol[Index(T_tmpmacro.min == T_tmpmacro.tmp)] = LIGANDS.mol[Index(T_tmpmacro.min == T_tmpmacro.tmp)]
      endif
      delete system s_dir + s_obfile
      if (@["l_progress"]) print bar i_noftmplcl l_info=yes
    endfor
    delete system s_dir + s_infile
    set directory s_dir
    delete system Sarray( s_dockdir + "/*" directory )
    delete directory s_dockdir
    if (@["l_qsar"]) then
      for i_tmplcl = 1, i_noftmplcl
        if (Nof(T_tmpmacro.tmpl==i_tmplcl)==0) continue
        s_mod = "mod"+String(i_tmplcl)
        if (Type(MolApfQsar) != "unknown") rename MolApfQsar "MolApfQsartmp"
        MolApfQsar = @[s_mod]
        MolApfQsar["ATOM_CONTRIB"] = yes
        T_tmpmacro2 = Predict( T_tmpmacro.mol[Index(T_tmpmacro.tmpl==i_tmplcl)] MolApfQsar)
#        T_tmpmacro.val[Index(T_tmpmacro.tmpl==i_tmplcl)] = Predict( T_tmpmacro.mol[Index(T_tmpmacro.tmpl==i_tmplcl)] MolApfQsar)
        T_tmpmacro.val[Index(T_tmpmacro.tmpl==i_tmplcl)] = T_tmpmacro2.MolApfQsar
        T_tmpmacro.ATOM_CONTRIB[Index(T_tmpmacro.tmpl==i_tmplcl)] = T_tmpmacro2.ATOM_CONTRIB
        delete MolApfQsar
        delete T_tmpmacro2 l_warn=no
#      T_tmpmacro.val[Index(T_tmpmacro.tmpl==i_tmplcl)] = Predict( T_tmpmacro.mol[Index(T_tmpmacro.tmpl==i_tmplcl)] @[s_mod])
      endfor
      T_tmpmacro.val[Index(T_tmpmacro.val>20.)] = Toreal("ND")
      if (Type(MolApfQsartmp) != "unknown") rename MolApfQsartmp "MolApfQsar"
      if (Exist(@,"APFcutoff")) then
        if (Exist(@,"QSARbase")) then
          T_tmpmacro.val[Index(T_tmpmacro.min>@["APFcutoff"])] =Toreal(@["QSARbase"])
        else
          T_tmpmacro.val[Index(T_tmpmacro.min>@["APFcutoff"])] =Toreal("ND")
        endif
      endif
      if (@["l_pose"]==yes) then
        add column T_tmpmacro Toreal(Sarray(Nof(T_tmpmacro) "ND")) name="MolSim"
        add column T_tmpmacro Chemical(Sarray(Nof(T_tmpmacro) "")) name="Molnn"
        if ((@["l_apfsim"]==yes)&(Exist(@ "MOL"))) then
          group table T_tmpmacro2 @["MOL"] "mol" Toreal(@["PKD"]) "PKD"
          T_tmpmacro2 = T_tmpmacro2.PKD > 5.
          if (Nof(T_tmpmacro2)>0) then
            if(Nof(pmf)==0)read pmf s_icmhome+"APF"
            for i_macro = 1, Nof(T_tmpmacro)
              if ((T_tmpmacro.val[i_macro]==0.)|(T_tmpmacro.val[i_macro]==Toreal("ND"))) continue
              group table T_tmpmacro3 T_tmpmacro.mol[i_macro] "mol"
              add T_tmpmacro3 T_tmpmacro2
              M_apfmacro = Score(T_tmpmacro3.mol[1] T_tmpmacro3.mol[2:$] field)
              R_selfmacro = Rarray(Nof(T_tmpmacro3) 0.)
              for i_selfmacro = 1, Nof(R_selfmacro)
                R_selfmacro[i_selfmacro] = Score(T_tmpmacro3.mol[i_selfmacro] field)[1,1]
              endfor
              add column T_tmpmacro2 Toreal(Sarray(Nof(T_tmpmacro2) "ND")) name="MolSim"
              for i_macro2 = 1, Nof(T_tmpmacro2)
                T_tmpmacro2.MolSim[i_macro2] = 1.-(R_selfmacro[1]+R_selfmacro[i_macro2+1]-2.*M_apfmacro[1,i_macro2])/(R_selfmacro[1]+R_selfmacro[i_macro2+1])
              endfor
              delete T_tmpmacro3 l_warn=no
              T_tmpmacro.MolSim[i_macro] = Max(T_tmpmacro2.MolSim)
              T_tmpmacro.Molnn[i_macro] = T_tmpmacro2.mol[Max(index T_tmpmacro2.MolSim)]
            endfor
          endif
          delete T_tmpmacro2 l_warn=no
        endif
      endif
      if (Exist(@,"modkr")) then
        if (Type(Molkr) != "unknown") rename Molkr "Molkrtmp"
        Molkr = @["modkr"]
        R_Molkr = Predict(P_mol2 Molkr)
#        T_tmpmacro.val = Max(T_tmpmacro.val Predict(P_mol2 Molkr))
        T_tmpmacro.val[Index(T_tmpmacro.val==Toreal("ND"))] = R_Molkr[Index(T_tmpmacro.val==Toreal("ND"))]
        T_tmpmacro.val[Index(T_tmpmacro.val < 3.)] = Toreal("ND")
        delete Molkr
        if (Type(Molkrtmp) != "unknown") rename Molkrtmp "Molkr"
        if ((@["l_pose"]==yes)&(@["l_apfsim"]==yes)&(Exist(@ "SMILES"))) then
          group table T_tmpmacro2 Chemical(@["SMILES"]) "mol" Toreal(@["PKD"]) "PKD"
          T_tmpmacro2 = T_tmpmacro2.PKD > 5.
          if (Nof(T_tmpmacro2)>0) then
            for i_macro = 1, Nof(T_tmpmacro)
              if ((T_tmpmacro.val[i_macro]>5.)&(T_tmpmacro.MolSim[i_macro]==Toreal("ND"))) then
                R_mindistmacro = Distance(T_tmpmacro.mol[i_macro] T_tmpmacro2.mol)[1]
                T_tmpmacro.MolSim[i_macro] = 1.-Min(R_mindistmacro)
                T_tmpmacro.Molnn[i_macro] = T_tmpmacro2.mol[Min(index R_mindistmacro)]
              endif
            endfor
          endif
          delete T_tmpmacro2 l_warn=no
        endif
      endif
      T_tmpmacro.val[Index(T_tmpmacro.val==0.)] = Toreal("ND")
    else
      T_tmpmacro.val = T_tmpmacro.min
    endif
    R_res = T_tmpmacro.val
#    if (Exist(@,"AClass")) T_tmpmacro.min = T_tmpmacro.min*@["AClass"]
#    if (Exist(@,"BClass")) T_tmpmacro.min = T_tmpmacro.min+@["BClass"]
    if (Exist(@,"r_posmean")&Exist(@,"r_posrmsd")&Exist(@,"r_negmean")&Exist(@,"r_negrmsd")&Exist(@,"r_posprior")) then
      R_postmp = -(T_tmpmacro.min-@["r_posmean"] )/@["r_posrmsd"]
      R_negtmp = -(T_tmpmacro.min-@["r_negmean"] )/@["r_negrmsd"]
      R_posabs = Max(Abs(R_postmp) Rarray(Nof(R_postmp) 0.000001))
      R_negabs = Max(Abs(R_negtmp) Rarray(Nof(R_negtmp) 0.000001))
      R_possign = Sign(R_postmp)
      R_negsign = Sign(R_negtmp)
      R_postmp = 0.5-0.5*R_possign+R_possign*((1.-Exp(-1.422*R_posabs))*Exp(-Power(R_posabs 2)/2.))/1.135/Sqrt(2.*Pi())/R_posabs
      R_negtmp = 0.5-0.5*R_negsign+R_negsign*((1.-Exp(-1.422*R_negabs))*Exp(-Power(R_negabs 2)/2.))/1.135/Sqrt(2.*Pi())/R_negabs
      T_tmpmacro.min = (@["r_posprior"]*R_postmp)/(@["r_posprior"]*R_postmp+(1.-@["r_posprior"])*R_negtmp)
    else
      if (Exist(@,"AClass")) T_tmpmacro.min = T_tmpmacro.min*@["AClass"]
      if (Exist(@,"BClass")) T_tmpmacro.min = T_tmpmacro.min+@["BClass"]
    endif
    if (Exist(@,"A")) R_res = R_res*@["A"]
    if (Exist(@,"B")) R_res = R_res+@["B"]
    s_tmppref =  Replace(@["model"] "dfa" "")+"_dfa"
    if (@["l_progress"]) print bar "done\n"  l_info=yes
    if (@["l_pose"]==yes) then
      return Collection("0" R_res Replace(@["model"] "dfa" "")+"_dfc" T_tmpmacro.min s_tmppref+"_pose" T_tmpmacro.mol s_tmppref+"_cl" T_tmpmacro.tmpl "ATOM_CONTRIB" T_tmpmacro.ATOM_CONTRIB "MolSim" T_tmpmacro.MolSim "Molnn" T_tmpmacro.Molnn)
    else
      return Collection("0" R_res Replace(@["model"] "dfa" "")+"_dfc" T_tmpmacro.min)
    endif
endfunction
#
macro make_dfzBG  s_target s_proj ("") os_obj (as_graph) l_addtomodel (yes) auto
  l_info = l_warn = no
  s_target = Trim(s_target all)
  if (s_target=="") return "Please specify the model name"
  if (s_target[1:3]=="dfz") s_target=Replace(s_target "dfz" "")
  s_proj = Trim(s_proj all)
  if (s_proj=="") then
    if (Nof(os_obj)>0) os_obj = Obj(os_obj)
    if (Nof(os_obj)==0) return "Please specify valid ligand object as APF template, or specify Pocketome Name"
  endif
  s_tmpfolder = s_tempDir+s_target
  if Exist(s_tmpfolder) then
    if (Match(Version() "/Win")!="") then
      s_cmd = "rmdir /s /q \""+s_tmpfolder+"\""; Unix(s_cmd)
    else
      sys rm -r $s_tmpfolder
    endif
  endif
  make directory s_tmpfolder
  fname_out = s_tempDir+s_target+"/dfz"+s_target+".icb"
  S_arg =Sarray(1 "output="+fname_out)
  S_arg //="mod="+"dfz"+s_target
  if (s_proj!="") then
    S_arg //="proj="+s_proj
  endif
  if (Nof(os_obj)>0) then
    fname_ob = s_tempDir+s_target+"/input.ob"
    write object os_obj fname_ob
    S_arg //= "obj="+fname_ob
  endif
  s_targetmod = "dfz"+s_target
  if ((l_addtomodel)&(Type($s_targetmod)=="parray")) write binary $s_targetmod fname_out
  s_cmd = Path(macro, "-P"+s_icmhome, s_icmhome+"models/make_dfz.icm", S_arg)
  make background s_cmd info="dfz model generation finished for target "+s_target+", please save the model to "+Split(TOOLS.modelsDir ";")[$]+" directory" command="read binary " + String(fname_out string)
  print " Info> dfz model generation started in background. You will be notified when the job is complete."
#  set directory s_dirold
endmacro
#
  function pred_multidfz P_mol
    R_res = Rarray(Sarray(Nof(P_mol),"ND"))
    if (!Exist(@,"ob1")) return R_res
    s_obfile = "T_ob"+String(Iproc())+".ob"
    s_infile = "T_in"+String(Iproc())+".sdf"
    s_oufile = "T_ou"+String(Iproc())+".icb"
    s_dir = ""
    i_noftmplcl = Nof(@["A"])
    group table T_tmp P_mol "mol"
    group table T_tmppose T_tmp.mol "mol" Toreal(Sarray(Nof(T_tmp) "ND")) "Score" Iarray(Nof(T_tmp) 0) "cl"
    write table mol T_tmp s_dir+s_infile delete
    if Exist(@ "effort") then
      S_cmdargs = Sarray(1 "effort="+Tostring(@["effort"]))
    else
      S_cmdargs = Sarray(1 "effort=2.")
    endif
    S_cmdargs = S_cmdargs // "-r" // "-S" // "-e"
    if (@["l_charge"]==yes) S_cmdargs //= "-c"
    if (@["l_mmffstrain"]==yes) S_cmdargs //= "-F"
    for i_tmplcl = 1, i_noftmplcl
      s_ob = "ob"+String(i_tmplcl)
      write object @[s_ob] s_dir+s_obfile delete
      s_cmd = Path(macro, "-s", s_icmhome + "_chemSuper", s_dir + s_obfile, s_dir + s_infile, s_dir +  s_oufile, S_cmdargs )
      s_out = Unix(s_cmd)
      delete system s_dir + s_obfile
      if (Exist(s_dir+s_oufile)) then
        read binary s_dir +s_oufile
        delete system s_dir + s_oufile
      endif
      if (Type(LIGANDS) == "unknown") continue
      if  (@["l_envelope"]==yes) LIGANDS.Score = LIGANDS.Score + LIGANDS.Steric
      if  (@["l_mmffstrain"]==yes) LIGANDS.Score = LIGANDS.Score + LIGANDS.Strain
      if (i_tmplcl==1) then
        T_tmppose.Score = LIGANDS.Score*@["A"][1]+@["B"][1]; T_tmppose.mol = LIGANDS.mol; T_tmppose.cl=Iarray(Nof(T_tmppose) 1)
      else
        for i_cpdtmp = 1, Nof(T_tmp)
          if (LIGANDS.Score[i_cpdtmp]*@["A"][i_tmplcl]+@["B"][i_tmplcl]<=T_tmppose.Score[i_cpdtmp]) continue
          T_tmppose.Score[i_cpdtmp] = LIGANDS.Score[i_cpdtmp]*@["A"][i_tmplcl]+@["B"][i_tmplcl]; T_tmppose.cl[i_cpdtmp] = i_tmplcl;
          T_tmppose.mol[i_cpdtmp] = LIGANDS.mol[i_cpdtmp]
        endfor
      endif
    endfor
    delete system s_dir + s_infile
    R_res = T_tmppose.Score
    if (@["l_pose"]==yes) then
       s_tmppref =  Replace(@["model"] "dfz" "")+"_dfz"
       return Collection("0" R_res s_tmppref+"_pose" T_tmppose.mol s_tmppref+"_cl" T_tmppose.cl)
    else
      return R_res
    endif
  endfunction
#
function pred_qsar P_mol
  R_res = Rarray(Sarray(Nof(P_mol),"ND"))
  P_atomContrib = Parray(rarray Nof(P_mol))
  # maps
  for i=1,7
    s_map = "m_g" + i
    $s_map = @[s_map]
  endfor
  l_atomContrib = Exist( @ "ATOM_CONTRIB" ) & @["ATOM_CONTRIB"]
  for i=1,Nof(P_mol)
    read mol P_mol[i] name="tmpqsarlig"
    set field a_//!h* Count(Nof(a_//!h*)) name="ord"
    build hydrogen
    set type charge mmff
    convert auto
    show energy "gp" mute
    R_res[i] = Energy("ener")
    if (l_atomContrib) then
      show energy "gp" atom mute
      as_sel = a_//!vt*,!h*
      add column tmp_ord Iarray(Field( as_sel "ord" )) Bfactor( as_sel ) - 20.
      sort tmp_ord.A
      P_atomContrib[i] = tmp_ord.B
      delete a_
      delete tmp_ord
    endif
  endfor
  if (l_atomContrib) then
    return Collection("pred", R_res, "ATOM_CONTRIB" P_atomContrib )
  else
    return R_res
  endif
endfunction
#
macro msdpcZScore s_modname ("") auto
HELP = """
  adding ZScore components to an empty dpc model that was generated from Docking->Export as Model
  Empty dpc models contain only the docking component and report raw docking score in molScreen
  This macro takes the model, dock the approved drug list to it, and use the docking score to calculate the Z-Score factor A and B
  Syntax:
    msdpcZscore <s_modname>
"""
  l_info=no; l_commands=no; l_warn=no
  s_modname = Trim(s_modname all)
  if (s_modname == "") return "Please specify the model name"
  l_loaded = yes
  if (Type($s_modname)!="parray") then
    l_loaded = no
    if Exist(s_modname+".icb") then
      read binary s_modname+".icb"
      s_modname =  Name(model)[$]
    elseif  Exist(s_modname) then
      read binary s_modname
      s_modname =  Name(model)[$]
    else
      return "Model specified not found"
    endif
  endif
  if (Exist($s_modname "SMILES")) then
    if (!l_loaded) delete $s_modname
    return "SMILES already exist in model, cannot proceed, this macro is only for populating empty dpc models"
  endif
  read binary s_icmhome+"models/DBapproved.icb"
  predict DBapproved $s_modname
  if (Type(DBapproved.$s_modname)!="rarray") return "Docking failed, there might be something wrong with the dpc model"
  r_mean = Mean(DBapproved.$s_modname)
  r_rmsd = Rmsd(DBapproved.$s_modname)
  r_A = -1./r_rmsd
  r_B = r_mean/r_rmsd
  $s_modname["A"] = r_A
  $s_modname["B"] = r_B
  $s_modname["l_ZScore"] = yes
  $s_modname["SMILES"] = Smiles(DBapproved.mol unique cistrans)
  $s_modname["ZPRED"] = DBapproved.$s_modname * r_A + r_B
  print "Finished. Please save the model:" s_modname "to another folder specified in TOOLS.modelsDir:" TOOLS.modelsDir
  keep $s_modname
endmacro
#
macro updatedfa s_dir ("") P_parameters (Collection()) auto
HELP = """
  updatedfa <s_dir> <P_parameters>

  Update the dfa model in the <s_dir> directory to the latest function, as well as updating the MolApfQsar models inside
  Save the updated model back to the <s_dir> directory, please make sure you have write access to that directory
  if using Linux version, will zip it using gzip to reduce size
  Additional changes can be made in the section below using the format:
  $s_mod["XXX"] = YYY
  or using the <P_parameters> to set the properties within the models

  example:
  updatedfa                                                        # update the dfa models in the current folder
  updatedfa '/data/model/' Collection('effort',2.,'l_charge',no )  # update the dfa models in the /data/model/ folder, set the 'effort' to 2, and l_charge to no
"""
  l_info = no; l_commands = no; l_warn = no
  if (s_dir == "") s_dir = Path()
  if (s_dir[$]!="/") s_dir = s_dir+"/"
  if !Exist(s_dir) return "Directory specified does not exist"
  if (Type(pred_dfa)!="macro") call s_icmhome+"_macro"
  if (Type(pred_qsar)!="macro") call s_icmhome+"_macro"
  l_zip = no
  if (Match(Version() " UNIX " ) != "") then
    read sys which gzip

    if (s_out != "") l_zip = yes
  endif
  S_mod = Sarray(s_dir+"dfa*.icb" directory)
  if (Nof(S_mod)==0) return "No model found"
  N = Nof(S_mod)
  sprintf " Info> Processing %d models",N
  print bar s_out  N l_info=yes
  for i_mod = 1, Nof(S_mod)
    s_mod = Name(S_mod[i_mod])
    read binary S_mod[i_mod]
    if (Type($s_mod)!="parray") then
      delete $s_mod l_warn=no; continue
    endif
    $s_mod["SCRIPT"] = String(pred_dfa)
    i_noftmplcl = $s_mod["NOF_TMPLCL"]
    for i_tmplcl = 1, i_noftmplcl
      s_modcl = "mod"+String(i_tmplcl)
      if Exist($s_mod s_modcl) then
        MolApfQsar = $s_mod[s_modcl]
        MolApfQsar["SCRIPT"] = String(pred_qsar)
        $s_mod[s_modcl] = MolApfQsar
        delete MolApfQsar l_warn=no
      endif
    endfor
#Optional additional changes
    $s_mod["effort"] = 2.
    $s_mod["PARAMETERS"] = {"l_charge","effort"}
    $s_mod["l_apfsim"] = yes
    for i_collection = 1, Nof(P_parameters)
      s_parameter = Name(P_parameters)[i_collection]
      $s_mod[s_parameter] = P_parameters[s_parameter]
    endfor
#End additional changes
    write binary $s_mod S_mod[i_mod] delete
    if (l_zip) then
      s_modicb = S_mod[i_mod]
      s_modicbgz = s_modicb+".gz"
      sys gzip $s_modicb

      sys mv $s_modicbgz $s_modicb

    endif
    delete $s_mod l_warn=no
    print bar N  l_info=yes
  endfor
  print bar "done\n"  l_info=yes
endmacro
#
macro updatedpc s_dir ("") P_parameters (Collection()) auto
HELP = """
  updatedpc <s_dir> <P_parameters>

  Update the dpc model in the <s_dir> directory to the latest function, as well as updating the MolApfQsar models inside
  Save the updated model back to the <s_dir> directory, please make sure you have write access to that directory
  if using Linux version, will zip it using gzip to reduce size
  Additional changes can be made in the section below using the format:
  $s_mod["XXX"] = YYY
  or using the <P_parameters> to set the properties within the models

  example:
  updatedpc                                                             # update the dpc models in the current folder
  updatedpc '/data/model/' Collection('dock.effort',2.,'l_charge',no )  # update the dfa models in the /data/model/ folder, set the 'dock.effort' to 2, and l_charge to no
"""
  l_info = no; l_commands = no; l_warn = no
  if (s_dir == "") s_dir = Path()
  if (s_dir[$]!="/") s_dir = s_dir+"/"
  if !Exist(s_dir) return "Directory specified does not exist"
  if (Type(pred_dock)!="macro") call s_icmhome+"_docking"
  if (Type(pred_qsar)!="macro") call s_icmhome+"_macro"
  l_zip = no
  if (Match(Version() " UNIX " ) != "") then
    read sys which gzip
    if (s_out != "") l_zip = yes
  endif
  S_mod = Sarray(s_dir+"dpc*.icb" directory)
  if (Nof(S_mod)==0) return "No model found"
  N = Nof(S_mod)
  sprintf " Info> Processing %d models",N
  print bar s_out  N l_info=yes
  for i_mod = 1, Nof(S_mod)
    s_mod = Name(S_mod[i_mod])
    read binary S_mod[i_mod]
    if (Type($s_mod)!="parray") then
      delete $s_mod l_warn=no; continue
    endif
    $s_mod["SCRIPT"] = String(pred_dock)
    if Exist($s_mod "mod1") then
      MolApfQsar = $s_mod["mod1"]
      MolApfQsar["SCRIPT"] = String(pred_qsar)
      $s_mod["mod1"] = MolApfQsar
      delete MolApfQsar l_warn=no
    endif
#Optional additional changes
    $s_mod["dock.effort"] = 2.
    $s_mod["l_apfsim"] = yes
    $s_mod["PARAMETERS"] = {"dock.*", "l_*"}
    for i_collection = 1, Nof(P_parameters)
      s_parameter = Name(P_parameters)[i_collection]
      $s_mod[s_parameter] = P_parameters[s_parameter]
    endfor
#End additional changes
    write binary $s_mod S_mod[i_mod] delete
    if (l_zip) then
      s_modicb = S_mod[i_mod]
      s_modicbgz = s_modicb+".gz"
      sys gzip $s_modicb

      sys mv $s_modicbgz $s_modicb

    endif
    delete $s_mod l_warn=no
    print bar N  l_info=yes
  endfor
  print bar "done\n"  l_info=yes
endmacro
#
macro make_localdpcBG  s_target ("") s_table ("LIG") s_activityColumn ("pkd") s_proj ("") os_obj (as_graph) l_localtable (yes) s_unit ("pKd") l_charge (yes) l_fromproject (yes) auto
  l_info = l_warn = no
  s_target = Trim(s_target all)
  if (s_target=="") return "Please specify the model name"
  if (s_target[1:3]=="dpc") s_target=Replace(s_target "dpc" "")
  s_table = Trim(s_table all)
  if (s_table=="") return "Please specify the chemical table name"
  if (Type($s_table)=="unknown") return "Table " s_table "not found"
  delete T_tmplig l_warn=no; T_tmplig = $s_table
  s_activityColumn = Trim(s_activityColumn all)
  if (s_activityColumn == "") return "Please specify activity column name"
  if (Type(T_tmplig.$s_activityColumn)=="unknown") return "Activity column " s_activityColumn "not found"
  s_proj = Trim(s_proj all)
  if (l_fromproject) then
    if (s_proj == "") return "Please specify either docking project/pocketome entry name"
  else
    os_obj = Obj(os_obj)
    if (Nof(os_obj)==0) return "Please specify valid receptor object as input for docking"
  endif
  if (l_localtable) then
    if (Type(T_tmplig.mol 2 )=="2D") then
      l_3D=no
    else
      l_3D=yes
    endif
    if (s_unit == "pKd") then
      add column T_tmplig T_tmplig.$s_activityColumn name="value"
    elseif (s_unit == "mM") then
      add column T_tmplig  3.-Log(Abs(T_tmplig.$s_activityColumn) 10) name="value"
    elseif (s_unit == "uM") then
      add column T_tmplig  6.-Log(Abs(T_tmplig.$s_activityColumn) 10) name="value"
    elseif (s_unit == "nM") then
      add column T_tmplig  9.-Log(Abs(T_tmplig.$s_activityColumn) 10) name="value"
    endif
    sort T_tmplig.mol
    add column T_tmplig function="MolWeight(mol)" index=2 name="molWeight" append format="%.3f"
    add column T_tmplig function="Nof_RotB(mol)" index=2 name="nof_RotB" append
    T_tmplig = T_tmplig.molWeight <= 700. & T_tmplig.nof_RotB <= 15
    if (Nof(T_tmplig)==0) return "No data found after filtering off MW>700 & nof_RotB>15 for target" s_target
    if ((!l_3D)&(l_charge)) set charge formal auto T_tmplig.mol 7.0
    if (s_table == "LIG") then; delete T_LIGtmp l_warn=no; rename LIG "T_LIGtmp";endif
    if (Type(T_tmplig.Score)!="unknown") then
      group T_tmplig.mol T_tmplig.Score "min,Score" T_tmplig.value "count,count" T_tmplig.value "min,min" T_tmplig.value "max,max" T_tmplig.value "mean,mean" T_tmplig.value "rmsd,rmsd" name="LIG"
    else
      group T_tmplig.mol T_tmplig.value "count,count" T_tmplig.value "min,min" T_tmplig.value "max,max" T_tmplig.value "mean,mean" T_tmplig.value "rmsd,rmsd" name="LIG"
    endif
    add column LIG Rarray(Nof(LIG)) name="value"
#    if (Type(T_tmplig.Score)!="unknown") add column LIG T_tmplig.Score name="Score" index=2
    for i_macro = 1, Nof(LIG)
      tmp = T_tmplig.mol == LIG.mol [i_macro]
      sort tmp.value reverse
      LIG.value [i_macro] = tmp.value [Integer(Ceil(Nof(tmp) * 0.2))]
      delete tmp
    endfor
    rename LIG.value "pkd"; delete T_tmplig
  endif
  s_tmpfolder = s_tempDir+s_target
  if Exist(s_tmpfolder) then
    if (Match(Version() "/Win")!="") then
      s_cmd = "rmdir /s /q \""+s_tmpfolder+"\""; Unix(s_cmd)
    else
      sys rm -r $s_tmpfolder
    endif
  endif
#  s_cmd = "mkdir \""+s_tmpfolder+"\""; Unix(s_cmd)
  make directory s_tmpfolder
#  fname_in = Name(system s_tempDir+s_target+"/LIG.sdf")
  fname_in = s_tempDir+s_target+"/LIG.sdf"
  fname_out = s_tempDir+s_target+"/dpc"+s_target+".icb"
  write table mol LIG fname_in delete
  if (Type(T_LIGtmp)!="unknown") then; rename LIG Name("LIG" unique); rename T_LIGtmp LIG; endif
#  s_dirold = Path()
#  set directory s_tmpfolder
  S_arg = Sarray(1 "pkd="+fname_in)
  S_arg //="output="+fname_out
  S_arg //="mod="+"dpc"+s_target
  if (s_proj!="") then
    S_arg //="proj="+s_proj
  endif
  if (Nof(os_obj)>0) then
    fname_ob = s_tempDir+s_target+"/input.ob"
    write object os_obj fname_ob
    S_arg //= "obj="+fname_ob
  endif
  if (!l_charge) S_arg //= "-nocharge"
  s_cmd = Path(macro, "-P"+s_icmhome, s_icmhome+"models/make_localdpc.icm", S_arg)
  make background s_cmd info="local (4D/2D) dpc model generation finished for table "+s_table+", please save the model to "+Split(TOOLS.modelsDir ";")[$]+" directory" command="read binary " + String(fname_out string)
  print " Info> local (4D/2D) dpc model generation started in background. You will be notified when the job is complete."
#  set directory s_dirold
endmacro
#
macro make_kcaBG s_target s_table ("LIG") s_activityColumn ("pkd") l_ChEMBLKdtopKd (yes)
  l_info = l_warn = no
  if (Type($s_table)=="unknown") return "Table " s_table "not found"
  delete T_tmplig; T_tmplig = $s_table
  if (l_ChEMBLKdtopKd) then
    if (Type(T_tmplig.standard_unit)!="unknown") T_tmplig = T_tmplig.standard_unit=="nM"
    if (Type(T_tmplig.standard_value)!="unknown") then
      add column T_tmplig 9.-Log(T_tmplig.standard_value 10) name="value" index=2
    else
      add column T_tmplig 9.-Lig(T_tmplig.$s_activityColumn 10) name="value"
    endif
  else
    add column T_tmplig T_tmplig.$s_activityColumn name="value"
  endif
  sort T_tmplig.mol
  add column T_tmplig function="MolWeight(mol)" index=2 name="molWeight" append format="%.3f"
  add column T_tmplig function="Nof_RotB(mol)" index=2 name="nof_RotB" append
  T_tmplig = T_tmplig.molWeight <= 700. & T_tmplig.nof_RotB <= 15
  if (Nof(T_tmplig)==0) return "No ChEMBL data found after filtering off MW>700 & nof_RotB>15 for target" s_target
  set charge formal auto T_tmplig.mol 7.0
  if (s_table == "LIG") then; delete T_LIGtmp; rename LIG "T_LIGtmp";endif
  group T_tmplig.mol T_tmplig.value "count,count" T_tmplig.value "min,min" T_tmplig.value "max,max" T_tmplig.value "mean,mean" T_tmplig.value "rmsd,rmsd" name="LIG"
  add column LIG Rarray(Nof(LIG)) name="value"
  for i_macro = 1, Nof(LIG)
    tmp = T_tmplig.mol == LIG.mol [i_macro]
    sort tmp.value reverse
    LIG.value [i_macro] = tmp.value [Integer(Ceil(Nof(tmp) * 0.2))]
    delete tmp
  endfor
  rename LIG.value "pkd"; delete T_tmplig
  s_tmpfolder = s_tempDir+s_target
  if Exist(s_tmpfolder) then
    if (Match(Version() "/Win")!="") then
      s_cmd = "rmdir /s /q \""+s_tmpfolder+"\""; Unix(s_cmd)
    else
      sys rm -r $s_tmpfolder
    endif
  endif
  s_cmd = "mkdir \""+s_tmpfolder+"\""; Unix(s_cmd)
  fname_in = Name(system s_tempDir+s_target+"/LIG.sdf")
  fname_out = s_tempDir+s_target+"/kca"+s_target+".icb"
  write table mol LIG fname_in delete
  if (Type(T_LIGtmp)!="unknown") then; delete LIG; rename T_LIGtmp LIG; endif
  s_dirold = Path()
  set directory s_tmpfolder
  s_cmd = Path(macro, "-P"+s_icmhome, s_icmhome+"models/make_kca.icm","pkd="+fname_in,"decoy="+s_icmhome+"models/DBapproved.icb")
  make background s_cmd info="kca fingerprint model generation finished for table "+s_table+", please save the model to "+Split(TOOLS.modelsDir ";")[$]+" directory" command="read binary " + String(fname_out string)
  print " Info> kca fingerprint model generation started in background. You will be notified when the job is complete."
  set directory s_dirold
endmacro
#
macro msChEMBLtarget s_target ("") S_target (Sarray(0)) r_pkdcutoff (0.) auto
HELP = """
  Find ChEMBL compounds with the supplied list of targets, either pKd value for the listed target or 1/0 class is presented
  Syntax:
  <s_target>|<S_target> : Target Uniprot Prefix, regexp can be used
  <r_pkdcutoff>         : If 0., pKd value will be presented, if >0., it will be used to classify compounds into active or inactive 1./0.
  Example:
  msChEMBLtarget 'VGFR*'
  msChEMBLtarget {'VGFR*','CDK[1-3]','ESR1'}
  msChEMBLtarget 'VGFR*' 5. # Compounds with pKd >= 5. will be classified as active (1.); < 5. will be inactive (0.)
"""
  l_info = l_commands = l_warn = no
  if (!Exist(s_icmhome+"/models/ChEMBL.icb")) return "Cannot find ChEMBL.icb in icmhome models directory"
  s_target = Trim(s_target all)
  if ((s_target == "") & (S_target == Sarray(0))) return "Please specify either a single target or sarray of targets"
  if (Type(ChEMBL)=="unknown") then
    read binary s_icmhome+"/models/ChEMBL.icb"
    l_loaded = no
  else
    l_loaded = yes
  endif
  S_targetlist = Sarray(0)
  if ((S_target!=Sarray(0)) & (s_target!="")) then
    S_target //= s_target
  elseif (s_target!="") then
    S_target = Sarray(1 s_target)
  endif
  for i_target = 1, Nof(S_target)
    s_target = S_target[i_target]
    if (s_target != "") then
      T_t1macro = ChEMBL.pkd ~ s_target+":*" | ChEMBL.pkd ~ "*\n"+s_target+":*"
      if (Nof(T_t1macro)!=0) then
        group table T_t2macro Unique(Sort(Field(Split(Sum(T_t1macro.pkd "\n" ) "\n") 1 ":"))) "targets"
        S_targetlist //= T_t2macro.targets [Index(T_t2macro.targets ~s_target)]
        delete T_t2macro l_warn=no
      endif
      delete T_t1macro l_warn=no
    endif
  endfor
  if (Nof(S_targetlist)==0) return "Cannot find any compound for the target listed"
  S_targetlist = Unique(Sort(S_targetlist))
  I_tmpmacro = Iarray(0)
  for i_target = 1, Nof(S_targetlist)
    s_target = S_targetlist[i_target]
    I_tmpmacro //= Index(ChEMBL.pkd ~ s_target+":*" | ChEMBL.pkd ~ "*\n"+s_target+":*")
  endfor
  I_tmpmacro = Unique(Sort(I_tmpmacro))
  T_t1macro = ChEMBL[I_tmpmacro]
  if (!l_loaded) delete ChEMBL l_warn=no
  group table T_t2macro Field(Split(Sum(T_t1macro.pkd "\n" ) "\n") 1 ":") "targets" Toreal(Field(Split(Sum(T_t1macro.pkd "\n" ) "\n") 2 ":")) "pkd"
  s_pKdcomment = "pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND indicates unknown"
  s_actcomment = "Active/Inactive classification based on a pKd cutoff of "+Tostring(r_pkdcutoff)+"\n1. indicates active, 0. indicates inactive\nND indicates unknown"
  for i_target = 1, Nof(S_targetlist)
    s_target = S_targetlist[i_target]
    I_tmpmacro = Index(T_t1macro.pkd ~ s_target+":*" | T_t1macro.pkd ~ "*\n"+s_target+":*")
    I_tmpmacro2 = Index(T_t2macro.targets == s_target)
    if (Nof(I_tmpmacro2)!=Nof(I_tmpmacro)) continue
    add column T_t1macro Toreal(Sarray(Nof(T_t1macro) "")) name=s_target
    i_tmp = Index(T_t1macro.S_Uniprot s_target)
    s_comment = ""
    if (i_tmp!=0) then
      s_comment = T_t1macro.S_Fullname[i_tmp]+"\n"
    endif
    set format T_t1macro.$s_target "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_comment+s_pKdcomment
    T_t1macro.$s_target[I_tmpmacro] = T_t2macro.pkd[I_tmpmacro2]
    if (r_pkdcutoff > 0.) then
      T_t1macro.$s_target[Index(T_t1macro.$s_target < r_pkdcutoff )] = 0.
      T_t1macro.$s_target[Index(T_t1macro.$s_target >= r_pkdcutoff )] = 1.
      set format T_t1macro.$s_target "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,0.:1.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_comment+s_actcomment
    endif
  endfor
  for i_target = 1, Nof(S_targetlist)
    s_target = S_targetlist[Nof(S_targetlist)-i_target+1]
    if (Type(T_t1macro.$s_target)!="unknown") sort reverse T_t1macro.$s_target
  endfor
  delete T_t2macro l_warn=no
  s_finaltable = Name("ChEMBLtarget" unique)
  print " Info> Converting chemicals, might take a while..."
  add column T_t1macro Chemical(T_t1macro.smiles simple) name="mol" index=2
  set property T_t1macro header
  if (Nof(T_t1macro.MOA == "")==Nof(T_t1macro)) set format T_t1macro.MOA show off
  if (Nof(T_t1macro.Indications == "")==Nof(T_t1macro)) set format T_t1macro.Indications show off
  if (Nof(T_t1macro.DrugClass == "")==Nof(T_t1macro)) set format T_t1macro.DrugClass show off
  if (Nof(T_t1macro.Warnings == "")==Nof(T_t1macro)) set format T_t1macro.Warnings show off
  rename T_t1macro s_finaltable
  keep $s_finaltable
endmacro
#
macro msChEMBLfield s_query ("") s_separator ("\n") auto
  l_info = l_warn = l_commands = no
  s_query = Trim(s_query all)
  if (s_query == "") return "Please specify a query term"
  S_query = Split(s_query s_separator)
  if (Nof(S_query)<1) return "Please specify a valid query term"
  if (Type(ChEMBL)=="unknown") then
    read binary s_icmhome+"models/ChEMBL.icb"
    l_loaded = no
  else
    l_loaded = yes
  endif
  I_tmpmacro = Iarray(0)
  for i_term = 1, Nof(S_query)
    s_term = S_query[i_term]
    if (Type(ChEMBL.MOA)!="unknown") I_tmpmacro //= Index(ChEMBL.MOA == s_term | ChEMBL.MOA ~s_term+"\n*" | ChEMBL.MOA ~"*\n"+s_term+"\n*" | ChEMBL.MOA ~"*\n"+s_term)
    if (Type(ChEMBL.Indications)!="unknown") I_tmpmacro //= Index(ChEMBL.Indications == s_term | ChEMBL.Indications ~s_term+"\n*" | ChEMBL.Indications ~"*\n"+s_term+"\n*" | ChEMBL.Indications ~"*\n"+s_term)
    if (Type(ChEMBL.DrugClass)!="unknown") I_tmpmacro //= Index(ChEMBL.DrugClass == s_term | ChEMBL.DrugClass ~s_term+"\n*" | ChEMBL.DrugClass ~"*\n"+s_term+"\n*" | ChEMBL.DrugClass ~"*\n"+s_term)
    if (Type(ChEMBL.Warnings)!="unknown") I_tmpmacro //= Index(ChEMBL.Warnings == s_term | ChEMBL.Warnings ~s_term+"\n*" | ChEMBL.Warnings ~"*\n"+s_term+"\n*" | ChEMBL.Warnings ~"*\n"+s_term)
  endfor
  group table t_tmpmacro I_tmpmacro "A"
  delete t_tmpmacro_A_freq l_warn=no
  group t_tmpmacro.A t_tmpmacro.A 'count,count' name='t_tmpmacro_A_freq'
  sort t_tmpmacro_A_freq.A
  add column t_tmpmacro_A_freq Toreal(t_tmpmacro_A_freq.count)/Nof(S_query) name="matchscore"
  T_t1macro = ChEMBL[t_tmpmacro_A_freq.A]
  add column T_t1macro t_tmpmacro_A_freq.matchscore name="matchscore"
  sort reverse T_t1macro.matchscore
  if (!l_loaded) delete ChEMBL l_warn=no
  s_pKdcomment = "pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND indicates unknown"
  s_finaltable = Name("ChEMBLfield" unique)
  print " Info> Converting chemicals, might take a while..."
  add column T_t1macro Chemical(T_t1macro.smiles simple) name="mol" index=2
  set property T_t1macro header
  if (Nof(T_t1macro.MOA == "")==Nof(T_t1macro)) set format T_t1macro.MOA show off
  if (Nof(T_t1macro.Indications == "")==Nof(T_t1macro)) set format T_t1macro.Indications show off
  if (Nof(T_t1macro.DrugClass == "")==Nof(T_t1macro)) set format T_t1macro.DrugClass show off
  if (Nof(T_t1macro.Warnings == "")==Nof(T_t1macro)) set format T_t1macro.Warnings show off
  rename T_t1macro s_finaltable
  keep $s_finaltable
endmacro
#
macro msChEMBLdrug s_drug ("")
HELP = """
  Find ChEMBL drug with matching name, chembl parent compound id, or uniprot name/prefix
  Syntax:
  <s_drug> : Drug name, ChEMBL Parent Compounds ID, or Uniprot Name/prefix
  Example:
  msChEMBLdrug 'gilter'
  msChEMBLdrug '3301622'
  msChEMBLdrug 'chembl3301622'
  msChEMBLdrug 'FLT3'
  msChEMBLdrug 'VGFR*'
"""

  l_info = l_commands = l_warn = no
  s_drug = Trim(s_drug)
  if (Type(ChEMBLDrug)!="unknown") then
    l_loaded = yes
  else
    l_loaded = no
    read binary s_icmhome+"/models/ChEMBLDrug.icb"
  endif
  if (s_drug=="") then
    keep ChEMBLDrug
    return
  endif
  I_tmp  = Index(Index(ChEMBLDrug.Name s_drug simple ) 1 all)
  if (Nof(I_tmp)==0) I_tmp = Index(ChEMBLDrug.Parent_Molecule Toupper(s_drug) all)
  if (Nof(I_tmp)==0) I_tmp = Index(ChEMBLDrug.Parent_Molecule "CHEMBL"+Toupper(s_drug) all)
  if (Nof(I_tmp)==0) then
    I_tmp //= Index(Index(ChEMBLDrug.Synonyms ".*"+s_drug+"|" regexp ) 1 all)
    I_tmp //= Index(Index(ChEMBLDrug.Synonyms ".*"+Toupper(s_drug)+"|" regexp ) 1 all)
    I_tmp //= Index(Index(ChEMBLDrug.Synonyms ".*"+Tolower(s_drug)+"|" regexp ) 1 all)
    I_tmp //= Index(Index(ChEMBLDrug.Synonyms ".*"+Toupper(Tolower(s_drug) 1)+"|" regexp ) 1 all)
    I_tmp //= Index(Index(ChEMBLDrug.Research_Codes ".*"+s_drug+"|" regexp ) 1 all)
    I_tmp //= Index(Index(ChEMBLDrug.Research_Codes ".*"+Toupper(s_drug)+"|" regexp ) 1 all)
    I_tmp //= Index(Index(ChEMBLDrug.Research_Codes ".*"+Tolower(s_drug)+"|" regexp ) 1 all)
    I_tmp //= Index(Index(ChEMBLDrug.Research_Codes ".*"+Toupper(Tolower(s_drug) 1)+"|" regexp ) 1 all)
  endif
  if (Nof(I_tmp)==0) then
    I_tmp = Index(ChEMBLDrug.MOA ~ Toupper(s_drug)+":*" | ChEMBLDrug.MOA ~ "*\n"+Toupper(s_drug)+":*" | ChEMBLDrug.MOA ~ Toupper(s_drug)+"_*" | ChEMBLDrug.MOA ~ "*\n"+Toupper(s_drug)+"_*" )
    I_tmp //= Index(ChEMBLDrug.ChEMBL_pKd ~ Toupper(s_drug)+":*" | ChEMBLDrug.ChEMBL_pKd ~ "*\n"+Toupper(s_drug)+":*" | ChEMBLDrug.ChEMBL_pKd  ~ Toupper(s_drug)+"_*" | ChEMBLDrug.ChEMBL_pKd  ~ "*\n"+Toupper(s_drug)+"_*" )
  endif
  if (Nof(I_tmp)==0) then
    if (!l_loaded) delete ChEMBLDrug l_warn=no
    return "Cannot find any matching drug"
  endif
  s_finaltable = Name("ChEMBLDrug_"+s_drug unique)
  I_tmp = Unique(Sort(I_tmp))
  $s_finaltable = ChEMBLDrug[I_tmp]
  keep $s_finaltable
  if (!l_loaded) delete ChEMBLDrug l_warn=no
endmacro
#
macro msChEMBLcpd P_mol (Chemical("")) S_smiles (Sarray(0)) r_tanisimilarity (0.6) auto
HELP = """
  Find ChEMBL Compounds that are similar to the query compounds

  Syntax:
  <P_mol>            : Query compounds and/or
  <S_smiles>         : Smiles of query compounds
  <r_tanisimilarity> : Tanimoto Fingerprint Similarity used to define 'similar'

  Example:
  msChEMBLcpd t1.mol

  Output:
  ChEMBLorig:    Chemical table of the original query molecules, can doubleclick to focus on specific compound
  ChEMBLsimilar: Chemical table of all the similar compounds.
"""
  l_info = l_commands = l_warn = no
  if (!Exist(s_icmhome+"/models/ChEMBL.icb")) return "Cannot find ChEMBL.icb in icmhome models directory"
  if (Nof(P_mol)==0) return "Please specify chemical(s)"
  if ((P_mol == Chemical("")) & (S_smiles == Sarray(0))) return "Please either specify compounds or smiles"
  if ((P_mol != Chemical("")) & (S_smiles != Sarray(0))) then
    P_mol //= Chemical(S_smiles smiles)
  elseif ((P_mol == Chemical("")) & (S_smiles != Sarray(0))) then
    P_mol = Chemical(S_smiles smiles)
  endif
  if ((r_tanisimilarity < 0.) | (r_tanisimilarity > 1.)) return "Please specify a Tanimoto Similarity cutoff between 0. and 1."
  group table T_t1macro P_mol "mol"
  modify T_t1macro.mol delete salt
  modify T_t1macro.mol delete salt simple
  delete hydrogen T_t1macro.mol
  modify T_t1macro.mol auto
  modify T_t1macro.mol delete charge
  T_t1macro = T_t1macro.mol != Chemical("")
  if (Nof(T_t1macro)==0) return "Please specify valid chemicals"
  add column T_t1macro Count(Nof(T_t1macro)) name="idx"
  add column T_t1macro Descriptor(T_t1macro.mol) name="Desc"
  set format show off T_t1macro.Desc
  if (Type(ChEMBL)=="unknown") then
    read binary s_icmhome+"/models/ChEMBL.icb"
    l_loaded = no
  else
    l_loaded = yes
  endif
  M_dist = Distance(T_t1macro.Desc ChEMBL.Desc)
  I_tmpmacro = Iarray(0)
  for i_cpd = 1, Nof(T_t1macro)
    group table T_t2macro M_dist[i_cpd] "dist"
    I_tmpmacro //= Index(T_t2macro.dist <= 1.-r_tanisimilarity)
    delete T_t2macro
  endfor
  I_tmpmacro = Unique(Sort(I_tmpmacro))
  if (Nof(I_tmpmacro)==0) return "Cannot find similar compound"
  T_t2macro = ChEMBL[I_tmpmacro]
  if (!l_loaded) delete ChEMBL l_warn=no
  M_dist = Distance(T_t2macro.Desc T_t1macro.Desc)
#  add column T_t2macro Chemical(T_t2macro.smiles smiles) name="mol" index=1
  add column T_t2macro Sarray(Nof(T_t2macro ) "") name="IDX"
  for i_cpd = 1, Nof(T_t2macro)
    group table T_t3macro M_dist[i_cpd] "dist"
    T_t2macro.IDX[i_cpd] =  Sum(Tostring(Index(T_t3macro.dist <= 1.-r_tanisimilarity)) ",")
    delete T_t3macro l_warn=no
  endfor
  add header T_t1macro r_tanisimilarity name="TanimotoSimilarity"
s_doubleClick = """
s_thistable = Name(%@ table)
s_thattable = Replace(s_thistable "ChEMBLorig" "ChEMBLsimilar")
if (Type($s_thattable)!="unknown") then
  add column $s_thattable Distance(($s_thistable.mol)[%#] $s_thattable.mol)[1] name="TanimotoDist" index=9
#  find table $s_thattable index=Index(Index($s_thattable.TanimotoDist <= 1.-$s_thistable.TanimotoSimilarity) Nof($s_thattable) inverse) show off
  sort $s_thattable.TanimotoDist
  set foreground $s_thattable
endif
"""
  add header T_t1macro s_doubleClick name="doubleClick"
  set format T_t1macro.mol comment="Double Click on the mol cell to calculate its Tanimoto Distance to similar compounds"
s_doubleClick = """
s_thistable = Name(%@ table)
s_thattable = Replace(s_thistable "ChEMBLsimilar" "ChEMBLorig")
"""
#  add column T_t2macro Chemical(T_t2macro.smiles smiles) name="mol" index=1
  add header T_t2macro s_doubleClick name="doubleClick"
  s_pKdcomment = "pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND indicates unknown"
#  set format T_t2macro.pkd comment="Uniprot prefix: "+s_pKdcomment+"\nDouble click on any cell to expand its target pKd into individual column"
#  set format T_t2macro.name comment="ChEMBL Preferred name or ChEMBL ID\nDouble click on any cell to retrieve the molecule from ChEMBL API online"
  s_finaltable = Name("ChEMBLorig" unique)
  s_finaltable2 = Name(Replace(s_finaltable "ChEMBLorig" "ChEMBLsimilar") unique)
  T_t3macro = T_t1macro
  add header T_t3macro "" name="toolsPanel"
  T_t3macro.toolsPanel = """
# txt_Hints (Double click on the mol cell to calculate its Tanimoto Distance to similar compounds)
"""
  set property T_t3macro header
  add column T_t2macro Chemical(T_t2macro.smiles simple) name="mol" index=2
  add column T_t2macro Distance(T_t3macro.mol[1] T_t2macro.mol)[1] name="TanimotoDist" index=9
  sort T_t2macro.TanimotoDist
  rename T_t3macro s_finaltable
  delete T_t1macro l_warn=no
  delete $s_finaltable2 l_warn=no
  set property T_t2macro header
  if (Nof(T_t2macro.MOA == "")==Nof(T_t2macro)) set format T_t2macro.MOA show off
  if (Nof(T_t2macro.Indications == "")==Nof(T_t2macro)) set format T_t2macro.Indications show off
  if (Nof(T_t2macro.DrugClass == "")==Nof(T_t2macro)) set format T_t2macro.DrugClass show off
  if (Nof(T_t2macro.Warnings == "")==Nof(T_t2macro)) set format T_t2macro.Warnings show off
  rename T_t2macro s_finaltable2
  keep $s_finaltable2 $s_finaltable
  set foreground $s_finaltable2
#  set foreground $s_finaltable2
  print " Info> Double Click on the orig table will display the similar compounds in the similar table"
endmacro
#
macro msChEMBLcol s_col ("") I_entries (Iarray(0))
  l_info = l_commands = l_warn = no
  s_col = Trim(s_col all)
  if (s_col == "") return "Please specify a table column name"
  if (Nof(Split(s_col "."))!=2) return "Please specify a table column name"
  if (Nof(I_entries)==0) return "Please specify table row"
  s_tab = Field(s_col 1 ".")
  s_col = Field(s_col 2 ".")
  S_targets = Unique(Sort(Field(Split(Sum(($s_tab.$s_col)[I_entries] "\n") "\n") 1 ":")))
  if (Nof(S_targets)==0) return "No target found"
  S_1 = Split(Sum($s_tab.$s_col "\n") "\n")
  R_2 = Toreal(Field(S_1 2 ":"))
  S_1 = Field(S_1 1 ":")
  group table T_t2macro S_1 "targets" R_2 "pkd"
  s_pKdcomment = "pKd, pKi, pIC50, pEC50, etc\n>6. indicates submicromolar value\nND indicates unknown"
  for i_target = 1, Nof(S_targets)
    s_target = S_targets[i_target]
    if (Index($s_tab.S_Uniprot s_target)==0) continue
    if (Type($s_tab.$s_target)!="unknown") continue
    I_tmpmacro = Index($s_tab.$s_col ~ s_target+":*" | $s_tab.$s_col ~ "*\n"+s_target+":*")
    I_tmpmacro2 = Index(T_t2macro.targets == s_target)
    if (Nof(I_tmpmacro2)!=Nof(I_tmpmacro)) continue
    add column $s_tab Toreal(Sarray(Nof($s_tab) "")) name=s_target
    i_tmp = Index($s_tab.S_Uniprot s_target)
    s_comment = ""
    if (i_tmp!=0) then
      s_comment = ($s_tab.S_Fullname)[i_tmp]+"\n"
    endif
    set format $s_tab.$s_target "%.1f" name="" color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'" comment=s_comment+s_pKdcomment
    s_tabtarget = s_tab+"."+s_target
    $s_tabtarget[I_tmpmacro] = T_t2macro.pkd[I_tmpmacro2]
  endfor
  delete T_t2macro l_warn=no
endmacro
#
macro optoffset R_var &r_fff
  l_warn = l_info = l_commands = no
  r_damp = 1.0
  r_rec = 1.0
  M_tmp = M_energy
  for i_tmp = 1, Nof(R_var)
    M_tmp[i_tmp,?] = M_tmp[i_tmp,?] + Rarray(Nof(M_tmp[i_tmp,?]) R_var[i_tmp])
  endfor
  R_tmp = Rarray(Nof(M_tmp[1]) 999.)
  I_minconf = Iarray(Nof(M_tmp[1,?]) 0)
  R_tmp2 = Rarray(Nof(M_tmp[1]) 999.)
  R_tmp3 = Rarray(Nof(M_tmp[1]) 999.)
  R_tmp4 = Rarray(Nof(M_tmp[1]) 999.)

  for i_tmp = 1, Nof(R_tmp)
    R_weight = Exp(- (M_tmp[?,i_tmp]-Min( M_tmp[?,i_tmp]))/(Boltzmann( )*298))
    R_tmp[i_tmp] = Sum(M_rmsd[?, i_tmp]*R_weight)/Sum(R_weight)
    if (Type(M_recrmsd)=="matrix") R_tmp2[i_tmp] = Sum(M_recrmsd[?, i_tmp]*R_weight)/Sum(R_weight)

    I_minconf[i_tmp] = Min(index M_tmp[?,i_tmp])
    R_tmp3[i_tmp] = M_rmsd[I_minconf[i_tmp], i_tmp]
    if (Type(M_recrmsd)=="matrix") R_tmp4[i_tmp] = M_recrmsd[I_minconf[i_tmp], i_tmp]
  endfor
  r_fff = Sum(Log(R_tmp +r_damp))
  if (Type(M_recrmsd)=="matrix") r_fff += r_rec*Sum(Log(R_tmp2 + r_damp))

  R_rmsdlig = R_tmp3
  keep R_rmsdlig I_minconf
  if (Type(M_recrmsd)=="matrix") then
    R_rmsdrec = R_tmp4
    keep R_rmsdrec
  endif
endmacro
#
macro msPocketoffset s_recligicb ("") os_rec (a_!*.) os_lig (a_!*. ) s_refrecligicb ("") r_effort (10.) auto
  l_warn = l_commands = l_info = no
  s_recligicb = Trim(s_recligicb all)
  s_refrecligicb = Trim(s_refrecligicb all)
  if (((s_recligicb) != "") & Exist(s_recligicb) & Extension(s_recligicb)==".icb") then
    print "Warning: all objects in the current session will be deleted"
    delete a_*. l_warn=no
    read binary s_recligicb
  endif
  if (Nof(a_*. & os_rec & a_*.A)==0) then
    if (Nof(Obj(a_*. & a_*.A))==1) then
      os_rec = Obj(a_*. & a_*.A)
    else
      return "Need single receptor object in the current session"
    endif
  elseif (Nof(Obj(a_*. & os_rec))==1) then
    os_rec = Obj(a_*. & os_rec)
  else
    return "Please specify one receptor object"
  endif
  if (Nof(a_*. & os_lig & a_*.H)==0) then
    if (Nof(Obj(a_*. & a_*.H))==1) then
      os_lig = Obj(a_*. & a_*.H)
    else
      return "Need single ligand object in the current session"
    endif
  elseif (Nof(Obj(a_*. & os_lig))==1) then
    os_lig = Obj(a_*. & os_lig)
  else
    return "Please specify one ligand object"
  endif
  if (os_rec == os_lig) return "Receptor Object and Ligand Object needs to be separate objects"
  delete a_*. &! os_rec &! os_lig l_warn=no
  i_nofrecconf = Nof(os_rec conf)
  if (i_nofrecconf <= 1) return "Receptor Object has only one conformation, nothing to do..."
  i_noflig = Nof(a_*.H & os_lig)
  as_graph = Res(Sphere(a_*.H & os_lig  a_*.* & os_rec 5.) )
  if (Nof(as_graph) == 0) return "The ligands are not within the receptor, nothing to do"
  if ((s_refrecligicb != "") & Exist(s_refrecligicb)) then
    i_nofobj = Nof(a_*.)
    read binary s_refrecligicb
    ms_newlig = (a_*.)[i_nofobj+1:Nof(a_*.)] & (a_*.H)
    if (Nof(ms_newlig)==i_noflig) then
      M_recrmsd = Matrix(i_nofrecconf i_noflig 999.)
      for i_rec = 1, i_nofrecconf
        set object os_rec[1]
        load conf a_ i_rec
        for i_lig = 1, i_noflig
          set object Obj((ms_newlig)[i_lig])
          M_recrmsd[i_rec i_lig] = Srmsd( a_*.A//ca & Res(Sphere(os_lig (a_*. & os_rec)[1] 5.)) a_*.A//ca & a_ align)
        endfor
      endfor
      set object os_rec[1]
      load conf a_ 1
    endif
    if (Nof(a_*.)>i_nofobj) delete (a_*.)[i_nofobj+1:Nof(a_*.)] l_warn=no
  endif

  s_parentdir = Path()
  s_tmpdockdir = s_tempDir +"tmpdock"+Iproc( )
  make directory s_tmpdockdir
  set directory s_tmpdockdir
  extractLigand (a_*.H & os_lig)[1] "2D" no "" no
  for i_lig = 2, i_noflig
    extractLigand (a_*.H & os_lig)[i_lig] "2D" yes Name( chem table ) no
  endfor
  add column chem Count(Nof(chem)) name="idx" index=2
  write table mol chem delete
  makeIndexChemDb s_tmpdockdir+"/chem.sdf" s_tmpdockdir+"/chem.inx" "mol" { "ID" }
  as_graph = Res(Sphere(a_*.H & os_lig  a_*.* & os_rec 5.) )
  if (Nof(as_graph) == 0) return "The ligands are not within the receptor, nothing to do"

  currentDockProj.data[8] = "yes"
  tempsel = as_graph & a_recobject.
  dock2SetupReceptor "mydock" a_recobject. tempsel no "none"
  currentDockProj.data[1] = "mydock"
  s_out = currentDockProj.data[1] + "_rec"
  Error()
  set object  a_$s_out.
  write object delete

  currentDockProj.data[8] = "yes"
  dockInit "mydock" "dock4StatusEdit"
  mydock.R_boxDim = Box(as_graph | os_lig 3.)
  write table mydock "mydock.dtb" delete
  dockUpdateGlobals "mydock" 0

  dockTableValue currentDockProj.data[1] "s_grid4DFlex" "string" "embedded"
  currentDockProj.l_readyMaps=no
  dock5CalcMaps currentDockProj.data[1] 0.5 4.0 no

  currentDockProj.data[2:9] = { "dock3DbScanSetup" "no" "no" }//s_tmpdockdir+"/chem.inx"//{"mol" "auto" "yes" "no"}
  currentDockProj.data[3] = "yes"
#  currentDockProj.data[4] = "yes"
  currentDockProj.data[9] = "yes"
  dock3DbScanSetup currentDockProj.data[1] no yes "default"
  dockUpdateGlobals currentDockProj.data[1] -2
  currentDockProj.data[8] = "yes"
  dockTableValue currentDockProj.data[1] "r_ScoreThreshold" "real" "999."
  dockTableValue currentDockProj.data[1] "r_mfScoreThreshold" "real" "999."
  dockTableValue currentDockProj.data[1] "i_minLigSize" "integer" "50"
  dockTableValue currentDockProj.data[1] "i_maxLigSize" "integer" "1000"
  dockTableValue currentDockProj.data[1] "i_maxHdonors" "integer" "10"
  dockTableValue currentDockProj.data[1] "i_maxNO" "integer" "20"
  dockTableValue currentDockProj.data[1] "i_maxTorsion" "integer" "20"
  dockTableValue currentDockProj.data[1] "l_samplePyramid" "logical" "yes"
  dockTableValue currentDockProj.data[1] "r_maxPk" "real" "20."
  dockTableValue currentDockProj.data[1] "r_minPk" "real" "-20"
  dockUpdateGlobals currentDockProj.data[1] -1

  dockUpdateGlobals currentDockProj.data[1] -2
  if(! no & Type( a_ligtemplate. )!="none") dockSetupTemplate currentDockProj.data[1] currentDockProj.data[1] + "_tmplt.ob" os_lig ""
  dockTableValue currentDockProj.data[1] "s_templateMatch" "string" "APF"

  M_energy = Matrix(i_nofrecconf i_noflig 999.)
  M_rmsd = Matrix(i_nofrecconf i_noflig 999.)
  M_score = Matrix(i_nofrecconf i_noflig 999.)

  print "Will take approximately " i_nofrecconf*i_noflig*2 " minutes to finish docking"

  N = i_nofrecconf
  print bar "Docking" N l_info=yes
  for i_recconf = 1, i_nofrecconf
    print "Working on Receptor conformation" i_recconf "out of" i_nofrecconf "conformations"
    print bar N
    s_cmd = " -a -s effort="+Tostring(r_effort)+" name=answers mydock single4D="+i_recconf+" -z"
    s_cmd= Path(origin, " " + " " + " \"" + s_icmhome + "/_dockScan\" " + s_cmd + " > " + "mydock" + "_all.ou" )
    currentDockProj.data[13]= "mydock" + "_" + "answers" + "1"
    currentDockProj.data[1] = "mydock"
    s_out = Unix(s_cmd)

    currentDockProj.data[8] = "yes"
    scanMakeHitList "mydock" "mydock_answers1" Name(Name( "mydock_answers1" ),simple) 1 ==2 no 1 ==1 no ? 100 : 0
    for i_lig = 1, i_noflig
      if (Nof(mydock_answers1.IX==i_lig)==1) M_score[i_recconf i_lig] = mydock_answers1.Score[Index(mydock_answers1.IX==i_lig)[1]]
      read object "mydock_answers1.ob" number=i_lig name="tmplig"
      set object a_tmplig.
      load conf a_ 1
      s_tmp = chem.sel[i_lig]
      R_tmp1 = Rarray(0)
      R_tmp2 = Rarray(0)
      for i_conf = 1, Nof(a_ conf)
        load conf a_ i_conf
        R_tmp1 //= Energy("func" )
        R_tmp2 //= Srmsd(a_tmplig. $s_tmp chemical)
      endfor
      R_tmp3 = Exp(- (R_tmp1-Min(R_tmp1))/(Boltzmann( )*298))
#      M_rmsd[i_recconf i_lig] = Srmsd(a_tmplig. $s_tmp chemical)
      M_energy[i_recconf i_lig] =  R_tmp1[1]
      M_rmsd[i_recconf i_lig] = Sum(R_tmp3 * R_tmp2)/Sum(R_tmp3)
      delete a_tmplig. l_warn=no
    endfor
    delete mydock_answers1 l_warn=no
    delete system "mydock_answers1.ob"
    delete system "mydock_all.ou"
  endfor
  print bar "End\n" l_info=yes
  write M_energy
  write M_rmsd
  write M_score
  if (Type(M_recrmsd)=="matrix") write M_recrmsd

  R_var = Rarray(i_nofrecconf 0.)
  niter=1000
  step=16.
  tolerance=0.000001
  fff=0.0
  R_outfin = Rarray()
  delete T_Parameter l_warn=no
  R_EndPointfin = Rarray(i_nofrecconf 0.)
  N = 1000
  print bar "Minimizing" N l_info = yes
  R_tmpstart = -Mean(Transpose(M_energy))
  for i_run = 1, 1000
#   icmmin "optoffset" R_EndPointfin $niter $step $tolerance
#    icmmin "optoffset" Rarray(i_nofrecconf 0.) $niter $step $tolerance
    icmmin "optoffset" R_tmpstart $niter $step $tolerance
    R_outfin//= r_out
    R_tmp = Sort(R_EndPoint)
    R_tmp2 = LinearFit(Toreal(Count(Nof(R_tmp ) )) R_tmp)
    R_EndPointtmp =  R_EndPoint -R_tmp2[1]*Mean(Count(Nof(R_tmp )))-R_tmp2[2]
    if (Min(R_outfin)==r_out) then
      R_EndPointfin = R_EndPointtmp
      print "Best offset so far in cycle" i_run ":" R_EndPointfin
      optoffset R_EndPointfin 0. l_warn=no
      print "Best RMSD so far in cycle" i_run ":" R_rmsdlig
    endif
    group table T_tmpout Iarray(1 i_run) "run" Rarray(1 R_outfin[$]) "score"
    for i_col = 1, Nof(R_EndPointtmp)
      add column T_tmpout Rarray(1 R_EndPointtmp[i_col]) name="para_"+String(i_col)
    endfor
    optoffset R_EndPointtmp 0. l_warn=no
    add column T_tmpout Rarray(1  Nof(Trim( R_rmsdlig 2. 0.) 2.)) name="nof_wrong" index=3
    if (Type(T_Parameter)=="unknown") then
      rename T_tmpout T_Parameter
    else
      add T_Parameter T_tmpout; delete T_tmpout l_warn=no
    endif
    print bar N l_info=yes
  endfor
  print bar "End\n" l_info=yes
  sort T_Parameter.score
  optoffset Rarray(i_nofrecconf 0.) 0. l_warn=no
  print "Original Lig RMSD:" R_rmsdlig
  if (Type(M_recrmsd)=="matrix") print "Original Rec RMSD:" R_rmsdrec
  print "Original conf:" I_minconf
  print "Best offset:" R_EndPointfin
  optoffset R_EndPointfin 0. l_warn=no
  print "Best Lig RMSD:" R_rmsdlig
  if (Type(M_recrmsd)=="matrix") print "Best Rec RMSD:" R_rmsdrec
  print "Best conf:" I_minconf
  R_tmp = R_EndPointfin
  group table T_finaloffset Count(i_nofrecconf) "Rec_Conf" R_tmp "Offset"
  keep T_finaloffset
  group table T_finaloffset append header M_energy
  group table T_finaloffset append header M_rmsd
  group table T_finaloffset append header M_score
  if (Type(M_recrmsd)=="matrix") group table T_finaloffset append header M_recrmsd
  M_finalenergy = T_finaloffset.M_energy
  for i_rec = 1, Nof(T_finaloffset)
    M_finalenergy[i_rec,?] = M_finalenergy[i_rec,?] + T_finaloffset.Offset[i_rec]
  endfor
  group table T_finaloffset append header M_finalenergy
  set directory s_parentdir

  write binary T_finaloffset delete
  write binary T_Parameter
  keep T_Parameter
endmacro
#
macro msClusterHitRep s_tab ("") r_clusterdist (0.2) auto
  l_info = l_warn = l_commands = no
  s_tab = Trim(s_tab all)
  if (s_tab=="") return "Please specify molScreen Hitlist table"
  if (Type($s_tab)!="table") return "molScreen Hitlist table specified not found"
  T_tabmacro = $s_tab
  add column T_tabmacro Count(Nof(T_tabmacro)) name="idxtmpmacro"
  i_noftarget = 1
  if (Type(T_tabmacro.Target)=="sarray") then
    S_targetmacro = Unique(Sort(T_tabmacro.Target))
    i_noftarget = Nof(S_targetmacro)
  endif
  S_col = {"MolScore","pPvalue","MolpKd","MolpKd_Error","MolZScore","MolClass","MolRecScore","MolTmplScore","MolSim"}
  delete T_tabmacro3 l_warn=no
  for i_target = 1, i_noftarget
    if (i_noftarget == 1) then
      T_tabmacro2 = T_tabmacro
    else
      T_tabmacro2 = T_tabmacro.Target == S_targetmacro[i_target]
    endif
    delete T_tabmacro2.cluster T_tabmacro2.cl T_tabmacro2.CO T_tabmacro2.ord l_warn=no
    make tree T_tabmacro2 compress split="cl" name=""
    split T_tabmacro2.cluster r_clusterdist
    sort T_tabmacro2.idxtmpmacro
    I_tmp = Index(T_tabmacro2.cluster center)
    T_tabmacrotmp = T_tabmacro[I_tmp]
    add column T_tabmacrotmp Iarray(Nof(T_tabmacrotmp) 1) name="nof_rep" index=3
    for i_tmp = 1, Nof(T_tabmacrotmp)
      i_idxtmp = T_tabmacrotmp.idxtmpmacro[i_tmp]
      i_cl = T_tabmacro2.cl[i_idxtmp]
      if (Nof(T_tabmacro2.cl == i_cl )==1) continue
      for i_col = 1, Nof(S_col)
        s_col = S_col[i_col]
        if (Type(T_tabmacrotmp.$s_col)!="rarray") continue
        T_tabmacrotmp.$s_col[i_tmp] = Median(T_tabmacro2.$s_col[Index(T_tabmacro2.cl==i_cl)])
      endfor
      T_tabmacrotmp.nof_rep[i_tmp] = Nof(T_tabmacro2.cl == i_cl )
    endfor
    if (Type(T_tabmacro3)=="unknown") then
      rename T_tabmacrotmp "T_tabmacro3"
    else
      add T_tabmacro3 T_tabmacrotmp l_warn=no
    endif
  endfor
  sort reverse T_tabmacro3.MolRecScore
  sort reverse T_tabmacro3.MolClass
  sort reverse T_tabmacro3.MolpKd
  sort reverse T_tabmacro3.pPvalue
  sort reverse T_tabmacro3.MolScore
  set format T_tabmacro3.nof_rep comment="Total number of compounds represented by each cluster centroid\nAll molScreen values are median of each cluster"
  delete T_tabmacro3.idxtmpmacro l_warn=no
  s_outtab = Name("msModelHitRep" unique)
  rename T_tabmacro3 s_outtab
  keep $s_outtab
endmacro
#
macro msPK s_tab ("") l_HideOrigCol (yes) auto
HELP = """
  Generate basic Pharmacokinetic prediction for chemical table
  Syntax: msPK <s_tab> <l_HideOrigCol>
  <s_tab>: Table name
  <l_HideOrigCol>: Whether to hide columns from original table, .mol and .NAME will not be hidden regardless
"""
  l_info = l_warn = l_commands = no
  s_tab = Trim(s_tab)
  if (s_tab == "") return " Info> Please specify a table name"
  if (Type($s_tab)!="table") return " Info> Please specify a valid table name"
  if (Type($s_tab.mol)!="parray") return " Info> Please specify a table with mol column"
  delete T_tmpmacro l_warn=no
  rename $s_tab "T_tmpmacro"
# Checking prerequisite columns
  print " Info> Predicting Permeability, PGP, P450, PAINS, etc, takes about 3-5 min per 1000 compounds..."
  N = 6
  if (Type(T_tmpmacro.mcpP450_tophit)=="unknown") predictModels "T_tmpmacro" {"mcpP450"} yes no no no  yes "" no yes no Collection() 0 0
  print bar "Predicting..." N l_info = yes
  if (Type(T_tmpmacro.MolLogPERME)=="unknown") add column T_tmpmacro function="predictModelsCol(mol,\"mcpLogPERME\")" name="molLogPERME" delete comment="Predict Log Permeability of PAMPA, CACO2 in cm/sec, a value >-5. indicates high permeability, <-6. indicates low permeability; Efflux Ratio of CACO2 >2. indicates active efflux " vector
  print bar N l_info = yes
  if (Type(T_tmpmacro.bbbScore)=="unknown") add column T_tmpmacro function="calcBBBScore(mol)" name="bbbScore" delete comment="Calculate the Blood-Brain Barries (BBB) Score " vector
  print bar N l_info = yes
  if (Type(T_tmpmacro.MolPGP)=="unknown") add column T_tmpmacro function="predictModelsCol(mol,\"mcpPGP\")" name="molPGP" delete comment="Predict P-Glycoprotein inhibitor/substrate, a value >0.5 indicates high probability of being a P-Glycoprotein inhibitor/substrate " vector
  print bar N l_info = yes
  if (Type(T_tmpmacro.molPAINS)=="unknown") add column T_tmpmacro function="predictModelsCol(mol,\"mcpPAINS\")" name="molPAINS" delete comment="Predict Pan Assay Interference Compound (PAINS), a value >0.5 indicates high probability of being a PAINS Compound " vector
  print bar N l_info = yes
  delete T_tmpmacro.Formula T_tmpmacro.Molecular_weight T_tmpmacro.Num_heavy_atoms T_tmpmacro.Num_rotatable_bonds T_tmpmacro.Num_H_bond_acceptors T_tmpmacro.Num_H_bond_donors T_tmpmacro.TPSA T_tmpmacro.Log_P T_tmpmacro.Log_D l_warn=no
  delete T_tmpmacro.Log_S T_tmpmacro.Solubility_mg_ml T_tmpmacro.Solubility_mmol_l T_tmpmacro.Solubility_Class T_tmpmacro.GI_Absorption T_tmpmacro.Active_Efflux T_tmpmacro.BBB_Permeable T_tmpmacro.PGP_Substrate l_warn=no
  delete T_tmpmacro.CYP1A2_Binder T_tmpmacro.CYP2C19_Binder T_tmpmacro.CYP2C9_Binder T_tmpmacro.CYP2D6_Binder T_tmpmacro.CYP3A4_Binder T_tmpmacro.PAINS T_tmpmacro.Synthetic_Accessibility l_warn=no
  S_col = Name(T_tmpmacro column)

  add column T_tmpmacro function="MolFormula(mol)" name="Formula" delete comment="Chemical formula,e.g. C2H6O, from .mol"
  set format T_tmpmacro.Formula 60 name="Formula"
  add column T_tmpmacro function="MolWeight(mol,'monoiso')"  name="Molecular_weight" delete format="%.2f" comment="Monoisotopic or average isotopic molecular weight from .mol [Daltons]"
  set format T_tmpmacro.Molecular_weight 70 name="Molecular_weight" color="rainbow='#FFFFFF/#FFFFAC/#FFACAC,500.:1000.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
  add column T_tmpmacro function="Nof_Atoms(mol,'*')" name="Num_heavy_atoms"  delete comment="Number of atoms from .mol"
  set format T_tmpmacro.Num_heavy_atoms 50 name="Num_heavy_atoms"
  add column T_tmpmacro function="Nof_RotB(mol)" name="Num_rotatable_bonds" delete comment="Number of freely rotatable bonds from .mol"
  set format T_tmpmacro.Num_rotatable_bonds 60 name="Num_rotatable_bonds" color="rainbow='#FFFFFF/#FFFFAC/#FFACAC,15.:25.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
  add column T_tmpmacro function="Nof_HBA(mol,yes)" name="Num_H_bond_acceptors" delete comment="Number of hydrogen bond acceptors from .mol"
  set format T_tmpmacro.Num_H_bond_acceptors 70 name="Num_H_bond_acceptors" color="rainbow='#FFFFFF/#FFFFAC/#FFACAC,10.:15.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
  add column T_tmpmacro function="Nof_HBD(mol)" name="Num_H_bond_donors" delete comment="Number of hydrogen bond donors from .mol"
  set format T_tmpmacro.Num_H_bond_donors 60 name="Num_H_bond_donors" color="rainbow='#FFFFFF/#FFFFAC/#FFACAC,5.:10.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
  add column T_tmpmacro function="MolPSA(mol)" name="TPSA" delete format="%.2f" comment="Polar surface area in square angstroms from .mol"
  set format T_tmpmacro.TPSA 60 name="TPSA" color="rainbow='#FFFFFF/#FFFFAC/#FFACAC,200.:300.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
  add column T_tmpmacro function="MolLogP(mol)" name="Log_P" delete format="%.2f" comment="Octanol water partition, Log10(C_oct/C_w) from .mol"
  set format T_tmpmacro.Log_P 60 name="Log_P" color="rainbow='#FFFFFF/#FFFFAC/#FFACAC,4.:6..,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
  add column T_tmpmacro function="MolLogD(mol)" name="Log_D" delete format="%.2f" comment="LogD is a log of partition of a chemical compound between the lipid and aqueous phases"
  set format T_tmpmacro.Log_D 60 name="Log_D" color="rainbow='#FFFFFF/#FFFFAC/#FFACAC,4.:6..,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
  print bar N l_info = yes
  add column T_tmpmacro function="MolLogS(mol)" name="Log_S" delete format="%.2f" comment="Water solubility, Log10([C]): 10-based logarithm of the solubility in mol/l or M units predicted from .mol"
  set format T_tmpmacro.Log_S 60 name="Log_S" color="rainbow='#FFACAC/#FFFFAC/#FFFFFF,-6.:-4..,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
  add column T_tmpmacro Power(10, T_tmpmacro.Log_S)*T_tmpmacro.Molecular_weight name="Solubility_mg_ml" delete format="%.3g" comment="Water solubility in mg/ml"
  set format T_tmpmacro.Solubility_mg_ml "%.3g" 60 name="Solubility (mg/ml)" color="rainbow='#FFACAC/#FFFFAC/#FFFFFF,0.0005.:0.03."
  add column T_tmpmacro Power(10, T_tmpmacro.Log_S)*1000 name="Solubility_mmol_l" delete format="%.3g" comment="Water solubility in mmol/l"
  set format T_tmpmacro.Solubility_mmol_l "%.3g" 60 name="Solubility (mmol/l)" color="rainbow='#FFACAC/#FFFFAC/#FFFFFF,0.001.:0.1."
  add column T_tmpmacro Sarray(Nof(T_tmpmacro) "Moderately soluble") name="Solubility_Class" comment="Solubility class based on Log_S prediction"
  T_tmpmacro.Solubility_Class[Index(T_tmpmacro.Log_S >= -4. )] = "Soluble"
  T_tmpmacro.Solubility_Class[Index(T_tmpmacro.Log_S < -6. )] = "Poorly soluble"
  set format T_tmpmacro.Solubility_Class 60 "" name="Solubility_Class" color=" _ == 'Moderately soluble'  ? '#ffff00' :  _ == 'Poorly soluble'  ? '#ff6400' :  _ == 'Soluble'  ? '#64ff00' : ''"  comment="Solubility class based on Log_S prediction"
  add column T_tmpmacro Sarray(Nof(T_tmpmacro) "Moderate") name="GI_Absorption" comment="Gastrointestinal absorption based on CACO2 permeability Papp prediction in cm/s\nHigh: Papp >=1e-5\nModerate: 1e-5 >Papp >=1e-6\nLow: <1e-6"
  T_tmpmacro.GI_Absorption[Index(T_tmpmacro.MolLogPERMECACO2 >= -5)] = "High"
  T_tmpmacro.GI_Absorption[Index(T_tmpmacro.MolLogPERMECACO2 < -6)] = "Low"
  set format T_tmpmacro.GI_Absorption 70 "" name="GI_Absorption" color=" _ == 'Moderate'  ? '#ffff00' :  _ == 'Low'  ? '#ff6400' :  _ == 'High'  ? '#64ff00' : ''"
  add column T_tmpmacro Sarray(Nof(T_tmpmacro) "Low") name="Active_Efflux" comment="Drug active efflux based on Efflux ratio prediction:\nHigh: >=2\nLow: <2"
  T_tmpmacro.Active_Efflux [Index(T_tmpmacro.MolEffluxRatioCACO2>=2.)] = "High"
  set format T_tmpmacro.Active_Efflux 60 "" name="Active_Efflux" color=" _ == 'High'  ? '#ffc8c8' :  _ == 'Low'  ? '#ffffff' : ''"  comment="Drug active efflux based on Efflux ratio prediction:\nHigh: >=2\nLow: <2"
  add column T_tmpmacro Sarray(Nof(T_tmpmacro) "No") name="BBB_Permeable" comment="Blood-Brain Barrier permeability prediction based on BBBScore:\nMayuri Gupta, Hyeok Jun Lee, Christopher J. Barden, and Donald F. Weaver\nJournal of Medicinal Chemistry Article\nDOI: 10.1021/acs.jmedchem.9b01220\nYes>=4.\nNo<4"
  T_tmpmacro.BBB_Permeable[Index(T_tmpmacro.bbbScore >=4.)] = "Yes"
  set format T_tmpmacro.BBB_Permeable 70 "" name="BBB_Permeable" color=" _ == 'Yes'  ? '#64ff00' :  _ == 'No'  ? '#ff9600' : ''"

  add column T_tmpmacro Sarray(Nof(T_tmpmacro) "No") name="PGP_Substrate" comment="P-Glycoprotein substrate prediction based on fully connected neural network method\nTraining Set: 4214Compounds\nExternal Test Set AUC: 0.9"
  T_tmpmacro.PGP_Substrate[Index(T_tmpmacro.MolPGPsubstrate>=0.5)] = "Yes"
  set format T_tmpmacro.PGP_Substrate 60 "" name="PGP_Substrate" color=" _ == 'Yes'  ? '#ffc8c8' :  _ == 'No'  ? '#ffffff' : ''"
  add column T_tmpmacro Sarray(Nof(T_tmpmacro) "No") name="CYP1A2_Binder" comment="Cytochrome P450 1A2 Binder/Inhibitor Prediction"
  add column T_tmpmacro Sarray(Nof(T_tmpmacro) "No") name="CYP2C19_Binder" comment="Cytochrome P450 2C19 Binder/Inhibitor Prediction"
  add column T_tmpmacro Sarray(Nof(T_tmpmacro) "No") name="CYP2C9_Binder" comment="Cytochrome P450 2C9 Binder/Inhibitor Prediction"
  add column T_tmpmacro Sarray(Nof(T_tmpmacro) "No") name="CYP2D6_Binder" comment="Cytochrome P450 2D6 Binder/Inhibitor Prediction"
  add column T_tmpmacro Sarray(Nof(T_tmpmacro) "No") name="CYP3A4_Binder" comment="Cytochrome P450 3A4 Binder/Inhibitor Prediction"
  T_tmpmacro.CYP1A2_Binder[Index(T_tmpmacro.1A2_Binder_mcpP450>=0.5)] = "Yes"
  T_tmpmacro.CYP2C19_Binder[Index(T_tmpmacro.2C19_Binder_mcpP450>=0.5)] = "Yes"
  T_tmpmacro.CYP2C9_Binder[Index(T_tmpmacro.2C9_Binder_mcpP450>=0.5)] = "Yes"
  T_tmpmacro.CYP2D6_Binder[Index(T_tmpmacro.2D6_Binder_mcpP450>=0.5)] = "Yes"
  T_tmpmacro.CYP3A4_Binder[Index(T_tmpmacro.3A4_Binder_mcpP450>=0.5)] = "Yes"
  set format T_tmpmacro.CYP1A2_Binder 60 "" name="CYP1A2_Binder" color=" _ == 'Yes'  ? '#ffc8c8' :  _ == 'No'  ? '#ffffff' : ''"
  set format T_tmpmacro.CYP2C19_Binder 60 "" name="CYP2C19_Binder" color=" _ == 'Yes'  ? '#ffc8c8' :  _ == 'No'  ? '#ffffff' : ''"
  set format T_tmpmacro.CYP2C9_Binder 60 "" name="CYP2C9_Binder" color=" _ == 'Yes'  ? '#ffc8c8' :  _ == 'No'  ? '#ffffff' : ''"
  set format T_tmpmacro.CYP2D6_Binder 60 "" name="CYP2D6_Binder" color=" _ == 'Yes'  ? '#ffc8c8' :  _ == 'No'  ? '#ffffff' : ''"
  set format T_tmpmacro.CYP3A4_Binder 60 "" name="CYP3A4_Binder" color=" _ == 'Yes'  ? '#ffc8c8' :  _ == 'No'  ? '#ffffff' : ''"

  add column T_tmpmacro Sarray(Nof(T_tmpmacro) "No") name="PAINS" comment="PAN Assay Interference(PAINS)/Promiscuous Prediction"
  T_tmpmacro.PAINS[Index(T_tmpmacro.molPAINS>=0.5)] = "Yes"
  set format T_tmpmacro.PAINS 40 "" name="PAINS " color=" _ == 'Yes'  ? '#ffc8c8' :  _ == 'No'  ? '#ffffff' : ''"
  add column T_tmpmacro function="MolSynth(mol)" name="Synthetic_Accessibility" format="%.2f" delete comment="Chemical Synthetic Accessibility [0-1]. 1-all fragments are very common, 0.-many unknown fragments" color="rainbow='#ff6666/#ffeeaa/#ffff66/#aaffaa/#aaffaa/#aaffaa,0.1:1.,pinwheel'"
  set format T_tmpmacro.Synthetic_Accessibility 80 name="Synthetic_Accessibility"
  if (l_HideOrigCol) then
    for i_col = 1, Nof(S_col)
      s_col = S_col[i_col]
      if ((s_col == "T_tmpmacro.mol")|(s_col ~ "T_tmpmacro.[Nn][Aa][Mm][Ee]*")) continue
      set format $s_col show off
    endfor
  endif
  delete $s_tab l_warn=no
  s_toolsPanel = """
# b_Generate_Single_Compound_Table_for_Selected_Compound (msTransposeCpd Name(variable %@) Index(%@ selection cursor)[1])
"""
  if (Type(T_tmpmacro.toolsPanel)=="unknown") then
    add header T_tmpmacro s_toolsPanel name="toolsPanel"
    set property T_tmpmacro header
  endif
  rename T_tmpmacro s_tab
#  delete T_tmpmacro l_warn=no
  keep $s_tab
endmacro
#
macro lighomBG os_tmpl (a_!*.) s_tmpl ("") os_ob (a_!*.) s_ob ("") s_ali ("") s_sdf ("") s_classcol ("") s_pkdcol ("") s_loop ("") s_anchor ("") r_nm (16.) l_forcestart (no) auto

  s_tmpl = Trim(s_tmpl all)
  if ((s_tmpl=="") & (Nof(os_tmpl)!=1)) return "Please specify the template object"
  if (s_tmpl!="") then
    if (!Exist(s_tmpl)) return "Template object specified does not exist"
    if ((Extension(s_tmpl)!=".ob")&(Extension(s_tmpl)!=".pdb")) return "Please specify either a .ob or .pdb template"
  else
    if (Nof(os_tmpl)!=1) return "Please specify only one template object"
  endif

  s_ob = Trim(s_ob all)
  if ((s_ob=="") & (Nof(os_ob)!=1)) return "Please specify the initial model object"
  if (s_ob!="") then
    if (!Exist(s_ob)) return "Initial model object specified does not exist"
    if ((Extension(s_ob)!=".ob")) return "Please specify a .ob initial model object"
  else
    if (Nof(os_ob)!=1) return "Please specify only one initial model object"
  endif

  s_ali = Trim(s_ali all)
  if (s_ali == "") return "Please specify a valid sequence alignment"
  if (Extension(s_ali)=="") then
    if (Type($s_ali)!="alignment") return "Alignment specified does not exist"
  elseif (!Exist(s_ali)) then
    return "Alignment specified does not exist"
  elseif (Extension(s_ali)!=".ali") then
    return "Please specify a .ali alignment"
  endif
  s_classcol = Trim(s_classcol all)
  s_pkdcol = Trim(s_pkdcol all)
  if ((s_classcol=="") & (s_pkdcol=="")) return "Please either specify a 1/0 class column or pkd column"
  s_sdf = Trim(s_sdf all)
  if (s_sdf == "") return "Please specify a valid sdf file"
  if (Extension(s_sdf)=="") then
    if (Type($s_sdf)=="table") then
      if (s_classcol!="") then
        if (Type($s_sdf.$s_classcol)!="iarray") return "Please specify an iarray class column"
        if ((Max($s_sdf.$s_classcol)!=1) | (Min($s_sdf.$s_classcol)!=0)) return "Please specify an iarray of 1/0 as class column"
      elseif (s_pkdcol!="") then
        if (Type($s_sdf.$s_pkdcol)!="rarray") return "Please specify an rarray pkd column"
        if (Max($s_sdf.$s_pkdcol)-Min($s_sdf.$s_pkdcol) < 1.) return "Please specify a valid pkd column or an 1/0 class column"
      endif
    else
      return "Table specified does not exist"
    endif
  elseif (!Exist(s_sdf)) then
    return "sdf file specified does not exist"
  elseif (Extension(s_sdf)!=".sdf") then
    return "Please specify a .sdf file"
  endif

  s_workdir =  s_tempDir +"lighom"+Iproc( )
  if (Exist(s_workdir) & (!l_forcestart)) then
    l_forcestart = Ask("Previous ligand guided homology directory exist, overwrite?", no)
    if (!l_forcestart) return "Please make sure the previous ligand guided homology job is finished before proceeding"
    delete system Sarray( s_workdir+"/*" directory )
    delete directory s_workdir
  endif
  make directory s_workdir

  S_arg = Sarray(0)
  if (s_tmpl=="") then
    write object Obj(os_tmpl) s_workdir+"/"+Name(os_tmpl)[1]+".ob" delete
    s_tmpl = s_workdir+"/"+Name(os_tmpl)[1]+".ob"
  endif
  if (s_ob=="") then
    write object Obj(os_ob) s_workdir+"/"+Name(os_ob)[1]+".ob" delete
    s_ob = s_workdir+"/"+Name(os_ob)[1]+".ob"
  endif
  if (s_tmpl == s_ob) return "Please specify different template object and initial model object"
  if (Path(s_tmpl)=="") then
    S_arg //= "tmpl="+Path()+s_tmpl
  else
    S_arg //= "tmpl="+s_tmpl
  endif
  if (Path(s_ob)=="") then
    S_arg //= "ob="+Path()+s_ob
  else
    S_arg //= "ob="+s_ob
  endif
  if (Extension(s_ali)=="") then
    write alignment $s_ali s_workdir+"/"+s_ali+".ali" delete
    s_ali = s_workdir+"/"+s_ali+".ali"
  endif
  if (Path(s_ali)=="") then
    S_arg //= "ali="+Path()+s_ali
  else
    S_arg //= "ali="+s_ali
  endif
  s_info = " Info> Ligand_guided homology modeling started in background. You will be notified when the job is complete."
  if (Extension(s_sdf)=="") then
    write table mol $s_sdf s_workdir+"/"+s_sdf+".sdf" delete
    s_info = s_info +"\n Info> The job will likely take more than "+Tostring(Integer(3.+Nof($s_sdf)/2. ))+" hours"
    s_sdf = s_workdir+"/"+s_sdf+".sdf"
  else
    s_info = s_info +"\n Info> The job will likely take more than 3 hours, depending on number of compounds in table"
  endif
  if (Path(s_sdf)=="") then
    S_arg //= "sdf="+Path()+s_sdf
  else
    S_arg //= "sdf="+s_sdf
  endif
  if (s_classcol!="") then
    S_arg //= "class="+s_classcol
  elseif (s_pkdcol!="") then
    S_arg //= "pkd="+s_pkdcol
  endif
  if (s_loop!="") S_arg //= "loop="+s_loop
  if (s_anchor!="") S_arg //= "anchor="+s_anchor
  S_arg //= "nm="+Tostring(r_nm)
  S_arg //= "out="+s_workdir+"/lighomoutput.icb"
  fname_out = s_workdir+"/lighomoutput.icb"
  S_arg //= " > "+s_workdir+"/lighom.ou"
  s_cmd = Path( macro, "-P"+s_icmhome, s_icmhome + "_lighom", S_arg )

  make background s_cmd info="Ligand-guided homology modeling finished" command="read binary "+String(fname_out string)
  print s_info
endmacro
#
macro findDecoy s_tab ("") r_multinof (10.) r_tight (1.) auto
HELP = """
  Finding Decoy from ChEMBL activity table matching the physical properties (molWeight,molLogP,molLogS,molPSA) of the input table
  Syntax: findDecoy <s_tab> <r_multinof> <r_tight>
  <s_tab>: Input table
  <r_multinof>: Size of the decoy table relative to the input table, default is 10. i.e. Decoy table is 10 times the size of input table
  <r_tight>: Tightness of the spread of physical property distribution.
"""
  l_info = l_warn = l_commands = no
  s_tab = Trim(s_tab all)
  if (s_tab == "") return "Please specify table name"
  if (Type($s_tab)!="table") return "Please specify valid table name"
  if (Type($s_tab.mol)!="parray") return "Please specify chemical table with .mol column"
  group table "T_tmpmacro" $s_tab.mol "mol"
  make flat T_tmpmacro index=Index( T_tmpmacro selection all ) window = 1.5
  modify T_tmpmacro.mol delete salt
  modify T_tmpmacro.mol delete salt simple
  delete hydrogen T_tmpmacro.mol
  modify T_tmpmacro.mol auto
  modify T_tmpmacro.mol delete charge
  add column T_tmpmacro function="MolPSA(mol)" index=2 name="molPSA" append format="%.2f"
  add column T_tmpmacro function="MolLogS(mol)" index=2 name="molLogS" append format="%.2f"
  add column T_tmpmacro function="MolLogP(mol)" index=2 name="molLogP" append format="%.2f"
  add column T_tmpmacro function="MolWeight(mol)" index=2 name="molWeight" append format="%.3f"
  S_col = {"molWeight","molLogP","molLogS","molPSA"}
  R_mean = Rarray(4 0.)
  R_rmsd = Rarray(4 0.01)
  for i_col = 1, Nof(S_col)
    s_col = "T_tmpmacro."+S_col[i_col]
    R_mean[i_col] = Mean($s_col)
    R_rmsd[i_col] = Max(Rmsd($s_col) 0.1)
  endfor
  read binary s_icmhome+"/models/ChEMBL.icb"
 if (Nof(T_tmpmacro)*r_multinof > Nof(ChEMBL)) then
  print "Decoy Table size larger than ChEMBL activity table, keeping all..."
  T_ChEMBLdecoy = ChEMBL
  keep T_ChEMBLdecoy
 else
  R_sum = Rarray(Nof(ChEMBL) 1.)
  for i_col = 1, Nof(S_col)
    s_col = "ChEMBL."+S_col[i_col]
    R_tmp = Trim(Abs(($s_col - R_mean[i_col])/R_rmsd[i_col]), 0.01, 9999.)
    R_tmp = (1.-Exp(-1.4*R_tmp ))*Exp(- R_tmp*R_tmp/2.)/1.135/Sqrt(2.*Pi())/R_tmp
    R_sum = R_sum * R_tmp
  endfor
  R_sum = 2.*Power(R_sum 0.25)
  add column ChEMBL R_sum name="pScore"
  sort ChEMBL.pScore reverse
  r_tmp = ChEMBL.pScore[Tointeger(r_multinof/2.*Nof(T_tmpmacro ))]
  ChEMBL.pScore = Power(ChEMBL.pScore Log(r_tight/4.)/Log(r_tmp))
  add column ChEMBL ChEMBL.pScore-Random(Nof(ChEMBL) 0. 1.) name="Rnd"
  sort ChEMBL.Rnd reverse
  delete ChEMBL.Rnd l_warn=no
  T_ChEMBLdecoy = ChEMBL[1:Min(Tointeger(Nof($s_tab )*(r_multinof+1.)) Nof(ChEMBL))]
  print " Info> Converting Smiles to Chemicals..."
  add column T_ChEMBLdecoy Chemical(T_ChEMBLdecoy.smiles smiles) name="mol" index=1
  T_ChEMBLdecoy = T_ChEMBLdecoy.mol != T_tmpmacro.mol
  T_ChEMBLdecoy = T_ChEMBLdecoy[1:Min(Tointeger(Nof($s_tab )*(r_multinof)) Nof(ChEMBL))]
  R_mean2 = Rarray(4 0.)
  R_rmsd2 = Rarray(4 0.)
  for i_col = 1, Nof(S_col)
    print "Mean and RMSD of" S_col[i_col] "for the original set are" R_mean[i_col] "and" R_rmsd[i_col]
    s_col = "T_ChEMBLdecoy."+S_col[i_col]
    make plot T_ChEMBLdecoy "x={"+S_col[i_col]+"};pinwheel=blue;depth=4.;;"
    make plot T_tmpmacro "x={"+S_col[i_col]+"};pinwheel=blue;depth=4.;;"
    R_mean2[i_col] = Mean($s_col)
    R_rmsd2[i_col] = Rmsd($s_col)
    print "Mean and RMSD of" S_col[i_col] "for the decoy set are" R_mean2[i_col] "and" R_rmsd2[i_col]
  endfor
  print bar "End\n" l_info = yes
  keep T_ChEMBLdecoy
 endif
endmacro
#
macro makeColorTable auto l_make3d (no)
  l_info=no
  if(Type(icmColors)!="table" ) then
    show color output="s_out"
    ll = Trim(Split(s_out,"\n"),all)
    if(Nof(ll)>2) ll = ll[3:$]
    add column icmColors Field(ll,1) Field(ll,2) Field(ll,3), Field(ll,3) Field(ll,3) name={"N","Name","Color","BlackBg","GreyBg"}
    set format icmColors.Name color="Color"
    set format icmColors.Color "<font color='%1'><b>%1</b></font>"
    set format icmColors.BlackBg "<font color='%1'><b>%1</b></font>"  color="'#000000'"
    set format icmColors.GreyBg "<font color='%1'><b>%1</b></font>"  color="'#BBBBBB'"
    set format icmColors.Color "%C"
    add column icmColors Table( Matrix( icmColors.Color color ) {'R' 'G' 'B' 'Intensity' 'Chroma' 'Lightness'})
    add header icmColors 0.15 * Distance(Matrix(icmColors.Color rgb) ) name="dm"
  endif
  if(l_make3d & Nof(a_dots.)==0 ) then
     GRAPHICS.l_redraw = no
     ds3D icmColors.dm icmColors.Name icmColors.Color
     display cpk a_dots. center
     # resLabelStyle = 10
     for i=1,Nof( a_dots.//o )
       s_out = Label( Res( a_//o [i] ), 10 )[1]
#print i,s_out
       color cpk xstick a_//o [i] $s_out
       display residue label a_//o
     endfor
     display new
     GRAPHICS.l_redraw = yes
  endif
  keep icmColors
endmacro

function cloudStandardizeChem P_mol
    group table XQ P_mol "mol"
    delete hydrogen XQ.mol
    modify XQ.mol auto
    modify XQ.mol delete charge
    return XQ.mol
endfunction

macro findChembl S_query ({""}) S_type ({""}) l_pkdonly (yes) s_version ("") l_quiet (yes) i_maxHits (1000) auto
    l_info = l_warn = no
    HELP =  """

      findChembl macro returns chembl activity data for either chemical or protein queries
       from a local chembl database in the Molsoft Cloud.

      Usage: findChembl <string> <type>
      Parameter:
        - query string
        - type:
            - 'chem'      : chemical name,
            - 'chembl id' : ChEMBL id,
            - 'smiles'    : smiles,
            - 'substruct' : substruct,
            - 'uniprot id': uniprot id,
            - 'uniprot ac': uniprot accession number,
            - 'protein'   : protein name
    """
    if Nof(S_query) != Nof(S_type) then
        print HELP + " Error> number of query doesn't match number of type"
        return
    endif

    if (s_version == "new" & S_type[1] == 'substruct') then
      s_smiles = Replace(S_query[1],"smiles:","",simple)
      s_resName = "chembl_" + Sum(Formula(Chemical(s_smiles)))
      params = Collection()
      params["smiles"] = s_smiles
      params["maxHits"] = i_maxHits
      s_out = "http://molsoft.com/cgi-bin/chemblsearch.cgi?" + String(params,html)
      s_out
      read json s_out name="j"
      delete $s_resName l_warn=no
      $s_resName = Table(j)
      keep global $s_resName
      return
    endif


    XTmp = funcChemblJson(S_query, S_type, l_pkdonly, s_version)
    XTBL = Table(XTmp)
    if ! Exist(XTBL.bioactivity) then
        delete XTBL
        delete XTmp
        # guess the source of the first non-empty field when no data retrieve
        l_guess = 0
        if Nof(Unique(S_type sort)) == 1 then
            if Match(S_query [1] "\w{1,16}_\w{1,16}") != "" then
                l_guess = 1
                S_type = Sarray(Nof(S_type), "uniprot id")
            elseif Match(Toupper(S_query [1]) "[OPQ][0-9][A-Z0-9]{3}[0-9]|[A-NR-Z][0-9]([A-Z][A-Z0-9]{2}[0-9]){1,2}") != "" then
                l_guess = 1
                S_type = Sarray(Nof(S_type), "uniprot ac")
            elseif Match(Toupper(S_query [1]) "CHEMBL[0-9]{1,9}") != "" then
                l_guess = 1
                S_type = Sarray(Nof(S_type), "chembl id")
            elseif Match(Toupper(S_query [1]) "(DB|APRD|BIOD|BTD|EXPT|NUTR)[0-9]{5}") != "" then
                l_guess = 1
                S_type = Sarray(Nof(S_type), "drugbank id")
            endif
        endif
        if l_guess == 1 then
            print "Initial query not found, guessing applies to source type:", Unique(S_type sort)[1]
            XTmp = funcChemblJson(S_query, S_type, l_pkdonly, s_version)
            XTBL = Table(XTmp)
            if ! Exist(XTBL.bioactivity) then
                delete XTBL
                print " Warning> no data retrieved"
                return Collection()
            endif
        else
            print " Warning> no data retrieved"
            return Collection()
        endif
    endif
    print "Data retrieved, ICM converting..."
    xtblnm = XTmp ["XNM"] ; delete XTmp.XNM
    XTBL = funcChemblJsonTable(XTBL)
    # cursor
    add header XTBL name="toolsPanel" """# b_Get_Best_Activity (findChemblBest Name(variable %@))
# b_Get_Ligand_Summary (findChemblSumm Name(variable %@))"""
    xtblnm = "chembl_" + xtblnm
    if (Nof($xtblnm)!=0) delete $xtblnm
    rename XTBL xtblnm
    s_status = ""
    keep s_status
    keep $xtblnm
    print xtblnm, "hit table loaded"
endmacro

function funcChemblJson S_query S_type l_pkdonly s_version
    l_info = l_warn = no
    qName = Sarray()
    qJson = Sarray()
    for xx = 1, Nof(S_query)
        if (S_query [xx] == "") continue
        x_query = S_query [xx]
        x_type = S_type [xx]
        if (x_type == 'chem' & Length(x_query) < 3) then
            print HELP + " Warning> minimum word size >= 3"
            continue
        endif
        if Tolower(x_query[1:3]) == 'smi' then
            x_query = Replace(x_query, "smiles:", "")
            group table XQ cloudStandardizeChem(Chemical(x_query smiles)) "mol"
            if x_type == 'substruct' then
                x_query = Smiles(XQ.mol unique)[1]
                x_type = 'substruct'
            else
                x_query = InChi(XQ.mol)[1]
                x_type = 'inchi'
            endif
        endif
        sprintf '{"name":"%s","type":"%s"}', String(x_query html), String(x_type html) name="stmp"
        qJson = qJson // stmp
        if x_type == 'smiles' | x_type == 'substruct' | x_type == 'inchi' then
            qName = qName // Formula(Chemical(x_query smiles))[1]
        else
            qName = qName // Name(x_query simple)
        endif
    endfor
    if Nof(qJson) == 0 then
        print HELP + " Warning> no query submitted"
        return Collection()
    endif
    sprintf 'http://www.molsoft.com/cloudAPI/getChemblActivity?q={"data":[%s],"version":"%s","pkdonly":"%i","simple":"1"}', Sum(qJson, ","), s_version, (l_pkdonly ? 1 : 0) name="sJson"
    read string sJson name="s_out"
    if Index(s_out, "Server Error (500)") != 0 then
        print " Warning> No hits. Server Error (500)"
        return Collection()
    endif
    QA = Table(Collection("bioactivity" Collection(s_out) ["bioactivity"]))
    if ! Exist(QA.bioactivity) then
        delete QA
        return Collection()
    endif
    add column QA function="Icm::String(bioactivity.activity_id==null?'':bioactivity.activity_id)" name="name" static
    i_cnt = 0
    i_len = 0
    qJson = Sarray()
    XTmp = Collection("bioactivity" Array())
    print bar "Fetching data" Nof(QA) l_info=yes
    for xx = 1, Nof(QA)
        print bar Nof(QA) l_info=yes
        x_query = QA.name [xx]
        x_type = "activity id"
        sprintf '{"name":"%s","type":"%s"}', String(x_query html), String(x_type html) name="stmp"
        i_cnt = i_cnt + 1
        i_len = i_len + Length(stmp)
        qJson = qJson // stmp
        if i_len > 1024*6 | xx == Nof(QA) then
            sprintf 'http://www.molsoft.com/cloudAPI/getChemblActivity?q={"data":[%s],"version":"%s","pkdonly":"%i"}', Sum(qJson, ","), s_version, (l_pkdonly ? 1 : 0) name="sJson"
            for jx = 1, 5
                read string sJson name="s_out"
                i_len = 0
                qJson = Sarray()
                if Index(s_out, "Server Error (500)") == 0 then
                    XTmp ["bioactivity"] = XTmp ["bioactivity"] // Collection(s_out) ["bioactivity"]
                    break
                endif
                print " Warning> No hits. Server Error (500)"
                return Collection()
            endfor
        endif
    endfor
    print bar "End\n" l_info = yes
    XTmp ["XNM"] = Sum(qName, "_")
    return XTmp
endfunction

function funcChemblJsonTable T_tbl
    l_info = l_warn = no
    add column T_tbl function="bioactivity.smiles" name="smiles" static
    add column T_tbl function="Icm::String(bioactivity.name==null?'':bioactivity.name)" name="name" static
    add column T_tbl function="Icm::String(bioactivity.synonyms==null?'':bioactivity.synonyms)" name="synonyms" static
    add column T_tbl function="Icm::String(bioactivity.uniprot_id==null?'':bioactivity.uniprot_id)" name="uniprot_id" static
    add column T_tbl function="Icm::String(bioactivity.fullname==null?'':bioactivity.fullname)" name="fullname" static
    add column T_tbl function="Icm::Real(bioactivity.pkd==null?'ND':bioactivity.pkd)" name="pAct" static
    add column T_tbl function="Icm::String(bioactivity.comment==null?'':bioactivity.comment)" name="comment" static
    add column T_tbl function="Icm::String(bioactivity.target_type==null?'':bioactivity.target_type)" name="target_type" static
    add column T_tbl function="Icm::String(bioactivity.target_class==null?'':bioactivity.target_class)" name="target_class" static
    add column T_tbl function="Icm::String(bioactivity.organism_class==null?'':bioactivity.organism_class)" name="organism_class" static
    add column T_tbl function="Icm::String(bioactivity.standard_type==null?'':bioactivity.standard_type)" name="type" static
    add column T_tbl function="Icm::String(bioactivity.standard_relation==null?'':bioactivity.standard_relation)" name="relation" static
    add column T_tbl function="Icm::Real(bioactivity.standard_value==null?'ND':bioactivity.standard_value)" name="value" static
    add column T_tbl function="Icm::String(bioactivity.standard_unit==null?'':bioactivity.standard_unit)" name="unit" static
    add column T_tbl function="Icm::Real(bioactivity.pchembl==null?'ND':bioactivity.pchembl)" name="pchembl" static
    add column T_tbl function="Icm::Real(bioactivity.confidence==null?'ND':bioactivity.confidence)" name="confidence" static
    add column T_tbl function="Icm::String(bioactivity.validity==null?'':bioactivity.validity)" name="validity" static
    add column T_tbl function="Icm::String(bioactivity.description==null?'':bioactivity.description)" name="description" static
    add column T_tbl function="Icm::String(bioactivity.activity_id==null?'':bioactivity.activity_id)" name="activity_id" static
    add column T_tbl function="Icm::String(bioactivity.assay_id==null?'':bioactivity.assay_id)" name="assay_id" static
    add column T_tbl function="Icm::String(bioactivity.pubmed_id==null?'':bioactivity.pubmed_id)" name="pubmed_id" static
    add column T_tbl function="Icm::Real(bioactivity.version)" name="version" static
    l_info = yes ; add column T_tbl Chemical(T_tbl.smiles smiles) name="mol" index=1 ; l_info = no ; rotate T_tbl.mol
    delete T_tbl.smiles
    delete T_tbl.bioactivity
    sort T_tbl.pAct reverse
    # format
    set format T_tbl.uniprot_id "<a href=http://www.uniprot.org/uniprot/%1>%1</a>"
    set format T_tbl.assay_id "<a href=https://www.ebi.ac.uk/chembl/assay/inspect/%1>%1</a>"
    set format T_tbl.pubmed_id "<a href=https://www.ncbi.nlm.nih.gov/pubmed/%1>%1</a>"
    set format T_tbl.pchembl color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
    set format T_tbl.pAct color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
    # header
#    if Type(s_query) == "sarray" then
#        add header T_tbl Sum(s_query, "; ") name="query_string"
#    elseif Type(s_query) == "string" then
#        add header T_tbl s_query name="query_string"
#    endif
#    if s_type == "chem" then
#        add header T_tbl "Chemical Name" name="query_type"
#    elseif s_type == "chembl id" then
#        add header T_tbl "ChEMBL ID" name="query_type"
#    elseif s_type == "smiles" then
#        add header T_tbl "SMILES" name="query_type"
#    elseif s_type == "substruct" then
#        add header T_tbl "Substructure" name="query_type"
#    elseif s_type == "drugbank id" then
#        add header T_tbl "DrugBank ID" name="query_type"
#    elseif s_type == "uniprot id" then
#        add header T_tbl "UniProt ID" name="query_type"
#    elseif s_type == "uniprot ac" then
#        add header T_tbl "UniProt AC" name="query_type"
#    elseif s_type == "protein" then
#        add header T_tbl "Protein Name" name="query_type"
#    elseif s_type == "action" then
#        add header T_tbl "Action" name="query_type"
#    endif
#    set property T_tbl header on
#    if s_type == 'substruct' then
#        s_query = Replace(s_query, "smiles:", "")
#        add header T_tbl String(Chemical(s_query smiles)) name="scaffold"
#        select chemical T_tbl.mol s_query
#        set property T_tbl chemical link off
#    endif
    return T_tbl
endfunction

macro findChemblBest s_table_name
    l_info = l_warn = no
    HELP =  """
    Get the best ChEMBL bioactivity for each chemical in a table

    Parameter:
        's_table_name'  : table name

    """
    XTBL = $s_table_name
    add column XTBL Smiles($s_table_name.mol unique cistrans) + $s_table_name.name + $s_table_name.fullname + $s_table_name.target_type name="TMP"
    sort XTBL.pAct reverse
    group XTBL.TMP XTBL.mol "first,mol" XTBL.name "first,name" XTBL.synonyms "first,synonyms" XTBL.uniprot_id "first,uniprot_id" XTBL.fullname "first,fullname" XTBL.name "count,records" XTBL.pAct "first,best_pAct" XTBL.pAct "rmsd,rmsd_pAct" XTBL.comment "first,comment" XTBL.target_type "first,target_type" XTBL.target_class "first,target_class" XTBL.organism_class "first,organism_class" XTBL.type "first,type" XTBL.relation "first,relation" XTBL.value "first,value" XTBL.unit "first,unit" XTBL.pchembl "first,pchembl" XTBL.confidence "first,confidence" XTBL.validity "first,validity" XTBL.description "first,description" XTBL.activity_id "first,activity_id" XTBL.assay_id "first,assay_id" XTBL.pubmed_id "first,pubmed_id" XTBL.version "first,version" name="XTBL"
    delete XTBL.TMP
    set format XTBL.uniprot_id "<a href=http://www.uniprot.org/uniprot/%1>%1</a>"
    set format XTBL.assay_id "<a href=https://www.ebi.ac.uk/chembl/assay/inspect/%1>%1</a>"
    set format XTBL.pubmed_id "<a href=https://www.ncbi.nlm.nih.gov/pubmed/%1>%1</a>"
    set format XTBL.pchembl color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
    set format XTBL.best_pAct color="rainbow='#FFFFFF/#FFFF76/#FF7676/#FF76FF/#7676FF,5.:9.,linear/0.:0./0.3:0.3/0.7:0.7/1.:1.'"
    move XTBL.rmsd_pAct 8
    xtblnm = s_table_name + "Best"
    if (Nof($xtblnm)!=0) delete $xtblnm
    rename XTBL xtblnm
    keep $xtblnm
endmacro

macro findChemblSumm s_table_name
    l_info = l_warn = no
    HELP =  """
    Get the summary of ChEMBL bioactivity for each chemical in a table

    Parameter:
        's_table_name'  : table name

    """
    XTBLTmp = $s_table_name ; sort reverse XTBLTmp.pAct
    add column XTBLTmp Smiles($s_table_name.mol unique cistrans) + $s_table_name.name name="TMP"
    group XTBLTmp.TMP XTBLTmp.name "first,name" name="XTBL" ; delete XTBL.name
    add column XTBL Chemical(Nof(XTBL)) name="mol"
    add column XTBL Sarray(Nof(XTBL)) name="name"
    add column XTBL Iarray(Nof(XTBL)) name="records"
    add column XTBL Sarray(Nof(XTBL)) name="synonyms"
    add column XTBL Sarray(Nof(XTBL)) name="uniprot_id"
    add column XTBL Sarray(Nof(XTBL)) name="fullname"
    add column XTBL Sarray(Nof(XTBL)) name="pAct"
    add column XTBL Sarray(Nof(XTBL)) name="comment"
    add column XTBL Sarray(Nof(XTBL)) name="target_type"
    add column XTBL Sarray(Nof(XTBL)) name="target_class"
    add column XTBL Sarray(Nof(XTBL)) name="organism_class"
    add column XTBL Sarray(Nof(XTBL)) name="type"
    add column XTBL Sarray(Nof(XTBL)) name="relation"
    add column XTBL Sarray(Nof(XTBL)) name="value"
    add column XTBL Sarray(Nof(XTBL)) name="unit"
    add column XTBL Sarray(Nof(XTBL)) name="pchembl"
    add column XTBL Sarray(Nof(XTBL)) name="confidence"
    add column XTBL Sarray(Nof(XTBL)) name="validity"
    add column XTBL Sarray(Nof(XTBL)) name="description"
    add column XTBL Sarray(Nof(XTBL)) name="activity_id"
    add column XTBL Sarray(Nof(XTBL)) name="assay_id"
    add column XTBL Sarray(Nof(XTBL)) name="pubmed_id"
    add column XTBL Sarray(Nof(XTBL)) name="version"
    for xx = 1, Nof(XTBL)
        xtmp = XTBLTmp.TMP == XTBL.TMP [xx]
        XTBL.mol [xx]            = Nof(xtmp) == 0 ? "" : xtmp.mol [1]
        XTBL.name [xx]           = Nof(xtmp) == 0 ? "" : xtmp.name [1]
        XTBL.synonyms [xx]       = Nof(xtmp) == 0 ? "" : xtmp.synonyms [1]
        XTBL.records [xx]        = Nof(xtmp) == 0 ? "" : Nof(xtmp)
        XTBL.uniprot_id [xx]     = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.uniprot_id), "\n")
        XTBL.fullname [xx]       = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.fullname), "\n")
        XTBL.target_type [xx]    = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.target_type), "\n")
        XTBL.target_class [xx]   = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.target_class), "\n")
        XTBL.organism_class [xx] = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.organism_class), "\n")
        XTBL.type [xx]           = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.type), "\n")
        XTBL.relation [xx]       = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.relation), "\n")
        XTBL.value [xx]          = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.value), "\n")
        XTBL.unit [xx]           = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.unit), "\n")
        XTBL.pchembl [xx]        = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.pchembl), "\n")
        XTBL.pAct [xx]           = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.pAct), "\n")
        XTBL.confidence [xx]     = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.confidence), "\n")
        XTBL.comment [xx]        = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.comment), "\n")
        XTBL.validity [xx]       = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.validity), "\n")
        XTBL.description [xx]    = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.description), "\n")
        XTBL.activity_id [xx]    = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.activity_id), "\n")
        XTBL.assay_id [xx]       = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.assay_id), "\n")
        XTBL.pubmed_id [xx]      = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.pubmed_id), "\n")
        XTBL.version [xx]        = Nof(xtmp) == 0 ? "" : Sum(Sarray(Iarray(xtmp.version)), "\n")
    endfor
    delete XTBL.TMP
    xtblnm = s_table_name + "Summ"
    if (Nof($xtblnm)!=0) delete $xtblnm
    rename XTBL xtblnm
    keep $xtblnm
endmacro

function funcChembl( P_mol )
    l_info = l_warn = no
    group table QA cloudStandardizeChem(P_mol) "mol"
    add column QA InChi(QA.mol) name="inchi"
    XTmp = funcChemblJson(QA.inchi, Sarray(Nof(QA), "inchi"), no, "")
    XTBL = Table(XTmp)
    if ! Exist(XTBL.bioactivity) then
        print "Warning> No data found"
        return Collection()
    endif
    print "All data retrieved, ICM converting..."
    XTBL = funcChemblJsonTable(XTBL)
    modify XTBL.mol auto
    modify XTBL.mol delete charge
    add column XTBL InChi(XTBL.mol) name="inchi"
    modify XTBL.mol delete salt simple
    add column XTBL InChi(XTBL.mol) name="inchi_nosalt"
    add column XTBL Field(XTBL.inchi_nosalt 1 "/") + Sarray(Nof(XTBL), "/") + Field(XTBL.inchi_nosalt 2 "/") + Sarray(Nof(XTBL), "/") + Field(XTBL.inchi_nosalt 3 "/") + Sarray(Nof(XTBL), "/") + Field(XTBL.inchi_nosalt 4 "/") name="inchi_nosalt_nostereo"
    delete XTBL.smiles ; delete XTBL.mol
    sort reverse XTBL.pAct
    group table OTBL Sarray(Nof(QA)) "ChEMBL_ID" Sarray(Nof(QA)) "ChEMBL_name" Sarray(Nof(QA)) "ChEMBL_synonyms" Sarray(Nof(QA)) "ChEMBL_uniprot_id" Sarray(Nof(QA)) "ChEMBL_fullname" Sarray(Nof(QA)) "ChEMBL_target_type" Sarray(Nof(QA)) "ChEMBL_target_class" Sarray(Nof(QA)) "ChEMBL_organism_class" Sarray(Nof(QA)) "ChEMBL_type" Sarray(Nof(QA)) "ChEMBL_relation" Sarray(Nof(QA)) "ChEMBL_value" Sarray(Nof(QA)) "ChEMBL_unit" Sarray(Nof(QA)) "ChEMBL_pchembl" Sarray(Nof(QA)) "ChEMBL_pAct" Sarray(Nof(QA)) "ChEMBL_confidence" Sarray(Nof(QA)) "ChEMBL_comment" Sarray(Nof(QA)) "ChEMBL_validity" Sarray(Nof(QA)) "ChEMBL_description" Sarray(Nof(QA)) "ChEMBL_activity_id" Sarray(Nof(QA)) "ChEMBL_assay_id" Sarray(Nof(QA)) "ChEMBL_pubmed_id" Iarray(Nof(QA)) "ChEMBL_records" Sarray(Nof(QA)) "ChEMBL_version"
    modify QA.mol delete salt simple
    add column QA InChi(QA.mol) name="inchi_nosalt"
    add column QA Field(QA.inchi_nosalt 1 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 2 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 3 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 4 "/") name="inchi_nosalt_nostereo"
    for xx = 1, Nof(QA)
        xtmp = XTBL.inchi == QA.inchi [xx]
        if Nof(xtmp) == 0 then
            xtmp = XTBL.inchi_nosalt == QA.inchi_nosalt [xx]
            if Nof(xtmp) == 0 then
                xtmp = XTBL.inchi_nosalt_nostereo == QA.inchi_nosalt_nostereo [xx]
            endif
        endif
        idtmp = Sarray()
        if Nof(xtmp) != 0 then
            syntmp = Sarray(xtmp.name [1]) // Split(xtmp.synonyms [1], "\n")
            for jx = 1, Nof(syntmp)
                if Match(syntmp [jx], "^[cC][hH][eE][mM][bB][lL][0-9]{1,9}") != "" then
                    idtmp = idtmp // Match(syntmp [jx], "^[cC][hH][eE][mM][bB][lL][0-9]{1,9}")
                endif
            endfor
        endif
        OTBL.ChEMBL_ID [xx]                = Nof(xtmp) == 0 ? "" : Sum(idtmp, "\n")
        OTBL.ChEMBL_name [xx]              = Nof(xtmp) == 0 ? "" : xtmp.name [1]
        OTBL.ChEMBL_synonyms [xx]          = Nof(xtmp) == 0 ? "" : xtmp.synonyms [1]
        OTBL.ChEMBL_uniprot_id [xx]        = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.uniprot_id), "\n")
        OTBL.ChEMBL_fullname [xx]          = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.fullname), "\n")
        OTBL.ChEMBL_target_type [xx]       = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.target_type), "\n")
        OTBL.ChEMBL_target_class [xx]      = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.target_class), "\n")
        OTBL.ChEMBL_organism_class [xx]    = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.organism_class), "\n")
        OTBL.ChEMBL_type [xx]              = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.type), "\n")
        OTBL.ChEMBL_relation [xx]          = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.relation), "\n")
        OTBL.ChEMBL_value [xx]             = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.value), "\n")
        OTBL.ChEMBL_unit [xx]              = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.unit), "\n")
        OTBL.ChEMBL_pchembl [xx]           = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.pchembl), "\n")
        OTBL.ChEMBL_pAct [xx]              = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.pAct), "\n")
        OTBL.ChEMBL_confidence [xx]        = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.confidence), "\n")
        OTBL.ChEMBL_comment [xx]           = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.comment), "\n")
        OTBL.ChEMBL_validity [xx]          = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.validity), "\n")
        OTBL.ChEMBL_description [xx]       = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.description), "\n")
        OTBL.ChEMBL_activity_id [xx]       = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.activity_id), "\n")
        OTBL.ChEMBL_assay_id [xx]          = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.assay_id), "\n")
        OTBL.ChEMBL_pubmed_id [xx]         = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.pubmed_id), "\n")
        OTBL.ChEMBL_records [xx]           = Nof(xtmp) == 0 ? 0 : Nof(xtmp)
        OTBL.ChEMBL_version [xx]           = Nof(xtmp) == 0 ? "" : Sum(Sarray(Iarray(xtmp.version)), "\n")
    endfor
    XCOL = Collection()
    XCOL["ChEMBL_ID"]                = Collection("_", OTBL.ChEMBL_ID "FORMAT" Collection(OTBL format)["ChEMBL_ID"])
    XCOL["ChEMBL_name"]              = Collection("_", OTBL.ChEMBL_name "FORMAT" Collection(OTBL format)["ChEMBL_name"])
    XCOL["ChEMBL_synonyms"]          = Collection("_", OTBL.ChEMBL_synonyms "FORMAT" Collection(OTBL format)["ChEMBL_synonyms"])
    XCOL["ChEMBL_uniprot_id"]        = Collection("_", OTBL.ChEMBL_uniprot_id "FORMAT" Collection(OTBL format)["ChEMBL_uniprot_id"])
    XCOL["ChEMBL_fullname"]          = Collection("_", OTBL.ChEMBL_fullname "FORMAT" Collection(OTBL format)["ChEMBL_fullname"])
    XCOL["ChEMBL_target_type"]       = Collection("_", OTBL.ChEMBL_target_type "FORMAT" Collection(OTBL format)["ChEMBL_target_type"])
    XCOL["ChEMBL_target_class"]      = Collection("_", OTBL.ChEMBL_target_class "FORMAT" Collection(OTBL format)["ChEMBL_target_class"])
    XCOL["ChEMBL_organism_class"]    = Collection("_", OTBL.ChEMBL_organism_class "FORMAT" Collection(OTBL format)["ChEMBL_organism_class"])
    XCOL["ChEMBL_type"]              = Collection("_", OTBL.ChEMBL_type "FORMAT" Collection(OTBL format)["ChEMBL_type"])
    XCOL["ChEMBL_relation"]          = Collection("_", OTBL.ChEMBL_relation "FORMAT" Collection(OTBL format)["ChEMBL_relation"])
    XCOL["ChEMBL_value"]             = Collection("_", OTBL.ChEMBL_value "FORMAT" Collection(OTBL format)["ChEMBL_value"])
    XCOL["ChEMBL_unit"]              = Collection("_", OTBL.ChEMBL_unit "FORMAT" Collection(OTBL format)["ChEMBL_unit"])
    XCOL["ChEMBL_pchembl"]           = Collection("_", OTBL.ChEMBL_pchembl "FORMAT" Collection(OTBL format)["ChEMBL_pchembl"])
    XCOL["ChEMBL_pAct"]              = Collection("_", OTBL.ChEMBL_pAct "FORMAT" Collection(OTBL format)["ChEMBL_pAct"])
    XCOL["ChEMBL_confidence"]        = Collection("_", OTBL.ChEMBL_confidence "FORMAT" Collection(OTBL format)["ChEMBL_confidence"])
    XCOL["ChEMBL_comment"]           = Collection("_", OTBL.ChEMBL_comment "FORMAT" Collection(OTBL format)["ChEMBL_comment"])
    XCOL["ChEMBL_validity"]          = Collection("_", OTBL.ChEMBL_validity "FORMAT" Collection(OTBL format)["ChEMBL_validity"])
    XCOL["ChEMBL_description"]       = Collection("_", OTBL.ChEMBL_description "FORMAT" Collection(OTBL format)["ChEMBL_description"])
    XCOL["ChEMBL_activity_id"]       = Collection("_", OTBL.ChEMBL_activity_id "FORMAT" Collection(OTBL format)["ChEMBL_activity_id"])
    XCOL["ChEMBL_assay_id"]          = Collection("_", OTBL.ChEMBL_assay_id "FORMAT" Collection(OTBL format)["ChEMBL_assay_id"])
    XCOL["ChEMBL_pubmed_id"]         = Collection("_", OTBL.ChEMBL_pubmed_id "FORMAT" Collection(OTBL format)["ChEMBL_pubmed_id"])
    XCOL["ChEMBL_records"]           = Collection("_", OTBL.ChEMBL_records "FORMAT" Collection(OTBL format)["ChEMBL_records"])
    XCOL["ChEMBL_version"]           = Collection("_", OTBL.ChEMBL_version "FORMAT" Collection(OTBL format)["ChEMBL_version"])
    return XCOL
endfunction

macro findChemblObject os_1 s_uniprot l_mammalian (yes) l_keep (no) l_quiet (no) auto
    l_info = l_warn = no
    if Nof(Mol(os_1)) == 0 then
        print "Warning> no molecules found in the object"
        return
    endif
#    S_mammalian = {"HUMAN","MOUSE","RAT","BOVIN","PIG","RABIT","CANLF","CAVPO","MACMU","SHEEP","MACFA","CRIGR","MESAU","HORSE","CAMDR","CANFA"}
    S_mammalian = {"HUMAN","MOUSE","RAT","BOVIN","PIG","RABIT","CANLF","CAVPO","MACMU","SHEEP","MACFA","CRIGR","MESAU","HORSE","CHLAE","CALJA","FELCA","MICOH","MUSCR","PANTR","CAPHI","CRILO","MERUN"}
    if l_mammalian then
        S_query = Sarray(Nof(S_mammalian), s_uniprot) + Sarray(Nof(S_mammalian), "_") + S_mammalian
        S_type = Sarray(Nof(S_mammalian), "uniprot id")
    else
        S_query = Sarray(s_uniprot)
        S_type = Sarray("uniprot id")
    endif
    group table QA cloudStandardizeChem(Chemical(Mol(os_1))) "mol" Name(Mol(os_1) full) "objname"
    add column QA InChi(QA.mol) name="inchi"
    S_query //= QA.inchi
    S_type //= Sarray(Nof(QA), "inchi")
    group table QE S_query "name" S_type "type"
    XTmp = funcChemblJson(S_query, S_type, no, "")
    XTBL = Table(XTmp)
    if ! Exist(XTBL.bioactivity) then
        delete XTBL
        print " Warning> no data retrieved"
        return
    endif
    print "All data retrieved, ICM converting..."
    XTBL = funcChemblJsonTable(XTBL)
    delete XTBL.type != "Ki" & XTBL.type != "Kd" & XTBL.type != "IC50" & XTBL.type != "EC50"
    delete XTBL.uniprot_id != QE.name [Index(QE.type == "uniprot id")]
    l_info = yes ; add column XTBL Chemical(XTBL.smiles smiles) name="mol" index=1 ; l_info = no
    modify XTBL.mol auto
    modify XTBL.mol delete charge
    add column XTBL InChi(XTBL.mol) name="inchi"
    modify XTBL.mol delete salt simple
    add column XTBL InChi(XTBL.mol) name="inchi_nosalt"
    add column XTBL Field(XTBL.inchi_nosalt 1 "/") + Sarray(Nof(XTBL), "/") + Field(XTBL.inchi_nosalt 2 "/") + Sarray(Nof(XTBL), "/") + Field(XTBL.inchi_nosalt 3 "/") + Sarray(Nof(XTBL), "/") + Field(XTBL.inchi_nosalt 4 "/") name="inchi_nosalt_nostereo"
    delete XTBL.smiles ; delete XTBL.mol
    sort reverse XTBL.pAct
    group table OTBL QA.mol "mol" QA.objname "objname" Sarray(Nof(QA)) "ChEMBL_ID" Sarray(Nof(QA)) "ChEMBL_name" Sarray(Nof(QA)) "ChEMBL_synonyms" Sarray(Nof(QA)) "ChEMBL_uniprot_id" Sarray(Nof(QA)) "ChEMBL_fullname" Sarray(Nof(QA)) "ChEMBL_target_type" Sarray(Nof(QA)) "ChEMBL_target_class" Sarray(Nof(QA)) "ChEMBL_organism_class" Sarray(Nof(QA)) "ChEMBL_type" Sarray(Nof(QA)) "ChEMBL_relation" Sarray(Nof(QA)) "ChEMBL_value" Sarray(Nof(QA)) "ChEMBL_unit" Sarray(Nof(QA)) "ChEMBL_pchembl" Sarray(Nof(QA)) "ChEMBL_pAct" Sarray(Nof(QA)) "ChEMBL_confidence" Sarray(Nof(QA)) "ChEMBL_comment" Sarray(Nof(QA)) "ChEMBL_validity" Sarray(Nof(QA)) "ChEMBL_description" Sarray(Nof(QA)) "ChEMBL_activity_id" Sarray(Nof(QA)) "ChEMBL_assay_id" Sarray(Nof(QA)) "ChEMBL_pubmed_id" Iarray(Nof(QA)) "ChEMBL_records" Sarray(Nof(QA)) "ChEMBL_version"
    modify QA.mol delete salt simple
    add column QA InChi(QA.mol) name="inchi_nosalt"
    add column QA Field(QA.inchi_nosalt 1 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 2 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 3 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 4 "/") name="inchi_nosalt_nostereo"
    for xx = 1, Nof(QA)
        xtmp = XTBL.inchi == QA.inchi [xx]
        if Nof(xtmp) == 0 then
            xtmp = XTBL.inchi_nosalt == QA.inchi_nosalt [xx]
            if Nof(xtmp) == 0 then
                xtmp = XTBL.inchi_nosalt_nostereo == QA.inchi_nosalt_nostereo [xx]
            endif
        endif
        idtmp = Sarray()
        if Nof(xtmp) != 0 then
            syntmp = Sarray(xtmp.name [1]) // Split(xtmp.synonyms [1], "\n")
            for jx = 1, Nof(syntmp)
                if Match(syntmp [jx], "^[cC][hH][eE][mM][bB][lL][0-9]{1,9}") != "" then
                    idtmp = idtmp // Match(syntmp [jx], "^[cC][hH][eE][mM][bB][lL][0-9]{1,9}")
                endif
            endfor
        endif
        if Nof(xtmp) != 0 then
            sprintf "best pKd: %.2f, %s", Max(xtmp.pAct), xtmp.name[1] name="SCMT"
            OBJNM = QA.objname [xx]
            set comment $OBJNM SCMT
        endif
        OTBL.ChEMBL_ID [xx]                = Nof(xtmp) == 0 ? "" : Sum(idtmp, "\n")
        OTBL.ChEMBL_name [xx]              = Nof(xtmp) == 0 ? "" : xtmp.name [1]
        OTBL.ChEMBL_synonyms [xx]          = Nof(xtmp) == 0 ? "" : xtmp.synonyms [1]
        OTBL.ChEMBL_uniprot_id [xx]        = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.uniprot_id), "\n")
        OTBL.ChEMBL_fullname [xx]          = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.fullname), "\n")
        OTBL.ChEMBL_target_type [xx]       = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.target_type), "\n")
        OTBL.ChEMBL_target_class [xx]      = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.target_class), "\n")
        OTBL.ChEMBL_organism_class [xx]    = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.organism_class), "\n")
        OTBL.ChEMBL_type [xx]              = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.type), "\n")
        OTBL.ChEMBL_relation [xx]          = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.relation), "\n")
        OTBL.ChEMBL_value [xx]             = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.value), "\n")
        OTBL.ChEMBL_unit [xx]              = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.unit), "\n")
        OTBL.ChEMBL_pchembl [xx]           = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.pchembl), "\n")
        OTBL.ChEMBL_pAct [xx]              = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.pAct), "\n")
        OTBL.ChEMBL_confidence [xx]        = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.confidence), "\n")
        OTBL.ChEMBL_comment [xx]           = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.comment), "\n")
        OTBL.ChEMBL_validity [xx]          = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.validity), "\n")
        OTBL.ChEMBL_description [xx]       = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.description), "\n")
        OTBL.ChEMBL_activity_id [xx]       = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.activity_id), "\n")
        OTBL.ChEMBL_assay_id [xx]          = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.assay_id), "\n")
        OTBL.ChEMBL_pubmed_id [xx]         = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.pubmed_id), "\n")
        OTBL.ChEMBL_records [xx]           = Nof(xtmp) == 0 ? 0 : Nof(xtmp)
        OTBL.ChEMBL_version [xx]           = Nof(xtmp) == 0 ? "" : Sum(Sarray(Iarray(xtmp.version)), "\n")
    endfor
    if l_keep then
        xtblnm = "chembl_" + Sum(Name(os_1), "_")
        if (Nof($xtblnm)!=0) delete $xtblnm
        rename OTBL xtblnm
        keep $xtblnm
        print xtblnm, "hit table loaded"
    endif
endmacro

macro findDrugbank S_query ({""}) s_where ("") l_append (no) l_quiet (no)
  l_commands = l_info = l_warn = no

  p = Collection()

  if (s_where == "act") p["act"] = "activities"
  p["maxHits"] = 5000
  p["what"] = Sum(S_query,"|")
  p["where"] = s_where
  #s_url =  "http://mars.molsoft.com/cgi-bin/drugbanksearch.cgi?" + String( p html )
  #s_tab = "drugbank_hits"
  s_url =  "http://mars.molsoft.com/cgi-bin/drugcentralsearch.cgi?" + String( p html )
  s_tab = "drugcentral_hits"
  s_url
  s_act_tab = ""
  if (s_where == "act") then
    s_act_tab = Name( "t_act_" + Sum(S_query,"_") unique )
    read table s_url name=s_act_tab
  else
    read string s_url
    if (Length(s_out) > 0 & s_out !~ "*Error>*") then
      read table mol input=s_out name="t"
    else
      print s_out
      print " Warning> no hits found for you query: " + Sum(S_query,"|")
    endif
  endif

  if (s_act_tab == "") then
    if ( !l_append ) delete $s_tab

    if (Nof(t) > 0) then
      add $s_tab t
      set format $s_tab.URL "<a href=%1 >%1</a>"
      add column $s_tab name="act" simple function = "num_act ? 'Load Activities' :''"
      delete $s_tab.num_act
      set format $s_tab.act Link( "findDrugbank Sarray( 1 String( %@.ID[%#] )) 'act' no no" command )

  #    set format $s_tab.drugbank_id "<a href=https://www.drugbank.ca/drugs/%1>%1</a>"
  #    set format $s_tab.ChEMBL_id "<a href=https://www.ebi.ac.uk/chembl/compound/inspect/%1>%1</a>"
  #    set format $s_tab.KEGG_id "<a href=https://www.genome.jp/dbget-bin/www_bget?dr:%1>%1</a>"
  #    set format $s_tab.target_uniprot_id "<a href=http://www.uniprot.org/uniprot/%1>%1</a>"
      keep global $s_tab
    endif
  else
    keep global $s_act_tab
  endif
endmacro

# macro findDrugbank S_query ({""}) S_type ({""}) l_append (no) l_quiet (no)
#     l_info = l_warn = no
#     HELP =  """
#
#       findDrugbank macro returns drugbank activity data for either chemical or protein queries
#        from a local drugbank database in the Molsoft Cloud.
#
#       Usage: findDrugbank <string> <type>
#       Parameter:
#         - string: query string
#         - type:
#             - "chem": chemical name,
#             - "smiles": smiles,
#             - "substruct": substruct,
#             - "drugbank id": drugbank id,
#             - "uniprot id": uniprot id,
#             - "uniprot ac": uniprot accession number,
#             - "protein": protein name,
#             - "action": action (agonist, antagoinst, etc)
#             - "status": status (approved, investigational, experimental, nutraceutical, withdrawn, etc)
#     """
#     XTmp = funcDrugbankJson(S_query, S_type)
#     XTBL = Table(XTmp)
#     if ! Exist(XTBL.data) then
#         delete XTBL
#         delete XTmp
#         # guess the source of the first non-empty field when no data retrieve
#         l_guess = 0
#         if Nof(Unique(S_type sort)) == 1 then
#             if Match(S_query [1] "\w{1,16}_\w{1,16}") != "" then
#                 l_guess = 1
#                 S_type = Sarray(Nof(S_type), "uniprot id")
#             elseif Match(Toupper(S_query [1]) "[OPQ][0-9][A-Z0-9]{3}[0-9]|[A-NR-Z][0-9]([A-Z][A-Z0-9]{2}[0-9]){1,2}") != "" then
#                 l_guess = 1
#                 S_type = Sarray(Nof(S_type), "uniprot ac")
#             elseif Match(Toupper(S_query [1]) "CHEMBL[0-9]{1,9}") != "" then
#                 l_guess = 1
#                 S_type = Sarray(Nof(S_type), "chembl id")
#             elseif Match(Toupper(S_query [1]) "(DB|APRD|BIOD|BTD|EXPT|NUTR)[0-9]{5}") != "" then
#                 l_guess = 1
#                 S_type = Sarray(Nof(S_type), "drugbank id")
#             endif
#         endif
#         if l_guess == 1 then
#             print "Initial query not found, guessing applies to source type:", Unique(S_type sort)[1]
#             XTmp = funcDrugbankJson(S_query, S_type)
#             XTBL = Table(XTmp)
#             if ! Exist(XTBL.data) then
#                 delete XTBL
#                 print " Warning> no data retrieved"
#                 return Collection()
#             endif
#         else
#             print " Warning> no data retrieved"
#             return Collection()
#         endif
#     endif
#     print "Data retrieved, ICM converting..."
#     xtblnm = XTmp ["XNM"] ; delete XTmp.XNM
#     XTBL = funcDrugbankJsonTable(XTBL)
#     XDLST = Unique(Match(Split(Sum(XTBL.target "\n") "\n") "(.*); (.*); (.*); (.*)" 1) sort) != ""
#     XDLST = {"All"} // XDLST
#     # cursor
#     sprintf """# b_Get_target_pairs_from_selection (findDrugbankTarget Name(variable %%@) $dtype Index(%%@ selection cursor))
# # s_Target_type:dtype (%s) [RDONLY]""", Sum(XDLST,"|") name="XCUR"
#     add header XTBL name="cursor" XCUR
#     xtblnm = "DB_" + xtblnm
#     if (Nof($xtblnm)!=0) delete $xtblnm
#     rename XTBL xtblnm
#     s_status = ""
#     keep s_status
#     keep $xtblnm
#     print xtblnm, "hit table loaded"
# endmacro

# function funcDrugbankJson S_query S_type
#     l_info = l_warn = no
#     i_cnt = 0
#     i_len = 0
#     qName = Sarray()
#     qJson = Sarray()
#     XTmp = Collection("data" Array())
#     group table QA S_query "name" S_type "type"
#     for xx = 1, Nof(QA)
#         print bar Nof(QA) l_info=yes
#         x_query = QA.name [xx]
#         x_type = QA.type [xx]
#         if (x_type == 'chem' & Length(x_query) < 3) then
#             print HELP + " Warning> minimum word size >= 3"
#             return Collection()
#         endif
#         if x_query[1:3] == 'smi' then
#             x_query = Replace(x_query, "smiles:", "")
#             group table XQ cloudStandardizeChem(Chemical(x_query smiles)) "mol"
#             if x_type == 'substruct' then
#                 x_query = Smiles(XQ.mol unique)[1]
#                 x_type = 'substruct'
#             else
#                 x_query = InChi(XQ.mol)[1]
#                 x_type = 'inchi'
#             endif
#         endif
#         if x_type == 'hash' then
#             x_query = String(x_query 32 hash)
#         endif
#         if x_type == 'smiles' | x_type == 'substruct' | x_type == 'inchi' then
#             qName = qName // Formula(Chemical(x_query smiles))[1]
#         else
#             qName = qName // Name(x_query simple)
#         endif
#         sprintf '{"name":"%s","type":"%s"}', String(x_query html), String(x_type html) name="stmp"
#         i_cnt = i_cnt + 1
#         i_len = i_len + Length(stmp)
#         qJson = qJson // stmp
#         if i_len > 1024*6 | xx == Nof(QA) then
#             sprintf 'http://www.molsoft.com/cloudAPI/getDrugbankActivity?q={"data":[%s]}', Sum(qJson, ",") name="sJson"
#             for jx = 1, 5
#                 read string sJson name="s_out"
#                 i_len = 0
#                 qJson = Sarray()
#                 if Index(s_out, "Server Error (500)") == 0 then
#                     XTmp ["data"] = XTmp ["data"] // Collection(s_out) ["bioactivity"]
#                     break
#                 elseif jx == 5 then
#                     print " Warning> Server Error (500)"
#                     return Collection()
#                 endif
#             endfor
#         endif
#     endfor
#     print bar "End\n" l_info = yes
#     XTmp ["XNM"] = Sum(qName, "_")
#     return XTmp
# endfunction

function funcDrugbankJsonTable T_tbl
    l_info = l_warn = no
    add column T_tbl function="data.smiles" name="smiles" static
    add column T_tbl function="Icm::String(data.drugbank_id==null?'':data.drugbank_id)" name="drugbank_id" static
    add column T_tbl function="Icm::String(data.status==null?'':data.status)" name="status" static
    add column T_tbl function="Icm::String(data.type==null?'':data.type)" name="type" static
    add column T_tbl function="Icm::String(data.name==null?'':data.name)" name="name" static
    add column T_tbl function="Icm::String(data.cas==null?'':data.cas)" name="cas" static
    add column T_tbl function="Icm::String(data.synonyms==null?'':data.synonyms)" name="synonyms" static
    add column T_tbl function="Icm::String(data.description==null?'':data.description)" name="description" static
    add column T_tbl function="Icm::String(data.indication==null?'':data.indication)" name="indication" static
    add column T_tbl function="Icm::String(data.metabolism==null?'':data.metabolism)" name="metabolism" static
    add column T_tbl function="Icm::String(data.moa==null?'':data.moa)" name="moa" static
    add column T_tbl function="Icm::String(data.toxicity==null?'':data.toxicity)" name="toxicity" static
    add column T_tbl function="Icm::String(data.absorption==null?'':data.absorption)" name="absorption" static
    add column T_tbl function="Icm::String(data.pharmacodynamics==null?'':data.pharmacodynamics)" name="pharmacodynamics" static
    add column T_tbl function="Icm::String(data.pathway==null?'':data.pathway)" name="pathway" static
    add column T_tbl function="Icm::String(data.clearance==null?'':data.clearance)" name="clearance" static
    add column T_tbl function="Icm::String(data.elimination==null?'':data.elimination)" name="elimination" static
    add column T_tbl function="Icm::String(data.route==null?'':data.route)" name="route" static
    add column T_tbl function="Icm::String(data.category==null?'':data.category)" name="category" static
    add column T_tbl function="Icm::String(data.distribution==null?'':data.distribution)" name="distribution" static
    add column T_tbl function="Icm::String(data.salt==null?'':data.salt)" name="salt" static
    add column T_tbl function="Icm::String(data.uniprot_id==null?'':data.uniprot_id)" name="uniprot_id" static
    add column T_tbl function="Icm::String(data.fullname==null?'':data.fullname)" name="fullname" static
    add column T_tbl function="Icm::String(data.type==null?'':data.type)" name="target_type" static
    add column T_tbl function="Icm::String(data.action==null?'':data.action)" name="action" static
    add column T_tbl function="Icm::String(data.half_life==null?'':data.half_life)" name="half_life" static
    add column T_tbl function="Icm::String(data.solubility==null?'':data.solubility)" name="solubility" static
    add column T_tbl function="Icm::String(data.melting_point==null?'':data.melting_point)" name="melting_point" static
    add column T_tbl function="Icm::String(data.boiling_point==null?'':data.boiling_point)" name="boiling_point" static
    add column T_tbl function="Icm::String(data.logP==null?'':data.logP)" name="logP" static
    add column T_tbl function="Icm::String(data.logS==null?'':data.logS)" name="logS" static
    add column T_tbl function="Icm::String(data.hydrophobicity==null?'':data.hydrophobicity)" name="hydrophobicity" static
    add column T_tbl function="Icm::String(data.isoelectric_point==null?'':data.isoelectric_point)" name="isoelectric_point" static
    add column T_tbl function="Icm::String(data.pKa==null?'':data.pKa)" name="pKa" static
    add column T_tbl function="Icm::String(data.caco2_permeability==null?'':data.caco2_permeability)" name="caco2_permeability" static
    add column T_tbl function="Icm::String(data.target==null?'':data.target)" name="target" static
    l_info = yes ; add column T_tbl Chemical(T_tbl.smiles smiles) name="mol" index=1 ; l_info = no ; rotate T_tbl.mol
    delete T_tbl.smiles
    delete T_tbl.data
    # format
    set format T_tbl.drugbank_id "<a href=http://www.drugbank.ca/drugs/%1>%1</a>"
    set format T_tbl.uniprot_id "<a href=http://www.uniprot.org/uniprot/%1>%1</a>"
    sort T_tbl.drugbank_id
    # header
#    add header T_tbl s_query name="query"
#    if s_type == "chem" then
#        add header T_tbl "Chemical Name" name="type"
#    elseif s_type == "smiles" then
#        add header T_tbl "SMILES" name="type"
#    elseif s_type == "substruct" then
#        add header T_tbl "Substructure" name="type"
#    elseif s_type == "drugbank id" then
#        add header T_tbl "DrugBank ID" name="type"
#    elseif s_type == "uniprot id" then
#        add header T_tbl "UniProt ID" name="type"
#    elseif s_type == "uniprot ac" then
#        add header T_tbl "UniProt AC" name="type"
#    elseif s_type == "protein" then
#        add header T_tbl "Protein Name" name="type"
#    elseif s_type == "action" then
#        add header T_tbl "Action" name="type"
#    endif
#    set property T_tbl header on
#    if s_type == 'substruct' then
#        s_query = Replace(s_query, "smiles:", "")
#        add header T_tbl String(Chemical(s_query smiles)) name="scaffold"
#        select chemical T_tbl.mol s_query
#        set property T_tbl chemical link off
#    endif
    return T_tbl
endfunction

macro findDrugbankSumm s_table_name
    l_info = l_warn = no
    HELP =  """
    Get the summary of DrugBank bioactivity for each chemical in a table

    Parameter:
        's_table_name'  : table name

    """
    XTBLTmp = $s_table_name
    group XTBLTmp.mol XTBLTmp.name "first,name" name="XTBL" ; delete XTBL.name
    add column XTBL Sarray(Nof(XTBL)) name="name"
    add column XTBL Iarray(Nof(XTBL)) name="records"
    add column XTBL Sarray(Nof(XTBL)) name="synonyms"
    add column XTBL Sarray(Nof(XTBL)) name="uniprot_id"
    add column XTBL Sarray(Nof(XTBL)) name="fullname"
    add column XTBL Sarray(Nof(XTBL)) name="target_type"
    add column XTBL Sarray(Nof(XTBL)) name="action"
    add column XTBL Sarray(Nof(XTBL)) name="status"
    add column XTBL Sarray(Nof(XTBL)) name="moa"
    add column XTBL Sarray(Nof(XTBL)) name="half_life"
    add column XTBL Sarray(Nof(XTBL)) name="solubility"
    add column XTBL Sarray(Nof(XTBL)) name="melting_point"
    add column XTBL Sarray(Nof(XTBL)) name="boiling_point"
    add column XTBL Sarray(Nof(XTBL)) name="logP"
    add column XTBL Sarray(Nof(XTBL)) name="logS"
    add column XTBL Sarray(Nof(XTBL)) name="hydrophobicity"
    add column XTBL Sarray(Nof(XTBL)) name="isoelectric_point"
    add column XTBL Sarray(Nof(XTBL)) name="pKa"
    add column XTBL Sarray(Nof(XTBL)) name="caco2_permeability"
    for xx = 1, Nof(XTBL)
        xtmp = XTBLTmp.mol == XTBL.mol [xx]
        XTBL.name [xx]               = Nof(xtmp) == 0 ? "" : xtmp.name [1]
        XTBL.synonyms [xx]           = Nof(xtmp) == 0 ? "" : xtmp.synonyms [1]
        XTBL.status [xx]             = Nof(xtmp) == 0 ? "" : xtmp.status [1]
        XTBL.moa [xx]                = Nof(xtmp) == 0 ? "" : xtmp.moa [1]
        XTBL.uniprot_id [xx]         = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.uniprot_id), "\n")
        XTBL.fullname [xx]           = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.fullname), "\n")
        XTBL.target_type [xx]        = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.target_type), "\n")
        XTBL.action [xx]             = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.action), "\n")
        XTBL.half_life [xx]          = Nof(xtmp) == 0 ? "" : xtmp.half_life [1]
        XTBL.solubility [xx]         = Nof(xtmp) == 0 ? "" : xtmp.solubility [1]
        XTBL.melting_point [xx]      = Nof(xtmp) == 0 ? "" : xtmp.melting_point [1]
        XTBL.boiling_point [xx]      = Nof(xtmp) == 0 ? "" : xtmp.boiling_point [1]
        XTBL.logP [xx]               = Nof(xtmp) == 0 ? "" : xtmp.logP [1]
        XTBL.logS [xx]               = Nof(xtmp) == 0 ? "" : xtmp.logS [1]
        XTBL.hydrophobicity [xx]     = Nof(xtmp) == 0 ? "" : xtmp.hydrophobicity [1]
        XTBL.isoelectric_point [xx]  = Nof(xtmp) == 0 ? "" : xtmp.isoelectric_point [1]
        XTBL.pKa [xx]                = Nof(xtmp) == 0 ? "" : xtmp.pKa [1]
        XTBL.caco2_permeability [xx] = Nof(xtmp) == 0 ? "" : xtmp.caco2_permeability [1]
        XTBL.records [xx]            = Nof(xtmp) == 0 ? "" : Nof(xtmp)
    endfor
    xtblnm = s_table_name + "Summ"
    if (Nof($xtblnm)!=0) delete $xtblnm
    rename XTBL xtblnm
    keep $xtblnm
endmacro

macro findDrugbankTarget s_table_name ("") s_type ("all") I_row_index ({0}) auto
    l_info = l_warn = no
    HELP =  """
    Get a list of pairwise chemical and DrugBank bioactivity in a table, which is returned from 'findDrugbank' function

    Parameter:
        's_table_name'  : table name

    """
    if (s_table_name=="") return "Warning> No table selected"
    if (Nof($s_table_name)==0) return "Table not found:", s_table_name
    group table XTBL Chemical() "mol" Sarray() "drugbank_id" Sarray() "name" Sarray() "action" Sarray() "Uniprot_ID" Sarray() "fullname" Sarray() "type"
    XSel = (I_row_index == {0}) ? Count(Nof($s_table_name)) : Index($s_table_name selection cursor)
    for xx = 1, Nof(XSel)
        xdx = XSel [xx]
        xtp = Split($s_table_name.target [xdx], "\n")
        for yy = 1, Nof(xtp)
            xt = Match(xtp [yy] "(.*); (.*); (.*); (.*)" 1)
            xu = Match(xtp [yy] "(.*); (.*); (.*); (.*)" 2)
            xf = Match(xtp [yy] "(.*); (.*); (.*); (.*)" 3)
            xa = Match(xtp [yy] "(.*); (.*); (.*); (.*)" 4)
            if (Tolower(s_type) != "all" & Tolower(xt) != Tolower(s_type)) continue
            add XTBL
            xcnt = Nof(XTBL)
            XTBL.mol [xcnt]         = $s_table_name.mol [xdx]
            XTBL.drugbank_id [xcnt] = $s_table_name.drugbank_id [xdx]
            XTBL.name [xcnt]        = $s_table_name.name [xdx]
            XTBL.action [xcnt]      = xa
            XTBL.Uniprot_ID [xcnt]  = xu
            XTBL.fullname [xcnt]    = xf
            XTBL.type [xcnt]        = xt
        endfor
    endfor
    set format XTBL.drugbank_id "<a href=http://www.drugbank.ca/drugs/%1>%1</a>"
    set format XTBL.Uniprot_ID "<a href=http://www.uniprot.org/uniprot/%1>%1</a>"
    xtblnm = s_table_name + "_target"
    if (Nof($xtblnm)!=0) delete $xtblnm
    rename XTBL xtblnm
    keep $xtblnm
endmacro

function funcDrugbank( P_mol )
  l_commands = l_info = l_warn = no
  p = Collection()
  p["what"] = Sum(Smiles(P_mol),"|")
  p["act"] = "struct2id"
  s_url =  "http://mars.molsoft.com/cgi-bin/drugbanksearch.cgi " + String( p html )
  read sarray s_url name="S_id"
  if Nof(S_id) != Nof(P_mol) then
    print " Warning> error processing request: " + Sum(S_id,"\n")
    return Collection()
  endif
  XCOL = Collection()
  XCOL["drugbank_id"]                 = Collection("_", S_id "FORMAT" Collection("format","<a href=https://www.drugbank.ca/drugs/%1>%1</a>"))
  return XCOL
endfunction

# function funcDrugbank( P_mol )
#     l_info = l_warn = no
#     group table QA cloudStandardizeChem(P_mol) "mol"
#     add column QA InChi(QA.mol) name="inchi"
#     XTmp = funcDrugbankJson(QA.inchi, Sarray(Nof(QA), "inchi"))
#     XTBL = Table(XTmp)
#     if ! Exist(XTBL.data) then
#         print " Warning> no data retrieved"
#         return Collection()
#     endif
#     print "All data retrieved, ICM converting..."
#     XTBL = funcDrugbankJsonTable(XTBL)
#     modify XTBL.mol auto
#     modify XTBL.mol delete charge
#     add column XTBL InChi(XTBL.mol) name="inchi"
#     modify XTBL.mol delete salt simple
#     add column XTBL InChi(XTBL.mol) name="inchi_nosalt"
#     add column XTBL Field(XTBL.inchi_nosalt 1 "/") + Sarray(Nof(XTBL), "/") + Field(XTBL.inchi_nosalt 2 "/") + Sarray(Nof(XTBL), "/") + Field(XTBL.inchi_nosalt 3 "/") + Sarray(Nof(XTBL), "/") + Field(XTBL.inchi_nosalt 4 "/") name="inchi_nosalt_nostereo"
#     delete XTBL.mol
#     group table OTBL Sarray(Nof(QA)) "DrugBank_ID" Sarray(Nof(QA)) "DrugBank_name" Sarray(Nof(QA)) "DrugBank_synonyms" Sarray(Nof(QA)) "DrugBank_status" Sarray(Nof(QA)) "DrugBank_moa" Sarray(Nof(QA)) "DrugBank_uniprot_id" Sarray(Nof(QA)) "DrugBank_fullname" Sarray(Nof(QA)) "DrugBank_target_type" Sarray(Nof(QA)) "DrugBank_action" Sarray(Nof(QA)) "DrugBank_half_life" Sarray(Nof(QA)) "DrugBank_solubility" Sarray(Nof(QA)) "DrugBank_melting_point" Sarray(Nof(QA)) "DrugBank_boiling_point" Sarray(Nof(QA)) "DrugBank_logP" Sarray(Nof(QA)) "DrugBank_logS" Sarray(Nof(QA)) "DrugBank_hydrophobicity" Sarray(Nof(QA)) "DrugBank_isoelectric_point" Sarray(Nof(QA)) "DrugBank_pKa" Sarray(Nof(QA)) "DrugBank_caco2_permeability" Iarray(Nof(QA)) "DrugBank_records"
#     modify QA.mol delete salt simple
#     add column QA InChi(QA.mol) name="inchi_nosalt"
#     add column QA Field(QA.inchi_nosalt 1 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 2 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 3 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 4 "/") name="inchi_nosalt_nostereo"
#     for xx = 1, Nof(QA)
#         xtmp = XTBL.inchi == QA.inchi [xx]
#         if Nof(xtmp) == 0 then
#             xtmp = XTBL.inchi_nosalt == QA.inchi_nosalt [xx]
#             if Nof(xtmp) == 0 then
#                 xtmp = XTBL.inchi_nosalt_nostereo == QA.inchi_nosalt_nostereo [xx]
#             endif
#         endif
#         OTBL.DrugBank_ID [xx]                 = Nof(xtmp) == 0 ? "" : xtmp.drugbank_id [1]
#         OTBL.DrugBank_name [xx]               = Nof(xtmp) == 0 ? "" : xtmp.name [1]
#         OTBL.DrugBank_synonyms [xx]           = Nof(xtmp) == 0 ? "" : xtmp.synonyms [1]
#         OTBL.DrugBank_status [xx]             = Nof(xtmp) == 0 ? "" : xtmp.status [1]
#         OTBL.DrugBank_moa [xx]                = Nof(xtmp) == 0 ? "" : xtmp.moa [1]
#         OTBL.DrugBank_uniprot_id [xx]         = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.uniprot_id), "\n")
#         OTBL.DrugBank_fullname [xx]           = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.fullname), "\n")
#         OTBL.DrugBank_target_type [xx]        = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.target_type), "\n")
#         OTBL.DrugBank_action [xx]             = Nof(xtmp) == 0 ? "" : Sum(Sarray(xtmp.action), "\n")
#         OTBL.DrugBank_half_life [xx]          = Nof(xtmp) == 0 ? "" : xtmp.half_life [1]
#         OTBL.DrugBank_solubility [xx]         = Nof(xtmp) == 0 ? "" : xtmp.solubility [1]
#         OTBL.DrugBank_melting_point [xx]      = Nof(xtmp) == 0 ? "" : xtmp.melting_point [1]
#         OTBL.DrugBank_boiling_point [xx]      = Nof(xtmp) == 0 ? "" : xtmp.boiling_point [1]
#         OTBL.DrugBank_logP [xx]               = Nof(xtmp) == 0 ? "" : xtmp.logP [1]
#         OTBL.DrugBank_logS [xx]               = Nof(xtmp) == 0 ? "" : xtmp.logS [1]
#         OTBL.DrugBank_hydrophobicity [xx]     = Nof(xtmp) == 0 ? "" : xtmp.hydrophobicity [1]
#         OTBL.DrugBank_isoelectric_point [xx]  = Nof(xtmp) == 0 ? "" : xtmp.isoelectric_point [1]
#         OTBL.DrugBank_pKa [xx]                = Nof(xtmp) == 0 ? "" : xtmp.pKa [1]
#         OTBL.DrugBank_caco2_permeability [xx] = Nof(xtmp) == 0 ? "" : xtmp.caco2_permeability [1]
#         OTBL.DrugBank_records [xx]            = Nof(xtmp) == 0 ? 0 : Nof(xtmp)
#     endfor
#     XCOL = Collection()
#     XCOL["DrugBank_ID"]                 = Collection("_", OTBL.DrugBank_ID "FORMAT" Collection(OTBL format)["DrugBank_ID"])
#     XCOL["DrugBank_name"]               = Collection("_", OTBL.DrugBank_name "FORMAT" Collection(OTBL format)["DrugBank_name"])
#     XCOL["DrugBank_synonyms"]           = Collection("_", OTBL.DrugBank_synonyms "FORMAT" Collection(OTBL format)["DrugBank_synonyms"])
#     XCOL["DrugBank_status"]             = Collection("_", OTBL.DrugBank_status "FORMAT" Collection(OTBL format)["DrugBank_status"])
#     XCOL["DrugBank_moa"]                = Collection("_", OTBL.DrugBank_moa "FORMAT" Collection(OTBL format)["DrugBank_moa"])
#     XCOL["DrugBank_uniprot_id"]         = Collection("_", OTBL.DrugBank_uniprot_id "FORMAT" Collection(OTBL format)["DrugBank_uniprot_id"])
#     XCOL["DrugBank_fullname"]           = Collection("_", OTBL.DrugBank_fullname "FORMAT" Collection(OTBL format)["DrugBank_fullname"])
#     XCOL["DrugBank_target_type"]        = Collection("_", OTBL.DrugBank_target_type "FORMAT" Collection(OTBL format)["DrugBank_target_type"])
#     XCOL["DrugBank_action"]             = Collection("_", OTBL.DrugBank_action "FORMAT" Collection(OTBL format)["DrugBank_action"])
#     XCOL["DrugBank_halflife"]           = Collection("_", OTBL.DrugBank_halflife "FORMAT" Collection(OTBL format)["DrugBank_halflife"])
#     XCOL["DrugBank_solubility"]         = Collection("_", OTBL.DrugBank_solubility "FORMAT" Collection(OTBL format)["DrugBank_solubility"])
#     XCOL["DrugBank_melting_point"]      = Collection("_", OTBL.DrugBank_melting_point "FORMAT" Collection(OTBL format)["DrugBank_melting_point"])
#     XCOL["DrugBank_boiling_point"]      = Collection("_", OTBL.DrugBank_boiling_point "FORMAT" Collection(OTBL format)["DrugBank_boiling_point"])
#     XCOL["DrugBank_logP"]               = Collection("_", OTBL.DrugBank_logP "FORMAT" Collection(OTBL format)["DrugBank_logP"])
#     XCOL["DrugBank_logS"]               = Collection("_", OTBL.DrugBank_logS "FORMAT" Collection(OTBL format)["DrugBank_logS"])
#     XCOL["DrugBank_hydrophobicity"]     = Collection("_", OTBL.DrugBank_hydrophobicity "FORMAT" Collection(OTBL format)["DrugBank_hydrophobicity"])
#     XCOL["DrugBank_isoelectric_point"]  = Collection("_", OTBL.DrugBank_isoelectric_point "FORMAT" Collection(OTBL format)["DrugBank_isoelectric_point"])
#     XCOL["DrugBank_pKa"]                = Collection("_", OTBL.DrugBank_pKa "FORMAT" Collection(OTBL format)["DrugBank_pKa"])
#     XCOL["DrugBank_caco2_permeability"] = Collection("_", OTBL.DrugBank_caco2_permeability "FORMAT" Collection(OTBL format)["DrugBank_caco2_permeability"])
#     XCOL["DrugBank_records"]            = Collection("_", OTBL.DrugBank_records "FORMAT" Collection(OTBL format)["DrugBank_records"])
#     return XCOL
# endfunction

macro findSurechembl s_query ("") s_type ("") l_append (no) l_quiet (no)
    l_info = l_warn = no
    HELP =  """

      findSureChembl macro returns chembl activity data for either chemical or protein queries
       from a local chembl database in the Molsoft Cloud.

      Usage: findSurechembl <string> <type>
      Parameter:
        - string: query string
        - type:
            - "chem": chemical name,
            - "chembl id": ChEMBL id,
            - "surechembl id": SureChEMBL id,
            - "smiles": smiles,
            - "substruct": substruct,
    """
    if (s_query == "") then
        print HELP + " Error> please specify <query name: string or sarray> "
        return
    endif
    if Type(s_query) == "string" then
        group table qa Sarray(s_query) "A"
    else
        print HELP + " Error> no item specified"
        return
    endif
    qJson = Sarray()
    for xx = 1, Nof(qa)
        x_query = qa.A [xx]
        x_type = s_type
        if (x_type == 'chem' & Length(x_query) < 3) then
            print HELP + " Warning> minimum word size >= 3"
            continue
        endif
        if Tolower(x_query[1:3]) == 'smi' then
            x_query = Replace(x_query, "smiles:", "")
            group table XQ cloudStandardizeChem(Chemical(x_query smiles)) "mol"
            if x_type == 'substruct' then
                x_query = Smiles(XQ.mol unique)[1]
                x_type = 'substruct'
            else
                x_query = InChi(XQ.mol)[1]
                x_type = 'inchi'
            endif
        elseif Match(x_query, "[sS][cC][hH][eE][mM][bB][lL][0-9]{1,10}") != "" then
            x_type = 'surechembl id'
        elseif Match(x_query, "[sS][cC][hH][eE][mM][bB][lL][0-9]{1,10}") != "" then
            x_type = 'chembl id'
        endif
        sprintf '{"name":"%s","type":"%s"}', String(x_query html), String(x_type html) name="stmp"
        qJson = qJson // stmp
    endfor
    if Nof(qJson) == 0 then
        print HELP + " Warning> no query submitted"
        return
    endif
    sprintf 'http://www.molsoft.com/cloudAPI/getSurechemblActivity?q={"data":[%s]}', Sum(qJson, ",") name="sJson"
    if (!l_quiet) print "Retrieving data from", sJson
    read string sJson name="s_out"
    if Index(s_out, "Server Error (500)") != 0 then
        print " Warning> Server Error (500)"
        s_status = "Error"
        keep s_status
        return
    endif
    tmpCol = Collection(s_out)
    surechemblResultTmp = Table(Collection("bioactivity" tmpCol ["bioactivity"]))
    if ! Exist(surechemblResultTmp.bioactivity) then
        delete surechemblResultTmp
        print " Warning> no data retrieved"
        return
    endif
    if (!l_quiet) print "Data retrieved, ICM converting..."
    add column surechemblResultTmp function="bioactivity.smiles" name="smiles" static
    add column surechemblResultTmp function="Icm::String(bioactivity.name==null?'':bioactivity.name)" name="name" static
    add column surechemblResultTmp function="Icm::String(bioactivity.schembl==null?'':bioactivity.schembl)" name="ID" static
    add column surechemblResultTmp function="Icm::String(bioactivity.synonyms==null?'':bioactivity.synonyms)" name="synonyms" static
    add column surechemblResultTmp function="Icm::Split(Icm::String(bioactivity.patent==null?'':bioactivity.patent) '\n')" name="patent" static
    l_info = yes ; add column surechemblResultTmp Chemical(surechemblResultTmp.smiles smiles) name="mol" index=1 ; l_info = no ; rotate surechemblResultTmp.mol
    set format surechemblResultTmp.ID "<a href='https://www.surechembl.org/chemical/%1'>%1</a>"
#    set format surechemblResultTmp.patent "<a href='https://www.google.com/patents/%1'>%1</a>"
    set format surechemblResultTmp.patent "<a href='https://www.surechembl.org/document/%1'>%1</a>"
    delete surechemblResultTmp.smiles
    delete surechemblResultTmp.bioactivity
    # append
    if Nof(surechemblResult) != 0 & l_append then
        add surechemblResult surechemblResultTmp
    else
        delete surechemblResult
        surechemblResult = surechemblResultTmp
    endif
    # header
    if Type(s_query) == "sarray" then
        add header surechemblResult Sum(s_query, "; ") name="query"
    elseif Type(s_query) == "string" then
        add header surechemblResult s_query name="query"
    endif
    if s_type == "chem" then
        add header surechemblResult "Chemical Name" name="type"
    elseif s_type == "surechembl id" then
        add header surechemblResult "ChEMBL ID" name="type"
    elseif s_type == "smiles" then
        add header surechemblResult "SMILES" name="type"
    elseif s_type == "substruct" then
        add header surechemblResult "Substructure" name="type"
    elseif s_type == "drugbank id" then
        add header surechemblResult "DrugBank ID" name="type"
    elseif s_type == "uniprot id" then
        add header surechemblResult "UniProt ID" name="type"
    elseif s_type == "uniprot ac" then
        add header surechemblResult "UniProt AC" name="type"
    elseif s_type == "protein" then
        add header surechemblResult "Protein Name" name="type"
    elseif s_type == "action" then
        add header surechemblResult "Action" name="type"
    endif
    set property surechemblResult header on
    if s_type == 'substruct' then
        s_query = Replace(s_query, "smiles:", "")
        add header surechemblResult String(Chemical(s_query smiles)) name="scaffold"
        select chemical surechemblResult.mol s_query
        set property surechemblResult chemical link off
    endif
    s_status = ""
    keep s_status
    keep surechemblResult
endmacro

function funcChemInfoByMol( P_mol )
    l_info = l_warn = no
    group table QA cloudStandardizeChem(P_mol) "mol"
    add column QA InChi(QA.mol) name="inchi"
    i_cnt = 0
    i_len = 0
    qJson = Sarray()
    XTmp = Collection("data" Array())
    print bar "Fetching data" Nof(QA) l_info=yes
    for xx = 1, Nof(QA)
        print bar Nof(QA) l_info=yes
        x_query = QA.inchi [xx]
        x_type = "inchi"
        sprintf '{"name":"%s","type":"%s"}', String(x_query html), String(x_type html) name="stmp"
        i_cnt = i_cnt + 1
        i_len = i_len + Length(stmp)
        qJson = qJson // stmp
        if i_len > 1024*6 | xx == Nof(QA) then
            sprintf 'http://www.molsoft.com/cloudAPI/getChemInfo?q={"data":[%s]}', Sum(qJson, ",") name="sJson"
            read string sJson name="s_out"
            i_len = 0
            qJson = Sarray()
            if Index(s_out, "Server Error (500)") != 0 then
                print "Warning> please try again"
                return
            endif
            XTmp ["data"] = XTmp ["data"] // Collection(s_out) ["info"]
        endif
    endfor
    print bar "End\n" l_info = yes
    XTBLHit = Table(XTmp)
    if ! Exist(XTBLHit.data) then
        print "Warning> No data found"
        return Collection()
    endif
    print "All data retrieved, ICM converting..."
    add column XTBLHit function="data.smiles" name="smiles" static
    add column XTBLHit function="Icm::String(data.name==null?'':data.name)" name="name" static
    add column XTBLHit function="Icm::String(data.synonyms==null?'':data.synonyms)" name="synonyms" static
    add column XTBLHit function="Icm::String(data.drugbank_id==null?'':data.drugbank_id)" name="drugbank_id" static
    add column XTBLHit function="Icm::String(data.chembl_id==null?'':data.chembl_id)" name="chembl_id" static
    add column XTBLHit function="Icm::String(data.surechembl_id==null?'':data.surechembl_id)" name="surechembl_id" static
    delete XTBLTmp.data
    l_info = yes ; add column XTBLHit Chemical(XTBLHit.smiles smiles) name="mol" index=1 ; l_info = no ; rotate XTBLHit.mol
    modify XTBLHit.mol auto
    modify XTBLHit.mol delete charge
    add column XTBLHit InChi(XTBLHit.mol) name="inchi"
    modify XTBLHit.mol delete salt simple
    add column XTBLHit InChi(XTBLHit.mol) name="inchi_nosalt"
    add column XTBLHit Field(XTBLHit.inchi_nosalt 1 "/") + Sarray(Nof(XTBLHit), "/") + Field(XTBLHit.inchi_nosalt 2 "/") + Sarray(Nof(XTBLHit), "/") + Field(XTBLHit.inchi_nosalt 3 "/") + Sarray(Nof(XTBLHit), "/") + Field(XTBLHit.inchi_nosalt 4 "/") name="inchi_nosalt_nostereo"
    delete XTBLHit.smiles ; delete XTBLHit.mol
    group table OTBL Sarray(Nof(QA)) "Chem_name" Sarray(Nof(QA)) "Chem_synonyms" Sarray(Nof(QA)) "Chem_DrugBank_ID" Sarray(Nof(QA)) "Chem_ChEMBL_ID" Sarray(Nof(QA)) "Chem_SureChEMBL_ID"
    modify QA.mol delete salt simple
    add column QA InChi(QA.mol) name="inchi_nosalt"
    add column QA Field(QA.inchi_nosalt 1 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 2 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 3 "/") + Sarray(Nof(QA), "/") + Field(QA.inchi_nosalt 4 "/") name="inchi_nosalt_nostereo"
    for xx = 1, Nof(QA)
        xtmp = XTBLHit.inchi == QA.inchi [xx]
        if Nof(xtmp) == 0 then
            xtmp = XTBLHit.inchi_nosalt == QA.inchi_nosalt [xx]
            if Nof(xtmp) == 0 then
                xtmp = XTBLHit.inchi_nosalt_nostereo == QA.inchi_nosalt_nostereo [xx]
            endif
        endif
        OTBL.Chem_name [xx]          = Nof(xtmp) == 0 ? "" : xtmp.name [1]
        OTBL.Chem_synonyms [xx]      = Nof(xtmp) == 0 ? "" : xtmp.synonyms [1]
        OTBL.Chem_DrugBank_ID [xx]   = Nof(xtmp) == 0 ? "" : xtmp.drugbank_id [1]
        OTBL.Chem_ChEMBL_ID [xx]     = Nof(xtmp) == 0 ? "" : xtmp.chembl_id [1]
        OTBL.Chem_SureChEMBL_ID [xx] = Nof(xtmp) == 0 ? "" : xtmp.surechembl_id [1]
    endfor
    XCOL = Collection()
    XCOL["Chem_name"]          = Collection("_", OTBL.Chem_name "FORMAT" Collection(OTBL format)["Chem_name"])
    XCOL["Chem_synonyms"]      = Collection("_", OTBL.Chem_synonyms "FORMAT" Collection(OTBL format)["Chem_synonyms"])
    XCOL["Chem_DrugBank_ID"]   = Collection("_", OTBL.Chem_DrugBank_ID "FORMAT" Collection(OTBL format)["Chem_DrugBank_ID"])
    XCOL["Chem_ChEMBL_ID"]     = Collection("_", OTBL.Chem_ChEMBL_ID "FORMAT" Collection(OTBL format)["Chem_ChEMBL_ID"])
    XCOL["Chem_SureChEMBL_ID"] = Collection("_", OTBL.Chem_SureChEMBL_ID "FORMAT" Collection(OTBL format)["Chem_SureChEMBL_ID"])
    return XCOL
endfunction

function funcChemInfoByS( S_nm )
    l_info = l_warn = no
    l_caseSensitivity = no
    group table QA S_nm "name"
    i_cnt = 0
    i_len = 0
    qJson = Sarray()
    XTmp = Collection("data" Array())
    print bar "Fetching data" Nof(QA) l_info=yes
    for xx = 1, Nof(QA)
        print bar Nof(QA) l_info=yes
        x_query = QA.name [xx]
        x_type = "chem"
        sprintf '{"name":"%s","type":"%s"}', String(x_query html), String(x_type html) name="stmp"
        i_cnt = i_cnt + 1
        i_len = i_len + Length(stmp)
        qJson = qJson // stmp
        if i_len > 1024*6 | xx == Nof(QA) then
            sprintf 'http://www.molsoft.com/cloudAPI/getChemInfo?q={"data":[%s]}', Sum(qJson, ",") name="sJson"
            read string sJson name="s_out"
            i_len = 0
            qJson = Sarray()
            if Index(s_out, "Server Error (500)") != 0 then
                print "Warning> please try again"
                return
            endif
            XTmp ["data"] = XTmp ["data"] // Collection(s_out) ["info"]
        endif
    endfor
    print bar "End\n" l_info = yes
    XTBLHit = Table(XTmp)
    if ! Exist(XTBLHit.data) then
        print "Warning> No data found"
        return Collection()
    endif
    print "All data retrieved, ICM converting..."
    add column XTBLHit function="data.smiles" name="smiles" static
    add column XTBLHit function="Icm::String(data.name==null?'':data.name)" name="name" static
    add column XTBLHit function="Icm::String(data.synonyms==null?'':data.synonyms)" name="synonyms" static
    add column XTBLHit function="Icm::String(data.drugbank_id==null?'':data.drugbank_id)" name="drugbank_id" static
    add column XTBLHit function="Icm::String(data.chembl_id==null?'':data.chembl_id)" name="chembl_id" static
    add column XTBLHit function="Icm::String(data.surechembl_id==null?'':data.surechembl_id)" name="surechembl_id" static
    delete XTBLTmp.data
    l_info = yes ; add column XTBLHit Chemical(XTBLHit.smiles smiles) name="mol" index=1 ; l_info = no ; rotate XTBLHit.mol
    delete XTBLHit.smiles
    modify XTBLHit.mol auto
    modify XTBLHit.mol delete charge
    group table OTBL Chemical(Nof(QA)) "mol" Sarray(Nof(QA)) "Chem_name" Sarray(Nof(QA)) "Chem_synonyms" Sarray(Nof(QA)) "Chem_DrugBank_ID" Sarray(Nof(QA)) "Chem_ChEMBL_ID" Sarray(Nof(QA)) "Chem_SureChEMBL_ID"
    for xx = 1, Nof(QA)
        xtmp = XTBLHit.name == QA.name [xx] | XTBLHit.drugbank_id == QA.name [xx] | XTBLHit.chembl_id == QA.name [xx] | XTBLHit.surechembl_id == QA.name [xx]
        if Nof(xtmp) == 0 then
            xtmp = XTBLHit.name ~ QA.name [xx] + "*"
            if Nof(xtmp) == 0 then
                xtmp = XTBLHit.synonyms ~ "*" + QA.name [xx] + "*"
            endif
        endif
        OTBL.mol [xx]                = Nof(xtmp) == 0 ? Chemical("") : xtmp.mol [1]
        OTBL.Chem_name [xx]          = Nof(xtmp) == 0 ? "" : xtmp.name [1]
        OTBL.Chem_synonyms [xx]      = Nof(xtmp) == 0 ? "" : xtmp.synonyms [1]
        OTBL.Chem_DrugBank_ID [xx]   = Nof(xtmp) == 0 ? "" : xtmp.drugbank_id [1]
        OTBL.Chem_ChEMBL_ID [xx]     = Nof(xtmp) == 0 ? "" : xtmp.chembl_id [1]
        OTBL.Chem_SureChEMBL_ID [xx] = Nof(xtmp) == 0 ? "" : xtmp.surechembl_id [1]
    endfor
    XCOL = Collection()
    XCOL["mol"]                = Collection("_", OTBL.mol "FORMAT" Collection(OTBL format)["mol"])
    XCOL["Chem_name"]          = Collection("_", OTBL.Chem_name "FORMAT" Collection(OTBL format)["Chem_name"])
    XCOL["Chem_synonyms"]      = Collection("_", OTBL.Chem_synonyms "FORMAT" Collection(OTBL format)["Chem_synonyms"])
    XCOL["Chem_DrugBank_ID"]   = Collection("_", OTBL.Chem_DrugBank_ID "FORMAT" Collection(OTBL format)["Chem_DrugBank_ID"])
    XCOL["Chem_ChEMBL_ID"]     = Collection("_", OTBL.Chem_ChEMBL_ID "FORMAT" Collection(OTBL format)["Chem_ChEMBL_ID"])
    XCOL["Chem_SureChEMBL_ID"] = Collection("_", OTBL.Chem_SureChEMBL_ID "FORMAT" Collection(OTBL format)["Chem_SureChEMBL_ID"])
    return XCOL
endfunction

function funcChemCloudMap S_query s_fr s_to
    l_info = l_warn = no
    l_caseSensitivity = no
    sprintf """
        funcChemCloudMapping S_query s_xfr s_xto

        s_fr is a query type
        s_to is a return type

        Query types
            name
            drugbank id
            chembl id
            chembl molregno
            surechembl id
            USP
            USAN
            FDA
            Trade name
            INN
            BAN
            JAN
            Merck index
            E number
            ATC
            WHO


        Return types
            name
            drugbank id
            drugbank name
            chembl id
            chembl molregno
            chembl name
            surechembl id
            inchi
            smiles
            USP
            USAN
            FDA
            Trade name
            INN
            BAN
            JAN
            Merck index
            E number
            ATC
            WHO


    """ name="xHelp"
    if (Nof(S_query) == 0) then
        print xHelp
        return Collection()
    endif
    QA = S_query != "" ; if Nof(QA) == 0 then ; print "Warning> all-empty column" ; return Collection() ; endif
    if (s_fr == s_to) then
        print "Warning> mapping to the same item"
        return Collection()
    endif
    XTmp = funcChemCloudMapJson(QA, s_fr, s_to)
    XTBL = Table(XTmp)
    if ! Exist(XTBL.data) then
        delete XTBL
        # guess the source of the first non-empty field when no data retrieve
        l_guess = 0
        if Match(QA [1] "(DB|APRD|BIOD|BTD|EXPT|NUTR)[0-9]{5}") != "" then
            l_guess = 1
            s_fr = "drugbank id"
        elseif Match(QA [1] "CHEMBL[0-9]{1,14}") != "" then
            l_guess = 1
            s_fr = "chembl id"
        elseif Match(QA [1] "SCHEMBL[0-9]{1,14}") != "" then
            l_guess = 1
            s_fr = "surechembl id"
        else
            print " Warning> no data retrieved"
            return Collection()
        endif
        if l_guess == 1 then
            print "Initial query not found, guessing applies to source type:", s_fr
            XTmp = funcChemCloudMapJson(QA, s_fr, s_to)
            XTBL = Table(XTmp)
            if ! Exist(XTBL.data) then
                delete XTBL
                print " Warning> no data retrieved"
                return Collection()
            endif
        endif
    endif
    XTBL = funcChemCloudMapJsonTable(XTBL, s_fr, s_to)
    xfr = Name(s_fr simple)
    xto = Name(s_to simple)
    group table OTBL Sarray(Nof(S_query)) xto
    for xx = 1, Nof(S_query)
        xtmp = XTBL.$xfr == S_query [xx]
        S_tmp = Split(S_query [xx] "/")
        if Nof(xtmp) == 0 & s_fr == "inchi" & Nof(S_tmp)>=4 then
            xtmp = XTBL.$xfr == Sum(S_tmp[1:4] "/")
        endif
        OTBL.$xto [xx] = Nof(xtmp) == 0 ? "" : xtmp.$xto [1]
    endfor
    XCOL = Collection()
    XCOL[xto] = Collection("_", OTBL.$xto "FORMAT" Collection(OTBL format)[xto])
    return XCOL
endfunction

function funcChemCloudMapMol P_query s_fr s_to
    S_query = InChi(cloudStandardizeChem(P_query))
    return funcChemCloudMap(S_query, "inchi", s_to)
endfunction

function funcChemCloudMapJson S_query s_fr s_to
    QA = Unique(S_query sort)
    i_cnt = 0
    i_len = 0
    qJson = Sarray()
    XTmp = Collection("data" Array())
    print bar "Fetching data" Nof(QA) l_info=yes
    for xx = 1, Nof(QA)
        print bar Nof(QA) l_info=yes
        x_query = QA [xx]
        sprintf '"%s"', String(x_query html) name="stmp"
        i_cnt = i_cnt + 1
        i_len = i_len + Length(stmp)
        qJson = qJson // stmp
        if i_len > 1024*6 | xx == Nof(QA) then
            sprintf 'http://www.molsoft.com/cloudAPI/getChemMap?q={"data":[%s],"fr":"%s","to":"%s"}', Sum(qJson, ","), String(s_fr html), String(s_to html) name="sJson"
            for jx = 1, 5
                read string sJson name="s_out"
                i_len = 0
                qJson = Sarray()
                if Index(s_out, "Server Error (500)") == 0 then
                    XTmp ["data"] = XTmp ["data"] // Collection(s_out) ["info"]
                    break
                endif
                print "Warning> please try again"
                return
            endfor
        endif
    endfor
    print bar "End\n" l_info = yes
    return XTmp
endfunction

function funcChemCloudMapJsonTable T_tbl s_fr s_to
    add column T_tbl function="Icm::String(data.fr==null?'':data.fr)" name=Name(s_fr simple) static
    add column T_tbl function="Icm::String(data.to==null?'':Icm::Sum(data.to, '\n'))" name=Name(s_to simple) static
    delete T_tbl.data
    return T_tbl
endfunction

macro findChemblpkd s_uniprot ("") l_mammalian (no) s_version ("") l_removeinactive (yes) s_keyword ("") l_filterbysize (yes) l_drugbank (no) auto
   l_info = l_warn = no
   s_uniprot=Trim(s_uniprot all)
   if ((Nof(Split(s_uniprot "_"))==1) & !l_mammalian) return "Uniprot ID species not specified"
   if Type(chemblpkd)!="unknown" delete chemblpkd
   if Type(chemblSummary)!="unknown" delete chemblSummary
   if Type(LIG)!="unknown" delete LIG
   if (s_version == "") s_version = "23"
  for i_version = 1, Nof(Split(s_version ","))
   s_version1 = Split(s_version ",")[i_version]
   if (!l_mammalian) then
     s_status = ""
     s_chemblName = "chembl_"+s_uniprot
     if (Type($s_chemblName)!="unknown") delete $s_chemblName l_warn=no
     for i_trial = 1, 5
       findChembl Sarray(s_uniprot) Sarray("uniprot id") yes s_version1 no
       if (s_status != "Error") break
       delete chemblpkd chemblSummary chemblBest l_warn = no
       if (i_trial == 5) return "Error finding pKd data for uniprot"
     endfor
     if Type(chemblSummary)!="unknown" delete chemblSummary
     if Type(chemblBest)!="unknown" delete chemblBest
     if (Type($s_chemblName)!="unknown") rename $s_chemblName "chemblpkd"
   else
#     S_mammalian = {"HUMAN","MOUSE","RAT","BOVIN","PIG","RABIT","CANLF","CAVPO","MACMU","SHEEP","MACFA","CRIGR","MESAU","HORSE","CAMDR","CANFA"}
     S_mammalian = {"HUMAN","MOUSE","RAT","BOVIN","PIG","RABIT","CANLF","CAVPO","MACMU","SHEEP","MACFA","CRIGR","MESAU","HORSE","CHLAE","CALJA","FELCA","MICOH","MUSCR","PANTR","CAPHI","CRILO","MERUN"}
     for i_mammalian = 1, Nof(S_mammalian)
       s_query = Field(s_uniprot 1 "_") + "_" + S_mammalian[i_mammalian]
       s_status = ""
       s_chemblName = "chembl_"+s_query
       if (Type($s_chemblName)!="unknown") delete $s_chemblName l_warn=no
       for i_trial = 1, 5
         findChembl Sarray(s_query) Sarray("uniprot id") yes s_version1 no
         if (s_status != "Error") break
         if (i_trial == 5) return "Error finding pKd data for uniprot"
       endfor
       if Type(chemblSummary)!="unknown" delete chemblSummary
       if Type(chemblBest)!="unknown" delete chemblBest
       if (Type($s_chemblName)!="unknown") then
         if (Nof($s_chemblName)!=0) then
           if (Type(chemblpkd)=="unknown") then
             rename $s_chemblName "chemblpkd"
           else
             add chemblpkd $s_chemblName; delete $s_chemblName l_warn=no
           endif
         endif
       endif
     endfor
   endif
  endfor
   if (Type(chemblpkd)=="unknown") return "No ChEMBL data found for target" s_uniprot
   sort chemblpkd.activity_id
   chemblpkd = Unique(chemblpkd "activity_id")
#   chemblpkd = chemblpkd.target_type == "SINGLE PROTEIN" |  chemblpkd.target_type == "PROTEIN-PROTEIN INTERACTION" | chemblpkd.target_type == "PROTEIN FAMILY" | chemblpkd.target_type == "PROTEIN COMPLEX"
   chemblpkd = chemblpkd.pAct != Toreal("ND")
   chemblpkd = chemblpkd.validity == ""
   chemblpkd = chemblpkd.mol != Chemical("")
   if (l_removeinactive) then
     chemblpkd = chemblpkd.comment!~"[Ii]nactive*"&chemblpkd.comment!~"[Ii]nconclusive*"&chemblpkd.comment!~"[Nn]ot [Aa]ctive*"
   endif
   if (s_keyword!="") then
     S_keyword = Split(s_keyword "|")
     I_tmpmacro = Iarray(Nof(chemblpkd) 0)
     for i_keyword = 1, Nof(S_keyword)
       s_keywordtmp = S_keyword[i_keyword]
       if (s_keywordtmp=="Ki"|s_keywordtmp=="Kd"|s_keywordtmp=="IC50"|s_keywordtmp=="EC50") then
         I_tmpmacro = I_tmpmacro+Index(chemblpkd.type s_keywordtmp simple)
       else
         I_tmpmacro = I_tmpmacro+Index(chemblpkd.description s_keywordtmp simple)
       endif
     endfor
     group table T_tmpmacro Count(Nof(I_tmpmacro)) "A" I_tmpmacro "B"
     T_tmpmacro = T_tmpmacro.B!=0
     I_tmpmacro = T_tmpmacro.A; delete T_tmpmacro
     chemblpkd = chemblpkd[I_tmpmacro]
   endif
   if (Nof(chemblpkd)==0) return "No ChEMBL data found after filtering for target" s_uniprot
   if (Type(chemblpkd.value)!="unknown") delete chemblpkd.value
   rename chemblpkd.pAct "value"
   if (l_drugbank) then
     if (Nof(s_uniprot "_")==0) then
       s_query = (s_uniprot+"_")
     else
       s_query = s_uniprot
     endif
     s_status = ""
     s_drugbankName = "DB_"+s_uniprot
     if (Type($s_drugbankName)!="unknown") delete $s_drugbankName l_warn=no
     for i_trial = 1, 5
       findDrugbank Sarray(1 s_query) "uniprot_id" no no
       if (s_status != "Error") break
       if (i_trial == 5) return "Error finding drugbank data for uniprot"
     endfor
     if (Type($s_drugbankName)!="unknown") then
       add column $s_drugbankName Rarray(Nof($s_drugbankName) 5.5) name="value"
       if (Type(T_drugbank)!="unknown") delete T_drugbank
       rename $s_drugbankName "T_drugbank"
       modify T_drugbank.mol delete salt
       modify T_drugbank.mol delete salt simple
       delete hydrogen T_drugbank.mol
       modify T_drugbank.mol auto
#       modify T_drugbank.mol delete charge
       sort T_drugbank.mol
       T_drugbank = T_drugbank.mol != Chemical("")
       group T_drugbank.mol all "first"  name="T_drugbank"
       add chemblpkd T_drugbank
       keep T_drugbank
     endif
   endif
   modify chemblpkd.mol delete salt
   modify chemblpkd.mol delete salt simple
   delete hydrogen chemblpkd.mol
   modify chemblpkd.mol auto
   modify chemblpkd.mol delete charge
   sort chemblpkd.mol
   add column chemblpkd function="MolWeight(mol)" index=2 name="molWeight" append format="%.3f"
   add column chemblpkd function="Nof_RotB(mol)" index=2 name="nof_RotB" append
   if (l_filterbysize) chemblpkd = chemblpkd.molWeight <= 700. & chemblpkd.nof_RotB <= 15
   chemblpkd = chemblpkd.mol != Chemical("")
#   set charge formal auto chemblpkd.mol 7.0
   if (Nof(chemblpkd)==0) return "No ChEMBL data found after filtering off MW>700 & nof_RotB>15 for target" s_uniprot
#   group chemblpkd.mol chemblpkd.name "unique,name"chemblpkd.value "count,count" chemblpkd.value "min,min" chemblpkd.value "max,max" chemblpkd.value "mean,mean" chemblpkd.value "rmsd,rmsd" name="LIG"
   group chemblpkd.mol chemblpkd.name "unique,name"chemblpkd.value "count,count" chemblpkd.value "min,min" chemblpkd.value "max,max" chemblpkd.value "mean,mean" chemblpkd.value "rmsd,rmsd" name="LIG" chemblpkd.activity_id "unique,activity_id" chemblpkd.assay_id "unique,assay_id" chemblpkd.pubmed_id "unique,pubmed_id"
   add column LIG Rarray(Nof(LIG)) name="value"
   for i_macro = 1, Nof(LIG)
     tmp = chemblpkd.mol == LIG.mol [i_macro]
     sort tmp.value reverse
     LIG.value [i_macro] = tmp.value [Integer(Ceil(Nof(tmp) * 0.2))]
     delete tmp
   endfor
   rename LIG.value "pkd"; delete chemblpkd; sort reverse LIG.pkd
   keep LIG s_status
endmacro
#
macro findChemblpkdtxt s_txtfile ("") s_uniprot ("") l_removeinactive (yes) s_keyword ("") l_filterbysize (yes) l_drugbank (no) auto
   l_info = l_warn = no
   s_uniprot=Trim(s_uniprot all)
#   if (s_uniprot=="") return "Please specify uniprot ac prefix (e.g. ESR1) or full ac (e.g. ESR1_HUMAN)"
   s_txtfile = Trim(s_txtfile all)
   if (s_txtfile=="") return "Please specify txt file downloaded from ChEMBL"
   if Type(chemblpkd)!="unknown" delete chemblpkd
   if Type(chemblSummary)!="unknown" delete chemblSummary
   if Type(LIG)!="unknown" delete LIG
   if (Index(Name(gui table) s_txtfile)!=0) then
     delete chemblpkd l_warn=no
     chemblpkd = $s_txtfile
   else
     if !Exist(s_txtfile) return "txt file specify does not exist"
     if (Extension(s_txtfile)!=".txt") return "Please specify a .txt file downloaded from ChEMBL"
     read table separator="\t" header s_txtfile name="chemblpkd"
   endif
   if (Type(chemblpkd)=="unknown") return "No ChEMBL data found for target" s_uniprot
   rename chemblpkd.ACTIVITY_ID "activity_id"
   sort chemblpkd.activity_id
   chemblpkd = Unique(chemblpkd "activity_id")
#   chemblpkd = chemblpkd.TARGET_TYPE == "SINGLE PROTEIN" |  chemblpkd.TARGET_TYPE == "PROTEIN-PROTEIN INTERACTION"  |  chemblpkd.TARGET_TYPE == "PROTEIN FAMILY" | chemblpkd.TARGET_TYPE == "PROTEIN COMPLEX"
   chemblpkd = chemblpkd.STANDARD_VALUE != ""
   chemblpkd = chemblpkd.STANDARD_UNITS == "nM"
   chemblpkd = chemblpkd.DATA_VALIDITY_COMMENT == ""
   if (Type(chemblpkd.mol)=="unknown") add column chemblpkd Chemical(chemblpkd.CANONICAL_SMILES smiles) name="mol" index=1
   modify chemblpkd.mol delete salt
   modify chemblpkd.mol delete salt simple
   delete hydrogen chemblpkd.mol
   modify chemblpkd.mol auto
   modify chemblpkd.mol delete charge
   chemblpkd = chemblpkd.mol != Chemical("")
   rename chemblpkd.ACTIVITY_COMMENT "comment"
   if (l_removeinactive) then
     chemblpkd = chemblpkd.comment!~"[Ii]nactive*"&chemblpkd.comment!~"[Ii]nconclusive*"&chemblpkd.comment!~"[Nn]ot [Aa]ctive*"
   endif
   rename chemblpkd.STANDARD_TYPE "type"
   rename chemblpkd.DESCRIPTION "description"
   s_status = ""
   if (s_keyword!="") then
     S_keyword = Split(s_keyword "|")
     I_tmpmacro = Iarray(Nof(chemblpkd) 0)
     for i_keyword = 1, Nof(S_keyword)
       s_keywordtmp = S_keyword[i_keyword]
       if (s_keywordtmp=="Ki"|s_keywordtmp=="Kd"|s_keywordtmp=="IC50"|s_keywordtmp=="EC50") then
         I_tmpmacro = I_tmpmacro+Index(chemblpkd.type s_keywordtmp simple)
       else
         I_tmpmacro = I_tmpmacro+Index(chemblpkd.description s_keywordtmp simple)
       endif
     endfor
     group table T_tmpmacro Count(Nof(I_tmpmacro)) "A" I_tmpmacro "B"
     T_tmpmacro = T_tmpmacro.B!=0
     I_tmpmacro = T_tmpmacro.A; delete T_tmpmacro
     chemblpkd = chemblpkd[I_tmpmacro]
   endif
   add column chemblpkd Toreal(chemblpkd.STANDARD_VALUE) name="tmpvalue"
   chemblpkd = chemblpkd.tmpvalue > 0.
   if (Nof(chemblpkd)==0) return "No ChEMBL data found after filtering for target" s_uniprot
   if (Type(chemblpkd.value)!="unknown") delete chemblpkd.value
   add column chemblpkd 9.-Log(Toreal(chemblpkd.STANDARD_VALUE) 10) name="value" index=3
   chemblpkd.value[Index(chemblpkd.STANDARD_RELATION==">")] \
   = Toreal(Sarray(Nof(chemblpkd.STANDARD_RELATION==">") "<")+String(chemblpkd.value[Index(chemblpkd.STANDARD_RELATION==">")]))
   chemblpkd.value[Index(chemblpkd.STANDARD_RELATION==">=")] \
   = Toreal(Sarray(Nof(chemblpkd.STANDARD_RELATION==">=") "<=")+String(chemblpkd.value[Index(chemblpkd.STANDARD_RELATION==">=")]))
   chemblpkd.value[Index(chemblpkd.STANDARD_RELATION=="<")] \
   = Toreal(Sarray(Nof(chemblpkd.STANDARD_RELATION=="<") ">")+String(chemblpkd.value[Index(chemblpkd.STANDARD_RELATION=="<")]))
   chemblpkd.value[Index(chemblpkd.STANDARD_RELATION=="<=")] \
   = Toreal(Sarray(Nof(chemblpkd.STANDARD_RELATION=="<=") ">=")+String(chemblpkd.value[Index(chemblpkd.STANDARD_RELATION=="<=")]))
   if (s_uniprot == "") then
     group chemblpkd.PROTEIN_ACCESSION chemblpkd.PROTEIN_ACCESSION 'count,count' name='chemblpkd_PROTEIN_ACCESSION_freq'
     sort reverse chemblpkd_PROTEIN_ACCESSION_freq.count
     s_uniprot = chemblpkd_PROTEIN_ACCESSION_freq.PROTEIN_ACCESSION[1]
     delete chemblpkd_PROTEIN_ACCESSION_freq l_warn=no
     read string "http://www.uniprot.org/uniprot/"+s_uniprot+".txt" name="s_tmp"
     s_uniprot = Field(Field(Trim(Match(Split(s_tmp "\n")[1] "ID(.*?)" 1) all) 1 " ") 1 "_")
   endif
   rename chemblpkd.ASSAY_ID "assay_id"
   rename chemblpkd.PUBMED_ID "pubmed_id"
   rename chemblpkd.PARENT_CMPD_CHEMBLID "name"
   chemblpkd.name[Index(chemblpkd.MOL_PREF_NAME!="")] = chemblpkd.MOL_PREF_NAME[Index(chemblpkd.MOL_PREF_NAME!="")]
   if (l_drugbank) then
     if (Nof(s_uniprot "_")==0) then
       s_query = (s_uniprot+"_")
     else
       s_query = s_uniprot
     endif
     s_status = ""
     s_drugbankName = "DB_"+s_uniprot
     if (Type($s_drugbankName)!="unknown") delete $s_drugbankName l_warn=no
     for i_trial = 1, 5
       findDrugbank Sarray(1 s_query) "uniprot_id" no no
       if (s_status != "Error") break
       if (i_trial == 5) return "Error finding drugbank data for uniprot"
     endfor
     if (Type($s_drugbankName)!="unknown") then
       add column $s_drugbankName Rarray(Nof($s_drugbankName) 5.5) name="value"
       if (Type(T_drugbank)!="unknown") delete T_drugbank
       rename $s_drugbankName "T_drugbank"
       modify T_drugbank.mol delete salt
       modify T_drugbank.mol delete salt simple
       delete hydrogen T_drugbank.mol
       modify T_drugbank.mol auto
       modify T_drugbank.mol delete charge
       sort T_drugbank.mol
       T_drugbank = T_drugbank.mol != Chemical("")
       group T_drugbank.mol all "first"  name="T_drugbank"
       add chemblpkd T_drugbank
       keep T_drugbank
     endif
   endif
   sort chemblpkd.mol
   add column chemblpkd function="MolWeight(mol)" index=2 name="molWeight" append format="%.3f"
   add column chemblpkd function="Nof_RotB(mol)" index=2 name="nof_RotB" append
   if (l_filterbysize) chemblpkd = chemblpkd.molWeight <= 700. & chemblpkd.nof_RotB <= 15
   chemblpkd = chemblpkd.mol != Chemical("")
#   set charge formal auto chemblpkd.mol 7.0
   if (Nof(chemblpkd)==0) return "No ChEMBL data found after filtering off MW>700 & nof_RotB>15 for target" s_uniprot
#   group chemblpkd.mol chemblpkd.name "unique,name"chemblpkd.value "count,count" chemblpkd.value "min,min" chemblpkd.value "max,max" chemblpkd.value "mean,mean" chemblpkd.value "rmsd,rmsd" name="LIG"
   group chemblpkd.mol chemblpkd.name "unique,name"chemblpkd.value "count,count" chemblpkd.value "min,min" chemblpkd.value "max,max" chemblpkd.value "mean,mean" chemblpkd.value "rmsd,rmsd" name="LIG" chemblpkd.activity_id "unique,activity_id" chemblpkd.assay_id "unique,assay_id" chemblpkd.pubmed_id "unique,pubmed_id"
   add column LIG Rarray(Nof(LIG)) name="value"
   for i_macro = 1, Nof(LIG)
     tmp = chemblpkd.mol == LIG.mol [i_macro]
     sort tmp.value reverse
     LIG.value [i_macro] = tmp.value [Integer(Ceil(Nof(tmp) * 0.2))]
     delete tmp
   endfor
   rename LIG.value "pkd"; delete chemblpkd; sort reverse LIG.pkd
   keep LIG s_status
endmacro
#
macro findatc s_query ("") l_onlinesearch (no) auto
HELP = """
  Find ATC info about a specific drug or ATC code

  Syntax: findatc <s_query> <l_onlinesearch>
  <s_query>: ATC Code or Drug Name (for offline search only)
  <l_onlinesearch>: Default no, will use local table, can use either ATC code or drug name
                    if yes, will use the whocc.no site for search, can only use ATC code

  Examples:
  findatc 'gilteritinib' no
  findatc 'L01XX33' yes
  findatc 'L01XX' yes
"""
  l_info = l_warn = l_commands = no
  s_query = Toupper(Trim(s_query all))
  s_tabname = Name("ATC_"+s_query unique)
  if (!l_onlinesearch) then
    if (Type(ATC)=="unknown") then
      l_loaded = no
      read binary s_icmhome+"models/ATC.icb"
    else
      l_loaded = yes
    endif
    if (s_query=="") then
      keep ATC
      return
    endif
    sort ATC.ATC
    add column ATC Count(Nof(ATC)) name="idxtmp"
    I_tmpmacro = Index(ATC.ATC == s_query)
    if (Nof(I_tmpmacro)==0) then
      I_tmpmacro //= Index(ATC.Name s_query all)
      I_tmpmacro //= Index(ATC.Name Tolower(s_query) all)
      I_tmpmacro //= Index(ATC.Name Toupper(Tolower(s_query) 1) all)
      I_tmpmacro //= Index(Index(ATC.Name s_query simple) 1 all)
      I_tmpmacro //= Index(Index(ATC.Name ".*"+Tolower(s_query) regexp) 1 all)
      I_tmpmacro //= Index(Index(ATC.Name ".*"+Toupper(s_query) regexp) 1 all)
      I_tmpmacro //= Index(Index(ATC.Name ".*"+Toupper(Tolower(s_query) 1) regexp) 1 all)
      I_tmpmacro = Unique(Sort(I_tmpmacro))
    endif
    if (Nof(I_tmpmacro)==0) then
      l_onlinesearch = yes
    else
      J_tmpmacro = I_tmpmacro
      for i_tmpmacro = 1, Nof(J_tmpmacro)
        j_tmpmacro = J_tmpmacro[i_tmpmacro]
        i_maxlevel = ATC.Level[j_tmpmacro]
        if (i_maxlevel <= 4) I_tmpmacro //= Index(ATC.ATC ~ATC.ATC[j_tmpmacro]+"*" & ATC.Level == i_maxlevel+1 )
        for i_level = i_maxlevel-1, 1, -1
          I_tmpmacro //=  Iarray(1 Index(ATC.Level == i_level & ATC.idxtmp < j_tmpmacro)[$])
        endfor
      endfor
      I_tmpmacro = Unique(Sort(I_tmpmacro))
      delete ATC.idxtmp l_warn=no
      $s_tabname = ATC[I_tmpmacro]
      keep $s_tabname
    endif
    if (!l_loaded) delete ATC l_warn=no
  endif
  if (l_onlinesearch) then
    if (s_query == "") return " Info> Please specify an ATC term"
    read string "https://www.whocc.no/atc_ddd_index/?code="+s_query+"&showdescription=no" name="s_tmp"
    S_tmp = Split(s_tmp "\n")
    S_tmp = Replace(S_tmp "<p>" "")
    s_1 = s_query[1]
    I_tmpmacro = Index(Index(S_tmp s_1+".*<b>" regexp) 1 all)
    if (Nof(I_tmpmacro)==0) return " Info> Cannot find anything, please double check the ATC code, for drug name please use offline search instead"
    S_tmpmacro = S_tmp[Iarray(1, I_tmpmacro[1]-1)//I_tmpmacro]
    S_tmpmacro[1] = Match(S_tmpmacro [1] "</p>(.*?)" 1)
    group table t_tmpmacro Field(S_tmpmacro 1 " ") "ATC" Field(Field(S_tmpmacro 3 ">") 1 "<") "Name"
    if (Length(s_query)>=5) then
      errorActionold = errorAction
      errorAction = 1
      read table html "https://www.whocc.no/atc_ddd_index/?code="+s_query+"&showdescription=no" name="t_tmpmacro2"
      if (!Error()) then
        delete t_tmpmacro2[1]
        t_tmpmacro2.A = Field(t_tmpmacro2.A 1 "&")
        t_tmpmacro2.B = Field(Field(t_tmpmacro2.B 2 ">") 1 "<")
        t_tmpmacro2.C = Field(t_tmpmacro2.C 1 "&")
        t_tmpmacro2.D = Field(t_tmpmacro2.D 1 "&")
        t_tmpmacro2.E = Field(t_tmpmacro2.E 1 "&")
        t_tmpmacro2.F = Field(t_tmpmacro2.F 1 "&")
        rename t_tmpmacro2.A "ATC"
        rename t_tmpmacro2.B "Name"
        rename t_tmpmacro2.C "DDD"
        rename t_tmpmacro2.D "U"
        rename t_tmpmacro2.E "AdmR"
        rename t_tmpmacro2.F "Note"
        delete T_join l_warn=no
        join left t_tmpmacro.ATC t_tmpmacro2.ATC
        delete T_join.t_tmpmacro2_Name l_warn=no
        add T_join t_tmpmacro2.ATC != T_join.ATC
        for i_join = 2, Nof(T_join)
          if (T_join.ATC[i_join]=="") T_join.ATC[i_join] = T_join.ATC[i_join-1]
          if (T_join.Name[i_join]=="") T_join.Name[i_join] = T_join.Name[i_join-1]
        endfor
        rename T_join s_tabname
      else
        rename t_tmpmacro s_tabname
        errorAction = errorActionold
      endif
    else
      rename t_tmpmacro s_tabname
    endif
    keep $s_tabname
  endif
endmacro
#
macro findpubmed s_searchterm ("") auto
HELP = """
  find publications from PubMed using search term
  e.g. findpubmed 'BPA AND ESR1'
  return a table summary
"""
  l_info = l_warn = no
  s_searchhttp = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term="
  s_summaryhttp = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed"
  if (s_searchterm == "") return "Please specify search term"
  s_searchterm = Trim(s_searchterm all)
  s_searchfield = Sum(Split(s_searchterm " ") "+")
  read xml name="x_1" s_searchhttp+s_searchfield+"&usehistory=y"
  i_nofresult = x_1["eSearchResult","Count"]
  if (i_nofresult == 0) return "No result found"
  i_QueryKey = x_1["eSearchResult","QueryKey"]
  s_WebEnv = x_1["eSearchResult","WebEnv"]
  read xml name="x_2" s_summaryhttp+"&query_key="+String(i_QueryKey)+"&WebEnv="+s_WebEnv+"&version=2.0"
  if (i_nofresult == 1) then
    group table PubMed_Summary Sarray(1 Tostring(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","uid"])) "PMID" \
    Sarray(1 Tostring(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","Title"])) "Title"\
    Sarray(1 Tostring(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","Source"])) "Source"\
    Sarray(1 Tostring(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","PubDate"])) "PubDate"\
    Sarray(1 Tostring(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","SortFirstAuthor"])) "FirstAuthor"\
    Sarray(1 Tostring(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","LastAuthor"])) "LastAuthor"\
    Sarray(1 Tostring(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","ELocationID"])) "ELocationID"
  else
    group table PubMed_Summary Sarray(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","uid"]) "PMID" \
    Sarray(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","Title"]) "Title"\
    Sarray(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","Source"]) "Source"\
    Sarray(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","PubDate"]) "PubDate"\
    Sarray(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","SortFirstAuthor"]) "FirstAuthor"\
    Sarray(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","LastAuthor"]) "LastAuthor"\
    Sarray(x_2["eSummaryResult","DocumentSummarySet","DocumentSummary","ELocationID"]) "ELocationID"
  endif
  set format PubMed_Summary.PMID "<a href=https://www.ncbi.nlm.nih.gov/pubmed/%1>%1</a>" name="" color="''"
  keep PubMed_Summary
endmacro

macro splitByChain ms_ l_delete_source (no) l_fixOrphans (no) l_retainFirstOnly (no)
  l_info = no
  ms = Mol( ms_ ) ;  os = Obj( ms_ )
  nnwob = 0
  obnams = Name( os )
  if( l_fixOrphans ) setChainOrphanHets ms
  for iob=1,Nof(obnams)
    stmp = obnams[iob]
    os1 = a_$stmp.
    ms1 = os1 & ms
    if(Nof(ms1)==0) continue
    nolob = nnwob
    oschains =  Unique( Sort( Name( ms1 chain )) )
    if( Nof(oschains) == 1 ) continue
    if( Nof(oschains) >= 1 & oschains[1]==" ") oschains[1]="_"
    for ich = 1,Nof( oschains )
      os1na = Name(os1)[1]+oschains[ich]
      chsel = "C"+oschains[ich]
      copyMol ms1 & a_*.$chsel os1na
      set chain a_$os1na.* " "  # ?
      nnwob += 1
      if(l_retainFirstOnly) break
    endfor
    if(l_delete_source & nolob<nnwob) delete Obj(os1)
  endfor
  if(nnwob >0) printf " Info> %d new objects created\n" nnwob
  if(nnwob==0) printf " Nothing to do\n"
endmacro

macro setChainOrphanHets ms_
  ms = Mol( ms_ & a_*.H & a_*.C_ )
  os = Obj( ms )
  for iob=1,Nof( os )
    ms1 = (os [iob] ) & ms
    for iml = 1,Nof( ms1 )
      chli = Name (Mol(Sphere(ms1[iml] ( a_*.A & os[iob] ), -1.25 ) ))
      show ms1[ iml ]  chli
      if(Nof(chli)>=1) set chain ms1[ iml ] chli[1]  # just takes the 1st chain
    endfor
  endfor
endmacro

macro deleteExtraChainsGrafts auto ms_ ( a_ ) l_deleteNCSchains (no)  l_gpcrGraftDelete (no)
  if(l_deleteNCSchains) then
    setChainOrphanHets ms_
    msuq = ms_ & a_*.A,N
    add column tmpct Name( msuq full) Name( msuq chain ) Name( msuq swiss )+ Field( msuq "_SEQ_")
    group tmpct.C tmpct.B "first" ; uqchains = "C"+ Sum(tmpct.B, "")
    msuq = ms_ & a_*.$uqchains
    if(Nof( Mol( msuq ) )>=1 ) then
      delete ms_ & !msuq
    endif
  endif
  if(l_gpcrGraftDelete ) then
    onam = Name( Obj( ms_ ))[1]
    delete a_*.A/1000:1999 & ms_
    if( onam =="4jkv"|onam=="4n4w" ) delete ms_ & a_*.A/-2:106
  endif
  delete (ms_ & a_*.H,W,M ) & !Mol(Sphere( ( ms_ & a_*.A,N ) ( a_*.H,W,M & ms_ ) 6. ))
  assign sstructure ms_
  if(Exist(gui)) display new
endmacro

macro placeLigand auto ms_movable as_static r_effort (1.) l_display (no) l_debug (no)
HELP = """
   placeLigand docks a ligand molecule in a single ICM object
     to the specified destination atom selection.
     Multiple destination objects will be treated
   If additional restraints/tethers are needed, use distance tool to define them
   Tethers set directly via 'set tethers' will be respected too.
   The macro saves a stack of preferred placements.
   Parameters:
     <ms_movable> : molecule to be moved to the destination selection
     <ms_static>  : atoms in one or several molecules of objects, - superposition target
     <r_effort>   : (default 1.) defines how rigorous/long the search is
     <l_display>  : display placement

   Example:
     read pdb '1abe'
     build smiles 'C1CCCCC1C(=O)[O-]'
     placeLigand a_ a_1.2

"""
  l_commands = l_info = l_debug
  if(!l_display) then; GRAPHICS.l_redraw = no; l_minRedraw = no; endif
  if( Type( Obj(ms_movable ) 2)!= "ICM")  return " Error_plLib> movable object needs convertion"
  ms_movable = Mol(ms_movable & a_ICM. )
  if(Nof(ms_movable)==0) return error " Error_plLig> movable molecule not found"
  if(Nof(a_*.)<1) return " Error_plLig> need at least one ICM object"
#  if( Nof( ms_movable )>1 ) return error " Error_plLig> can not move more than one molecule"
#  if(Nof( as_static)>1) return error " Error_plLig> more than one object in destination selection"
  if( Nof(as_static)==0 | Type( Obj(as_static)[1] 2)!= "ICM")  return " Error_plLib> destination ligand empty or needs convertion"
  s_oldterms = Info(term)
  N=1; print bar N " Preparing target selection and superimposing" l_info=yes
  if(Nof(Obj(as_static & a_ICM. ))>1) then
    appendMol Mol( as_static & a_ICM. ) "TMPAPF"
    set Sphere( as_static a_TMPAPF.// 0.0001 ) off
    as_static = a_TMPAPF.
  endif
  set object Obj( ms_movable )
  delete selftether ms_movable ; delete tether ms_movable
  unfix V_//V
# superimpose Atom( as_static & a_*.//!vt*)[1:3]  Atom( ms_movable & a_*.//!vt* )[1:3]  exact
  translate ms_movable Mean(Xyz( as_static ))
  nat2 = Nof(a_//!vt* )/2 ; if nat2<=0 nat2=1   # find middle atom
  if(r_effort==0.) goto endPlaceLig
  print bar N l_info=yes
  if(Type(distpairs)=="parray") then; as_out = Atom(distpairs); else; as_out=a_NULL. ;endif
  if( Nof( as_out & ms_movable)>0 & Nof( as_out & !ms_movable )>0 ) then
    print " Info_placeLig>  tethers found"
    set tether as_out & ms_movable distpairs
  else
    set selftether a_//!vt* [nat2] Mean(Xyz( as_static ))
  endif
  if(Nof(a_//T)>0) set term "tz"
  setApfTypes
  print bar N " Making destination fields" l_info=yes
  bx = Box( as_static 5. )
  make map potential "gp" as_static bx GRID.gpGaussianRadius = 1.2
  make map potential "gc,gb" bx  Sphere( as_static Obj(as_static) & !(as_static | a_*.W) , 5.)
  interruptAction = 1; autoSavePeriod = 0; mcShake=5.; vwMethod="soft" ; vwSoftMaxEnergy=10.; vicinity = 1.0;
  s_skipMessages="[66][67][206]"
  GRID.gcghExteriorPenalty = "zero"  # does it apply to gp?
  set term only "vw,14,hb,to,gp,gc,gb,bb,bs,af,ts"
#  print bar N " Minimizing" l_info=yes
#  minimize v_//V & ms_movable
  nvars = Nof( v_//!V,M,T3,T11 & ms_movable );
  mncallsMC = Integer((1000 + 2*nvars*nvars*nvars)*r_effort)
  compare static ms_movable l_warn = no
  print bar N " First try"
  delete stack
  montecarlo reverse v_// & ms_movable v_// & ms_movable store append mncallsMC = mncallsMC/6 temperature=5000. TOOLS.tsToleranceRadius=8.
  print bar N " Second try" l_info=yes
  montecarlo reverse v_// & ms_movable v_// & ms_movable store append temperature=1000. TOOLS.tsToleranceRadius=14.
  load conf 0
  print bar "End\n" l_info=yes
  delete tether selftether a_ & as_out
endPlaceLig:
  if( Nof(a_TMPAPF.)>0 ) delete a_TMPAPF.
  set term s_oldterms only
  GRAPHICS.l_redraw = yes
  if(!l_display) display new
  if(l_debug) keep map
endmacro

macro fillGrobWithAtoms auto &g_ s_name ("") l_delete (no)
   l_commands = l_info = no
   vol= Abs(Volume(g_ ))
   nat = Integer( vol/60. ); if(nat==0) nat=1
   if(s_name=="") s_name=Name("gatoms",unique)
   if( Nof( a_$s_name. )==1 ) return error " Object "+s_name+" already exists"
   if(nat==1) then
     build string "c" name=s_name
     set selftether a_//c* Mean(Xyz(g_))
   else
     build smiles String("O",nat) name = s_name  # also adds hydrogens
     vx = Xyz( g_ )
     nvx = Nof(g_)
     nww = Max( nvx/nat , 1 )
#  printf "nat=%d nvx=%d nww=%d\n",nat,nvx,nww
     ito=0
     translate a_ Mean( vx )
     for i=1,nat
       ifr=Min(ito+1,nvx)
       ito=Min(ifr+nww, nvx)
# printf "i=%d  ifr=%d ito=%d\n",i,ifr,ito
       set selftether a_//c* [i] Matrix(Mean(vx[ifr:ito,?]))
     endfor
   endif
   unfix V_//bo*,fo*,ao*
   minimize "ts"  mncalls = 300
endmacro

macro placeLigand2Grob auto ms_movable &g_ l_flexible (no) r_effort (1.) l_delete (yes)
HELP = """
  ms_ligand   : what to move
  g_shape     : where to move
  l_flexible (no) : translate to shape center or flexible dock
  r_effort (1.)   : how long to sample in flexible mode
  l_delete (yes)  : delete temporary atoms inside the grob in flexible mode
"""
# IN PROGRESS
  fillGrobWithAtoms g_ "TMPGROB" yes
  if(Nof(a_TMPGROB.)==0) return
  if(l_flexible) then
    placeLigand ms_movable a_TMPGROB. 1. yes
  else
    translate ms_movable Mean( Xyz( g_ ) )
  endif
  if(l_delete) delete a_TMPGROB.
endmacro

macro place2model ms_movable as_static as_pock r_effort (1.) l_display (no)
  if(Nof(Obj(as_static & as_pock))==0) then
    placeLigand ms_movable as_static r_effort l_display
    delete a_TMP2M.
    copyMol Mol(as_pock) "TMP2M"
    appendMol ms_movable "TMP2M"
    set object a_TMP2M.
  else
    set object Obj(ms_movable) [1]
  endif
# start optimization in pocket
  delete stack
  store conf
endmacro

macro scanCysBridges auto  rs_1 rs_2 ( a_NULL./ )
HELP="""
  Scan pairs of residues in two input residue selections that can be replaced by Cysteines forming
  a disulfide bridge. If the second argument is empty it is assumed equal to the first selection. The procedure returns a table called CysBridges with possible pairs sorted by the strain associated with the bridge.
"""
  l_commands = no
#  errorAction = "exit"
  rs_1 = Res(rs_1)
  if(Nof(rs_2)==0) rs_2 = rs_1
  rs_2 = Res(rs_2)
  rs_ = rs_1 | rs_2
  rena1  = Name(rs_1 full)
  rena2  = Name(rs_2 full)
  rena12 = Name( rs_ full )
  nob = Nof(Obj(rs_));
  if(nob >1) return error " Error_scanCysBridges> Selections in two different objects. Define two selections in the same object"
  if(nob==0) return error " Error_scanCysBridges> empty selection"
  if( Nof(rs_ & a_tmpss,tmpsss. )> 0 ) return error " Error_scanCysBridges> can not use selection in temporary objects (a_tmpss*.) "
  delete a_tmpss,tmpsss.
  delete CysBridges l_warn = no
  os = Obj(rs_ )[1]
  rs_ = rs_ & os & a_*.A
  copy os "tmpss" delete strip
  delete a_tmpss. & !Sphere( rs_ a_tmpss. 0.001 )
  convert a_tmpss. name="tmpss"
  make distance rs_1 & a_*.//ca rs_2 & a_*.//ca 7. name="tmdist"  # 7A limit
  CysBridges = Table( tmdist distance );
  add column CysBridges Replace(CysBridges.atom1,"/ca","") name={"A"} index=1;
  add column CysBridges Replace(CysBridges.atom2,"/ca","") name={"B"} index=2;
  delete CysBridges.atom1 CysBridges.atom2 CysBridges.color CysBridges.label
  for ipa = 1,Nof(CysBridges)
    if( Nof( Select( $CysBridges.A[ipa] margin 1 ) & Select ( $CysBridges.B[ipa] margin 1)) > 0  ) then
      CysBridges.dist[ipa] = 999.;
    endif
  endfor
  delete CysBridges.dist > 7.; npa = Nof(CysBridges)
  add column CysBridges Rarray(npa) Rarray(npa) Rarray(npa) Rarray(npa) Rarray(npa) name={"Energy","SStorsion","SSbondlen","CSCangle1","CSCangle2"}

  delete disulfide bond a_tmpss.

  for ipa = 1,Nof(CysBridges)
    copy a_tmpss. "tmpsss" delete l_info=no
    set object a_tmpsss.  l_info=no
    res1 = "a_tmpsss."+Field(CysBridges.A[ipa],2,".")
    res2 = "a_tmpsss."+Field(CysBridges.B[ipa],2,".")
    modify $res1 | $res2 "cys" l_warn = no l_info=no
    make ssbond $res1 & a_tmpsss.//sg $res2 & a_tmpsss.//sg
    minimize v_/cys*/x* & ( $res1 | $res2 )  "ss,to,vw,14" l_showMinSteps = no l_info=no
    CysBridges.Energy[ipa]    = Energy("ss,to")
    CysBridges.SStorsion[ipa] = Torsion( ( $res1 & a_tmpsss.//cb,sg ) | ( $res2 & a_tmpsss.//cb,sg )  )
    CysBridges.SSbondlen[ipa] = Distance( ( $res1 & a_tmpsss.//sg ) ( $res2 & a_tmpsss.//sg ) )
    CysBridges.CSCangle1[ipa] = Angle(  $res1 & a_tmpsss.//cb  $res1 & a_tmpsss.//sg  $res2 & a_tmpsss.//sg )
    CysBridges.CSCangle2[ipa] = Angle(  $res1 & a_tmpsss.//sg  $res2 & a_tmpsss.//sg  $res2 & a_tmpsss.//cb )
    delete a_tmpsss.  l_info=no
  endfor
  l_info=no
  sort CysBridges.Energy
  delete CysBridges.Energy > 0.
  rename CysBridges.dist "Ca_dist"
  set format CysBridges.Energy    "%.1f" color="rainbow='#AAAAFF/#AAFFAA/#FF8888,0.:-10.,pinwheel'"
  set format CysBridges.CSCangle1 "%.0f" color="rainbow='#FF8888/#AAFFAA/#AAAAFF/#AAFFAA/#FF8888,83.:123.,pinwheel'"
  set format CysBridges.CSCangle2 "%.0f" color="rainbow='#FF8888/#AAFFAA/#AAAAFF/#AAFFAA/#FF8888,83.:123.,pinwheel'"
  set format CysBridges.SStorsion "%.0f" color="rainbow='#FF8888/#FFFFFF/#AAAAFF/#FFFFFF/#FF8888/#FFFFFF/#AAAAFF/#FFFFFF/#FF8888,-180.:180.,pinwheel'"
  add header CysBridges name="doubleClick" "as_out= $%@.A[%#] | $%@.B[%#] ; display ribbon Mol(as_out); display xstick residue label as_out; center as_out margin = 5."

  delete a_tmpss.
  keep CysBridges
endmacro
macro makeSSbridge auto rs_1 rs_2  ( a_NULL./ )
  if(Nof(Res(rs_1))==2 & Nof(Res(rs_2))==0 ) then; rs_1 = Res(rs_1)[1]; rs_2 = Res(rs_1)[2]; endif
  os_ = Obj( rs_1 )[1]; rs_1 = Res( rs_1 ); rs_2 = Res( rs_2 )
show "r1",rs_1
show "r2",rs_2
  if(Type( os_ 2 ) != "ICM") return error " makeSSBridge> convert source object to ICM"
  if(Nof(rs_1)!=1 | Nof(rs_2)!= 1 | Obj(rs_1)!= Obj(rs_2) ) return error " makeSSBridge> Wrong selection(s)" + Sum( Name( rs_1 | rs2 , full) )
  delete a_tmp*. l_info=no
  copy os_ "tmpss" selection delete l_info=no
  set object a_tmpss.  l_info=no
  rs_1 = Select( rs_1 , a_tmpss. ) ;  rs_2 = Select( rs_2 , a_tmpss. )
  delete disulfide bond a_tmpss.
  modify rs_1 | rs_2 "cys" l_warn = no l_info=no
  rs_1 = Res(rs_1); rs_2 = Res(rs_2)
  make disulfide bond rs_1  rs_2;
  rs_1 = Res(rs_1); rs_2 = Res(rs_2)
  minimize v_/cys*/x* & ( rs_1 | rs_2 )  "ss,to,vw,14" l_showMinSteps = no l_info=no
  s_out = "E="+String(Energy("ss,to"),1)+" SSdist="+ String(Distance( ( rs_1 & a_tmpss.//sg ) ( rs_2 & a_tmpss.//sg ) ),1) + " Tors="+ Integer(Torsion( ( rs_1 & a_tmpss.//cb,sg ) | ( rs_2 & a_tmpss.//cb,sg )  ))
  set comment a_tmpss. s_out
  rename a_tmpss. "tmp" + Field(Name(rs_1 full)[1],2,"^") + Field(Name(rs_2 full)[1],2,"^")
endmacro
#macro deleteResSelection rs_
#  rs_ = Res(rs_); os_ = Obj(rs_)
#  if(Nof(rs_)==0) return
#  for iob=1,Nof( os_ )
#    os1 = os_ [iob]
#    set object os1
#    rs1 = rs_ & a_ ; rs1o = a_ & ! rs1
#    delete Res(rs1 | Next( rs1 & a_*.A//ca bond ) )
#  endfor
#endmacro
macro cutSignalPeptide &seq_  s_newSeqName
  tmpftt = Table( seq_ site )
  i_2out=1
  tmpftt = tmpftt.key=="SIGNAL"
  if(Nof(tmpftt)==1) then
    i_2out = tmpftt.to[1]+1
    if(Trim(s_newSeqName,all)=="") s_newSeqName="matureseq"
    s_newSeqName = Name(Name( s_newSeqName, simple), unique)
    $s_newSeqName = seq_ [i_2out:$]
    keep $s_newSeqName i_2out
  else
    print " Info> No signal peptide found. Nothing to do"
    keep i_2out
  endif
  l_warn=l_info=no
endmacro

macro slide2view i_slide
  if(Nof(slideshow)==0) return error " Error_slide2view> no slides found"
  if(i_slide<1 | i_slide > Nof(slideshow)) return error " Error_slide2view> slide number out of range"
  s_view = Name("view"+Name(slideshow.slides [i_slide])[1] unique)
  $s_view = View( slideshow.slides [i_slide] )
  keep $s_view
  l_info=no
endmacro

macro rotateView auto s_axis ("Y") r_angle (180.)
HELP = """
  rotateView <s_axis> <r_angle>
    Arguments:
     <s_axis> : 'X','Y','Z','all'
        option 'all' just generates six views and ignores the angle.
    <r_angle> : angle in degrees
  Example:  rotateView 'all' 0.; rotateView 'X' 90.
"""
#  R_ax = View( s_axis )  # screen axis
  s_axis = Trim(Tolower(s_axis),all)
  if(s_axis=="all") then
    vFront = View()
    rotate view Rot({1. 0. 0.}, 90. )
    vBottom = View()
    rotate view Rot({1. 0. 0.}, -180. )
    vTop = View()
    set view vFront
    rotate view Rot({0. 1. 0.}, 90. )
    vRight = View()
    rotate view Rot({0. 1. 0.}, 90. )
    vBack = View()
    rotate view Rot({0. 1. 0.}, 90. )
    vLeft = View()
    set view vFront
    keep vFront vTop vBottom vBack vRight vLeft
  else
    ix = Index("xyz",s_axis)
    if(ix==0) return error " Error_rotateView> wrong axis name, use 'x','y', or 'z'"
    R_ax = {0. 0. 0.}; R_ax[ix]=1.
    rotate view Rot( R_ax r_angle )
  endif
endmacro
#
macro assignAbCDR s_seqNaLight s_seqNaHeavy l_setSite (yes)
  l_info = no
  pfNames = Sarray(12 "ABCDRS.p") + { "H1n" "H1c" "H2n" "H2c" "H3n" "H3c" "L1n" "L1c" "L2n" "L2c" "L3n" "L3c" }
  cdrNames = { "HCDR1" "HCDR2" "HCDR3" "LCDR1" "LCDR2" "LCDR3" }
  if(Type(ABCDRS) != "table") read binary s_icmhome + "ABCDRS.icb"
  I_CDRtermini = Iarray(12, -1)
  for i = 1 6
    if(i<4) s_seqNa = s_seqNaHeavy
    if(i>3) s_seqNa = s_seqNaLight
    if(s_seqNa=="")continue
    pfna = pfNames[2*i-1]
    find $pfna $s_seqNa
    i_bgn = i_out + 8
    pfna = pfNames[2*i]
    find $pfna $s_seqNa
    i_end = i_out + 2
    if(i_end-i_bgn<0)then
      print " Warning> Could not detect " + cdrNames[i]
    else
      if(i_end-i_bgn>50) print " Warning> Strange " + cdrNames[i] + " length: " + (i_end-i_bgn)
      if(l_setSite)set site $s_seqNa i_bgn // i_end cdrNames[i]
      I_CDRtermini[i*2-1] = i_bgn
      I_CDRtermini[i*2  ] = i_end
    endif
  endfor
  if(l_setSite)then
    if(s_seqNaLight!="") show site $s_seqNaLight
    if(s_seqNaHeavy!="") show site $s_seqNaHeavy
  else
    show I_CDRtermini
    keep I_CDRtermini
  endif
endmacro
#
macro findAbTemplates s_seqNaLight s_seqNaHeavy
  assignAbCDR s_seqNaLight s_seqNaHeavy no
  if(Min(I_CDRtermini)==-1)then
    print " Some CDRs not detected"
    return
  endif
  if(Type(ABTEMPLATES) != "unknown") delete ABTEMPLATES
  if(Type(PDBMABS) != "table") read table s_icmhome + "PDBMABS.tab"
  lHCDR1 = I_CDRtermini[2 ]-I_CDRtermini[1 ]
  lHCDR2 = I_CDRtermini[4 ]-I_CDRtermini[3 ]
  lHCDR3 = I_CDRtermini[6 ]-I_CDRtermini[5 ]
  lLCDR1 = I_CDRtermini[8 ]-I_CDRtermini[7 ]
  lLCDR2 = I_CDRtermini[10]-I_CDRtermini[9 ]
  lLCDR3 = I_CDRtermini[12]-I_CDRtermini[11]
  sHCDR1 = $s_seqNaHeavy [I_CDRtermini[1 ]:I_CDRtermini[2 ]]
  sHCDR2 = $s_seqNaHeavy [I_CDRtermini[3 ]:I_CDRtermini[4 ]]
  sHCDR3 = $s_seqNaHeavy [I_CDRtermini[5 ]:I_CDRtermini[6 ]]
  sLCDR1 = $s_seqNaLight [I_CDRtermini[7 ]:I_CDRtermini[8 ]]
  sLCDR2 = $s_seqNaLight [I_CDRtermini[9 ]:I_CDRtermini[10]]
  sLCDR3 = $s_seqNaLight [I_CDRtermini[11]:I_CDRtermini[12]]
# try to find templates with all CDR lengths matching
  ABTEMPLATES = PDBMABS.lHCDR1 == lHCDR1 & PDBMABS.lHCDR2 == lHCDR2 & PDBMABS.lHCDR3 == lHCDR3 & PDBMABS.lLCDR1 == lLCDR1 & PDBMABS.lLCDR2 == lLCDR2 & PDBMABS.lLCDR3 == lLCDR3
  n = Nof(ABTEMPLATES)
  group table append ABTEMPLATES Sarray(n "H1,H2,H3,L1,L2,L3") "goodCDRs"
# templates with all but HCDR3 matching
  ABTS = PDBMABS.lHCDR1 == lHCDR1 & PDBMABS.lHCDR2 == lHCDR2 & PDBMABS.lHCDR3 != lHCDR3 & PDBMABS.lLCDR1 == lLCDR1 & PDBMABS.lLCDR2 == lLCDR2 & PDBMABS.lLCDR3 == lLCDR3
  if(Nof(ABTS)!=0)then
    n = Nof(ABTS)
    group table append ABTS Sarray(Nof(ABTS) "H1,H2,L1,L2,L3") "goodCDRs"
    add ABTEMPLATES ABTS
  endif
# light chain match
  ABTS = PDBMABS.lLCDR1 == lLCDR1 & PDBMABS.lLCDR2 == lLCDR2 & PDBMABS.lLCDR3 == lLCDR3
  delete ABTS.PDB == ABTEMPLATES.PDB # already found
  if(Nof(ABTS)!=0)then
    n = Nof(ABTS)
    group table append ABTS Sarray(Nof(ABTS) "L1,L2,L3") "goodCDRs"
    add ABTEMPLATES ABTS
  endif
# heavy chain match
  ABTS = PDBMABS.lHCDR1 == lHCDR1 & PDBMABS.lHCDR2 == lHCDR2 & PDBMABS.lHCDR3 == lHCDR3
  delete ABTS.PDB == ABTEMPLATES.PDB # already found
  if(Nof(ABTS)!=0)then
    n = Nof(ABTS)
    group table append ABTS Sarray(Nof(ABTS) "H1,H2,H3") "goodCDRs"
    add ABTEMPLATES ABTS
  endif
# heavy chain match CDR1 CDR2
  ABTS = PDBMABS.lHCDR1 == lHCDR1 & PDBMABS.lHCDR2 == lHCDR2
  delete ABTS.PDB == ABTEMPLATES.PDB # already found
  if(Nof(ABTS)!=0)then
    n = Nof(ABTS)
    group table append ABTS Sarray(Nof(ABTS) "H1,H2") "goodCDRs"
    add ABTEMPLATES ABTS
  endif
#
  add ABTEMPLATES 1
  ABTEMPLATES.PDB[1] = "QUERY"
  ABTEMPLATES.lHCDR1[1] = lHCDR1
  ABTEMPLATES.lHCDR2[1] = lHCDR2
  ABTEMPLATES.lHCDR3[1] = lHCDR3
  ABTEMPLATES.lLCDR1[1] = lLCDR1
  ABTEMPLATES.lLCDR2[1] = lLCDR2
  ABTEMPLATES.lLCDR3[1] = lLCDR3
  ABTEMPLATES.sHCDR1[1] = String(sHCDR1)
  ABTEMPLATES.sHCDR2[1] = String(sHCDR2)
  ABTEMPLATES.sHCDR3[1] = String(sHCDR3)
  ABTEMPLATES.sLCDR1[1] = String(sLCDR1)
  ABTEMPLATES.sLCDR2[1] = String(sLCDR2)
  ABTEMPLATES.sLCDR3[1] = String(sLCDR3)
#
  n = Nof(ABTEMPLATES)
  group table append ABTEMPLATES Rarray(n) "ScH1" Rarray(n) "ScH2" Rarray(n) "ScH3" Rarray(n) "ScL1" Rarray(n) "ScL2" Rarray(n) "ScL3" Rarray(n) "ScTT"
  for i = 1 n
    if(ABTEMPLATES.lHCDR1[i] == lHCDR1) ABTEMPLATES.ScH1[i] = Score( sHCDR1 Sequence( ABTEMPLATES.sHCDR1 [i]))
    if(ABTEMPLATES.lHCDR2[i] == lHCDR2) ABTEMPLATES.ScH2[i] = Score( sHCDR2 Sequence( ABTEMPLATES.sHCDR2 [i]))
    if(ABTEMPLATES.lHCDR3[i] == lHCDR3) ABTEMPLATES.ScH3[i] = Score( sHCDR3 Sequence( ABTEMPLATES.sHCDR3 [i]))
    if(ABTEMPLATES.lLCDR1[i] == lLCDR1) ABTEMPLATES.ScL1[i] = Score( sLCDR1 Sequence( ABTEMPLATES.sLCDR1 [i]))
    if(ABTEMPLATES.lLCDR2[i] == lLCDR2) ABTEMPLATES.ScL2[i] = Score( sLCDR2 Sequence( ABTEMPLATES.sLCDR2 [i]))
    if(ABTEMPLATES.lLCDR3[i] == lLCDR3) ABTEMPLATES.ScL3[i] = Score( sLCDR3 Sequence( ABTEMPLATES.sLCDR3 [i]))
  endfor
  ABTEMPLATES.ScTT = ABTEMPLATES.ScH1 + ABTEMPLATES.ScH2 + ABTEMPLATES.ScH3 + ABTEMPLATES.ScL1 + ABTEMPLATES.ScL2 + ABTEMPLATES.ScL3
  set format ABTEMPLATES.ScH1 color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:"+ Max(ABTEMPLATES.ScH1) +"'"
  set format ABTEMPLATES.ScH2 color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:"+ Max(ABTEMPLATES.ScH2) +"'"
  set format ABTEMPLATES.ScH3 color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:"+ Max(ABTEMPLATES.ScH3) +"'"
  set format ABTEMPLATES.ScL1 color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:"+ Max(ABTEMPLATES.ScL1) +"'"
  set format ABTEMPLATES.ScL2 color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:"+ Max(ABTEMPLATES.ScL2) +"'"
  set format ABTEMPLATES.ScL3 color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:"+ Max(ABTEMPLATES.ScL3) +"'"
  set format ABTEMPLATES.ScTT color="rainbow='#FF8888/#FFFFFF/#88FFFF/#8888FF,0.:"+ Max(ABTEMPLATES.ScTT) +"'"
  keep ABTEMPLATES
endmacro
#
macro calphaRebuild os_CalphaTrace ( a_ )
  l_minRedraw=no
  set object os_CalphaTrace
  build string IcmSequence( a_ ) name= Name( a_ ) [1] + "_full"
  fix v_//omg
  set tether a_ a_1.
  tzWeight = 10.
  minimize tether
  minimize "tz" 10000
  print bar "Rebuilding backbone phi/psi" Nof( a_/* )-2 l_info=yes
  for i = 2 Nof( a_/* )-1
    if(i==2 | i==Nof( a_/* )-1)then
      ire  = i-1
      ire2 = i+1
    else
      ire  = i-2
      ire2 = i+2
    endif
    ire1 = i+1
    t = Torsion( a_/ [ire:ire2] loop)
    if(Nof( v_//phi & (a_/ [i]))==0)then
      print "skipping proline phi for now"
    else
      set vrestraint energy v_//phi & (a_/ [i])    t[1:1] , -50. 0. 200. l_info=no
      set vrestraint energy v_//phi & (a_/ [i])    t[1:1] , -50. 0. 100. l_info=no
      set vrestraint energy v_//phi & (a_/ [i])    t[1:1] , -50. 0.  50. l_info=no
    endif
    set vrestraint energy v_//psi & (a_/ [ire1]) t[2:2] , -50. 0. 200. l_info=no
    set vrestraint energy v_//psi & (a_/ [ire1]) t[2:2] , -50. 0. 100. l_info=no
    set vrestraint energy v_//psi & (a_/ [ire1]) t[2:2] , -50. 0.  50. l_info=no
    print bar Nof( a_/* )-1 l_info=yes
  endfor
  print bar "End\n" l_info = yes
#
  minimize "tz,rs,to" v_//phi,psi,omg* 100000
#
  make ssbond
  set term "vw,14,hb,to,el,tz,rs"
  vwMethod = "soft"
  vwSoftMaxEnergy = 4.
#
  minimize v_//xi* 1000
#
  ssearch residue fast v_//xi*
  minimize 100000
  assign sstructure
#
endmacro
#
macro makeTagPocketFromLigand auto rs_lig os_ ( a_NONE. )
 if(Nof( os_)==0 ) os_ = Obj( rs_lig )
 set field Sphere( rs_lig ( os_ & ! rs_lig ) , -1.2 ) name="pocket"
 set field Res(Sphere( rs_lig os_ , -1.2 )) name="psite"
endmacro

macro evalChemOdd s_chem
 read iarray s_icmhome + "fcounts.iar"
 pF = Log(fcounts + 1.) /Log(10.)
 fpw= Trim( Max(pF) - pF 4. 100.) - 4.
 fpd = '32384 5 "cd,sp,qfm" "bt,r" '
 add column $s_chem Rarray(Nof( $s_chem )) name="oddChem"
 for i = 1 Nof( $s_chem )
   $s_chem.oddChem [i] = Length(fpw*Iarray(Descriptor( $s_chem.mol [i] $fpd )))
 endfor
 keep $s_chem
endmacro

macro pkMakeChemTable
  delete T_pk
  as_tmp = a_*.H/!so4,gol,zn,mg,ca,cl,edo,po4,hem,nag,act,fad,adp,peg,gal,anp,glc,fuc,pge,sf4,epe,cit,gdp,acy,fmt,pg4,mes,trs,dms,bme
  as_tmp = Mol( as_tmp )
  add column T_pk Chemical( as_tmp exact ), Name( as_tmp, full), Namex(as_tmp)
  keep T_pk
endmacro

macro mkLigContactTable rs_lig rs_pk r_di (1.4)
  l_commands = yes  # as_pk and bb_pk are atoms
  stbna = "T_"+Name(Mol(rs_lig))[1]+"_pk"
  sdina = "dist_"+Name(Mol(rs_lig))[1]+"_pk"
  delete $stbna $sdina
  if(Nof(rs_lig)==0) rs_pk = Obj( rs_lig ) & ! rs_lig
  rs_lig = rs_lig & a_*.//!h*  # become atoms
  rs_pk  = rs_pk  & a_*.//!h*  # become atoms
  as_pk = Sphere( rs_lig , rs_pk , -r_di  )
  ds cpk as_pk
  make distance rs_lig as_pk 2.2 + r_di name=sdina  # replace by -1.2 later, append make hbond
  $stbna = Table( $sdina distance ) # need to extend
  add column $stbna Sarray(Nof($stbna) "sc") name="type"
  keep $stbna
endmacro
#
macro makePocketomeAnnotation as_lig
 obsel = Obj(as_lig)
 delete field name="ligand" Res(obsel)
 delete field name="pocket" Atom(obsel)
 delete field name="psite"  Res(obsel)
 delete field name="site"   Atom(obsel)
#
 set field Res(as_lig) name="ligand"
 set field name="site" Sphere( as_lig (obsel & a_*.//!h*,d*,vt* & !Res(as_lig)) , -1.2 ) # atom
 set field name="psite" Res(Select(a_*.// "site")) # res
 set field name="ligand" Res( as_lig )
 for iob=1,Nof(obsel)
   set field name="pocket" Sphere( as_lig & obsel[ iob ]  obsel[ iob ] & ! as_lig , -1.2 )
 endfor
endmacro
#
macro makePocketomeFile as_lig s_pkfilename ("pk")
  makePocketomeAnnotation as_lig
  write binary Obj( as_lig ) s_pkfilename
endmacro

macro makeGrobFromSel as_ s_color l_solid (no)
  if(Nof(as_ )==0) return
  make map potential as_ name="m_tmp"
  sgna = Name("shape",unique)
  sclr = s_color
#  print sgna, sclr
  make grob (!l_solid)?:solid m_tmp $sclr name=sgna
  compress $sgna 0.5
  link $sgna Mol(as_ )
  link $sgna Obj(as_ )
  if(Exist(view)) display $sgna (!l_solid)?:transparent
  keep $sgna
endmacro

macro calcHbResContacts as_   #rna #dna
  l_info=no
  as_ = as_ & a_*.!W  # exclude water
  if(Nof(as_ )==0) return error " Error> empty selection, nothing to do"
  if(Type(Obj(as_),2)!="ICM") return error " Error> object needs convertion"
  hbondPrepare as_
  cnbo = {"-",":","=","4","5"}
  hbname = Name("hbond_"+Name(Obj(as_)[1])[1], unique)
  make distance hbond as_ as_  name = hbname  2.6  GRAPHICS.hbondMinStrength = 0.8
  if(Type( $hbname ) == "unknown" | Nof( $hbname )==0 ) return error " Error> no hbonded pairs found"
  tbna = Name( "thb_"+Name(Obj( as_ )[1])[1] , unique )
  $tbna = Table( $hbname distance ) # contains pairs of atoms from same res
  add column $tbna Iarray(Nof( $tbna ),1 ) name="Nhb"
  group $tbna.res $tbna.Nhb "sum"  # in place
  np = Nof( $tbna )
  add column $tbna Sarray(np) Sarray(np) name={"Pairs","Type"}
# columns: .res .Nhb .Pairs .Type
  for ii=1,np
    sre2 = $tbna.res [ii]
    nbo = $tbna.Nhb [ii]
    if( Field(sre2,1,"|")==Field(sre2,2,"|") ) then
      $tbna.Pairs [ii]=Tr321(Name( $sre2 )[1])
      $tbna.Type  [ii] = "S"  # single/same
    else
      $tbna.Pairs [ii] = Tr321(Name( $sre2 )[1])+cnbo[ nbo ]+Tr321(Name( $sre2 )[$])  # sometimes the same residue
      if( Nof( $sre2 & a_*.N ) > 0 &  Index({"C=G","G=C","A:U","U:A","A:T","T:A"}, $tbna.Pairs [ii] ) ==0 ) then
        $tbna.Type [ii] = "U"
        if(Exist(view)) color ribbon base $sre2 green
      endif
    endif
  endfor
  delete $tbna.Type == "S"
  printf " Info> table '%s' with %d contact pairs created\n", tbna, Nof( $tbna )
  add header $tbna name="doubleClick" "as_graph= Atom( %1 ); display residue label black %1 ; color ribbon base %1 green ;"
  set format $tbna.Type "" name="" color=" _ ~ 'U'  ? '#32ffdd' : ''"
  keep  $tbna
endmacro

function listOnlineExtensions
  read json TOOLS.addonsDir + "index.json" name="cont"
  add column T_cont Sarray( cont["name"] ) name="name"
  add column T_cont Sarray( Nof(T_cont) "install/update" ) name="install"
  add column T_cont Sarray( Nof(T_cont) "remove" ) name="uninstall"
  add column T_cont Sarray( cont["description"] ) name="description"
  set format T_cont.install   Link( "installOnlineExtension %@.name[%#] yes" command )
  set format T_cont.uninstall Link( "installOnlineExtension %@.name[%#] no" command )
  return Collection( T_cont all )
endfunction

macro installOnlineExtension s_name l_on (yes) auto
  l_commands = l_info = no
  read json TOOLS.addonsDir + "index.json" name="cont"
  for i=1,Nof(cont)
    if (cont[i,"name"] == s_name) break
  endfor
  if (i>Nof(cont)) return error " Error> cannot find extension " + s_name

  ext = cont[i]

  s_extDir = s_userDir + ext["name"]

  if (Nof(ext["files"]) ==0) return

  s_userStartup = s_userDir + "user_startup.icm"
  s_userStartupCont = ""

  if (Exist(s_userStartup)) read string s_userStartup name="s_userStartupCont"

  s_callString = "call \"" + s_extDir + "/" + ext["files",1] + "\""

  if (l_on) then
    make directory s_extDir

    for i=1,Nof(ext["files"])
      read blob TOOLS.addonsDir + ext["files",i] name="filecont"
      write filecont delete s_extDir + "/" + ext["files",i]
    endfor

    if (Index(s_userStartupCont,s_callString) == 0) then
      s_userStartupCont += "\n" + s_callString + "\n"
      write s_userStartupCont s_userStartup delete l_info = yes
    endif
  else
    if (Index(s_userStartupCont,s_callString) != 0) then
      s_userStartupCont = Replace(s_userStartupCont,s_callString,"",simple)
      write s_userStartupCont s_userStartup delete l_info = yes
    endif
  endif

  printf " Info> Extension '%s' is sucessfully %s. Please restart ICM\n", ext["name"], l_on ? "installed/updated" : "removed"
endmacro

function Pseudorotation rs_
  set object Obj( rs_ )
  toRad = Pi()/180.
  v0 = toRad*Torsion( a_//c4' & rs_ a_//o4' & rs_ a_//c1' & rs_ a_//c2' & rs_ )
  v1 = toRad*Torsion( a_//o4' & rs_ a_//c1' & rs_ a_//c2' & rs_ a_//c3' & rs_ )
  v2 = toRad*Torsion( a_//c1' & rs_ a_//c2' & rs_ a_//c3' & rs_ a_//c4' & rs_ )
  v3 = toRad*Torsion( a_//c2' & rs_ a_//c3' & rs_ a_//c4' & rs_ a_//o4' & rs_ )
  v4 = toRad*Torsion( a_//c3' & rs_ a_//c4' & rs_ a_//o4' & rs_ a_//c1' & rs_ )
  Pconst = Sin(180./5) + Sin(180./2.5)  # 1.5388
  P = Atan2(v4 + v1 - v3 - v0, 2.0 * v2 * Pconst)  # 2.9034
  A = v2 / Cos(P)  # amplitude: 48.469
  X = P // A
  return X
endfunction

macro plotPseudorotation auto rs_ (a_N/)
  l_commands = no
  l_info     = no
  l_confirm  = yes
  l_icmobj = yes
  PLOT.logo = no
  s_File=Sum(Name(Obj(rs_)))
  t_rama  =("Pseudorotation plot of "+s_File) // "Phase Tau, deg"//"Amplitude P"
  resLabelStyle = 1
  rs_= Res(rs_)
  nesl_rama=Nof(rs_)
  x_rama=Rarray(nesl_rama)
  y_rama=Rarray(nesl_rama)
  s_rama=Sarray(nesl_rama)
  s_name=Sarray(nesl_rama)
  j=0
  for i=1,nesl_rama
    V = Pseudorotation( rs_[i] )
    j=j+1
# may need to skip some?
    x_rama[j]=V[1]
    y_rama[j]=V[2]
    s_name[j]=Sum(Name(rs_[i]))
    s_rama[j]=Sum(Label(rs_[i]))
  endfor
  global group table PSEUDOROTATION Sarray( rs_ residue ) "", x_rama[1:j] "Tau", y_rama[1:j] "P" s_name "Name",s_rama "Label" Count(j) "i" header "as_graph=a_%1/c1',c2',c3',c4',o4'\ndisplay residue label a_%1 \ncenter a_%1" "cursor"
  if(Nof(PSEUDOROTATION)==0) return error " No suitable bases selected."
  set format show off PSEUDOROTATION.A
  make plot PSEUDOROTATION "x=Tau;y=P;labels=Name;labelOnSelect=yes;;xStep=60;yStep=0.2;title=Pseudorotation;xRange=0.:360.;yRange=0.:1.;;"
endmacro

macro importSequenceFromString s_inp s_seqName s_type ("auto")
  l_commands = l_info = no
  s_inp = Trim( s_inp all)
  ic_3letter = yes
  c_amino = Collection( "ala" "A" "arg" "R" "asn" "N" "asp" "D" "asx" "B" "cys" "C" "gln" "Q" "glu" "E" "gly" "G" "his" "H" "ile" "I" "leu" "L" "lys" "K" "met" "M" "phe" "F" "pro" "P" "ser" "S" "thr" "T" "trp" "W" "tyr" "Y" "val" "V" )
  S_3letter = Split( s_inp, "\\W+" regexp )
  n_unknown = 0
  s_1letter = ""
  for i=1,Nof(S_3letter)
    if ( Exist( c_amino, Tolower(S_3letter[i])) ) then
      s_1letter += c_amino[Tolower(S_3letter[i])]
    else
      s_1letter += "X"
      n_unknown += 1
    endif
  endfor
  if (Nof(S_3letter)>1 & n_unknown < Nof(S_3letter)/3) s_inp = s_1letter

  ic_fasta = no
  if (s_inp[1] == ">") ic_fasta = yes
  if (!ic_fasta) read sequence fasta select auto input = "> " + s_seqName + "\n" + Trim( s_inp all)
  if ( ic_fasta) read sequence fasta select input = Trim( s_inp all)
  s_seqName = s_out
  if ( !ic_fasta ) then
    if s_type == "rna"                    set type $s_seqName  nucleotide "rna"
    if s_type != "auto" & s_type != "rna" set type $s_seqName  $s_type
  endif
  keep $s_seqName global
endmacro

macro tabulateStackEnergyTerms
  stackEnergyTerms=Table(stack)
  n=Nof(stackEnergyTerms)
  group table append stackEnergyTerms Rarray(n) "vw" Rarray(n) "vw14" Rarray(n) "el" Rarray(n) "to" Rarray(n) "hb" Rarray(n) "bb" Rarray(n) "sf"
  for i = 1 Nof(stackEnergyTerms)
    load conf i
    stackEnergyTerms.vw[i]   = Energy("vw")
    stackEnergyTerms.vw14[i] = Energy("14")
    stackEnergyTerms.el[i]   = Energy("el")
    stackEnergyTerms.to[i]   = Energy("to")
    stackEnergyTerms.hb[i]   = Energy("hb")
    stackEnergyTerms.bb[i]   = Energy("bb")
    stackEnergyTerms.sf[i]   = Energy("sf")
  endfor
  keep stackEnergyTerms
endmacro

macro calcSSBONDSdev s_SSBONDS rs_1 rs_2 s_name ("dev")
  add column $s_SSBONDS Rarray( Nof( $s_SSBONDS )) name=s_name
  keep $s_SSBONDS
  if(Nof(rs_1)!=1 | Nof(rs_2)!=1 | Nof(Obj(rs_1|rs_2))!=1) return error "two single residue selections in one object expected"
  copy Obj(rs_1|rs_2) "temp" selection strip
  set object a_temp.
  delete a_ & ! ( rs_2 | rs_1  )
  convert selection
  delete a_temp.
  load object $s_SSBONDS.TMPL
  superimpose exact a_//c,ca,n,cb rs_1 & a_temp_1.//c,ca,n,cb
  delete a_
  $s_SSBONDS.$s_name = Distance( Matrix(Rarray(Xyz( rs_2 & a_temp_1.//c,ca,n,cb ) )) Matrix(SSBONDS.xyz  ))[1]
  delete a_temp_1.
endmacro

macro processPROTACsims s_files ("")
  S_fina = Sarray(s_files,directory)
  delete a_protacModelAll.
  delete PROTAC_poses PROTAC_posesAll
  for j = 1 Nof( S_fina )
    read binary S_fina[j]
    load stack a_
    for i = Nof(conf) 1, -1
      if( Nof(PROTAC_poses.i == i )==0) delete conf i
    endfor
    store stack a_
    if(j==1 )then
      rename a_ "protacModelAll"
      rename PROTAC_poses PROTAC_posesAll
    else
      cuob = a_
      set object a_protacModelAll.
      load stack a_
      load stack append cuob
      delete Obj(cuob)
      store stack a_
      add PROTAC_posesAll PROTAC_poses
      sort PROTAC_posesAll.ener
    endif
    PROTAC_posesAll.i = Count(Nof(PROTAC_posesAll))
  endfor
  PROTAC_posesAll.cursor = Replace( PROTAC_posesAll.cursor "protac_complex_model" "protacModelAll")
  load stack a_
  sort stack
  store stack a_
  keep PROTAC_posesAll
endmacro
#
macro traverseTree s_nk s_fu l_sort (no) l_up (yes) i_root
  l_info=no
#
  ttt = Time();
  l_max = yes
  ibr =0
  cuso=0 # global for the setPoint
  s_bt = "bx" # $s_nk.s_bt
  $s_bt = Table( $s_nk.nk ["bonds"] )
#
  if(i_root==0)i_root=1
  rd = 1
  I_s = Iarray(rd i_root)
  I_b = Iarray(rd 1)
  if(l_up) $s_fu s_nk I_s I_b rd
  NN = Nof( $s_nk )*2
  print bar "Builging network graph" NN l_info=yes
  while(yes)
#     group table D Index( $s_nk I_s[rd] tree ) "target" Rarray( $s_nk.nk ["bonds" "power" ] ) [Index( $s_nk I_s[rd] bond )]  "width"
     D = ( $s_bt.source == I_s[rd])
     if(Nof(D)<I_b[rd])then
       if(!l_up) $s_fu s_nk I_s I_b rd
       if(rd==1)break
       rd = rd-1
       I_b[rd] = I_b[rd]+1
      # continue
     else
       if(l_sort)then
         if(l_max)  sort D.width D.target
         if(!l_max) sort reverse D.width D.target
       endif
       I_s = I_s[1:rd] // (D.target[I_b[rd]])
       I_b = I_b[1:rd] // 1
       rd = rd+1
       if(l_up) $s_fu s_nk I_s I_b rd
     endif
     print bar NN l_info = yes
  endwhile
  print bar "End\n" l_info=yes
  #print "traverseTree: " Time() - ttt;
endmacro

macro treePointLayoutWheel s_nk I_s I_b i_rd
 if(i_rd<2)return
 gamm = $s_nk.layoutParams [1]
 i0 = I_s[i_rd]
 if( $s_nk.x [i0] != 0. | $s_nk.y [i0] != 0. ) return
 I12 = Index( $s_nk i0 tree )
 xyr = $s_nk.x [i_root] // ( $s_nk.y [i_root] )
 if( Nof(I12)==0)then
   ag = (360.*itt)/ntt
   $s_nk.tilt [i0] = ag+0.0001
   itt = itt+1
   keep itt
   $s_nk.x [i0] = radius*Cos(ag) + xyr[1]
   $s_nk.y [i0] = radius*Sin(ag) + xyr[2]
   $s_nk.size [i0] = radius*0.8*2*Pi()/ntt
 else
   i1 = I12 [1]
   i2 = I12 [2]
   if( ( $s_nk.x [i1] == 0. & $s_nk.y [i1]==0.) | ( $s_nk.x [i2] == 0. & $s_nk.y [i2] ==0.) ) return
   $s_nk.x [i0] = gamm*Mean( $s_nk.x [i1//i2] ) + (1.-gamm)*xyr[1]
   $s_nk.y [i0] = gamm*Mean( $s_nk.y [i1//i2] ) + (1.-gamm)*xyr[2]
   r1 = Distance( $s_nk.x [i1] //( $s_nk.y [i1] ) xyr )
   r2 = Distance( $s_nk.x [i2] //( $s_nk.y [i2] ) xyr )
   r0 = Distance( $s_nk.x [i0] //( $s_nk.y [i0] ) xyr )
   if(r0>Min(r1 r2))then
     qf = Sqrt(Min(r1 r2)/r0)*(gamm+1.)/2.
     $s_nk.x [i0] = qf* $s_nk.x [i0] + (1.-qf)*xyr[1]
     $s_nk.y [i0] = qf* $s_nk.y [i0] + (1.-qf)*xyr[2]
   endif
 endif
endmacro

macro treePointLayoutFractal s_nk I_s I_b i_rd
 if(i_rd<2)then
   i0 = I_s[i_rd]
   i12 = Index( $s_nk i0 tree )
   $s_nk.size [i0] = 0.25* Mean(Length( ( $s_nk.x [i12[1]] ) // ( $s_nk.y [i12[1]] )) // Length( ( $s_nk.x [i12[2]] ) // ( $s_nk.y [i12[2]] )))
   return
 endif
 i0 = I_s[i_rd]
 i1 = I_s[i_rd-1]
 $s_nk.tilt [i0] = 0.0
 if(i_rd==2)then
   i2=0
   dx=0.
   dy=1.
 else
   i2 = I_s[i_rd-2]
   dx = $s_nk.x [i1] - $s_nk.x [i2]
   dy = $s_nk.y [i1] - $s_nk.y [i2]
 endif

 mx_rd = Integer( $s_nk.layoutParams [6] )
 Ibr = Index( $s_nk i0 tree )
 if(i_rd > mx_rd)then
   if(Nof(Ibr)>0)then
     $s_nk.x [i0] = $s_nk.x [i1]
     $s_nk.y [i0] = $s_nk.y [i1]
     return
   endif
   i1 = I_s[mx_rd]
   i2 = I_s[mx_rd-1]
   dx = $s_nk.x [i1] - $s_nk.x [i2]
   dy = $s_nk.y [i1] - $s_nk.y [i2]
   if(cuso != i1)then
     cuso = i1
     keep cuso
     ibr = 0
   endif
   mnbr = $s_nk.nk ["bonds" Index( $s_nk cuso bond reverse)[1] "power"]
   ag = 120.*Real(ibr)/(mnbr-1) -60.
   cs = Cos(ag)
   sn = Sin(ag)
   $s_nk.x [i0] = $s_nk.x [i1] + dx*cs + dy*sn
   $s_nk.y [i0] = $s_nk.y [i1] - dx*sn + dy*cs

   ibr = ibr+1
   keep ibr
   return
 endif
  gamm =  $s_nk.layoutParams [1]
  beta =  $s_nk.layoutParams [2]
  omg  =  $s_nk.layoutParams [3]
  ag0  =  $s_nk.layoutParams [4]
  dag  =  $s_nk.layoutParams [5]
  qf =1.
#    if( Nof(Ibr) == 2)then
#      qf = 1. + 10./(10. + Max(( $s_bt.source == i0 ) .width )/Min( ( $s_bt.source == i0 ) .width ) )
#      if(no)qf = 1. + Power(Min(( $s_bt.source == i0 ) .width ) / Min (( $s_bt.source == i1 ) .width ) 0.3333)
#      # print Sum( {-1. 1.} * ( $s_bt.source == i0 ) .width )/ Sum( ( $s_bt.source == i0 ) .width )  qf
#    endif
#    qf = qf / Power( ( $s_bt.target == i0 ) .width [1] / Sum( ( $s_bt.source == i1 ) .width  )   0.25    )
#    qf = qf * ( ( $s_bt.target == i0    ) .dist [1] + 0.1) * Power( gamm i_rd )
  qf = qf * ( $s_nk.nk ["bonds" Index( $s_nk i0 bond reverse)[1] "dist"] + 0.1) * Power( gamm i_rd )   # power law, orig distance and normalization
  qf = qf * (1. + 0.5*Log( $s_nk.nk ["bonds" Index( $s_nk i0 bond reverse)[1] "power"] ))                                       # elongate main trunks
  qf1 = 1.
  if( Nof(Ibr) == 2)then                 # shorten trunk between small branches
#      qf1 = Power(2* ( Min(( $s_bt.source == i0 ) .width ) / Sum( ( $s_bt.source == i0 ) .width ) + Min(( $s_bt.source == i1 ) .width)  / Sum( ( $s_bt.source == i1 ) .width)  ) 0.5)
    W0 =  $s_nk.nk ["bonds" Index( $s_nk i0 bond )[1] "power"] // $s_nk.nk ["bonds" Index( $s_nk i0 bond )[2] "power"]
    W1 =  $s_nk.nk ["bonds" Index( $s_nk i1 bond )[1] "power"] // $s_nk.nk ["bonds" Index( $s_nk i1 bond )[2] "power"]
    qf1 = 0.5*Power(0.5, -omg)*( Power( Min(W0) / Sum(W0) omg ) +  Power(Min(W1)/Sum(W1)  omg))
  endif
  qf = qf*qf1
#
 ttw = 0.
 w0 =  $s_nk.nk ["bonds" Index( $s_nk I_s [2]  bond reverse )[1] "power"]
 for i = 2 i_rd
    w = $s_nk.nk ["bonds" Index( $s_nk I_s [i]  bond reverse )[1] "power"]
    ttw = ttw + Log(w 2.) - (Log(w0 2.) - (i-2))
 endfor
 qf = qf* Power( 1.+beta ttw )
#
 $s_nk.size [i0] = 0.66*qf
#   if( Replace( Smiles( $s_nk.mol [i1] unique) "R[1-9]" "R") == Replace( Smiles( $s_nk.mol [i0] unique) "R[1-9]" "R") ) $s_nk.showStr [i0] = 0 # $s_nk.size [i0] = 0.
  if( Type( $s_nk.showStr ) != "unknown" & ( Nof( $s_nk.mol [i1] atom ) == Nof( $s_nk.mol [i0] atom ) & Nof(Ibr) != 0  ) ) $s_nk.showStr [i0] = 0
#
  qf = qf / Sqrt(dx*dx + dy*dy)
  dx = dx*qf
  dy = dy*qf

  ag = ag0
  dag1 = dag
  if(i2!=0)then
#      qf1 = Power(2* ( Min(( $s_bt.source == i1 ) .width ) / Sum( ( $s_bt.source == i1 ) .width ) +  Min(( $s_bt.source == i2 ) .width)  / Sum( ( $s_bt.source == i2 ) .width)  ) 0.5)
    W1 =  $s_nk.nk ["bonds" Index( $s_nk i1 bond )[1] "power"] // $s_nk.nk ["bonds" Index( $s_nk i1 bond )[2] "power"]
    W2 =  $s_nk.nk ["bonds" Index( $s_nk i2 bond )[1] "power"] // $s_nk.nk ["bonds" Index( $s_nk i2 bond )[2] "power"]
    qf1 = 0.5*Power(0.5, -omg)*(Power( ( Min(W1) / Sum(W1)) omg ) +  Power(Min(W2)  / Sum(W2)  omg))
    ag = ag0*qf1
    dag1 = dag  - 0.5*ag0*(1.-qf1)
  endif
cs1 = Cos(ag)
sn1 = Sin(ag)
cs2 = Cos(ag-dag1)
sn2 = Sin(ag-dag1)

 if(I_b[i_rd-1]==2)then
   $s_nk.x [i0] = $s_nk.x [i1] + dx*cs1 + dy*sn1
   $s_nk.y [i0] = $s_nk.y [i1] - dx*sn1 + dy*cs1
 else
   $s_nk.x [i0] = $s_nk.x [i1] + dx*cs2 + dy*sn2
   $s_nk.y [i0] = $s_nk.y [i1] - dx*sn2 + dy*cs2
 endif
endmacro

macro mcsOnlyShowMajor s_nk I_s I_b i_rd
 i0 = I_s[i_rd]
 if(i_rd<2) return
 $s_nk.visible [i0] = (Sum(Mass( $s_nk.mol [i0] )) < r_mcsFractioniVisible*Mean(Mass( $s_nk.ord ==  $s_nk.llist [i0] .mol  )))?1:0
endmacro

macro mcsImproveTriplet s_nk I_s I_b i_rd
 i0 = I_s[i_rd]
 if(i_rd<2 | Nof( Index( $s_nk i0 tree))==0)then # root or terminal
   $s_nk.mcsChanged_ [i0] = 0
   return
 endif
 i1 = Index( $s_nk i0 tree reverse)[1]
 iab =  Index( $s_nk i0 tree)
 ic  =  Sum( Index( $s_nk i1 tree)) - i0 # trick to get the other branch
 if(Sum( $s_nk.mcsChanged_ [ iab // ic // i0 // i1 ]) ==0) return
 find sstructure $s_nk.mol [iab]   name = "ss_ab"
 find sstructure ss_ab.mol // $s_nk.mol [ic]  name = "ss_abc"
 find sstructure $s_nk.mol [iab[1]] // ($s_nk.mol [ic])  name = "ss_ac"
 find sstructure ss_ac.mol // $s_nk.mol [iab[2]]  name = "ss_acb"
 find sstructure $s_nk.mol [iab[2]] // ($s_nk.mol [ic])  name = "ss_bc"
 find sstructure ss_bc.mol // $s_nk.mol [iab[1]]  name = "ss_bca"
 sz_ac = Nof( ss_ac.mol atom )[1]  # nof atom might be better
 sz_acb= Nof( ss_acb.mol atom)[1]
 sz_bc = Nof( ss_bc.mol atom)[1]
 sz_bca= Nof( ss_bca.mol atom)[1]
 sz_ab = Nof( ss_ab.mol atom)[1]
 sz_abc= Nof( ss_abc.mol atom)[1]
 $s_nk.mol [i0] = ss_ab.mol
 $s_nk.mol [i1] = ss_abc.mol
 if( sz_ac >= sz_ab & sz_acb >= sz_abc & sz_ac+sz_acb > sz_ab+sz_abc+0.1 & sz_ac+sz_acb > sz_bc+sz_bca )then
    print "Non-parsimonious" iab[1] iab[2] ic sz_ac sz_ab sz_acb sz_abc
    ixb = Index( $s_bt.target == iab[2] )[1]
    ixc = Index( $s_bt.target == ic ) [1]
    $s_nk.nk ["bonds" ixb "source"] = i1
    $s_nk.nk ["bonds" ixc "source"] = i0
    $s_bt.source [ixb] = i1
    $s_bt.source [ixc] = i0
    $s_nk.mol [i0] = ss_ac.mol
    $s_nk.mol [i1] = ss_acb.mol
    $s_nk.mcsChanged_ [i0] = 1
    $s_nk.mcsChanged_ [i1] = 1
    return
 endif
 if( sz_bc >= sz_ab & sz_bca >= sz_abc & sz_bc+sz_bca > sz_ab+sz_abc+0.1 & sz_bc+sz_bca >=sz_ac+sz_acb )then
    print "Non-parsimonious" iab[2] iab[1] ic sz_bc sz_ab sz_bca sz_abc
    ixa = Index( $s_bt.target == iab[1] ) [1]
    ixc = Index( $s_bt.target == ic ) [1]
    $s_nk.nk ["bonds" ixa "source"] = i1
    $s_nk.nk ["bonds" ixc "source"] = i0
    $s_bt.source [ixa] = i1
    $s_bt.source [ixc] = i0
    $s_nk.mol [i0] = ss_bc.mol
    $s_nk.mol [i1] = ss_bca.mol
    $s_nk.mcsChanged_ [i0] = 1
    $s_nk.mcsChanged_ [i0] = 1
    return
 endif
 $s_nk.mcsChanged_ [i0] = 0
endmacro

# macro calcCoord s_nk I_s I_b i_rd
#   i0 = I_s[i_rd]
#   if(Nof( Index( $s_nk i0 tree))>0)return
#   for i = 1 i_rd - 1
#     ix = I_s[i]
#     $s_nk.coord  [ix] = $s_nk.coord [ix] + $s_nk.coord [ I_s[i_rd]]
#     $s_nk.weight [ix] = $s_nk.weight [ix] + 1
#   endfor
# endmacro

macro makeMCStree s_tab s_label ("") l_optimize (no) s_layout ("treePointLayoutFractal")
 l_info = l_commands = no
 icMol = Type( $s_tab.mol ) == "parray"
 if (icMol) then
   make tree $s_tab full "UPGMA" matrix split="cl" label="%NAME_;"
   make network $s_tab.cluster sstructure l_info = yes
 else
   if (Type( $s_tab.dimt ) == "matrix") then
     make tree $s_tab distance="dimt" matrix split="cl" label="%NAME_;"
   else
     S_sel = Field( Name( $s_tab selection ) 2 "." )
     if (Nof(S_sel) == 0) S_sel = Field( Name( $s_tab number ) 2 "." )
     if (Nof(S_sel) == 0) return error "no column found for clustering"
     make tree $s_tab full "UPGMA" matrix column = S_sel split="cl" label="%NAME_;"
   endif
   make network $s_tab.cluster l_info = yes
   l_optimize = no
 endif
 s_nk = s_tab + "_MCStree"
 rename nk s_nk
 set label $s_nk [ Index( $s_nk.ord != 0 ) ] 3
 set label $s_nk [1] 5
 add column $s_nk Sarray(Nof( $s_nk ) "yellow") name = "color"
 add column $s_nk Rarray(Nof( $s_nk )) name = "tilt"
 if (icMol) add column $s_nk Iarray( Nof( $s_nk ) yes logical ) index=2 name="showStr" append
 add column $s_nk Iarray( Nof( $s_nk ) yes logical ) index=2 name="showLabel" append
 add column $s_nk Iarray( Nof( $s_nk ) yes logical ) index=2 name="visible" append
 if (icMol) then
   make plot $s_nk "x=x;y=y;color=<rowcolor>;shape=ChemicalCircle;wsize=size;label="+ s_label +";visible=visible;labelStyle=outside;labelColor=black;labelAngle=tilt;tooltip=mol;showChem=showStr;showLabel=showLabel;;grid=no;;scales=no;;editMode=yes;;"
else
   make plot $s_nk "x=x;y=y;color=<rowcolor>;wsize=size;label="+ s_label +";visible=visible;labelStyle=auto;labelColor=black;labelAngle=tilt;tooltip=" + s_label + ";showLabel=showLabel;;grid=no;;scales=no;;editMode=yes;;"
endif

s_tools =             "#"
s_tools = s_tools + "\n# r_Level_Scale ( 0.78 )  [BEGINFRAME:Fractal Layout]"
s_tools = s_tools + "\n# r_Major_Boost ( 0.01 ) "
s_tools = s_tools + "\n# r_Minor_Squeeze ( 0.66 )"
s_tools = s_tools + "\n# r_Tilt ( 60. ) "
s_tools = s_tools + "\n# b_Apply ( %@.layoutParams = { $1 $2 $3 $4 120. 100. } | traverseTree \"%@\" \"treePointLayoutFractal\" yes yes 1 ) [ENDFRAME]"
#
s_tools = s_tools + "\n# r_Level_Scale ( 0.85 ) [BEGINFRAME:Wheel Layout]"
s_tools = s_tools + "\n# b_Apply ( %@.layoutParams [1] = $6 | treeWheelLayout \"%@\" 0 ) ]"
s_tools = s_tools + "\n# b_Branch ( %@.layoutParams [1] = $6 | if(Nof(Index( %@ selection))==1) treeWheelLayout \"%@\" Index( %@ selection)[1] ) [ENDFRAME]"
#
s_tools = s_tools + "\n# b_Bigger  ( if(Nof(Index( %@ selection ))==0) %@.size = 1.1* %@.size | if(Nof(Index( %@ selection ))!=0) %@.size [Index( %@ selection )] = 1.1* %@.size [Index( %@ selection )] ) [BEGINFRAME:Structures]"
s_tools = s_tools + "\n# b_Smaller ( if(Nof(Index( %@ selection ))==0) %@.size = 0.9* %@.size | if(Nof(Index( %@ selection ))!=0) %@.size [Index( %@ selection )] = 0.9* %@.size [Index( %@ selection )] ) "
s_tools = s_tools + "\n# b_Set_Size ( if(Nof(Index( %@ selection ))==0) %@.size = Rarray(Nof( %@ ) $12 ) | if(Nof(Index( %@ selection ))!=0) %@.size [ Index( %@ selection ) ] = Rarray(Nof( Index( %@ selection ))  $12 )) r_size ( 0.1 ) [ENDFRAME]"

s_tools = s_tools + "\n# b_Select_Children ( if(Nof(Index( %@ selection))==1) select %@ [ Index( %@ Index( %@ selection)[1] tree all ) ] )"
s_tools = s_tools + "\n# b_Select_Branch   ( if(Nof(Index( %@ selection))==1) select %@ [ Index( %@ Index( %@ selection)[1] tree all ) // Index( %@ selection )] )"
s_tools = s_tools + "\n# b_Bunch/Branch    ( if(Nof(Index( %@ selection))==1) %@.visible [ Index( %@[ Index( %@ Index( %@ selection)[1] tree all) ] & %@.ord ==0) ] = Sum( %@.visible [Index( %@ Index( %@ selection)[1] tree)])==0?1:0 )"

#
# s_tools = s_tools + "\n# s_Name ( \"Compound\" )"
# s_tools = s_tools + "\n# b_Set_Label ( if(Nof(Index( %@ selection ))==0) %@.name [Index( %@ selection )] = Sarray( $12 Nof(Index( %@ selection ))) ) "

add header $s_nk s_tools name="toolsPanel"

# add column nk Parray( Matrix( Nof(nk) Nof(t) ) ) name = "coord"
# corMat = Disgeo( $s_tab.dimt_UPGMA  )
# for i = 1,Nof(t)
#
#
# endfor
 if ( Type( $s_tab.dimt_UPGMA ) != "unknown" ) then
   add header $s_nk $s_tab.dimt_UPGMA name="dimt_leaves"
 elseif ( Type( $s_tab.dimt ) != "unknown" ) then
   add header $s_nk $s_tab.dimt name="dimt_leaves"
 endif
 add header $s_nk "b" name="s_bt"
#
if(l_optimize) optimizeMCStree s_nk
#
 makeMCSTreeBonds s_nk

 # gamm beta omg ag0 dag mx_rd
#   add header $s_nk  { 0.85 0.008 0.66 60. 120. 100. } name = "layoutParams"
 add header $s_nk  { 0.78 0.008 0.66 60. 120. 100. } name = "layoutParams"

 #traverseTree s_nk "treePointLayoutFractal" yes yes 1
 traverseTree s_nk s_layout yes yes 1
 delete $s_tab.cluster
 keep $s_nk
endmacro
#
macro makeMCSTreeBonds s_nk
 l_commands = no
 add column $s_nk Parray( iarray Sarray(Nof( $s_nk )) ) name="llist"
 for i = 1 Nof( $s_nk.nk ["bonds"])
   $s_nk.nk [ "bonds" i "power" ] = 0.
 endfor
 for i = 1 Nof( $s_nk )
   if(Nof(Index( $s_nk i tree))!=0)continue
   ix = Iarray(1 i) # descend from each leaf
   while(Nof(ix)>0)
     $s_nk.llist [ix[1]] = $s_nk.llist [ix[1]] // $s_nk.ord [i]
     bix = Index( $s_nk ix[1] bond reverse)
     if(Nof(bix)) $s_nk.nk ["bonds" bix[1] "power" ] = $s_nk.nk ["bonds" bix[1] "power" ] + 1
     ix = Index( $s_nk ix[1] tree reverse)
   endwhile
 endfor
 mxwi = Max(Rarray( $s_nk.nk ["bonds" "power"] ))
 for i = 1 Nof( $s_nk.nk ["bonds"])
   $s_nk.nk [ "bonds" i "width" ] = Max( 1. 10.*Sqrt( $s_nk.nk ["bonds" i "power"]/mxwi ))
 endfor

 midi = 999999.
 for i0 = 1 Nof( $s_nk )
   i12 = Index( $s_nk i0 tree)
   if(Nof(i12)==0)continue
   IX1 = $s_nk.llist [ i12[1]  ]
   IX2 = $s_nk.llist [ i12[2]  ]
   IX12 = Iarray(Rarray( Transpose(Matrix(Rarray(Nof(IX2) 1.)))*Matrix(Rarray(IX1)) + Transpose(Transpose(Matrix(Rarray(Nof(IX1) 1.)))*Matrix(Rarray(IX2-1 )*Nof(t) ) )))
   di = Mean(Rarray( $s_nk.dimt_leaves )[IX12])
#     ix = Index( b.source == i0 )
#     b.dist [ix[1]] = 0.5*di
#     b.dist [ix[2]] = 0.5*di
   ix = Index( $s_nk i0 bond )
   $s_nk.nk [ "bonds" ix[1] "dist" ] = 0.5*di
   $s_nk.nk [ "bonds" ix[2] "dist" ] = 0.5*di
   if(di > 0 & di < midi ) midi = di
 endfor

 for i = 1 Nof( $s_nk.nk ["bonds"])
   $s_nk.nk [ "bonds" i "dist" ] = Max( $s_nk.nk [ "bonds" i "dist" ] midi )    #b.dist[i]
 endfor
 $s_nk.nk ["directed"] = yes
#   keep b
endmacro
#
macro treeWheelLayout s_nk i_root ( 0 )
 if(i_root>0)then
   I_br = Index( $s_nk i_root tree all )
   roro = Index( $s_nk i_root tree reverse )
   if(Nof(roro)!=0) radius = 0.5*Distance( $s_nk.x [i_root] //( $s_nk.y [i_root] )  $s_nk.x [roro[1]] //( $s_nk.y [roro[1]] ))
   if(Nof(roro)==0) radius = 1.
 else
   I_br = Count(Nof( $s_nk ))
   radius = 1.
 endif
 $s_nk.x [I_br] = Rarray( Nof( I_br ))
 $s_nk.y [I_br] = Rarray( Nof( I_br ))
 ntt = Nof ( $s_nk.ord != 0 & $s_nk [I_br] )
 print "ntt = ", ntt
 for i = 1 100
   itt = 0
   traverseTree s_nk "treePointLayoutWheel" yes yes i_root
# detect when done
 endfor
endmacro
#
macro optimizeMCStree s_nk
 add column $s_nk Iarray(Nof( $s_nk ) 1) name="mcsChanged_"
 print bar "optimizeMCStree" 100 l_info=yes
 for i = 1 100
   traverseTree s_nk "mcsImproveTriplet" yes yes 1
   print "iteration" i Sum(Mass( $s_nk.mol ))
   print bar N l_info = yes
   if(Sum( $s_nk.mcsChanged_ )==0) break
 endfor
 print bar "End\n" l_info=yes
 makeMCSTreeBonds s_nk
endmacro
#

if l_info printf "Startup> Loading modules.. _macro "
